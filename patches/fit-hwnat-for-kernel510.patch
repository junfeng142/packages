diff -uprN a/target/linux/generic/backport-5.10/011-kbuild-export-SUBARCH.patch b/target/linux/generic/backport-5.10/011-kbuild-export-SUBARCH.patch
--- a/target/linux/generic/backport-5.10/011-kbuild-export-SUBARCH.patch	2024-03-18 15:15:10.789419098 +0800
+++ b/target/linux/generic/backport-5.10/011-kbuild-export-SUBARCH.patch	2024-03-18 15:16:23.706637149 +0800
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/Makefile
 +++ b/Makefile
-@@ -516,7 +516,7 @@ KBUILD_LDFLAGS_MODULE :=
+@@ -507,7 +507,7 @@ KBUILD_LDFLAGS_MODULE :=
  KBUILD_LDFLAGS :=
  CLANG_FLAGS :=
  
diff -uprN a/target/linux/generic/backport-5.10/350-v5.12-NFSv4_2-SSC-helper-should-use-its-own-config.patch b/target/linux/generic/backport-5.10/350-v5.12-NFSv4_2-SSC-helper-should-use-its-own-config.patch
--- a/target/linux/generic/backport-5.10/350-v5.12-NFSv4_2-SSC-helper-should-use-its-own-config.patch	2024-03-18 15:15:10.677423372 +0800
+++ b/target/linux/generic/backport-5.10/350-v5.12-NFSv4_2-SSC-helper-should-use-its-own-config.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,140 +0,0 @@
-From 02591f9febd5f69bb4c266a4abf899c4cf21964f Mon Sep 17 00:00:00 2001
-From: Dai Ngo <dai.ngo@oracle.com>
-Date: Thu, 28 Jan 2021 01:42:26 -0500
-Subject: [PATCH] NFSv4_2: SSC helper should use its own config.
-
-Currently NFSv4_2 SSC helper, nfs_ssc, incorrectly uses GRACE_PERIOD
-as its config. Fix by adding new config NFS_V4_2_SSC_HELPER which
-depends on NFS_V4_2 and is automatically selected when NFSD_V4 is
-enabled. Also removed the file name from a comment in nfs_ssc.c.
-
-Signed-off-by: Dai Ngo <dai.ngo@oracle.com>
-Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
----
- fs/Kconfig              |  4 ++++
- fs/nfs/nfs4file.c       |  4 ++++
- fs/nfs/super.c          | 12 ++++++++++++
- fs/nfs_common/Makefile  |  2 +-
- fs/nfs_common/nfs_ssc.c |  2 --
- fs/nfsd/Kconfig         |  1 +
- 6 files changed, 22 insertions(+), 3 deletions(-)
-
---- a/fs/Kconfig
-+++ b/fs/Kconfig
-@@ -333,6 +333,10 @@ config NFS_COMMON
- 	depends on NFSD || NFS_FS || LOCKD
- 	default y
- 
-+config NFS_V4_2_SSC_HELPER
-+	tristate
-+	default y if NFS_V4=y || NFS_FS=y
-+
- source "net/sunrpc/Kconfig"
- source "fs/ceph/Kconfig"
- source "fs/cifs/Kconfig"
---- a/fs/nfs/nfs4file.c
-+++ b/fs/nfs/nfs4file.c
-@@ -430,7 +430,9 @@ static const struct nfs4_ssc_client_ops
-  */
- void nfs42_ssc_register_ops(void)
- {
-+#ifdef CONFIG_NFSD_V4
- 	nfs42_ssc_register(&nfs4_ssc_clnt_ops_tbl);
-+#endif
- }
- 
- /**
-@@ -441,7 +443,9 @@ void nfs42_ssc_register_ops(void)
-  */
- void nfs42_ssc_unregister_ops(void)
- {
-+#ifdef CONFIG_NFSD_V4
- 	nfs42_ssc_unregister(&nfs4_ssc_clnt_ops_tbl);
-+#endif
- }
- #endif /* CONFIG_NFS_V4_2 */
- 
---- a/fs/nfs/super.c
-+++ b/fs/nfs/super.c
-@@ -86,9 +86,11 @@ const struct super_operations nfs_sops =
- };
- EXPORT_SYMBOL_GPL(nfs_sops);
- 
-+#ifdef CONFIG_NFS_V4_2
- static const struct nfs_ssc_client_ops nfs_ssc_clnt_ops_tbl = {
- 	.sco_sb_deactive = nfs_sb_deactive,
- };
-+#endif
- 
- #if IS_ENABLED(CONFIG_NFS_V4)
- static int __init register_nfs4_fs(void)
-@@ -111,15 +113,21 @@ static void unregister_nfs4_fs(void)
- }
- #endif
- 
-+#ifdef CONFIG_NFS_V4_2
- static void nfs_ssc_register_ops(void)
- {
-+#ifdef CONFIG_NFSD_V4
- 	nfs_ssc_register(&nfs_ssc_clnt_ops_tbl);
-+#endif
- }
- 
- static void nfs_ssc_unregister_ops(void)
- {
-+#ifdef CONFIG_NFSD_V4
- 	nfs_ssc_unregister(&nfs_ssc_clnt_ops_tbl);
-+#endif
- }
-+#endif /* CONFIG_NFS_V4_2 */
- 
- static struct shrinker acl_shrinker = {
- 	.count_objects	= nfs_access_cache_count,
-@@ -148,7 +156,9 @@ int __init register_nfs_fs(void)
- 	ret = register_shrinker(&acl_shrinker);
- 	if (ret < 0)
- 		goto error_3;
-+#ifdef CONFIG_NFS_V4_2
- 	nfs_ssc_register_ops();
-+#endif
- 	return 0;
- error_3:
- 	nfs_unregister_sysctl();
-@@ -168,7 +178,9 @@ void __exit unregister_nfs_fs(void)
- 	unregister_shrinker(&acl_shrinker);
- 	nfs_unregister_sysctl();
- 	unregister_nfs4_fs();
-+#ifdef CONFIG_NFS_V4_2
- 	nfs_ssc_unregister_ops();
-+#endif
- 	unregister_filesystem(&nfs_fs_type);
- }
- 
---- a/fs/nfs_common/Makefile
-+++ b/fs/nfs_common/Makefile
-@@ -7,4 +7,4 @@ obj-$(CONFIG_NFS_ACL_SUPPORT) += nfs_acl
- nfs_acl-objs := nfsacl.o
- 
- obj-$(CONFIG_GRACE_PERIOD) += grace.o
--obj-$(CONFIG_GRACE_PERIOD) += nfs_ssc.o
-+obj-$(CONFIG_NFS_V4_2_SSC_HELPER) += nfs_ssc.o
---- a/fs/nfs_common/nfs_ssc.c
-+++ b/fs/nfs_common/nfs_ssc.c
-@@ -1,7 +1,5 @@
- // SPDX-License-Identifier: GPL-2.0-only
- /*
-- * fs/nfs_common/nfs_ssc_comm.c
-- *
-  * Helper for knfsd's SSC to access ops in NFS client modules
-  *
-  * Author: Dai Ngo <dai.ngo@oracle.com>
---- a/fs/nfsd/Kconfig
-+++ b/fs/nfsd/Kconfig
-@@ -77,6 +77,7 @@ config NFSD_V4
- 	select CRYPTO_MD5
- 	select CRYPTO_SHA256
- 	select GRACE_PERIOD
-+	select NFS_V4_2_SSC_HELPER if NFS_V4_2
- 	help
- 	  This option enables support in your system's NFS server for
- 	  version 4 of the NFS protocol (RFC 3530).
diff -uprN a/target/linux/generic/backport-5.10/350-v5.18-MIPS-pgalloc-fix-memory-leak-caused-by-pgd_free.patch b/target/linux/generic/backport-5.10/350-v5.18-MIPS-pgalloc-fix-memory-leak-caused-by-pgd_free.patch
--- a/target/linux/generic/backport-5.10/350-v5.18-MIPS-pgalloc-fix-memory-leak-caused-by-pgd_free.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-5.10/350-v5.18-MIPS-pgalloc-fix-memory-leak-caused-by-pgd_free.patch	2024-03-18 15:16:23.678638217 +0800
@@ -0,0 +1,48 @@
+From e852442da56f43795cb6255d90b9fd0c84b209bb Mon Sep 17 00:00:00 2001
+From: Yaliang Wang <Yaliang.Wang@windriver.com>
+Date: Thu, 10 Mar 2022 19:31:16 +0800
+Subject: [PATCH] MIPS: pgalloc: fix memory leak caused by pgd_free()
+
+pgd page is freed by generic implementation pgd_free() since commit
+f9cb654cb550 ("asm-generic: pgalloc: provide generic pgd_free()"),
+however, there are scenarios that the system uses more than one page as
+the pgd table, in such cases the generic implementation pgd_free() won't
+be applicable anymore. For example, when PAGE_SIZE_4KB is enabled and
+MIPS_VA_BITS_48 is not enabled in a 64bit system, the macro "PGD_ORDER"
+will be set as "1", which will cause allocating two pages as the pgd
+table. Well, at the same time, the generic implementation pgd_free()
+just free one pgd page, which will result in the memory leak.
+
+The memory leak can be easily detected by executing shell command:
+"while true; do ls > /dev/null; grep MemFree /proc/meminfo; done"
+
+Fixes: f9cb654cb550 ("asm-generic: pgalloc: provide generic pgd_free()")
+Signed-off-by: Yaliang Wang <Yaliang.Wang@windriver.com>
+Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
+(cherry picked from commit 2bc5bab9a763d520937e4f3fe8df51c6a1eceb97)
+---
+ arch/mips/include/asm/pgalloc.h | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/arch/mips/include/asm/pgalloc.h
++++ b/arch/mips/include/asm/pgalloc.h
+@@ -15,6 +15,7 @@
+ 
+ #define __HAVE_ARCH_PMD_ALLOC_ONE
+ #define __HAVE_ARCH_PUD_ALLOC_ONE
++#define __HAVE_ARCH_PGD_FREE
+ #include <asm-generic/pgalloc.h>
+ 
+ static inline void pmd_populate_kernel(struct mm_struct *mm, pmd_t *pmd,
+@@ -49,6 +50,11 @@ static inline void pud_populate(struct m
+ extern void pgd_init(unsigned long page);
+ extern pgd_t *pgd_alloc(struct mm_struct *mm);
+ 
++static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
++{
++	free_pages((unsigned long)pgd, PGD_ORDER);
++}
++
+ #define __pte_free_tlb(tlb,pte,address)			\
+ do {							\
+ 	pgtable_pte_page_dtor(pte);			\
diff -uprN a/target/linux/generic/backport-5.10/351-v5.13-NFSv4_2-Remove-ifdef-CONFIG_NFSD-from-client-SSC.patch b/target/linux/generic/backport-5.10/351-v5.13-NFSv4_2-Remove-ifdef-CONFIG_NFSD-from-client-SSC.patch
--- a/target/linux/generic/backport-5.10/351-v5.13-NFSv4_2-Remove-ifdef-CONFIG_NFSD-from-client-SSC.patch	2024-03-18 15:15:10.681423219 +0800
+++ b/target/linux/generic/backport-5.10/351-v5.13-NFSv4_2-Remove-ifdef-CONFIG_NFSD-from-client-SSC.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,84 +0,0 @@
-From d9092b4bb2109502eb8972021a3f74febc931a63 Mon Sep 17 00:00:00 2001
-From: Dai Ngo <dai.ngo@oracle.com>
-Date: Thu, 22 Apr 2021 03:37:49 -0400
-Subject: [PATCH] NFSv4.2: Remove ifdef CONFIG_NFSD from NFSv4.2 client SSC
- code.
-
-The client SSC code should not depend on any of the CONFIG_NFSD config.
-This patch removes all CONFIG_NFSD from NFSv4.2 client SSC code and
-simplifies the config of CONFIG_NFS_V4_2_SSC_HELPER, NFSD_V4_2_INTER_SSC.
-
-Signed-off-by: Dai Ngo <dai.ngo@oracle.com>
-Signed-off-by: Trond Myklebust <trond.myklebust@hammerspace.com>
----
- fs/Kconfig        | 4 ++--
- fs/nfs/nfs4file.c | 4 ----
- fs/nfs/super.c    | 4 ----
- fs/nfsd/Kconfig   | 2 +-
- 4 files changed, 3 insertions(+), 11 deletions(-)
-
---- a/fs/Kconfig
-+++ b/fs/Kconfig
-@@ -334,8 +334,8 @@ config NFS_COMMON
- 	default y
- 
- config NFS_V4_2_SSC_HELPER
--	tristate
--	default y if NFS_V4=y || NFS_FS=y
-+	bool
-+	default y if NFS_V4_2
- 
- source "net/sunrpc/Kconfig"
- source "fs/ceph/Kconfig"
---- a/fs/nfs/nfs4file.c
-+++ b/fs/nfs/nfs4file.c
-@@ -430,9 +430,7 @@ static const struct nfs4_ssc_client_ops
-  */
- void nfs42_ssc_register_ops(void)
- {
--#ifdef CONFIG_NFSD_V4
- 	nfs42_ssc_register(&nfs4_ssc_clnt_ops_tbl);
--#endif
- }
- 
- /**
-@@ -443,9 +441,7 @@ void nfs42_ssc_register_ops(void)
-  */
- void nfs42_ssc_unregister_ops(void)
- {
--#ifdef CONFIG_NFSD_V4
- 	nfs42_ssc_unregister(&nfs4_ssc_clnt_ops_tbl);
--#endif
- }
- #endif /* CONFIG_NFS_V4_2 */
- 
---- a/fs/nfs/super.c
-+++ b/fs/nfs/super.c
-@@ -116,16 +116,12 @@ static void unregister_nfs4_fs(void)
- #ifdef CONFIG_NFS_V4_2
- static void nfs_ssc_register_ops(void)
- {
--#ifdef CONFIG_NFSD_V4
- 	nfs_ssc_register(&nfs_ssc_clnt_ops_tbl);
--#endif
- }
- 
- static void nfs_ssc_unregister_ops(void)
- {
--#ifdef CONFIG_NFSD_V4
- 	nfs_ssc_unregister(&nfs_ssc_clnt_ops_tbl);
--#endif
- }
- #endif /* CONFIG_NFS_V4_2 */
- 
---- a/fs/nfsd/Kconfig
-+++ b/fs/nfsd/Kconfig
-@@ -138,7 +138,7 @@ config NFSD_FLEXFILELAYOUT
- 
- config NFSD_V4_2_INTER_SSC
- 	bool "NFSv4.2 inter server to server COPY"
--	depends on NFSD_V4 && NFS_V4_1 && NFS_V4_2
-+	depends on NFSD_V4 && NFS_V4_2
- 	help
- 	  This option enables support for NFSv4.2 inter server to
- 	  server copy where the destination server calls the NFSv4.2
diff -uprN a/target/linux/generic/backport-5.10/408-v5.13-mtd-cfi_cmdset_0002-Disable-buffered-writes-for-AMD.patch b/target/linux/generic/backport-5.10/408-v5.13-mtd-cfi_cmdset_0002-Disable-buffered-writes-for-AMD.patch
--- a/target/linux/generic/backport-5.10/408-v5.13-mtd-cfi_cmdset_0002-Disable-buffered-writes-for-AMD.patch	2024-03-18 15:15:10.681423219 +0800
+++ b/target/linux/generic/backport-5.10/408-v5.13-mtd-cfi_cmdset_0002-Disable-buffered-writes-for-AMD.patch	2024-03-18 15:16:23.642639590 +0800
@@ -41,7 +41,7 @@ Link: https://lore.kernel.org/r/20210309
 
 --- a/drivers/mtd/chips/cfi_cmdset_0002.c
 +++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -276,6 +276,10 @@ static void fixup_use_write_buffers(stru
+@@ -272,6 +272,10 @@ static void fixup_use_write_buffers(stru
  {
  	struct map_info *map = mtd->priv;
  	struct cfi_private *cfi = map->fldrv_priv;
diff -uprN a/target/linux/generic/backport-5.10/411-v6.0-mtd-parsers-add-support-for-Sercomm-partitions.patch b/target/linux/generic/backport-5.10/411-v6.0-mtd-parsers-add-support-for-Sercomm-partitions.patch
--- a/target/linux/generic/backport-5.10/411-v6.0-mtd-parsers-add-support-for-Sercomm-partitions.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/411-v6.0-mtd-parsers-add-support-for-Sercomm-partitions.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,301 +0,0 @@
-From 9b78ef0c7997052e9eaa0f7a4513d546fa17358c Mon Sep 17 00:00:00 2001
-From: Mikhail Zhilkin <csharper2005@gmail.com>
-Date: Sun, 29 May 2022 11:07:14 +0000
-Subject: [PATCH] mtd: parsers: add support for Sercomm partitions
-
-This adds an MTD partition parser for the Sercomm partition table that
-is used in some Beeline, Netgear and Sercomm routers.
-
-The Sercomm partition map table contains real partition offsets, which
-may differ from device to device depending on the number and location of
-bad blocks on NAND.
-
-Original patch (proposed by NOGUCHI Hiroshi):
-Link: https://github.com/openwrt/openwrt/pull/1318#issuecomment-420607394
-
-Signed-off-by: NOGUCHI Hiroshi <drvlabo@gmail.com>
-Signed-off-by: Mikhail Zhilkin <csharper2005@gmail.com>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20220529110714.189732-1-csharper2005@gmail.com
----
- drivers/mtd/parsers/Kconfig  |   9 ++
- drivers/mtd/parsers/Makefile |   1 +
- drivers/mtd/parsers/scpart.c | 248 +++++++++++++++++++++++++++++++++++
- 3 files changed, 258 insertions(+)
- create mode 100644 drivers/mtd/parsers/scpart.c
-
---- a/drivers/mtd/parsers/Kconfig
-+++ b/drivers/mtd/parsers/Kconfig
-@@ -179,3 +179,12 @@ config MTD_REDBOOT_PARTS_READONLY
- 	  'FIS directory' images, enable this option.
- 
- endif # MTD_REDBOOT_PARTS
-+
-+config MTD_SERCOMM_PARTS
-+	tristate "Sercomm partition table parser"
-+	depends on MTD && RALINK
-+	help
-+	  This provides partitions table parser for devices with Sercomm
-+	  partition map. This partition table contains real partition
-+	  offsets, which may differ from device to device depending on the
-+	  number and location of bad blocks on NAND.
---- a/drivers/mtd/parsers/Makefile
-+++ b/drivers/mtd/parsers/Makefile
-@@ -10,5 +10,6 @@ ofpart-$(CONFIG_MTD_OF_PARTS_LINKSYS_NS)
- obj-$(CONFIG_MTD_PARSER_IMAGETAG)	+= parser_imagetag.o
- obj-$(CONFIG_MTD_AFS_PARTS)		+= afs.o
- obj-$(CONFIG_MTD_PARSER_TRX)		+= parser_trx.o
-+obj-$(CONFIG_MTD_SERCOMM_PARTS)		+= scpart.o
- obj-$(CONFIG_MTD_SHARPSL_PARTS)		+= sharpslpart.o
- obj-$(CONFIG_MTD_REDBOOT_PARTS)		+= redboot.o
---- /dev/null
-+++ b/drivers/mtd/parsers/scpart.c
-@@ -0,0 +1,248 @@
-+// SPDX-License-Identifier: GPL-2.0-or-later
-+/*
-+ *    drivers/mtd/scpart.c: Sercomm Partition Parser
-+ *
-+ *    Copyright (C) 2018 NOGUCHI Hiroshi
-+ *    Copyright (C) 2022 Mikhail Zhilkin
-+ */
-+
-+#include <linux/kernel.h>
-+#include <linux/slab.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/mtd/partitions.h>
-+#include <linux/module.h>
-+
-+#define	MOD_NAME	"scpart"
-+
-+#ifdef pr_fmt
-+#undef pr_fmt
-+#endif
-+
-+#define pr_fmt(fmt) MOD_NAME ": " fmt
-+
-+#define	ID_ALREADY_FOUND	0xffffffffUL
-+
-+#define	MAP_OFFS_IN_BLK		0x800
-+#define	MAP_MIRROR_NUM		2
-+
-+static const char sc_part_magic[] = {
-+	'S', 'C', 'F', 'L', 'M', 'A', 'P', 'O', 'K', '\0',
-+};
-+#define	PART_MAGIC_LEN		sizeof(sc_part_magic)
-+
-+/* assumes that all fields are set by CPU native endian */
-+struct sc_part_desc {
-+	uint32_t	part_id;
-+	uint32_t	part_offs;
-+	uint32_t	part_bytes;
-+};
-+
-+static uint32_t scpart_desc_is_valid(struct sc_part_desc *pdesc)
-+{
-+	return ((pdesc->part_id != 0xffffffffUL) &&
-+		(pdesc->part_offs != 0xffffffffUL) &&
-+		(pdesc->part_bytes != 0xffffffffUL));
-+}
-+
-+static int scpart_scan_partmap(struct mtd_info *master, loff_t partmap_offs,
-+			       struct sc_part_desc **ppdesc)
-+{
-+	int cnt = 0;
-+	int res = 0;
-+	int res2;
-+	loff_t offs;
-+	size_t retlen;
-+	struct sc_part_desc *pdesc = NULL;
-+	struct sc_part_desc *tmpdesc;
-+	uint8_t *buf;
-+
-+	buf = kzalloc(master->erasesize, GFP_KERNEL);
-+	if (!buf) {
-+		res = -ENOMEM;
-+		goto out;
-+	}
-+
-+	res2 = mtd_read(master, partmap_offs, master->erasesize, &retlen, buf);
-+	if (res2 || retlen != master->erasesize) {
-+		res = -EIO;
-+		goto free;
-+	}
-+
-+	for (offs = MAP_OFFS_IN_BLK;
-+	     offs < master->erasesize - sizeof(*tmpdesc);
-+	     offs += sizeof(*tmpdesc)) {
-+		tmpdesc = (struct sc_part_desc *)&buf[offs];
-+		if (!scpart_desc_is_valid(tmpdesc))
-+			break;
-+		cnt++;
-+	}
-+
-+	if (cnt > 0) {
-+		int bytes = cnt * sizeof(*pdesc);
-+
-+		pdesc = kcalloc(cnt, sizeof(*pdesc), GFP_KERNEL);
-+		if (!pdesc) {
-+			res = -ENOMEM;
-+			goto free;
-+		}
-+		memcpy(pdesc, &(buf[MAP_OFFS_IN_BLK]), bytes);
-+
-+		*ppdesc = pdesc;
-+		res = cnt;
-+	}
-+
-+free:
-+	kfree(buf);
-+
-+out:
-+	return res;
-+}
-+
-+static int scpart_find_partmap(struct mtd_info *master,
-+			       struct sc_part_desc **ppdesc)
-+{
-+	int magic_found = 0;
-+	int res = 0;
-+	int res2;
-+	loff_t offs = 0;
-+	size_t retlen;
-+	uint8_t rdbuf[PART_MAGIC_LEN];
-+
-+	while ((magic_found < MAP_MIRROR_NUM) &&
-+			(offs < master->size) &&
-+			 !mtd_block_isbad(master, offs)) {
-+		res2 = mtd_read(master, offs, PART_MAGIC_LEN, &retlen, rdbuf);
-+		if (res2 || retlen != PART_MAGIC_LEN) {
-+			res = -EIO;
-+			goto out;
-+		}
-+		if (!memcmp(rdbuf, sc_part_magic, PART_MAGIC_LEN)) {
-+			pr_debug("Signature found at 0x%llx\n", offs);
-+			magic_found++;
-+			res = scpart_scan_partmap(master, offs, ppdesc);
-+			if (res > 0)
-+				goto out;
-+		}
-+		offs += master->erasesize;
-+	}
-+
-+out:
-+	if (res > 0)
-+		pr_info("Valid 'SC PART MAP' (%d partitions) found at 0x%llx\n", res, offs);
-+	else
-+		pr_info("No valid 'SC PART MAP' was found\n");
-+
-+	return res;
-+}
-+
-+static int scpart_parse(struct mtd_info *master,
-+			const struct mtd_partition **pparts,
-+			struct mtd_part_parser_data *data)
-+{
-+	const char *partname;
-+	int n;
-+	int nr_scparts;
-+	int nr_parts = 0;
-+	int res = 0;
-+	struct sc_part_desc *scpart_map = NULL;
-+	struct mtd_partition *parts = NULL;
-+	struct device_node *mtd_node;
-+	struct device_node *ofpart_node;
-+	struct device_node *pp;
-+
-+	mtd_node = mtd_get_of_node(master);
-+	if (!mtd_node) {
-+		res = -ENOENT;
-+		goto out;
-+	}
-+
-+	ofpart_node = of_get_child_by_name(mtd_node, "partitions");
-+	if (!ofpart_node) {
-+		pr_info("%s: 'partitions' subnode not found on %pOF.\n",
-+				master->name, mtd_node);
-+		res = -ENOENT;
-+		goto out;
-+	}
-+
-+	nr_scparts = scpart_find_partmap(master, &scpart_map);
-+	if (nr_scparts <= 0) {
-+		pr_info("No any partitions was found in 'SC PART MAP'.\n");
-+		res = -ENOENT;
-+		goto free;
-+	}
-+
-+	parts = kcalloc(of_get_child_count(ofpart_node), sizeof(*parts),
-+		GFP_KERNEL);
-+	if (!parts) {
-+		res = -ENOMEM;
-+		goto free;
-+	}
-+
-+	for_each_child_of_node(ofpart_node, pp) {
-+		u32 scpart_id;
-+
-+		if (of_property_read_u32(pp, "sercomm,scpart-id", &scpart_id))
-+			continue;
-+
-+		for (n = 0 ; n < nr_scparts ; n++)
-+			if ((scpart_map[n].part_id != ID_ALREADY_FOUND) &&
-+					(scpart_id == scpart_map[n].part_id))
-+				break;
-+		if (n >= nr_scparts)
-+			/* not match */
-+			continue;
-+
-+		/* add the partition found in OF into MTD partition array */
-+		parts[nr_parts].offset = scpart_map[n].part_offs;
-+		parts[nr_parts].size = scpart_map[n].part_bytes;
-+		parts[nr_parts].of_node = pp;
-+
-+		if (!of_property_read_string(pp, "label", &partname))
-+			parts[nr_parts].name = partname;
-+		if (of_property_read_bool(pp, "read-only"))
-+			parts[nr_parts].mask_flags |= MTD_WRITEABLE;
-+		if (of_property_read_bool(pp, "lock"))
-+			parts[nr_parts].mask_flags |= MTD_POWERUP_LOCK;
-+
-+		/* mark as 'done' */
-+		scpart_map[n].part_id = ID_ALREADY_FOUND;
-+
-+		nr_parts++;
-+	}
-+
-+	if (nr_parts > 0) {
-+		*pparts = parts;
-+		res = nr_parts;
-+	} else
-+		pr_info("No partition in OF matches partition ID with 'SC PART MAP'.\n");
-+
-+	of_node_put(pp);
-+
-+free:
-+	kfree(scpart_map);
-+	if (res <= 0)
-+		kfree(parts);
-+
-+out:
-+	return res;
-+}
-+
-+static const struct of_device_id scpart_parser_of_match_table[] = {
-+	{ .compatible = "sercomm,sc-partitions" },
-+	{},
-+};
-+MODULE_DEVICE_TABLE(of, scpart_parser_of_match_table);
-+
-+static struct mtd_part_parser scpart_parser = {
-+	.parse_fn = scpart_parse,
-+	.name = "scpart",
-+	.of_match_table = scpart_parser_of_match_table,
-+};
-+module_mtd_part_parser(scpart_parser);
-+
-+/* mtd parsers will request the module by parser name */
-+MODULE_ALIAS("scpart");
-+MODULE_LICENSE("GPL");
-+MODULE_AUTHOR("NOGUCHI Hiroshi <drvlabo@gmail.com>");
-+MODULE_AUTHOR("Mikhail Zhilkin <csharper2005@gmail.com>");
-+MODULE_DESCRIPTION("Sercomm partition parser");
diff -uprN a/target/linux/generic/backport-5.10/414-v6.1-mtd-allow-getting-MTD-device-associated-with-a-speci.patch b/target/linux/generic/backport-5.10/414-v6.1-mtd-allow-getting-MTD-device-associated-with-a-speci.patch
--- a/target/linux/generic/backport-5.10/414-v6.1-mtd-allow-getting-MTD-device-associated-with-a-speci.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/414-v6.1-mtd-allow-getting-MTD-device-associated-with-a-speci.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,72 +0,0 @@
-From b0321721be50b80c03a51866a94fde4f94690e18 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 15 Jun 2022 21:42:59 +0200
-Subject: [PATCH] mtd: allow getting MTD device associated with a specific DT
- node
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-MTD subsystem API allows interacting with MTD devices (e.g. reading,
-writing, handling bad blocks). So far a random driver could get MTD
-device only by its name (get_mtd_device_nm()). This change allows
-getting them also by a DT node.
-
-This API is required for drivers handling DT defined MTD partitions in a
-specific way (e.g. U-Boot (sub)partition with environment variables).
-
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
-Acked-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
----
- drivers/mtd/mtdcore.c   | 28 ++++++++++++++++++++++++++++
- include/linux/mtd/mtd.h |  1 +
- 2 files changed, 29 insertions(+)
-
---- a/drivers/mtd/mtdcore.c
-+++ b/drivers/mtd/mtdcore.c
-@@ -1011,6 +1011,34 @@ int __get_mtd_device(struct mtd_info *mt
- EXPORT_SYMBOL_GPL(__get_mtd_device);
- 
- /**
-+ * of_get_mtd_device_by_node - obtain an MTD device associated with a given node
-+ *
-+ * @np: device tree node
-+ */
-+struct mtd_info *of_get_mtd_device_by_node(struct device_node *np)
-+{
-+	struct mtd_info *mtd = NULL;
-+	struct mtd_info *tmp;
-+	int err;
-+
-+	mutex_lock(&mtd_table_mutex);
-+
-+	err = -EPROBE_DEFER;
-+	mtd_for_each_device(tmp) {
-+		if (mtd_get_of_node(tmp) == np) {
-+			mtd = tmp;
-+			err = __get_mtd_device(mtd);
-+			break;
-+		}
-+	}
-+
-+	mutex_unlock(&mtd_table_mutex);
-+
-+	return err ? ERR_PTR(err) : mtd;
-+}
-+EXPORT_SYMBOL_GPL(of_get_mtd_device_by_node);
-+
-+/**
-  *	get_mtd_device_nm - obtain a validated handle for an MTD device by
-  *	device name
-  *	@name: MTD device name to open
---- a/include/linux/mtd/mtd.h
-+++ b/include/linux/mtd/mtd.h
-@@ -675,6 +675,7 @@ extern int mtd_device_unregister(struct
- extern struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num);
- extern int __get_mtd_device(struct mtd_info *mtd);
- extern void __put_mtd_device(struct mtd_info *mtd);
-+extern struct mtd_info *of_get_mtd_device_by_node(struct device_node *np);
- extern struct mtd_info *get_mtd_device_nm(const char *name);
- extern void put_mtd_device(struct mtd_info *mtd);
- 
diff -uprN a/target/linux/generic/backport-5.10/419-v5.14-mtd-spinand-gigadevice-Support-GD5F1GQ5UExxG.patch b/target/linux/generic/backport-5.10/419-v5.14-mtd-spinand-gigadevice-Support-GD5F1GQ5UExxG.patch
--- a/target/linux/generic/backport-5.10/419-v5.14-mtd-spinand-gigadevice-Support-GD5F1GQ5UExxG.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/419-v5.14-mtd-spinand-gigadevice-Support-GD5F1GQ5UExxG.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,172 +0,0 @@
-From bd568cc04c675b7fa97214d278a54794c2ecc2ad Mon Sep 17 00:00:00 2001
-From: Reto Schneider <reto.schneider@husqvarnagroup.com>
-Date: Thu, 11 Feb 2021 12:36:19 +0100
-Subject: [PATCH] mtd: spinand: gigadevice: Support GD5F1GQ5UExxG
-
-The relevant changes to the already existing GD5F1GQ4UExxG support has
-been determined by consulting the GigaDevice product change notice
-AN-0392-10, version 1.0 from November 30, 2020.
-
-As the overlaps are huge, variable names have been generalized
-accordingly.
-
-Apart from the lowered ECC strength (4 instead of 8 bits per 512 bytes),
-the new device ID, and the extra quad IO dummy byte, no changes had to
-be taken into account.
-
-New hardware features are not supported, namely:
- - Power on reset
- - Unique ID
- - Double transfer rate (DTR)
- - Parameter page
- - Random data quad IO
-
-The inverted semantic of the "driver strength" register bits, defaulting
-to 100% instead of 50% for the Q5 devices, got ignored as the driver has
-never touched them anyway.
-
-The no longer supported "read from cache during block erase"
-functionality is not reflected as the current SPI NAND core does not
-support it anyway.
-
-Implementation has been tested on MediaTek MT7688 based GARDENA smart
-Gateways using both, GigaDevice GD5F1GQ5UEYIG and GD5F1GQ4UBYIG.
-
-Signed-off-by: Reto Schneider <reto.schneider@husqvarnagroup.com>
-Reviewed-by: Frieder Schrempf <frieder.schrempf@kontron.de>
-Reviewed-by: Stefan Roese <sr@denx.de>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20210211113619.3502-1-code@reto-schneider.ch
-(cherry picked from commit 469b992489852b500d39048aa0013639dfe9f2e6)
----
- drivers/mtd/nand/spi/gigadevice.c | 69 +++++++++++++++++++++++++++----
- 1 file changed, 60 insertions(+), 9 deletions(-)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -13,7 +13,10 @@
- #define GD5FXGQ4XA_STATUS_ECC_1_7_BITFLIPS	(1 << 4)
- #define GD5FXGQ4XA_STATUS_ECC_8_BITFLIPS	(3 << 4)
- 
--#define GD5FXGQ4UEXXG_REG_STATUS2		0xf0
-+#define GD5FXGQ5XE_STATUS_ECC_1_4_BITFLIPS	(1 << 4)
-+#define GD5FXGQ5XE_STATUS_ECC_4_BITFLIPS	(3 << 4)
-+
-+#define GD5FXGQXXEXXG_REG_STATUS2		0xf0
- 
- #define GD5FXGQ4UXFXXG_STATUS_ECC_MASK		(7 << 4)
- #define GD5FXGQ4UXFXXG_STATUS_ECC_NO_BITFLIPS	(0 << 4)
-@@ -102,7 +105,7 @@ static int gd5fxgq4xa_ecc_get_status(str
- 	return -EINVAL;
- }
- 
--static int gd5fxgq4_variant2_ooblayout_ecc(struct mtd_info *mtd, int section,
-+static int gd5fxgqx_variant2_ooblayout_ecc(struct mtd_info *mtd, int section,
- 				       struct mtd_oob_region *region)
- {
- 	if (section)
-@@ -114,7 +117,7 @@ static int gd5fxgq4_variant2_ooblayout_e
- 	return 0;
- }
- 
--static int gd5fxgq4_variant2_ooblayout_free(struct mtd_info *mtd, int section,
-+static int gd5fxgqx_variant2_ooblayout_free(struct mtd_info *mtd, int section,
- 					struct mtd_oob_region *region)
- {
- 	if (section)
-@@ -127,9 +130,10 @@ static int gd5fxgq4_variant2_ooblayout_f
- 	return 0;
- }
- 
--static const struct mtd_ooblayout_ops gd5fxgq4_variant2_ooblayout = {
--	.ecc = gd5fxgq4_variant2_ooblayout_ecc,
--	.free = gd5fxgq4_variant2_ooblayout_free,
-+/* Valid for Q4/Q5 and Q6 (untested) devices */
-+static const struct mtd_ooblayout_ops gd5fxgqx_variant2_ooblayout = {
-+	.ecc = gd5fxgqx_variant2_ooblayout_ecc,
-+	.free = gd5fxgqx_variant2_ooblayout_free,
- };
- 
- static int gd5fxgq4xc_ooblayout_256_ecc(struct mtd_info *mtd, int section,
-@@ -165,7 +169,7 @@ static int gd5fxgq4uexxg_ecc_get_status(
- 					u8 status)
- {
- 	u8 status2;
--	struct spi_mem_op op = SPINAND_GET_FEATURE_OP(GD5FXGQ4UEXXG_REG_STATUS2,
-+	struct spi_mem_op op = SPINAND_GET_FEATURE_OP(GD5FXGQXXEXXG_REG_STATUS2,
- 						      &status2);
- 	int ret;
- 
-@@ -203,6 +207,43 @@ static int gd5fxgq4uexxg_ecc_get_status(
- 	return -EINVAL;
- }
- 
-+static int gd5fxgq5xexxg_ecc_get_status(struct spinand_device *spinand,
-+					u8 status)
-+{
-+	u8 status2;
-+	struct spi_mem_op op = SPINAND_GET_FEATURE_OP(GD5FXGQXXEXXG_REG_STATUS2,
-+						      &status2);
-+	int ret;
-+
-+	switch (status & STATUS_ECC_MASK) {
-+	case STATUS_ECC_NO_BITFLIPS:
-+		return 0;
-+
-+	case GD5FXGQ5XE_STATUS_ECC_1_4_BITFLIPS:
-+		/*
-+		 * Read status2 register to determine a more fine grained
-+		 * bit error status
-+		 */
-+		ret = spi_mem_exec_op(spinand->spimem, &op);
-+		if (ret)
-+			return ret;
-+
-+		/*
-+		 * 1 ... 4 bits are flipped (and corrected)
-+		 */
-+		/* bits sorted this way (1...0): ECCSE1, ECCSE0 */
-+		return ((status2 & STATUS_ECC_MASK) >> 4) + 1;
-+
-+	case STATUS_ECC_UNCOR_ERROR:
-+		return -EBADMSG;
-+
-+	default:
-+		break;
-+	}
-+
-+	return -EINVAL;
-+}
-+
- static int gd5fxgq4ufxxg_ecc_get_status(struct spinand_device *spinand,
- 					u8 status)
- {
-@@ -282,7 +323,7 @@ static const struct spinand_info gigadev
- 					      &write_cache_variants,
- 					      &update_cache_variants),
- 		     SPINAND_HAS_QE_BIT,
--		     SPINAND_ECCINFO(&gd5fxgq4_variant2_ooblayout,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
- 				     gd5fxgq4uexxg_ecc_get_status)),
- 	SPINAND_INFO("GD5F1GQ4UFxxG",
- 		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE, 0xb1, 0x48),
-@@ -292,8 +333,18 @@ static const struct spinand_info gigadev
- 					      &write_cache_variants,
- 					      &update_cache_variants),
- 		     SPINAND_HAS_QE_BIT,
--		     SPINAND_ECCINFO(&gd5fxgq4_variant2_ooblayout,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
- 				     gd5fxgq4ufxxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F1GQ5UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x51),
-+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
-+		     NAND_ECCREQ(4, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq5xexxg_ecc_get_status)),
- };
- 
- static const struct spinand_manufacturer_ops gigadevice_spinand_manuf_ops = {
diff -uprN a/target/linux/generic/backport-5.10/420-v5.19-01-mtd-spinand-gigadevice-fix-Quad-IO-for-GD5F1GQ5UExxG.patch b/target/linux/generic/backport-5.10/420-v5.19-01-mtd-spinand-gigadevice-fix-Quad-IO-for-GD5F1GQ5UExxG.patch
--- a/target/linux/generic/backport-5.10/420-v5.19-01-mtd-spinand-gigadevice-fix-Quad-IO-for-GD5F1GQ5UExxG.patch	2024-03-18 15:15:10.701422456 +0800
+++ b/target/linux/generic/backport-5.10/420-v5.19-01-mtd-spinand-gigadevice-fix-Quad-IO-for-GD5F1GQ5UExxG.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,44 +0,0 @@
-From a4f9dd55c5e1bb951db6f1dee20e62e0103f3438 Mon Sep 17 00:00:00 2001
-From: Chuanhong Guo <gch981213@gmail.com>
-Date: Sun, 20 Mar 2022 17:59:57 +0800
-Subject: [PATCH 1/5] mtd: spinand: gigadevice: fix Quad IO for GD5F1GQ5UExxG
-
-Read From Cache Quad IO (EBH) uses 2 dummy bytes on this chip according
-to page 23 of the datasheet[0].
-
-[0]: https://www.gigadevice.com/datasheet/gd5f1gq5xexxg/
-
-Fixes: 469b99248985 ("mtd: spinand: gigadevice: Support GD5F1GQ5UExxG")
-Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20220320100001.247905-2-gch981213@gmail.com
----
- drivers/mtd/nand/spi/gigadevice.c | 10 +++++++++-
- 1 file changed, 9 insertions(+), 1 deletion(-)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -39,6 +39,14 @@ static SPINAND_OP_VARIANTS(read_cache_va
- 		SPINAND_PAGE_READ_FROM_CACHE_OP_3A(true, 0, 1, NULL, 0),
- 		SPINAND_PAGE_READ_FROM_CACHE_OP_3A(false, 0, 0, NULL, 0));
- 
-+static SPINAND_OP_VARIANTS(read_cache_variants_1gq5,
-+		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 2, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
-+
- static SPINAND_OP_VARIANTS(write_cache_variants,
- 		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
- 		SPINAND_PROG_LOAD(true, 0, NULL, 0));
-@@ -339,7 +347,7 @@ static const struct spinand_info gigadev
- 		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x51),
- 		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
- 		     NAND_ECCREQ(4, 512),
--		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
- 					      &write_cache_variants,
- 					      &update_cache_variants),
- 		     SPINAND_HAS_QE_BIT,
diff -uprN a/target/linux/generic/backport-5.10/420-v5.19-02-mtd-spinand-gigadevice-add-support-for-GD5FxGQ4xExxG.patch b/target/linux/generic/backport-5.10/420-v5.19-02-mtd-spinand-gigadevice-add-support-for-GD5FxGQ4xExxG.patch
--- a/target/linux/generic/backport-5.10/420-v5.19-02-mtd-spinand-gigadevice-add-support-for-GD5FxGQ4xExxG.patch	2024-03-18 15:15:10.757420320 +0800
+++ b/target/linux/generic/backport-5.10/420-v5.19-02-mtd-spinand-gigadevice-add-support-for-GD5FxGQ4xExxG.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
-From 573eec222bc82fb5e724586267fbbb1aed9ffd03 Mon Sep 17 00:00:00 2001
-From: Chuanhong Guo <gch981213@gmail.com>
-Date: Sun, 20 Mar 2022 17:59:58 +0800
-Subject: [PATCH 2/5] mtd: spinand: gigadevice: add support for GD5FxGQ4xExxG
-
-Add support for:
- GD5F1GQ4RExxG
- GD5F2GQ4{U,R}ExxG
-
-These chips differ from GD5F1GQ4UExxG only in chip ID, voltage
-and capacity.
-
-Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20220320100001.247905-3-gch981213@gmail.com
----
- drivers/mtd/nand/spi/gigadevice.c | 30 ++++++++++++++++++++++++++++++
- 1 file changed, 30 insertions(+)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -333,6 +333,36 @@ static const struct spinand_info gigadev
- 		     SPINAND_HAS_QE_BIT,
- 		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
- 				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F1GQ4RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_ADDR, 0xc1),
-+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GQ4UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_ADDR, 0xd2),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GQ4RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_ADDR, 0xc2),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
- 	SPINAND_INFO("GD5F1GQ4UFxxG",
- 		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE, 0xb1, 0x48),
- 		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
diff -uprN a/target/linux/generic/backport-5.10/420-v5.19-03-mtd-spinand-gigadevice-add-support-for-GD5F1GQ5RExxG.patch b/target/linux/generic/backport-5.10/420-v5.19-03-mtd-spinand-gigadevice-add-support-for-GD5F1GQ5RExxG.patch
--- a/target/linux/generic/backport-5.10/420-v5.19-03-mtd-spinand-gigadevice-add-support-for-GD5F1GQ5RExxG.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/420-v5.19-03-mtd-spinand-gigadevice-add-support-for-GD5F1GQ5RExxG.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,33 +0,0 @@
-From 620a988813403318023296b61228ee8f3fcdb8e0 Mon Sep 17 00:00:00 2001
-From: Chuanhong Guo <gch981213@gmail.com>
-Date: Sun, 20 Mar 2022 17:59:59 +0800
-Subject: [PATCH 3/5] mtd: spinand: gigadevice: add support for GD5F1GQ5RExxG
-
-This chip is the 1.8v version of GD5F1GQ5UExxG.
-
-Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20220320100001.247905-4-gch981213@gmail.com
----
- drivers/mtd/nand/spi/gigadevice.c | 10 ++++++++++
- 1 file changed, 10 insertions(+)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -383,6 +383,16 @@ static const struct spinand_info gigadev
- 		     SPINAND_HAS_QE_BIT,
- 		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
- 				     gd5fxgq5xexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F1GQ5RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x41),
-+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
-+		     NAND_ECCREQ(4, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq5xexxg_ecc_get_status)),
- };
- 
- static const struct spinand_manufacturer_ops gigadevice_spinand_manuf_ops = {
diff -uprN a/target/linux/generic/backport-5.10/420-v5.19-04-mtd-spinand-gigadevice-add-support-for-GD5F-2-4-GQ5x.patch b/target/linux/generic/backport-5.10/420-v5.19-04-mtd-spinand-gigadevice-add-support-for-GD5F-2-4-GQ5x.patch
--- a/target/linux/generic/backport-5.10/420-v5.19-04-mtd-spinand-gigadevice-add-support-for-GD5F-2-4-GQ5x.patch	2024-03-18 15:15:10.773419710 +0800
+++ b/target/linux/generic/backport-5.10/420-v5.19-04-mtd-spinand-gigadevice-add-support-for-GD5F-2-4-GQ5x.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,84 +0,0 @@
-From 194ec04b3a9e7fa97d1fbef296410631bc3cf1c8 Mon Sep 17 00:00:00 2001
-From: Chuanhong Guo <gch981213@gmail.com>
-Date: Sun, 20 Mar 2022 18:00:00 +0800
-Subject: [PATCH 4/5] mtd: spinand: gigadevice: add support for GD5F{2,
- 4}GQ5xExxG
-
-Add support for:
- GD5F2GQ5{U,R}ExxG
- GD5F4GQ6{U,R}ExxG
-
-These chips uses 4 dummy bytes for quad io and 2 dummy bytes for dual io.
-Besides that and memory layout, they are identical to their 1G variant.
-
-Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20220320100001.247905-5-gch981213@gmail.com
----
- drivers/mtd/nand/spi/gigadevice.c | 48 +++++++++++++++++++++++++++++++
- 1 file changed, 48 insertions(+)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -47,6 +47,14 @@ static SPINAND_OP_VARIANTS(read_cache_va
- 		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
- 		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
- 
-+static SPINAND_OP_VARIANTS(read_cache_variants_2gq5,
-+		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 4, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 2, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
-+		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
-+
- static SPINAND_OP_VARIANTS(write_cache_variants,
- 		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
- 		SPINAND_PROG_LOAD(true, 0, NULL, 0));
-@@ -391,6 +399,46 @@ static const struct spinand_info gigadev
- 					      &write_cache_variants,
- 					      &update_cache_variants),
- 		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq5xexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GQ5UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x52),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
-+		     NAND_ECCREQ(4, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_2gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq5xexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GQ5RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x42),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
-+		     NAND_ECCREQ(4, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_2gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq5xexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F4GQ6UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x55),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 2, 1),
-+		     NAND_ECCREQ(4, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_2gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq5xexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F4GQ6RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x45),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 2, 1),
-+		     NAND_ECCREQ(4, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_2gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
- 		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
- 				     gd5fxgq5xexxg_ecc_get_status)),
- };
diff -uprN a/target/linux/generic/backport-5.10/420-v5.19-05-mtd-spinand-gigadevice-add-support-for-GD5FxGM7xExxG.patch b/target/linux/generic/backport-5.10/420-v5.19-05-mtd-spinand-gigadevice-add-support-for-GD5FxGM7xExxG.patch
--- a/target/linux/generic/backport-5.10/420-v5.19-05-mtd-spinand-gigadevice-add-support-for-GD5FxGM7xExxG.patch	2024-03-18 15:15:10.773419710 +0800
+++ b/target/linux/generic/backport-5.10/420-v5.19-05-mtd-spinand-gigadevice-add-support-for-GD5FxGM7xExxG.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,91 +0,0 @@
-From 54647cd003c08b714474a5b599a147ec6a160486 Mon Sep 17 00:00:00 2001
-From: Chuanhong Guo <gch981213@gmail.com>
-Date: Sun, 20 Mar 2022 18:00:01 +0800
-Subject: [PATCH 5/5] mtd: spinand: gigadevice: add support for GD5FxGM7xExxG
-
-Add support for:
- GD5F{1,2}GM7{U,R}ExxG
- GD5F4GM8{U,R}ExxG
-
-These are new 27nm counterparts for the GD5FxGQ4 chips from GigaDevice
-with 8b/512b on-die ECC capability.
-These chips (and currently supported GD5FxGQ5 chips) have QIO DTR
-instruction for reading page cache. It isn't added in this patch because
-I don't have a DTR spi controller for testing.
-
-Signed-off-by: Chuanhong Guo <gch981213@gmail.com>
-Signed-off-by: Miquel Raynal <miquel.raynal@bootlin.com>
-Link: https://lore.kernel.org/linux-mtd/20220320100001.247905-6-gch981213@gmail.com
----
- drivers/mtd/nand/spi/gigadevice.c | 60 +++++++++++++++++++++++++++++++
- 1 file changed, 60 insertions(+)
-
---- a/drivers/mtd/nand/spi/gigadevice.c
-+++ b/drivers/mtd/nand/spi/gigadevice.c
-@@ -441,6 +441,66 @@ static const struct spinand_info gigadev
- 		     SPINAND_HAS_QE_BIT,
- 		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
- 				     gd5fxgq5xexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F1GM7UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x91),
-+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F1GM7RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x81),
-+		     NAND_MEMORG(1, 2048, 128, 64, 1024, 20, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GM7UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x92),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F2GM7RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x82),
-+		     NAND_MEMORG(1, 2048, 128, 64, 2048, 40, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F4GM8UExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x95),
-+		     NAND_MEMORG(1, 2048, 128, 64, 4096, 80, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
-+	SPINAND_INFO("GD5F4GM8RExxG",
-+		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0x85),
-+		     NAND_MEMORG(1, 2048, 128, 64, 4096, 80, 1, 1, 1),
-+		     NAND_ECCREQ(8, 512),
-+		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants_1gq5,
-+					      &write_cache_variants,
-+					      &update_cache_variants),
-+		     SPINAND_HAS_QE_BIT,
-+		     SPINAND_ECCINFO(&gd5fxgqx_variant2_ooblayout,
-+				     gd5fxgq4uexxg_ecc_get_status)),
- };
- 
- static const struct spinand_manufacturer_ops gigadevice_spinand_manuf_ops = {
diff -uprN a/target/linux/generic/backport-5.10/600-v5.12-net-extract-napi-poll-functionality-to-__napi_poll.patch b/target/linux/generic/backport-5.10/600-v5.12-net-extract-napi-poll-functionality-to-__napi_poll.patch
--- a/target/linux/generic/backport-5.10/600-v5.12-net-extract-napi-poll-functionality-to-__napi_poll.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/600-v5.12-net-extract-napi-poll-functionality-to-__napi_poll.patch	2024-03-18 15:16:23.702637301 +0800
@@ -18,7 +18,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -6813,15 +6813,10 @@ void __netif_napi_del(struct napi_struct
+@@ -6805,15 +6805,10 @@ void __netif_napi_del(struct napi_struct
  }
  EXPORT_SYMBOL(__netif_napi_del);
  
@@ -35,7 +35,7 @@ Signed-off-by: David S. Miller <davem@da
  	weight = n->weight;
  
  	/* This NAPI_STATE_SCHED test is for avoiding a race
-@@ -6841,7 +6836,7 @@ static int napi_poll(struct napi_struct
+@@ -6833,7 +6828,7 @@ static int napi_poll(struct napi_struct
  			    n->poll, work, weight);
  
  	if (likely(work < weight))
@@ -44,7 +44,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	/* Drivers must not modify the NAPI state if they
  	 * consume the entire weight.  In such cases this code
-@@ -6850,7 +6845,7 @@ static int napi_poll(struct napi_struct
+@@ -6842,7 +6837,7 @@ static int napi_poll(struct napi_struct
  	 */
  	if (unlikely(napi_disable_pending(n))) {
  		napi_complete(n);
@@ -53,7 +53,7 @@ Signed-off-by: David S. Miller <davem@da
  	}
  
  	if (n->gro_bitmask) {
-@@ -6868,12 +6863,29 @@ static int napi_poll(struct napi_struct
+@@ -6860,12 +6855,29 @@ static int napi_poll(struct napi_struct
  	if (unlikely(!list_empty(&n->poll_list))) {
  		pr_warn_once("%s: Budget exhausted after napi rescheduled\n",
  			     n->dev ? n->dev->name : "backlog");
diff -uprN a/target/linux/generic/backport-5.10/601-v5.12-net-implement-threaded-able-napi-poll-loop-support.patch b/target/linux/generic/backport-5.10/601-v5.12-net-implement-threaded-able-napi-poll-loop-support.patch
--- a/target/linux/generic/backport-5.10/601-v5.12-net-implement-threaded-able-napi-poll-loop-support.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/601-v5.12-net-implement-threaded-able-napi-poll-loop-support.patch	2024-03-18 15:16:23.706637149 +0800
@@ -30,7 +30,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -356,6 +356,7 @@ struct napi_struct {
+@@ -347,6 +347,7 @@ struct napi_struct {
  	struct list_head	dev_list;
  	struct hlist_node	napi_hash_node;
  	unsigned int		napi_id;
@@ -38,7 +38,7 @@ Signed-off-by: David S. Miller <davem@da
  };
  
  enum {
-@@ -366,6 +367,7 @@ enum {
+@@ -357,6 +358,7 @@ enum {
  	NAPI_STATE_LISTED,	/* NAPI added to system lists */
  	NAPI_STATE_NO_BUSY_POLL,/* Do not add in napi_hash, no busy polling */
  	NAPI_STATE_IN_BUSY_POLL,/* sk_busy_loop() owns this NAPI */
@@ -46,7 +46,7 @@ Signed-off-by: David S. Miller <davem@da
  };
  
  enum {
-@@ -376,6 +378,7 @@ enum {
+@@ -367,6 +369,7 @@ enum {
  	NAPIF_STATE_LISTED	 = BIT(NAPI_STATE_LISTED),
  	NAPIF_STATE_NO_BUSY_POLL = BIT(NAPI_STATE_NO_BUSY_POLL),
  	NAPIF_STATE_IN_BUSY_POLL = BIT(NAPI_STATE_IN_BUSY_POLL),
@@ -54,7 +54,7 @@ Signed-off-by: David S. Miller <davem@da
  };
  
  enum gro_result {
-@@ -506,20 +509,7 @@ static inline bool napi_complete(struct
+@@ -497,20 +500,7 @@ static inline bool napi_complete(struct
   */
  void napi_disable(struct napi_struct *n);
  
@@ -76,7 +76,7 @@ Signed-off-by: David S. Miller <davem@da
  
  /**
   *	napi_synchronize - wait until NAPI is not running
-@@ -1865,6 +1855,8 @@ enum netdev_ml_priv_type {
+@@ -1842,6 +1832,8 @@ enum netdev_ml_priv_type {
   *
   *	@wol_enabled:	Wake-on-LAN is enabled
   *
@@ -85,7 +85,7 @@ Signed-off-by: David S. Miller <davem@da
   *	@net_notifier_list:	List of per-net netdev notifier block
   *				that follow this device when it is moved
   *				to another network namespace.
-@@ -2184,6 +2176,7 @@ struct net_device {
+@@ -2161,6 +2153,7 @@ struct net_device {
  	struct lock_class_key	*qdisc_running_key;
  	bool			proto_down;
  	unsigned		wol_enabled:1;
@@ -131,7 +131,7 @@ Signed-off-by: David S. Miller <davem@da
  static int __dev_open(struct net_device *dev, struct netlink_ext_ack *extack)
  {
  	const struct net_device_ops *ops = dev->netdev_ops;
-@@ -4274,6 +4296,21 @@ int gro_normal_batch __read_mostly = 8;
+@@ -4267,6 +4289,21 @@ int gro_normal_batch __read_mostly = 8;
  static inline void ____napi_schedule(struct softnet_data *sd,
  				     struct napi_struct *napi)
  {
@@ -153,7 +153,7 @@ Signed-off-by: David S. Miller <davem@da
  	list_add_tail(&napi->poll_list, &sd->poll_list);
  	__raise_softirq_irqoff(NET_RX_SOFTIRQ);
  }
-@@ -6766,6 +6803,12 @@ void netif_napi_add(struct net_device *d
+@@ -6758,6 +6795,12 @@ void netif_napi_add(struct net_device *d
  	set_bit(NAPI_STATE_NPSVC, &napi->state);
  	list_add_rcu(&napi->dev_list, &dev->napi_list);
  	napi_hash_add(napi);
@@ -166,7 +166,7 @@ Signed-off-by: David S. Miller <davem@da
  }
  EXPORT_SYMBOL(netif_napi_add);
  
-@@ -6782,9 +6825,28 @@ void napi_disable(struct napi_struct *n)
+@@ -6774,9 +6817,28 @@ void napi_disable(struct napi_struct *n)
  	hrtimer_cancel(&n->timer);
  
  	clear_bit(NAPI_STATE_DISABLE, &n->state);
@@ -195,7 +195,7 @@ Signed-off-by: David S. Miller <davem@da
  static void flush_gro_hash(struct napi_struct *napi)
  {
  	int i;
-@@ -6810,6 +6872,11 @@ void __netif_napi_del(struct napi_struct
+@@ -6802,6 +6864,11 @@ void __netif_napi_del(struct napi_struct
  
  	flush_gro_hash(napi);
  	napi->gro_bitmask = 0;
@@ -207,7 +207,7 @@ Signed-off-by: David S. Miller <davem@da
  }
  EXPORT_SYMBOL(__netif_napi_del);
  
-@@ -6891,6 +6958,51 @@ static int napi_poll(struct napi_struct
+@@ -6883,6 +6950,51 @@ static int napi_poll(struct napi_struct
  	return work;
  }
  
diff -uprN a/target/linux/generic/backport-5.10/602-v5.12-net-add-sysfs-attribute-to-control-napi-threaded-mod.patch b/target/linux/generic/backport-5.10/602-v5.12-net-add-sysfs-attribute-to-control-napi-threaded-mod.patch
--- a/target/linux/generic/backport-5.10/602-v5.12-net-add-sysfs-attribute-to-control-napi-threaded-mod.patch	2024-03-18 15:15:10.673423525 +0800
+++ b/target/linux/generic/backport-5.10/602-v5.12-net-add-sysfs-attribute-to-control-napi-threaded-mod.patch	2024-03-18 15:16:23.642639590 +0800
@@ -46,7 +46,7 @@ Signed-off-by: David S. Miller <davem@da
 +		== ==================================
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -500,6 +500,8 @@ static inline bool napi_complete(struct
+@@ -491,6 +491,8 @@ static inline bool napi_complete(struct
  	return napi_complete_done(n, 0);
  }
  
@@ -57,7 +57,7 @@ Signed-off-by: David S. Miller <davem@da
   *	@n: NAPI context
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -4300,8 +4300,9 @@ static inline void ____napi_schedule(str
+@@ -4293,8 +4293,9 @@ static inline void ____napi_schedule(str
  
  	if (test_bit(NAPI_STATE_THREADED, &napi->state)) {
  		/* Paired with smp_mb__before_atomic() in
@@ -69,7 +69,7 @@ Signed-off-by: David S. Miller <davem@da
  		 * wake_up_process() when it's not NULL.
  		 */
  		thread = READ_ONCE(napi->thread);
-@@ -6776,6 +6777,49 @@ static void init_gro_hash(struct napi_st
+@@ -6768,6 +6769,49 @@ static void init_gro_hash(struct napi_st
  	napi->gro_bitmask = 0;
  }
  
diff -uprN a/target/linux/generic/backport-5.10/603-v5.12-net-fix-race-between-napi-kthread-mode-and-busy-poll.patch b/target/linux/generic/backport-5.10/603-v5.12-net-fix-race-between-napi-kthread-mode-and-busy-poll.patch
--- a/target/linux/generic/backport-5.10/603-v5.12-net-fix-race-between-napi-kthread-mode-and-busy-poll.patch	2024-03-18 15:15:10.669423677 +0800
+++ b/target/linux/generic/backport-5.10/603-v5.12-net-fix-race-between-napi-kthread-mode-and-busy-poll.patch	2024-03-18 15:16:23.638639742 +0800
@@ -27,7 +27,7 @@ Cc: Hannes Frederic Sowa <hannes@stressi
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -368,6 +368,7 @@ enum {
+@@ -359,6 +359,7 @@ enum {
  	NAPI_STATE_NO_BUSY_POLL,/* Do not add in napi_hash, no busy polling */
  	NAPI_STATE_IN_BUSY_POLL,/* sk_busy_loop() owns this NAPI */
  	NAPI_STATE_THREADED,		/* The poll is performed inside its own thread*/
@@ -35,7 +35,7 @@ Cc: Hannes Frederic Sowa <hannes@stressi
  };
  
  enum {
-@@ -379,6 +380,7 @@ enum {
+@@ -370,6 +371,7 @@ enum {
  	NAPIF_STATE_NO_BUSY_POLL = BIT(NAPI_STATE_NO_BUSY_POLL),
  	NAPIF_STATE_IN_BUSY_POLL = BIT(NAPI_STATE_IN_BUSY_POLL),
  	NAPIF_STATE_THREADED	 = BIT(NAPI_STATE_THREADED),
@@ -45,7 +45,7 @@ Cc: Hannes Frederic Sowa <hannes@stressi
  enum gro_result {
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -4307,6 +4307,8 @@ static inline void ____napi_schedule(str
+@@ -4300,6 +4300,8 @@ static inline void ____napi_schedule(str
  		 */
  		thread = READ_ONCE(napi->thread);
  		if (thread) {
@@ -54,7 +54,7 @@ Cc: Hannes Frederic Sowa <hannes@stressi
  			wake_up_process(thread);
  			return;
  		}
-@@ -6568,7 +6570,8 @@ bool napi_complete_done(struct napi_stru
+@@ -6560,7 +6562,8 @@ bool napi_complete_done(struct napi_stru
  
  		WARN_ON_ONCE(!(val & NAPIF_STATE_SCHED));
  
@@ -64,7 +64,7 @@ Cc: Hannes Frederic Sowa <hannes@stressi
  
  		/* If STATE_MISSED was set, leave STATE_SCHED set,
  		 * because we will call napi->poll() one more time.
-@@ -7004,16 +7007,25 @@ static int napi_poll(struct napi_struct
+@@ -6996,16 +6999,25 @@ static int napi_poll(struct napi_struct
  
  static int napi_thread_wait(struct napi_struct *napi)
  {
diff -uprN a/target/linux/generic/backport-5.10/604-v5.12-net-fix-hangup-on-napi_disable-for-threaded-napi.patch b/target/linux/generic/backport-5.10/604-v5.12-net-fix-hangup-on-napi_disable-for-threaded-napi.patch
--- a/target/linux/generic/backport-5.10/604-v5.12-net-fix-hangup-on-napi_disable-for-threaded-napi.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/604-v5.12-net-fix-hangup-on-napi_disable-for-threaded-napi.patch	2024-03-18 15:16:23.702637301 +0800
@@ -34,7 +34,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -7011,7 +7011,7 @@ static int napi_thread_wait(struct napi_
+@@ -7003,7 +7003,7 @@ static int napi_thread_wait(struct napi_
  
  	set_current_state(TASK_INTERRUPTIBLE);
  
@@ -43,7 +43,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  		/* Testing SCHED_THREADED bit here to make sure the current
  		 * kthread owns this napi and could poll on this napi.
  		 * Testing SCHED bit is not enough because SCHED bit might be
-@@ -7029,6 +7029,7 @@ static int napi_thread_wait(struct napi_
+@@ -7021,6 +7021,7 @@ static int napi_thread_wait(struct napi_
  		set_current_state(TASK_INTERRUPTIBLE);
  	}
  	__set_current_state(TASK_RUNNING);
diff -uprN a/target/linux/generic/backport-5.10/605-v5.12-net-export-dev_set_threaded-symbol.patch b/target/linux/generic/backport-5.10/605-v5.12-net-export-dev_set_threaded-symbol.patch
--- a/target/linux/generic/backport-5.10/605-v5.12-net-export-dev_set_threaded-symbol.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/605-v5.12-net-export-dev_set_threaded-symbol.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From: Lorenzo Bianconi <lorenzo@kernel.org>
-Date: Sun, 14 Mar 2021 15:49:19 +0100
-Subject: [PATCH] net: export dev_set_threaded symbol
-
-For wireless devices (e.g. mt76 driver) multiple net_devices belongs to
-the same wireless phy and the napi object is registered in a dummy
-netdevice related to the wireless phy.
-Export dev_set_threaded in order to be reused in device drivers enabling
-threaded NAPI.
-
-Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
-
---- a/net/core/dev.c
-+++ b/net/core/dev.c
-@@ -6822,6 +6822,7 @@ int dev_set_threaded(struct net_device *
- 
- 	return err;
- }
-+EXPORT_SYMBOL(dev_set_threaded);
- 
- void netif_napi_add(struct net_device *dev, struct napi_struct *napi,
- 		    int (*poll)(struct napi_struct *, int), int weight)
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-01-netfilter-flowtable-separate-replace-destroy-and-sta.patch b/target/linux/generic/backport-5.10/610-v5.13-01-netfilter-flowtable-separate-replace-destroy-and-sta.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-01-netfilter-flowtable-separate-replace-destroy-and-sta.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-01-netfilter-flowtable-separate-replace-destroy-and-sta.patch	2024-03-18 15:16:23.678638217 +0800
@@ -58,7 +58,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  }
  
  static int nf_flow_table_block_setup(struct nf_flowtable *flowtable,
-@@ -1017,15 +1027,33 @@ EXPORT_SYMBOL_GPL(nf_flow_table_offload_
+@@ -1013,15 +1023,33 @@ EXPORT_SYMBOL_GPL(nf_flow_table_offload_
  
  int nf_flow_table_offload_init(void)
  {
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-10-netfilter-nftables-update-table-flags-from-the-commi.patch b/target/linux/generic/backport-5.10/610-v5.13-10-netfilter-nftables-update-table-flags-from-the-commi.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-10-netfilter-nftables-update-table-flags-from-the-commi.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-10-netfilter-nftables-update-table-flags-from-the-commi.patch	2024-03-18 15:16:23.702637301 +0800
@@ -12,7 +12,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/net/netfilter/nf_tables.h
 +++ b/include/net/netfilter/nf_tables.h
-@@ -1474,13 +1474,16 @@ struct nft_trans_chain {
+@@ -1470,13 +1470,16 @@ struct nft_trans_chain {
  
  struct nft_trans_table {
  	bool				update;
@@ -34,7 +34,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	struct nft_set			*set;
 --- a/net/netfilter/nf_tables_api.c
 +++ b/net/netfilter/nf_tables_api.c
-@@ -917,6 +917,12 @@ static void nf_tables_table_disable(stru
+@@ -891,6 +891,12 @@ static void nf_tables_table_disable(stru
  	nft_table_disable(net, table, 0);
  }
  
@@ -47,7 +47,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  static int nf_tables_updtable(struct nft_ctx *ctx)
  {
  	struct nft_trans *trans;
-@@ -940,19 +946,17 @@ static int nf_tables_updtable(struct nft
+@@ -914,19 +920,17 @@ static int nf_tables_updtable(struct nft
  
  	if ((flags & NFT_TABLE_F_DORMANT) &&
  	    !(ctx->table->flags & NFT_TABLE_F_DORMANT)) {
@@ -70,7 +70,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	nft_trans_table_update(trans) = true;
  	list_add_tail(&trans->list, &ctx->net->nft.commit_list);
  	return 0;
-@@ -7918,11 +7922,10 @@ static int nf_tables_commit(struct net *
+@@ -7908,11 +7912,10 @@ static int nf_tables_commit(struct net *
  		switch (trans->msg_type) {
  		case NFT_MSG_NEWTABLE:
  			if (nft_trans_table_update(trans)) {
@@ -86,7 +86,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  			} else {
  				nft_clear(net, trans->ctx.table);
  			}
-@@ -8139,11 +8142,9 @@ static int __nf_tables_abort(struct net
+@@ -8125,11 +8128,9 @@ static int __nf_tables_abort(struct net
  		switch (trans->msg_type) {
  		case NFT_MSG_NEWTABLE:
  			if (nft_trans_table_update(trans)) {
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-11-net-resolve-forwarding-path-from-virtual-netdevice-a.patch b/target/linux/generic/backport-5.10/610-v5.13-11-net-resolve-forwarding-path-from-virtual-netdevice-a.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-11-net-resolve-forwarding-path-from-virtual-netdevice-a.patch	2024-03-18 15:15:10.677423372 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-11-net-resolve-forwarding-path-from-virtual-netdevice-a.patch	2024-03-18 15:16:23.642639590 +0800
@@ -58,7 +58,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -850,6 +850,27 @@ typedef u16 (*select_queue_fallback_t)(s
+@@ -827,6 +827,27 @@ typedef u16 (*select_queue_fallback_t)(s
  				       struct sk_buff *skb,
  				       struct net_device *sb_dev);
  
@@ -86,7 +86,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  enum tc_setup_type {
  	TC_SETUP_QDISC_MQPRIO,
  	TC_SETUP_CLSU32,
-@@ -1296,6 +1317,8 @@ struct netdev_net_notifier {
+@@ -1273,6 +1294,8 @@ struct netdev_net_notifier {
   * struct net_device *(*ndo_get_peer_dev)(struct net_device *dev);
   *	If a device is paired with a peer device, return the peer instance.
   *	The caller must be under RCU read context.
@@ -95,7 +95,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
   */
  struct net_device_ops {
  	int			(*ndo_init)(struct net_device *dev);
-@@ -1504,6 +1527,8 @@ struct net_device_ops {
+@@ -1481,6 +1504,8 @@ struct net_device_ops {
  	int			(*ndo_tunnel_ctl)(struct net_device *dev,
  						  struct ip_tunnel_parm *p, int cmd);
  	struct net_device *	(*ndo_get_peer_dev)(struct net_device *dev);
@@ -104,7 +104,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  };
  
  /**
-@@ -2851,6 +2876,8 @@ void dev_remove_offload(struct packet_of
+@@ -2828,6 +2853,8 @@ void dev_remove_offload(struct packet_of
  
  int dev_get_iflink(const struct net_device *dev);
  int dev_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb);
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-12-net-8021q-resolve-forwarding-path-for-vlan-devices.patch b/target/linux/generic/backport-5.10/610-v5.13-12-net-8021q-resolve-forwarding-path-for-vlan-devices.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-12-net-8021q-resolve-forwarding-path-for-vlan-devices.patch	2024-03-18 15:15:10.645424592 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-12-net-8021q-resolve-forwarding-path-for-vlan-devices.patch	2024-03-18 15:16:23.638639742 +0800
@@ -28,7 +28,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -852,11 +852,18 @@ typedef u16 (*select_queue_fallback_t)(s
+@@ -829,11 +829,18 @@ typedef u16 (*select_queue_fallback_t)(s
  
  enum net_device_path_type {
  	DEV_PATH_ETHERNET = 0,
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-13-net-bridge-resolve-forwarding-path-for-bridge-device.patch b/target/linux/generic/backport-5.10/610-v5.13-13-net-bridge-resolve-forwarding-path-for-bridge-device.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-13-net-bridge-resolve-forwarding-path-for-bridge-device.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-13-net-bridge-resolve-forwarding-path-for-bridge-device.patch	2024-03-18 15:16:23.706637149 +0800
@@ -9,7 +9,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -853,6 +853,7 @@ typedef u16 (*select_queue_fallback_t)(s
+@@ -830,6 +830,7 @@ typedef u16 (*select_queue_fallback_t)(s
  enum net_device_path_type {
  	DEV_PATH_ETHERNET = 0,
  	DEV_PATH_VLAN,
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-14-net-bridge-resolve-forwarding-path-for-VLAN-tag-acti.patch b/target/linux/generic/backport-5.10/610-v5.13-14-net-bridge-resolve-forwarding-path-for-VLAN-tag-acti.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-14-net-bridge-resolve-forwarding-path-for-VLAN-tag-acti.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-14-net-bridge-resolve-forwarding-path-for-VLAN-tag-acti.patch	2024-03-18 15:16:23.706637149 +0800
@@ -15,7 +15,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -864,10 +864,20 @@ struct net_device_path {
+@@ -841,10 +841,20 @@ struct net_device_path {
  			u16		id;
  			__be16		proto;
  		} encap;
@@ -36,7 +36,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  
  struct net_device_path_stack {
  	int			num_paths;
-@@ -877,6 +887,12 @@ struct net_device_path_stack {
+@@ -854,6 +864,12 @@ struct net_device_path_stack {
  struct net_device_path_ctx {
  	const struct net_device *dev;
  	const u8		*daddr;
@@ -145,7 +145,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  					const struct net_bridge *br)
 --- a/net/bridge/br_vlan.c
 +++ b/net/bridge/br_vlan.c
-@@ -1350,6 +1350,59 @@ int br_vlan_get_pvid_rcu(const struct ne
+@@ -1327,6 +1327,59 @@ int br_vlan_get_pvid_rcu(const struct ne
  }
  EXPORT_SYMBOL_GPL(br_vlan_get_pvid_rcu);
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-15-net-ppp-resolve-forwarding-path-for-bridge-pppoe-dev.patch b/target/linux/generic/backport-5.10/610-v5.13-15-net-ppp-resolve-forwarding-path-for-bridge-pppoe-dev.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-15-net-ppp-resolve-forwarding-path-for-bridge-pppoe-dev.patch	2024-03-18 15:15:10.701422456 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-15-net-ppp-resolve-forwarding-path-for-bridge-pppoe-dev.patch	2024-03-18 15:16:23.662638827 +0800
@@ -83,7 +83,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  static int pppoe_recvmsg(struct socket *sock, struct msghdr *m,
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -854,6 +854,7 @@ enum net_device_path_type {
+@@ -831,6 +831,7 @@ enum net_device_path_type {
  	DEV_PATH_ETHERNET = 0,
  	DEV_PATH_VLAN,
  	DEV_PATH_BRIDGE,
@@ -91,7 +91,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  };
  
  struct net_device_path {
-@@ -863,6 +864,7 @@ struct net_device_path {
+@@ -840,6 +841,7 @@ struct net_device_path {
  		struct {
  			u16		id;
  			__be16		proto;
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-16-net-dsa-resolve-forwarding-path-for-dsa-slave-ports.patch b/target/linux/generic/backport-5.10/610-v5.13-16-net-dsa-resolve-forwarding-path-for-dsa-slave-ports.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-16-net-dsa-resolve-forwarding-path-for-dsa-slave-ports.patch	2024-03-18 15:15:10.681423219 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-16-net-dsa-resolve-forwarding-path-for-dsa-slave-ports.patch	2024-03-18 15:16:23.642639590 +0800
@@ -10,7 +10,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -855,6 +855,7 @@ enum net_device_path_type {
+@@ -832,6 +832,7 @@ enum net_device_path_type {
  	DEV_PATH_VLAN,
  	DEV_PATH_BRIDGE,
  	DEV_PATH_PPPOE,
@@ -18,7 +18,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  };
  
  struct net_device_path {
-@@ -875,6 +876,10 @@ struct net_device_path {
+@@ -852,6 +853,10 @@ struct net_device_path {
  			u16		vlan_id;
  			__be16		vlan_proto;
  		} bridge;
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-26-netfilter-nft_flow_offload-use-direct-xmit-if-hardwa.patch b/target/linux/generic/backport-5.10/610-v5.13-26-netfilter-nft_flow_offload-use-direct-xmit-if-hardwa.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-26-netfilter-nft_flow_offload-use-direct-xmit-if-hardwa.patch	2024-03-18 15:15:10.681423219 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-26-netfilter-nft_flow_offload-use-direct-xmit-if-hardwa.patch	2024-03-18 15:16:23.642639590 +0800
@@ -70,7 +70,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 +{
 +	if (!dev || (dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||
 +	    dev->addr_len != ETH_ALEN || !is_valid_ether_addr(dev->dev_addr))
-+		return false;
++		return true;
 +
 +	return true;
 +}
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-27-netfilter-flowtable-bridge-vlan-hardware-offload-and.patch b/target/linux/generic/backport-5.10/610-v5.13-27-netfilter-flowtable-bridge-vlan-hardware-offload-and.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-27-netfilter-flowtable-bridge-vlan-hardware-offload-and.patch	2024-03-18 15:15:10.789419098 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-27-netfilter-flowtable-bridge-vlan-hardware-offload-and.patch	2024-03-18 15:16:23.706637149 +0800
@@ -12,7 +12,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -872,6 +872,7 @@ struct net_device_path {
+@@ -849,6 +849,7 @@ struct net_device_path {
  				DEV_PATH_BR_VLAN_KEEP,
  				DEV_PATH_BR_VLAN_TAG,
  				DEV_PATH_BR_VLAN_UNTAG,
@@ -57,7 +57,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  		break;
 --- a/net/bridge/br_vlan.c
 +++ b/net/bridge/br_vlan.c
-@@ -1397,6 +1397,8 @@ int br_vlan_fill_forward_path_mode(struc
+@@ -1374,6 +1374,8 @@ int br_vlan_fill_forward_path_mode(struc
  
  	if (path->bridge.vlan_mode == DEV_PATH_BR_VLAN_TAG)
  		path->bridge.vlan_mode = DEV_PATH_BR_VLAN_KEEP;
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-31-net-ethernet-mtk_eth_soc-fix-parsing-packets-in-GDM.patch b/target/linux/generic/backport-5.10/610-v5.13-31-net-ethernet-mtk_eth_soc-fix-parsing-packets-in-GDM.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-31-net-ethernet-mtk_eth_soc-fix-parsing-packets-in-GDM.patch	2024-03-18 15:15:10.769419862 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-31-net-ethernet-mtk_eth_soc-fix-parsing-packets-in-GDM.patch	2024-03-18 15:16:23.678638217 +0800
@@ -19,7 +19,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  
  #include "mtk_eth_soc.h"
  
-@@ -1297,13 +1298,12 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1285,13 +1286,12 @@ static int mtk_poll_rx(struct napi_struc
  			break;
  
  		/* find out which mac the packet come from. values start at 1 */
@@ -38,7 +38,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  
  		if (unlikely(mac < 0 || mac >= MTK_MAC_COUNT ||
  			     !eth->netdev[mac]))
-@@ -2275,6 +2275,9 @@ static void mtk_gdm_config(struct mtk_et
+@@ -2254,6 +2254,9 @@ static void mtk_gdm_config(struct mtk_et
  
  		val |= config;
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-32-net-ethernet-mtk_eth_soc-add-support-for-initializin.patch b/target/linux/generic/backport-5.10/610-v5.13-32-net-ethernet-mtk_eth_soc-add-support-for-initializin.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-32-net-ethernet-mtk_eth_soc-add-support-for-initializin.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-32-net-ethernet-mtk_eth_soc-add-support-for-initializin.patch	2024-03-18 15:16:23.706637149 +0800
@@ -27,7 +27,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  obj-$(CONFIG_NET_MEDIATEK_STAR_EMAC) += mtk_star_emac.o
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2300,15 +2300,20 @@ static int mtk_open(struct net_device *d
+@@ -2279,12 +2279,17 @@ static int mtk_open(struct net_device *d
  
  	/* we run 2 netdevs on the same dma ring so we only bring it up once */
  	if (!refcount_read(&eth->dma_refcnt)) {
@@ -37,10 +37,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  
 +		err = mtk_start_dma(eth);
  		if (err)
- 		if (err) {
- 			phylink_disconnect_phy(mac->phylink);
  			return err;
- 		}
  
 -		mtk_gdm_config(eth, MTK_GDMA_TO_PDMA);
 +		if (eth->soc->offload_version && mtk_ppe_start(&eth->ppe) == 0)
@@ -50,7 +47,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  
  		napi_enable(&eth->tx_napi);
  		napi_enable(&eth->rx_napi);
-@@ -2375,6 +2380,9 @@ static int mtk_stop(struct net_device *d
+@@ -2351,6 +2356,9 @@ static int mtk_stop(struct net_device *d
  
  	mtk_dma_free(eth);
  
@@ -60,7 +57,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	return 0;
  }
  
-@@ -3103,6 +3111,13 @@ static int mtk_probe(struct platform_dev
+@@ -3079,6 +3087,13 @@ static int mtk_probe(struct platform_dev
  			goto err_free_dev;
  	}
  
@@ -74,7 +71,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	for (i = 0; i < MTK_MAX_DEVS; i++) {
  		if (!eth->netdev[i])
  			continue;
-@@ -3177,6 +3192,7 @@ static const struct mtk_soc_data mt7621_
+@@ -3153,6 +3168,7 @@ static const struct mtk_soc_data mt7621_
  	.hw_features = MTK_HW_FEATURES,
  	.required_clks = MT7621_CLKS_BITMAP,
  	.required_pctl = false,
@@ -82,7 +79,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  };
  
  static const struct mtk_soc_data mt7622_data = {
-@@ -3185,6 +3201,7 @@ static const struct mtk_soc_data mt7622_
+@@ -3161,6 +3177,7 @@ static const struct mtk_soc_data mt7622_
  	.hw_features = MTK_HW_FEATURES,
  	.required_clks = MT7622_CLKS_BITMAP,
  	.required_pctl = false,
@@ -121,7 +118,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  #define RX_DMA_L4_VALID		BIT(24)
  #define RX_DMA_L4_VALID_PDMA	BIT(30)		/* when PDMA is used */
  #define RX_DMA_FPORT_SHIFT	19
-@@ -820,6 +828,7 @@ struct mtk_soc_data {
+@@ -819,6 +827,7 @@ struct mtk_soc_data {
  	u32		caps;
  	u32		required_clks;
  	bool		required_pctl;
@@ -129,7 +126,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	netdev_features_t hw_features;
  };
  
-@@ -919,6 +928,8 @@ struct mtk_eth {
+@@ -918,6 +927,8 @@ struct mtk_eth {
  	u32				tx_int_status_reg;
  	u32				rx_dma_l4_valid;
  	int				ip_align;
@@ -580,9 +577,9 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 +
 +	mtk_ppe_cache_enable(ppe, true);
 +
-+	val = MTK_PPE_FLOW_CFG_IP4_TCP_FRAG |
-+	      MTK_PPE_FLOW_CFG_IP4_UDP_FRAG |
-+	      MTK_PPE_FLOW_CFG_IP6_3T_ROUTE |
++	 
++	 
++	val = MTK_PPE_FLOW_CFG_IP6_3T_ROUTE |
 +	      MTK_PPE_FLOW_CFG_IP6_5T_ROUTE |
 +	      MTK_PPE_FLOW_CFG_IP6_6RD |
 +	      MTK_PPE_FLOW_CFG_IP4_NAT |
@@ -611,7 +608,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 +	      FIELD_PREP(MTK_PPE_BIND_LIMIT1_NON_L4, 1);
 +	ppe_w32(ppe, MTK_PPE_BIND_LIMIT1, val);
 +
-+	val = FIELD_PREP(MTK_PPE_BIND_RATE_BIND, 30) |
++	val = FIELD_PREP(MTK_PPE_BIND_RATE_BIND, 1) |
 +	      FIELD_PREP(MTK_PPE_BIND_RATE_PREBIND, 1);
 +	ppe_w32(ppe, MTK_PPE_BIND_RATE, val);
 +
@@ -666,7 +663,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 +
 +#define MTK_ETH_PPE_BASE		0xc00
 +
-+#define MTK_PPE_ENTRIES_SHIFT		3
++#define MTK_PPE_ENTRIES_SHIFT		4
 +#define MTK_PPE_ENTRIES			(1024 << MTK_PPE_ENTRIES_SHIFT)
 +#define MTK_PPE_HASH_MASK		(MTK_PPE_ENTRIES - 1)
 +
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-33-net-ethernet-mtk_eth_soc-add-flow-offloading-support.patch b/target/linux/generic/backport-5.10/610-v5.13-33-net-ethernet-mtk_eth_soc-add-flow-offloading-support.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-33-net-ethernet-mtk_eth_soc-add-flow-offloading-support.patch	2024-03-18 15:15:10.697422608 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-33-net-ethernet-mtk_eth_soc-add-flow-offloading-support.patch	2024-03-18 15:16:23.662638827 +0800
@@ -21,7 +21,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  obj-$(CONFIG_NET_MEDIATEK_STAR_EMAC) += mtk_star_emac.o
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2858,6 +2858,7 @@ static const struct net_device_ops mtk_n
+@@ -2834,6 +2834,7 @@ static const struct net_device_ops mtk_n
  #ifdef CONFIG_NET_POLL_CONTROLLER
  	.ndo_poll_controller	= mtk_poll_controller,
  #endif
@@ -29,7 +29,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  };
  
  static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
-@@ -3116,6 +3117,10 @@ static int mtk_probe(struct platform_dev
+@@ -3092,6 +3093,10 @@ static int mtk_probe(struct platform_dev
  				   eth->base + MTK_ETH_PPE_BASE, 2);
  		if (err)
  			goto err_free_dev;
@@ -60,7 +60,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  #define MTK_HW_FEATURES_MT7628	(NETIF_F_SG | NETIF_F_RXCSUM)
  #define NEXT_DESP_IDX(X, Y)	(((X) + 1) & ((Y) - 1))
  
-@@ -930,6 +932,7 @@ struct mtk_eth {
+@@ -929,6 +931,7 @@ struct mtk_eth {
  	int				ip_align;
  
  	struct mtk_ppe			ppe;
@@ -68,7 +68,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  };
  
  /* struct mtk_mac -	the structure that holds the info about the MACs of the
-@@ -974,4 +977,9 @@ int mtk_gmac_sgmii_path_setup(struct mtk
+@@ -973,4 +976,9 @@ int mtk_gmac_sgmii_path_setup(struct mtk
  int mtk_gmac_gephy_path_setup(struct mtk_eth *eth, int mac_id);
  int mtk_gmac_rgmii_path_setup(struct mtk_eth *eth, int mac_id);
  
@@ -539,7 +539,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
 +		block_cb = flow_block_cb_lookup(f->block, cb, dev);
 +		if (!block_cb)
 +			return -ENOENT;
-+
++		
 +		if (flow_block_cb_decref(block_cb)) {
 +			flow_block_cb_remove(block_cb, f);
 +			list_del(&block_cb->driver_list);
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-38-net-ethernet-mtk_eth_soc-unmap-RX-data-before-callin.patch b/target/linux/generic/backport-5.10/610-v5.13-38-net-ethernet-mtk_eth_soc-unmap-RX-data-before-callin.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-38-net-ethernet-mtk_eth_soc-unmap-RX-data-before-callin.patch	2024-03-18 15:15:10.629425203 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-38-net-ethernet-mtk_eth_soc-unmap-RX-data-before-callin.patch	2024-03-18 15:16:23.638639742 +0800
@@ -17,7 +17,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1334,6 +1334,9 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1319,6 +1319,9 @@ static int mtk_poll_rx(struct napi_struc
  			goto release_desc;
  		}
  
@@ -27,7 +27,7 @@ Signed-off-by: David S. Miller <davem@da
  		/* receive data */
  		skb = build_skb(data, ring->frag_size);
  		if (unlikely(!skb)) {
-@@ -1343,8 +1346,6 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1328,8 +1331,6 @@ static int mtk_poll_rx(struct napi_struc
  		}
  		skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-39-net-ethernet-mtk_eth_soc-fix-build_skb-cleanup.patch b/target/linux/generic/backport-5.10/610-v5.13-39-net-ethernet-mtk_eth_soc-fix-build_skb-cleanup.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-39-net-ethernet-mtk_eth_soc-fix-build_skb-cleanup.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-39-net-ethernet-mtk_eth_soc-fix-build_skb-cleanup.patch	2024-03-18 15:16:23.678638217 +0800
@@ -16,7 +16,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1340,9 +1340,9 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1325,9 +1325,9 @@ static int mtk_poll_rx(struct napi_struc
  		/* receive data */
  		skb = build_skb(data, ring->frag_size);
  		if (unlikely(!skb)) {
@@ -28,7 +28,7 @@ Signed-off-by: David S. Miller <davem@da
  		}
  		skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);
  
-@@ -1362,6 +1362,7 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1347,6 +1347,7 @@ static int mtk_poll_rx(struct napi_struc
  		skb_record_rx_queue(skb, 0);
  		napi_gro_receive(napi, skb);
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-40-net-ethernet-mtk_eth_soc-use-napi_consume_skb.patch b/target/linux/generic/backport-5.10/610-v5.13-40-net-ethernet-mtk_eth_soc-use-napi_consume_skb.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-40-net-ethernet-mtk_eth_soc-use-napi_consume_skb.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-40-net-ethernet-mtk_eth_soc-use-napi_consume_skb.patch	2024-03-18 15:16:23.702637301 +0800
@@ -14,7 +14,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -891,7 +891,8 @@ static int txd_to_idx(struct mtk_tx_ring
+@@ -879,7 +879,8 @@ static int txd_to_idx(struct mtk_tx_ring
  	return ((void *)dma - (void *)ring->dma) / sizeof(*dma);
  }
  
@@ -24,7 +24,7 @@ Signed-off-by: David S. Miller <davem@da
  {
  	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {
  		if (tx_buf->flags & MTK_TX_FLAGS_SINGLE0) {
-@@ -923,8 +924,12 @@ static void mtk_tx_unmap(struct mtk_eth
+@@ -911,8 +912,12 @@ static void mtk_tx_unmap(struct mtk_eth
  
  	tx_buf->flags = 0;
  	if (tx_buf->skb &&
@@ -39,7 +39,7 @@ Signed-off-by: David S. Miller <davem@da
  	tx_buf->skb = NULL;
  }
  
-@@ -1102,7 +1107,7 @@ err_dma:
+@@ -1090,7 +1095,7 @@ err_dma:
  		tx_buf = mtk_desc_to_tx_buf(ring, itxd);
  
  		/* unmap dma */
@@ -48,7 +48,7 @@ Signed-off-by: David S. Miller <davem@da
  
  		itxd->txd3 = TX_DMA_LS0 | TX_DMA_OWNER_CPU;
  		if (!MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))
-@@ -1424,7 +1429,7 @@ static int mtk_poll_tx_qdma(struct mtk_e
+@@ -1409,7 +1414,7 @@ static int mtk_poll_tx_qdma(struct mtk_e
  			done[mac]++;
  			budget--;
  		}
@@ -57,7 +57,7 @@ Signed-off-by: David S. Miller <davem@da
  
  		ring->last_free = desc;
  		atomic_inc(&ring->free_count);
-@@ -1461,7 +1466,7 @@ static int mtk_poll_tx_pdma(struct mtk_e
+@@ -1446,7 +1451,7 @@ static int mtk_poll_tx_pdma(struct mtk_e
  			budget--;
  		}
  
@@ -66,7 +66,7 @@ Signed-off-by: David S. Miller <davem@da
  
  		desc = &ring->dma[cpu];
  		ring->last_free = desc;
-@@ -1663,7 +1668,7 @@ static void mtk_tx_clean(struct mtk_eth
+@@ -1648,7 +1653,7 @@ static void mtk_tx_clean(struct mtk_eth
  
  	if (ring->buf) {
  		for (i = 0; i < MTK_DMA_SIZE; i++)
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-42-net-ethernet-mtk_eth_soc-remove-unnecessary-TX-queue.patch b/target/linux/generic/backport-5.10/610-v5.13-42-net-ethernet-mtk_eth_soc-remove-unnecessary-TX-queue.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-42-net-ethernet-mtk_eth_soc-remove-unnecessary-TX-queue.patch	2024-03-18 15:15:10.705422304 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-42-net-ethernet-mtk_eth_soc-remove-unnecessary-TX-queue.patch	2024-03-18 15:16:23.662638827 +0800
@@ -16,7 +16,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1164,17 +1164,6 @@ static void mtk_wake_queue(struct mtk_et
+@@ -1152,17 +1152,6 @@ static void mtk_wake_queue(struct mtk_et
  	}
  }
  
@@ -34,7 +34,7 @@ Signed-off-by: David S. Miller <davem@da
  static netdev_tx_t mtk_start_xmit(struct sk_buff *skb, struct net_device *dev)
  {
  	struct mtk_mac *mac = netdev_priv(dev);
-@@ -1195,7 +1184,7 @@ static netdev_tx_t mtk_start_xmit(struct
+@@ -1183,7 +1172,7 @@ static netdev_tx_t mtk_start_xmit(struct
  
  	tx_num = mtk_cal_txd_req(skb);
  	if (unlikely(atomic_read(&ring->free_count) <= tx_num)) {
@@ -43,7 +43,7 @@ Signed-off-by: David S. Miller <davem@da
  		netif_err(eth, tx_queued, dev,
  			  "Tx Ring full when queue awake!\n");
  		spin_unlock(&eth->page_lock);
-@@ -1221,7 +1210,7 @@ static netdev_tx_t mtk_start_xmit(struct
+@@ -1209,7 +1198,7 @@ static netdev_tx_t mtk_start_xmit(struct
  		goto drop;
  
  	if (unlikely(atomic_read(&ring->free_count) <= ring->thresh))
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-43-net-ethernet-mtk_eth_soc-use-larger-burst-size-for-Q.patch b/target/linux/generic/backport-5.10/610-v5.13-43-net-ethernet-mtk_eth_soc-use-larger-burst-size-for-Q.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-43-net-ethernet-mtk_eth_soc-use-larger-burst-size-for-Q.patch	2024-03-18 15:15:10.769419862 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-43-net-ethernet-mtk_eth_soc-use-larger-burst-size-for-Q.patch	2024-03-18 15:16:23.682638064 +0800
@@ -15,7 +15,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2235,7 +2235,7 @@ static int mtk_start_dma(struct mtk_eth
+@@ -2214,7 +2214,7 @@ static int mtk_start_dma(struct mtk_eth
  	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {
  		mtk_w32(eth,
  			MTK_TX_WB_DDONE | MTK_TX_DMA_EN |
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-45-net-ethernet-mtk_eth_soc-implement-dynamic-interrupt.patch b/target/linux/generic/backport-5.10/610-v5.13-45-net-ethernet-mtk_eth_soc-implement-dynamic-interrupt.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-45-net-ethernet-mtk_eth_soc-implement-dynamic-interrupt.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-45-net-ethernet-mtk_eth_soc-implement-dynamic-interrupt.patch	2024-03-18 15:16:23.702637301 +0800
@@ -28,7 +28,7 @@ Signed-off-by: David S. Miller <davem@da
  	  MediaTek SoC family.
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1266,12 +1266,13 @@ static void mtk_update_rx_cpu_idx(struct
+@@ -1254,12 +1254,13 @@ static void mtk_update_rx_cpu_idx(struct
  static int mtk_poll_rx(struct napi_struct *napi, int budget,
  		       struct mtk_eth *eth)
  {
@@ -43,7 +43,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	while (done < budget) {
  		struct net_device *netdev;
-@@ -1348,6 +1349,7 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1333,6 +1334,7 @@ static int mtk_poll_rx(struct napi_struc
  		else
  			skb_checksum_none_assert(skb);
  		skb->protocol = eth_type_trans(skb, netdev);
@@ -51,7 +51,7 @@ Signed-off-by: David S. Miller <davem@da
  
  		if (netdev->features & NETIF_F_HW_VLAN_CTAG_RX &&
  		    (trxd.rxd2 & RX_DMA_VTAG))
-@@ -1380,6 +1382,12 @@ rx_done:
+@@ -1365,6 +1367,12 @@ rx_done:
  		mtk_update_rx_cpu_idx(eth);
  	}
  
@@ -64,7 +64,7 @@ Signed-off-by: David S. Miller <davem@da
  	return done;
  }
  
-@@ -1472,6 +1480,7 @@ static int mtk_poll_tx_pdma(struct mtk_e
+@@ -1457,6 +1465,7 @@ static int mtk_poll_tx_pdma(struct mtk_e
  static int mtk_poll_tx(struct mtk_eth *eth, int budget)
  {
  	struct mtk_tx_ring *ring = &eth->tx_ring;
@@ -72,7 +72,7 @@ Signed-off-by: David S. Miller <davem@da
  	unsigned int done[MTK_MAX_DEVS];
  	unsigned int bytes[MTK_MAX_DEVS];
  	int total = 0, i;
-@@ -1489,8 +1498,14 @@ static int mtk_poll_tx(struct mtk_eth *e
+@@ -1474,8 +1483,14 @@ static int mtk_poll_tx(struct mtk_eth *e
  			continue;
  		netdev_completed_queue(eth->netdev[i], done[i], bytes[i]);
  		total += done[i];
@@ -87,7 +87,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (mtk_queue_stopped(eth) &&
  	    (atomic_read(&ring->free_count) > ring->thresh))
  		mtk_wake_queue(eth);
-@@ -2171,6 +2186,7 @@ static irqreturn_t mtk_handle_irq_rx(int
+@@ -2150,6 +2165,7 @@ static irqreturn_t mtk_handle_irq_rx(int
  {
  	struct mtk_eth *eth = _eth;
  
@@ -95,7 +95,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (likely(napi_schedule_prep(&eth->rx_napi))) {
  		__napi_schedule(&eth->rx_napi);
  		mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
-@@ -2183,6 +2199,7 @@ static irqreturn_t mtk_handle_irq_tx(int
+@@ -2162,6 +2178,7 @@ static irqreturn_t mtk_handle_irq_tx(int
  {
  	struct mtk_eth *eth = _eth;
  
@@ -103,7 +103,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (likely(napi_schedule_prep(&eth->tx_napi))) {
  		__napi_schedule(&eth->tx_napi);
  		mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
-@@ -2370,6 +2387,9 @@ static int mtk_stop(struct net_device *d
+@@ -2346,6 +2363,9 @@ static int mtk_stop(struct net_device *d
  	napi_disable(&eth->tx_napi);
  	napi_disable(&eth->rx_napi);
  
@@ -113,7 +113,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))
  		mtk_stop_dma(eth, MTK_QDMA_GLO_CFG);
  	mtk_stop_dma(eth, MTK_PDMA_GLO_CFG);
-@@ -2422,6 +2442,64 @@ err_disable_clks:
+@@ -2398,6 +2418,64 @@ err_disable_clks:
  	return ret;
  }
  
@@ -178,7 +178,7 @@ Signed-off-by: David S. Miller <davem@da
  static int mtk_hw_init(struct mtk_eth *eth)
  {
  	int i, val, ret;
-@@ -2443,9 +2521,6 @@ static int mtk_hw_init(struct mtk_eth *e
+@@ -2419,9 +2497,6 @@ static int mtk_hw_init(struct mtk_eth *e
  			goto err_disable_pm;
  		}
  
@@ -188,7 +188,7 @@ Signed-off-by: David S. Miller <davem@da
  		/* disable delay and normal interrupt */
  		mtk_tx_irq_disable(eth, ~0);
  		mtk_rx_irq_disable(eth, ~0);
-@@ -2484,11 +2559,11 @@ static int mtk_hw_init(struct mtk_eth *e
+@@ -2460,11 +2535,11 @@ static int mtk_hw_init(struct mtk_eth *e
  	/* Enable RX VLan Offloading */
  	mtk_w32(eth, 1, MTK_CDMP_EG_CTRL);
  
@@ -203,7 +203,7 @@ Signed-off-by: David S. Miller <davem@da
  	mtk_tx_irq_disable(eth, ~0);
  	mtk_rx_irq_disable(eth, ~0);
  
-@@ -2993,6 +3068,13 @@ static int mtk_probe(struct platform_dev
+@@ -2969,6 +3044,13 @@ static int mtk_probe(struct platform_dev
  	spin_lock_init(&eth->page_lock);
  	spin_lock_init(&eth->tx_irq_lock);
  	spin_lock_init(&eth->rx_irq_lock);
@@ -269,7 +269,7 @@ Signed-off-by: David S. Miller <davem@da
  
  /* QDMA Interrupt grouping registers */
  #define MTK_QDMA_INT_GRP1	0x1a20
-@@ -864,6 +870,7 @@ struct mtk_sgmii {
+@@ -863,6 +869,7 @@ struct mtk_sgmii {
   * @page_lock:		Make sure that register operations are atomic
   * @tx_irq__lock:	Make sure that IRQ register operations are atomic
   * @rx_irq__lock:	Make sure that IRQ register operations are atomic
@@ -277,7 +277,7 @@ Signed-off-by: David S. Miller <davem@da
   * @dummy_dev:		we run 2 netdevs on 1 physical DMA ring and need a
   *			dummy for NAPI to work
   * @netdev:		The netdev instances
-@@ -882,6 +889,14 @@ struct mtk_sgmii {
+@@ -881,6 +888,14 @@ struct mtk_sgmii {
   * @rx_ring_qdma:	Pointer to the memory holding info about the QDMA RX ring
   * @tx_napi:		The TX NAPI struct
   * @rx_napi:		The RX NAPI struct
@@ -292,7 +292,7 @@ Signed-off-by: David S. Miller <davem@da
   * @scratch_ring:	Newer SoCs need memory for a second HW managed TX ring
   * @phy_scratch_ring:	physical address of scratch_ring
   * @scratch_head:	The scratch memory that scratch_ring points to.
-@@ -926,6 +941,18 @@ struct mtk_eth {
+@@ -925,6 +940,18 @@ struct mtk_eth {
  
  	const struct mtk_soc_data	*soc;
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-46-net-ethernet-mtk_eth_soc-cache-HW-pointer-of-last-fr.patch b/target/linux/generic/backport-5.10/610-v5.13-46-net-ethernet-mtk_eth_soc-cache-HW-pointer-of-last-fr.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-46-net-ethernet-mtk_eth_soc-cache-HW-pointer-of-last-fr.patch	2024-03-18 15:15:10.697422608 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-46-net-ethernet-mtk_eth_soc-cache-HW-pointer-of-last-fr.patch	2024-03-18 15:16:23.662638827 +0800
@@ -17,7 +17,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1400,7 +1400,7 @@ static int mtk_poll_tx_qdma(struct mtk_e
+@@ -1385,7 +1385,7 @@ static int mtk_poll_tx_qdma(struct mtk_e
  	struct mtk_tx_buf *tx_buf;
  	u32 cpu, dma;
  
@@ -26,7 +26,7 @@ Signed-off-by: David S. Miller <davem@da
  	dma = mtk_r32(eth, MTK_QTX_DRX_PTR);
  
  	desc = mtk_qdma_phys_to_virt(ring, cpu);
-@@ -1434,6 +1434,7 @@ static int mtk_poll_tx_qdma(struct mtk_e
+@@ -1419,6 +1419,7 @@ static int mtk_poll_tx_qdma(struct mtk_e
  		cpu = next_cpu;
  	}
  
@@ -34,7 +34,7 @@ Signed-off-by: David S. Miller <davem@da
  	mtk_w32(eth, cpu, MTK_QTX_CRX_PTR);
  
  	return budget;
-@@ -1634,6 +1635,7 @@ static int mtk_tx_alloc(struct mtk_eth *
+@@ -1619,6 +1620,7 @@ static int mtk_tx_alloc(struct mtk_eth *
  	atomic_set(&ring->free_count, MTK_DMA_SIZE - 2);
  	ring->next_free = &ring->dma[0];
  	ring->last_free = &ring->dma[MTK_DMA_SIZE - 1];
@@ -42,7 +42,7 @@ Signed-off-by: David S. Miller <davem@da
  	ring->thresh = MAX_SKB_FRAGS;
  
  	/* make sure that all changes to the dma ring are flushed before we
-@@ -1647,9 +1649,7 @@ static int mtk_tx_alloc(struct mtk_eth *
+@@ -1632,9 +1634,7 @@ static int mtk_tx_alloc(struct mtk_eth *
  		mtk_w32(eth,
  			ring->phys + ((MTK_DMA_SIZE - 1) * sz),
  			MTK_QTX_CRX_PTR);
@@ -55,7 +55,7 @@ Signed-off-by: David S. Miller <davem@da
  	} else {
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-@@ -657,6 +657,7 @@ struct mtk_tx_buf {
+@@ -656,6 +656,7 @@ struct mtk_tx_buf {
   * @phys:		The physical addr of tx_buf
   * @next_free:		Pointer to the next free descriptor
   * @last_free:		Pointer to the last free descriptor
@@ -63,7 +63,7 @@ Signed-off-by: David S. Miller <davem@da
   * @thresh:		The threshold of minimum amount of free descriptors
   * @free_count:		QDMA uses a linked list. Track how many free descriptors
   *			are present
-@@ -667,6 +668,7 @@ struct mtk_tx_ring {
+@@ -666,6 +667,7 @@ struct mtk_tx_ring {
  	dma_addr_t phys;
  	struct mtk_tx_dma *next_free;
  	struct mtk_tx_dma *last_free;
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-47-net-ethernet-mtk_eth_soc-only-read-the-full-RX-descr.patch b/target/linux/generic/backport-5.10/610-v5.13-47-net-ethernet-mtk_eth_soc-only-read-the-full-RX-descr.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-47-net-ethernet-mtk_eth_soc-only-read-the-full-RX-descr.patch	2024-03-18 15:15:10.793418947 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-47-net-ethernet-mtk_eth_soc-only-read-the-full-RX-descr.patch	2024-03-18 15:16:23.706637149 +0800
@@ -16,7 +16,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -799,13 +799,18 @@ static inline int mtk_max_buf_size(int f
+@@ -798,13 +798,18 @@ static inline int mtk_max_buf_size(int f
  	return buf_size;
  }
  
@@ -36,8 +36,8 @@ Signed-off-by: David S. Miller <davem@da
 +	return true;
  }
  
- static void *mtk_max_lro_buf_alloc(gfp_t gfp_mask)
-@@ -1288,8 +1293,7 @@ static int mtk_poll_rx(struct napi_struc
+ /* the qdma core needs scratch memory to be setup */
+@@ -1276,8 +1281,7 @@ static int mtk_poll_rx(struct napi_struc
  		rxd = &ring->dma[idx];
  		data = ring->data[idx];
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-48-net-ethernet-mtk_eth_soc-reduce-unnecessary-interrup.patch b/target/linux/generic/backport-5.10/610-v5.13-48-net-ethernet-mtk_eth_soc-reduce-unnecessary-interrup.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-48-net-ethernet-mtk_eth_soc-reduce-unnecessary-interrup.patch	2024-03-18 15:15:10.761420167 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-48-net-ethernet-mtk_eth_soc-reduce-unnecessary-interrup.patch	2024-03-18 15:16:23.674638369 +0800
@@ -14,7 +14,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1555,8 +1555,8 @@ static int mtk_napi_tx(struct napi_struc
+@@ -1540,8 +1540,8 @@ static int mtk_napi_tx(struct napi_struc
  	if (status & MTK_TX_DONE_INT)
  		return budget;
  
@@ -25,7 +25,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	return tx_done;
  }
-@@ -1589,8 +1589,9 @@ poll_again:
+@@ -1574,8 +1574,9 @@ poll_again:
  		remain_budget -= rx_done;
  		goto poll_again;
  	}
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-49-net-ethernet-mtk_eth_soc-rework-NAPI-callbacks.patch b/target/linux/generic/backport-5.10/610-v5.13-49-net-ethernet-mtk_eth_soc-rework-NAPI-callbacks.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-49-net-ethernet-mtk_eth_soc-rework-NAPI-callbacks.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-49-net-ethernet-mtk_eth_soc-rework-NAPI-callbacks.patch	2024-03-18 15:16:23.678638217 +0800
@@ -17,7 +17,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -1532,7 +1532,6 @@ static void mtk_handle_status_irq(struct
+@@ -1517,7 +1517,6 @@ static void mtk_handle_status_irq(struct
  static int mtk_napi_tx(struct napi_struct *napi, int budget)
  {
  	struct mtk_eth *eth = container_of(napi, struct mtk_eth, tx_napi);
@@ -25,7 +25,7 @@ Signed-off-by: David S. Miller <davem@da
  	int tx_done = 0;
  
  	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA))
-@@ -1541,21 +1540,19 @@ static int mtk_napi_tx(struct napi_struc
+@@ -1526,21 +1525,19 @@ static int mtk_napi_tx(struct napi_struc
  	tx_done = mtk_poll_tx(eth, budget);
  
  	if (unlikely(netif_msg_intr(eth))) {
@@ -52,7 +52,7 @@ Signed-off-by: David S. Miller <davem@da
  		mtk_tx_irq_enable(eth, MTK_TX_DONE_INT);
  
  	return tx_done;
-@@ -1564,36 +1561,33 @@ static int mtk_napi_tx(struct napi_struc
+@@ -1549,36 +1546,33 @@ static int mtk_napi_tx(struct napi_struc
  static int mtk_napi_rx(struct napi_struct *napi, int budget)
  {
  	struct mtk_eth *eth = container_of(napi, struct mtk_eth, rx_napi);
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-50-net-ethernet-mtk_eth_soc-set-PPE-flow-hash-as-skb-ha.patch b/target/linux/generic/backport-5.10/610-v5.13-50-net-ethernet-mtk_eth_soc-set-PPE-flow-hash-as-skb-ha.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-50-net-ethernet-mtk_eth_soc-set-PPE-flow-hash-as-skb-ha.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-50-net-ethernet-mtk_eth_soc-set-PPE-flow-hash-as-skb-ha.patch	2024-03-18 15:16:23.678638217 +0800
@@ -24,7 +24,7 @@ Signed-off-by: David S. Miller <davem@da
  #include <net/dsa.h>
  
  #include "mtk_eth_soc.h"
-@@ -1283,6 +1284,7 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1271,6 +1272,7 @@ static int mtk_poll_rx(struct napi_struc
  		struct net_device *netdev;
  		unsigned int pktlen;
  		dma_addr_t dma_addr;
@@ -32,7 +32,7 @@ Signed-off-by: David S. Miller <davem@da
  		int mac;
  
  		ring = mtk_get_rx_ring(eth);
-@@ -1355,6 +1357,12 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1340,6 +1342,12 @@ static int mtk_poll_rx(struct napi_struc
  		skb->protocol = eth_type_trans(skb, netdev);
  		bytes += pktlen;
  
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-51-net-ethernet-mtk_eth_soc-use-iopoll.h-macro-for-DMA-.patch b/target/linux/generic/backport-5.10/610-v5.13-51-net-ethernet-mtk_eth_soc-use-iopoll.h-macro-for-DMA-.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-51-net-ethernet-mtk_eth_soc-use-iopoll.h-macro-for-DMA-.patch	2024-03-18 15:15:10.697422608 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-51-net-ethernet-mtk_eth_soc-use-iopoll.h-macro-for-DMA-.patch	2024-03-18 15:16:23.662638827 +0800
@@ -19,7 +19,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2075,25 +2075,22 @@ static int mtk_set_features(struct net_d
+@@ -2054,25 +2054,22 @@ static int mtk_set_features(struct net_d
  /* wait for DMA to finish whatever it is doing before we start using it again */
  static int mtk_dma_busy_wait(struct mtk_eth *eth)
  {
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-55-netfilter-conntrack-Introduce-tcp-offload-timeout-co.patch b/target/linux/generic/backport-5.10/610-v5.13-55-netfilter-conntrack-Introduce-tcp-offload-timeout-co.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-55-netfilter-conntrack-Introduce-tcp-offload-timeout-co.patch	2024-03-18 15:15:10.769419862 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-55-netfilter-conntrack-Introduce-tcp-offload-timeout-co.patch	2024-03-18 15:16:23.682638064 +0800
@@ -33,7 +33,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  enum udp_conntrack {
 --- a/net/netfilter/nf_conntrack_proto_tcp.c
 +++ b/net/netfilter/nf_conntrack_proto_tcp.c
-@@ -1457,6 +1457,11 @@ void nf_conntrack_tcp_init_net(struct ne
+@@ -1438,6 +1438,11 @@ void nf_conntrack_tcp_init_net(struct ne
  	tn->tcp_loose = nf_ct_tcp_loose;
  	tn->tcp_be_liberal = nf_ct_tcp_be_liberal;
  	tn->tcp_max_retrans = nf_ct_tcp_max_retrans;
@@ -58,7 +58,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	NF_SYSCTL_CT_PROTO_TCP_LOOSE,
  	NF_SYSCTL_CT_PROTO_TCP_LIBERAL,
  	NF_SYSCTL_CT_PROTO_TCP_MAX_RETRANS,
-@@ -757,6 +761,20 @@ static struct ctl_table nf_ct_sysctl_tab
+@@ -758,6 +762,20 @@ static struct ctl_table nf_ct_sysctl_tab
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec_jiffies,
  	},
@@ -79,7 +79,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	[NF_SYSCTL_CT_PROTO_TCP_LOOSE] = {
  		.procname	= "nf_conntrack_tcp_loose",
  		.maxlen		= sizeof(int),
-@@ -960,6 +978,12 @@ static void nf_conntrack_standalone_init
+@@ -967,6 +985,12 @@ static void nf_conntrack_standalone_init
  	XASSIGN(LIBERAL, &tn->tcp_be_liberal);
  	XASSIGN(MAX_RETRANS, &tn->tcp_max_retrans);
  #undef XASSIGN
diff -uprN a/target/linux/generic/backport-5.10/610-v5.13-56-netfilter-conntrack-Introduce-udp-offload-timeout-co.patch b/target/linux/generic/backport-5.10/610-v5.13-56-netfilter-conntrack-Introduce-udp-offload-timeout-co.patch
--- a/target/linux/generic/backport-5.10/610-v5.13-56-netfilter-conntrack-Introduce-udp-offload-timeout-co.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.13-56-netfilter-conntrack-Introduce-udp-offload-timeout-co.patch	2024-03-18 15:16:23.678638217 +0800
@@ -58,7 +58,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP,
  	NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6,
  #ifdef CONFIG_NF_CT_PROTO_SCTP
-@@ -809,6 +813,20 @@ static struct ctl_table nf_ct_sysctl_tab
+@@ -810,6 +814,20 @@ static struct ctl_table nf_ct_sysctl_tab
  		.mode		= 0644,
  		.proc_handler	= proc_dointvec_jiffies,
  	},
@@ -79,7 +79,7 @@ Signed-off-by: Pablo Neira Ayuso <pablo@
  	[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP] = {
  		.procname	= "nf_conntrack_icmp_timeout",
  		.maxlen		= sizeof(unsigned int),
-@@ -1070,6 +1088,10 @@ static int nf_conntrack_standalone_init_
+@@ -1078,6 +1096,10 @@ static int nf_conntrack_standalone_init_
  	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
  	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];
  	table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];
diff -uprN a/target/linux/generic/backport-5.10/610-v5.18-netfilter-flowtable-move-dst_check-to-packet-path.patch b/target/linux/generic/backport-5.10/610-v5.18-netfilter-flowtable-move-dst_check-to-packet-path.patch
--- a/target/linux/generic/backport-5.10/610-v5.18-netfilter-flowtable-move-dst_check-to-packet-path.patch	2024-03-18 15:15:10.761420167 +0800
+++ b/target/linux/generic/backport-5.10/610-v5.18-netfilter-flowtable-move-dst_check-to-packet-path.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,99 +0,0 @@
-From 2738d9d963bd1f06d5114c2b4fa5771a95703991 Mon Sep 17 00:00:00 2001
-From: Ritaro Takenaka <ritarot634@gmail.com>
-Date: Tue, 17 May 2022 12:55:30 +0200
-Subject: [PATCH] netfilter: flowtable: move dst_check to packet path
-
-Fixes sporadic IPv6 packet loss when flow offloading is enabled.
-
-IPv6 route GC and flowtable GC are not synchronized.
-When dst_cache becomes stale and a packet passes through the flow before
-the flowtable GC teardowns it, the packet can be dropped.
-So, it is necessary to check dst every time in packet path.
-
-Fixes: 227e1e4d0d6c ("netfilter: nf_flowtable: skip device lookup from interface index")
-Signed-off-by: Ritaro Takenaka <ritarot634@gmail.com>
-Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
----
- net/netfilter/nf_flow_table_core.c | 23 +----------------------
- net/netfilter/nf_flow_table_ip.c   | 19 +++++++++++++++++++
- 2 files changed, 20 insertions(+), 22 deletions(-)
-
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -429,33 +429,12 @@ nf_flow_table_iterate(struct nf_flowtabl
- 	return err;
- }
- 
--static bool flow_offload_stale_dst(struct flow_offload_tuple *tuple)
--{
--	struct dst_entry *dst;
--
--	if (tuple->xmit_type == FLOW_OFFLOAD_XMIT_NEIGH ||
--	    tuple->xmit_type == FLOW_OFFLOAD_XMIT_XFRM) {
--		dst = tuple->dst_cache;
--		if (!dst_check(dst, tuple->dst_cookie))
--			return true;
--	}
--
--	return false;
--}
--
--static bool nf_flow_has_stale_dst(struct flow_offload *flow)
--{
--	return flow_offload_stale_dst(&flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple) ||
--	       flow_offload_stale_dst(&flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple);
--}
--
- static void nf_flow_offload_gc_step(struct flow_offload *flow, void *data)
- {
- 	struct nf_flowtable *flow_table = data;
- 
- 	if (nf_flow_has_expired(flow) ||
--	    nf_ct_is_dying(flow->ct) ||
--	    nf_flow_has_stale_dst(flow))
-+	    nf_ct_is_dying(flow->ct))
- 		set_bit(NF_FLOW_TEARDOWN, &flow->flags);
- 
- 	if (test_bit(NF_FLOW_TEARDOWN, &flow->flags)) {
---- a/net/netfilter/nf_flow_table_ip.c
-+++ b/net/netfilter/nf_flow_table_ip.c
-@@ -229,6 +229,15 @@ static bool nf_flow_exceeds_mtu(const st
- 	return true;
- }
- 
-+static inline bool nf_flow_dst_check(struct flow_offload_tuple *tuple)
-+{
-+	if (tuple->xmit_type != FLOW_OFFLOAD_XMIT_NEIGH &&
-+	    tuple->xmit_type != FLOW_OFFLOAD_XMIT_XFRM)
-+		return true;
-+
-+	return dst_check(tuple->dst_cache, tuple->dst_cookie);
-+}
-+
- static unsigned int nf_flow_xmit_xfrm(struct sk_buff *skb,
- 				      const struct nf_hook_state *state,
- 				      struct dst_entry *dst)
-@@ -364,6 +373,11 @@ nf_flow_offload_ip_hook(void *priv, stru
- 	if (nf_flow_state_check(flow, iph->protocol, skb, thoff))
- 		return NF_ACCEPT;
- 
-+	if (!nf_flow_dst_check(&tuplehash->tuple)) {
-+		flow_offload_teardown(flow);
-+		return NF_ACCEPT;
-+	}
-+
- 	if (skb_try_make_writable(skb, thoff + hdrsize))
- 		return NF_DROP;
- 
-@@ -600,6 +614,11 @@ nf_flow_offload_ipv6_hook(void *priv, st
- 	if (nf_flow_state_check(flow, ip6h->nexthdr, skb, thoff))
- 		return NF_ACCEPT;
- 
-+	if (!nf_flow_dst_check(&tuplehash->tuple)) {
-+		flow_offload_teardown(flow);
-+		return NF_ACCEPT;
-+	}
-+
- 	if (skb_try_make_writable(skb, thoff + hdrsize))
- 		return NF_DROP;
- 
diff -uprN a/target/linux/generic/backport-5.10/611-v5.12-net-ethernet-mediatek-support-setting-MTU.patch b/target/linux/generic/backport-5.10/611-v5.12-net-ethernet-mediatek-support-setting-MTU.patch
--- a/target/linux/generic/backport-5.10/611-v5.12-net-ethernet-mediatek-support-setting-MTU.patch	2024-03-18 15:15:10.761420167 +0800
+++ b/target/linux/generic/backport-5.10/611-v5.12-net-ethernet-mediatek-support-setting-MTU.patch	2024-03-18 15:16:23.678638217 +0800
@@ -25,10 +25,10 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	mcr_new = mcr_cur;
 -	mcr_new |= MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
 +	mcr_new |= MAC_MCR_IPG_CFG | MAC_MCR_FORCE_MODE |
- 		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK |
- 		   MAC_MCR_RX_FIFO_CLR_DIS;
+ 		   MAC_MCR_BACKOFF_EN | MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_LINK;
  
-@@ -783,8 +783,8 @@ static void mtk_get_stats64(struct net_d
+ 	/* Only update control register when needed! */
+@@ -782,8 +782,8 @@ static void mtk_get_stats64(struct net_d
  static inline int mtk_max_frag_size(int mtu)
  {
  	/* make sure buf_size will be at least MTK_MAX_RX_LENGTH */
@@ -39,7 +39,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	return SKB_DATA_ALIGN(MTK_RX_HLEN + mtu) +
  		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
-@@ -795,7 +795,7 @@ static inline int mtk_max_buf_size(int f
+@@ -794,7 +794,7 @@ static inline int mtk_max_buf_size(int f
  	int buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -
  		       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
  
@@ -48,7 +48,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	return buf_size;
  }
-@@ -2630,6 +2630,35 @@ static void mtk_uninit(struct net_device
+@@ -2606,6 +2606,35 @@ static void mtk_uninit(struct net_device
  	mtk_rx_irq_disable(eth, ~0);
  }
  
@@ -84,7 +84,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  static int mtk_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
  {
  	struct mtk_mac *mac = netdev_priv(dev);
-@@ -2926,6 +2955,7 @@ static const struct net_device_ops mtk_n
+@@ -2902,6 +2931,7 @@ static const struct net_device_ops mtk_n
  	.ndo_set_mac_address	= mtk_set_mac_address,
  	.ndo_validate_addr	= eth_validate_addr,
  	.ndo_do_ioctl		= mtk_do_ioctl,
@@ -92,7 +92,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	.ndo_tx_timeout		= mtk_tx_timeout,
  	.ndo_get_stats64        = mtk_get_stats64,
  	.ndo_fix_features	= mtk_fix_features,
-@@ -3028,7 +3058,10 @@ static int mtk_add_mac(struct mtk_eth *e
+@@ -3004,7 +3034,10 @@ static int mtk_add_mac(struct mtk_eth *e
  	eth->netdev[id]->irq = eth->irq[0];
  	eth->netdev[id]->dev.of_node = np;
  
diff -uprN a/target/linux/generic/backport-5.10/615-v5.14-ip-Treat-IPv4-segment-s-lowest-address-as-unicast.patch b/target/linux/generic/backport-5.10/615-v5.14-ip-Treat-IPv4-segment-s-lowest-address-as-unicast.patch
--- a/target/linux/generic/backport-5.10/615-v5.14-ip-Treat-IPv4-segment-s-lowest-address-as-unicast.patch	2024-03-18 15:15:10.773419710 +0800
+++ b/target/linux/generic/backport-5.10/615-v5.14-ip-Treat-IPv4-segment-s-lowest-address-as-unicast.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,32 +0,0 @@
-From 94c821c74bf5fe0c25e09df5334a16f98608db90 Mon Sep 17 00:00:00 2001
-From: Seth David Schoen <schoen@loyalty.org>
-Date: Wed, 12 May 2021 21:37:49 -0700
-Subject: [PATCH] ip: Treat IPv4 segment's lowest address as unicast
-
-Treat only the highest, not the lowest, IPv4 address within a local
-subnet as a broadcast address.
-
-Signed-off-by: Seth David Schoen <schoen@loyalty.org>
-Suggested-by: John Gilmore <gnu@toad.com>
-Acked-by: Dave Taht <dave.taht@gmail.com>
-Reviewed-by: David Ahern <dsahern@kernel.org>
-Signed-off-by: David S. Miller <davem@davemloft.net>
-Link: https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git/commit/?id=94c821c74bf5
----
- net/ipv4/fib_frontend.c | 4 +---
- 1 file changed, 1 insertion(+), 3 deletions(-)
-
---- a/net/ipv4/fib_frontend.c
-+++ b/net/ipv4/fib_frontend.c
-@@ -1132,10 +1132,8 @@ void fib_add_ifaddr(struct in_ifaddr *if
- 				  prefix, ifa->ifa_prefixlen, prim,
- 				  ifa->ifa_rt_priority);
- 
--		/* Add network specific broadcasts, when it takes a sense */
-+		/* Add the network broadcast address, when it makes sense */
- 		if (ifa->ifa_prefixlen < 31) {
--			fib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix, 32,
--				  prim, 0);
- 			fib_magic(RTM_NEWROUTE, RTN_BROADCAST, prefix | ~mask,
- 				  32, prim, 0);
- 			arp_invalidate(dev, prefix | ~mask, false);
diff -uprN a/target/linux/generic/backport-5.10/630-v5.15-page_pool_frag_support.patch b/target/linux/generic/backport-5.10/630-v5.15-page_pool_frag_support.patch
--- a/target/linux/generic/backport-5.10/630-v5.15-page_pool_frag_support.patch	2024-03-18 15:15:10.705422304 +0800
+++ b/target/linux/generic/backport-5.10/630-v5.15-page_pool_frag_support.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,798 +0,0 @@
---- a/include/net/page_pool.h
-+++ b/include/net/page_pool.h
-@@ -45,7 +45,10 @@
- 					* Please note DMA-sync-for-CPU is still
- 					* device driver responsibility
- 					*/
--#define PP_FLAG_ALL		(PP_FLAG_DMA_MAP | PP_FLAG_DMA_SYNC_DEV)
-+#define PP_FLAG_PAGE_FRAG	BIT(2) /* for page frag feature */
-+#define PP_FLAG_ALL		(PP_FLAG_DMA_MAP |\
-+				 PP_FLAG_DMA_SYNC_DEV |\
-+				 PP_FLAG_PAGE_FRAG)
- 
- /*
-  * Fast allocation side cache array/stack
-@@ -65,7 +68,7 @@
- #define PP_ALLOC_CACHE_REFILL	64
- struct pp_alloc_cache {
- 	u32 count;
--	void *cache[PP_ALLOC_CACHE_SIZE];
-+	struct page *cache[PP_ALLOC_CACHE_SIZE];
- };
- 
- struct page_pool_params {
-@@ -79,6 +82,22 @@ struct page_pool_params {
- 	unsigned int	offset;  /* DMA addr offset */
- };
- 
-+
-+static inline int page_pool_ethtool_stats_get_count(void)
-+{
-+	return 0;
-+}
-+
-+static inline u8 *page_pool_ethtool_stats_get_strings(u8 *data)
-+{
-+	return data;
-+}
-+
-+static inline u64 *page_pool_ethtool_stats_get(u64 *data, void *stats)
-+{
-+	return data;
-+}
-+
- struct page_pool {
- 	struct page_pool_params p;
- 
-@@ -88,6 +107,9 @@ struct page_pool {
- 	unsigned long defer_warn;
- 
- 	u32 pages_state_hold_cnt;
-+	unsigned int frag_offset;
-+	struct page *frag_page;
-+	long frag_users;
- 
- 	/*
- 	 * Data structure for allocation side
-@@ -137,6 +159,18 @@ static inline struct page *page_pool_dev
- 	return page_pool_alloc_pages(pool, gfp);
- }
- 
-+struct page *page_pool_alloc_frag(struct page_pool *pool, unsigned int *offset,
-+				  unsigned int size, gfp_t gfp);
-+
-+static inline struct page *page_pool_dev_alloc_frag(struct page_pool *pool,
-+						    unsigned int *offset,
-+						    unsigned int size)
-+{
-+	gfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN);
-+
-+	return page_pool_alloc_frag(pool, offset, size, gfp);
-+}
-+
- /* get the stored dma direction. A driver might decide to treat this locally and
-  * avoid the extra cache line from page_pool to determine the direction
-  */
-@@ -146,6 +180,8 @@ inline enum dma_data_direction page_pool
- 	return pool->p.dma_dir;
- }
- 
-+bool page_pool_return_skb_page(struct page *page);
-+
- struct page_pool *page_pool_create(const struct page_pool_params *params);
- 
- #ifdef CONFIG_PAGE_POOL
-@@ -165,6 +201,7 @@ static inline void page_pool_release_pag
- 					  struct page *page)
- {
- }
-+
- #endif
- 
- void page_pool_put_page(struct page_pool *pool, struct page *page,
-@@ -189,19 +226,48 @@ static inline void page_pool_recycle_dir
- 	page_pool_put_full_page(pool, page, true);
- }
- 
-+#define PAGE_POOL_DMA_USE_PP_FRAG_COUNT	\
-+		(sizeof(dma_addr_t) > sizeof(unsigned long))
-+
- static inline dma_addr_t page_pool_get_dma_addr(struct page *page)
- {
--	dma_addr_t ret = page->dma_addr[0];
--	if (sizeof(dma_addr_t) > sizeof(unsigned long))
--		ret |= (dma_addr_t)page->dma_addr[1] << 16 << 16;
-+	dma_addr_t ret = page->dma_addr;
-+
-+	if (PAGE_POOL_DMA_USE_PP_FRAG_COUNT)
-+		ret |= (dma_addr_t)page->dma_addr_upper << 16 << 16;
-+
- 	return ret;
- }
- 
- static inline void page_pool_set_dma_addr(struct page *page, dma_addr_t addr)
- {
--	page->dma_addr[0] = addr;
--	if (sizeof(dma_addr_t) > sizeof(unsigned long))
--		page->dma_addr[1] = upper_32_bits(addr);
-+	page->dma_addr = addr;
-+	if (PAGE_POOL_DMA_USE_PP_FRAG_COUNT)
-+		page->dma_addr_upper = upper_32_bits(addr);
-+}
-+
-+static inline void page_pool_set_frag_count(struct page *page, long nr)
-+{
-+	atomic_long_set(&page->pp_frag_count, nr);
-+}
-+
-+static inline long page_pool_atomic_sub_frag_count_return(struct page *page,
-+							  long nr)
-+{
-+	long ret;
-+
-+	/* As suggested by Alexander, atomic_long_read() may cover up the
-+	 * reference count errors, so avoid calling atomic_long_read() in
-+	 * the cases of freeing or draining the page_frags, where we would
-+	 * not expect it to match or that are slowpath anyway.
-+	 */
-+	if (__builtin_constant_p(nr) &&
-+	    atomic_long_read(&page->pp_frag_count) == nr)
-+		return 0;
-+
-+	ret = atomic_long_sub_return(nr, &page->pp_frag_count);
-+	WARN_ON(ret < 0);
-+	return ret;
- }
- 
- static inline bool is_page_pool_compiled_in(void)
-@@ -225,4 +291,23 @@ static inline void page_pool_nid_changed
- 	if (unlikely(pool->p.nid != new_nid))
- 		page_pool_update_nid(pool, new_nid);
- }
-+
-+static inline void page_pool_ring_lock(struct page_pool *pool)
-+	__acquires(&pool->ring.producer_lock)
-+{
-+	if (in_serving_softirq())
-+		spin_lock(&pool->ring.producer_lock);
-+	else
-+		spin_lock_bh(&pool->ring.producer_lock);
-+}
-+
-+static inline void page_pool_ring_unlock(struct page_pool *pool)
-+	__releases(&pool->ring.producer_lock)
-+{
-+	if (in_serving_softirq())
-+		spin_unlock(&pool->ring.producer_lock);
-+	else
-+		spin_unlock_bh(&pool->ring.producer_lock);
-+}
-+
- #endif /* _NET_PAGE_POOL_H */
---- a/net/core/page_pool.c
-+++ b/net/core/page_pool.c
-@@ -11,16 +11,22 @@
- #include <linux/device.h>
- 
- #include <net/page_pool.h>
-+#include <net/xdp.h>
-+
- #include <linux/dma-direction.h>
- #include <linux/dma-mapping.h>
- #include <linux/page-flags.h>
- #include <linux/mm.h> /* for __put_page() */
-+#include <linux/poison.h>
-+#include <linux/ethtool.h>
- 
- #include <trace/events/page_pool.h>
- 
- #define DEFER_TIME (msecs_to_jiffies(1000))
- #define DEFER_WARN_INTERVAL (60 * HZ)
- 
-+#define BIAS_MAX	LONG_MAX
-+
- static int page_pool_init(struct page_pool *pool,
- 			  const struct page_pool_params *params)
- {
-@@ -64,6 +70,10 @@ static int page_pool_init(struct page_po
- 		 */
- 	}
- 
-+	if (PAGE_POOL_DMA_USE_PP_FRAG_COUNT &&
-+	    pool->p.flags & PP_FLAG_PAGE_FRAG)
-+		return -EINVAL;
-+
- 	if (ptr_ring_init(&pool->ring, ring_qsize, GFP_KERNEL) < 0)
- 		return -ENOMEM;
- 
-@@ -180,40 +190,10 @@ static void page_pool_dma_sync_for_devic
- 					 pool->p.dma_dir);
- }
- 
--/* slow path */
--noinline
--static struct page *__page_pool_alloc_pages_slow(struct page_pool *pool,
--						 gfp_t _gfp)
-+static bool page_pool_dma_map(struct page_pool *pool, struct page *page)
- {
--	struct page *page;
--	gfp_t gfp = _gfp;
- 	dma_addr_t dma;
- 
--	/* We could always set __GFP_COMP, and avoid this branch, as
--	 * prep_new_page() can handle order-0 with __GFP_COMP.
--	 */
--	if (pool->p.order)
--		gfp |= __GFP_COMP;
--
--	/* FUTURE development:
--	 *
--	 * Current slow-path essentially falls back to single page
--	 * allocations, which doesn't improve performance.  This code
--	 * need bulk allocation support from the page allocator code.
--	 */
--
--	/* Cache was empty, do real allocation */
--#ifdef CONFIG_NUMA
--	page = alloc_pages_node(pool->p.nid, gfp, pool->p.order);
--#else
--	page = alloc_pages(gfp, pool->p.order);
--#endif
--	if (!page)
--		return NULL;
--
--	if (!(pool->p.flags & PP_FLAG_DMA_MAP))
--		goto skip_dma_map;
--
- 	/* Setup DMA mapping: use 'struct page' area for storing DMA-addr
- 	 * since dma_addr_t can be either 32 or 64 bits and does not always fit
- 	 * into page private data (i.e 32bit cpu with 64bit DMA caps)
-@@ -222,22 +202,53 @@ static struct page *__page_pool_alloc_pa
- 	dma = dma_map_page_attrs(pool->p.dev, page, 0,
- 				 (PAGE_SIZE << pool->p.order),
- 				 pool->p.dma_dir, DMA_ATTR_SKIP_CPU_SYNC);
--	if (dma_mapping_error(pool->p.dev, dma)) {
--		put_page(page);
--		return NULL;
--	}
-+	if (dma_mapping_error(pool->p.dev, dma))
-+		return false;
-+
- 	page_pool_set_dma_addr(page, dma);
- 
- 	if (pool->p.flags & PP_FLAG_DMA_SYNC_DEV)
- 		page_pool_dma_sync_for_device(pool, page, pool->p.max_len);
- 
--skip_dma_map:
-+	return true;
-+}
-+
-+static void page_pool_set_pp_info(struct page_pool *pool,
-+				  struct page *page)
-+{
-+	page->pp = pool;
-+	page->pp_magic |= PP_SIGNATURE;
-+}
-+
-+static void page_pool_clear_pp_info(struct page *page)
-+{
-+	page->pp_magic = 0;
-+	page->pp = NULL;
-+}
-+
-+/* slow path */
-+noinline
-+static struct page *__page_pool_alloc_pages_slow(struct page_pool *pool,
-+						 gfp_t gfp)
-+{
-+	struct page *page;
-+
-+	gfp |= __GFP_COMP;
-+	page = alloc_pages_node(pool->p.nid, gfp, pool->p.order);
-+	if (unlikely(!page))
-+		return NULL;
-+
-+	if ((pool->p.flags & PP_FLAG_DMA_MAP) &&
-+	    unlikely(!page_pool_dma_map(pool, page))) {
-+		put_page(page);
-+		return NULL;
-+	}
-+
-+	page_pool_set_pp_info(pool, page);
-+
- 	/* Track how many pages are held 'in-flight' */
- 	pool->pages_state_hold_cnt++;
--
- 	trace_page_pool_state_hold(pool, page, pool->pages_state_hold_cnt);
--
--	/* When page just alloc'ed is should/must have refcnt 1. */
- 	return page;
- }
- 
-@@ -302,10 +313,12 @@ void page_pool_release_page(struct page_
- 			     DMA_ATTR_SKIP_CPU_SYNC);
- 	page_pool_set_dma_addr(page, 0);
- skip_dma_unmap:
-+	page_pool_clear_pp_info(page);
-+
- 	/* This may be the last page returned, releasing the pool, so
- 	 * it is not safe to reference pool afterwards.
- 	 */
--	count = atomic_inc_return(&pool->pages_state_release_cnt);
-+	count = atomic_inc_return_relaxed(&pool->pages_state_release_cnt);
- 	trace_page_pool_state_release(pool, page, count);
- }
- EXPORT_SYMBOL(page_pool_release_page);
-@@ -331,7 +344,10 @@ static bool page_pool_recycle_in_ring(st
- 	else
- 		ret = ptr_ring_produce_bh(&pool->ring, page);
- 
--	return (ret == 0) ? true : false;
-+	if (!ret)
-+		return true;
-+
-+	return false;
- }
- 
- /* Only allow direct recycling in special circumstances, into the
-@@ -350,46 +366,43 @@ static bool page_pool_recycle_in_cache(s
- 	return true;
- }
- 
--/* page is NOT reusable when:
-- * 1) allocated when system is under some pressure. (page_is_pfmemalloc)
-- */
--static bool pool_page_reusable(struct page_pool *pool, struct page *page)
--{
--	return !page_is_pfmemalloc(page);
--}
--
- /* If the page refcnt == 1, this will try to recycle the page.
-  * if PP_FLAG_DMA_SYNC_DEV is set, we'll try to sync the DMA area for
-  * the configured size min(dma_sync_size, pool->max_len).
-  * If the page refcnt != 1, then the page will be returned to memory
-  * subsystem.
-  */
--void page_pool_put_page(struct page_pool *pool, struct page *page,
--			unsigned int dma_sync_size, bool allow_direct)
--{
-+static __always_inline struct page *
-+__page_pool_put_page(struct page_pool *pool, struct page *page,
-+		     unsigned int dma_sync_size, bool allow_direct)
-+{
-+	/* It is not the last user for the page frag case */
-+	if (pool->p.flags & PP_FLAG_PAGE_FRAG &&
-+	    page_pool_atomic_sub_frag_count_return(page, 1))
-+		return NULL;
-+
- 	/* This allocator is optimized for the XDP mode that uses
- 	 * one-frame-per-page, but have fallbacks that act like the
- 	 * regular page allocator APIs.
- 	 *
- 	 * refcnt == 1 means page_pool owns page, and can recycle it.
-+	 *
-+	 * page is NOT reusable when allocated when system is under
-+	 * some pressure. (page_is_pfmemalloc)
- 	 */
--	if (likely(page_ref_count(page) == 1 &&
--		   pool_page_reusable(pool, page))) {
-+	if (likely(page_ref_count(page) == 1 && !page_is_pfmemalloc(page))) {
- 		/* Read barrier done in page_ref_count / READ_ONCE */
- 
- 		if (pool->p.flags & PP_FLAG_DMA_SYNC_DEV)
- 			page_pool_dma_sync_for_device(pool, page,
- 						      dma_sync_size);
- 
--		if (allow_direct && in_serving_softirq())
--			if (page_pool_recycle_in_cache(page, pool))
--				return;
-+		if (allow_direct && in_serving_softirq() &&
-+		    page_pool_recycle_in_cache(page, pool))
-+			return NULL;
- 
--		if (!page_pool_recycle_in_ring(pool, page)) {
--			/* Cache full, fallback to free pages */
--			page_pool_return_page(pool, page);
--		}
--		return;
-+		/* Page found as candidate for recycling */
-+		return page;
- 	}
- 	/* Fallback/non-XDP mode: API user have elevated refcnt.
- 	 *
-@@ -407,9 +420,98 @@ void page_pool_put_page(struct page_pool
- 	/* Do not replace this with page_pool_return_page() */
- 	page_pool_release_page(pool, page);
- 	put_page(page);
-+
-+	return NULL;
-+}
-+
-+void page_pool_put_page(struct page_pool *pool, struct page *page,
-+			unsigned int dma_sync_size, bool allow_direct)
-+{
-+	page = __page_pool_put_page(pool, page, dma_sync_size, allow_direct);
-+	if (page && !page_pool_recycle_in_ring(pool, page))
-+		/* Cache full, fallback to free pages */
-+		page_pool_return_page(pool, page);
- }
- EXPORT_SYMBOL(page_pool_put_page);
- 
-+static struct page *page_pool_drain_frag(struct page_pool *pool,
-+					 struct page *page)
-+{
-+	long drain_count = BIAS_MAX - pool->frag_users;
-+
-+	/* Some user is still using the page frag */
-+	if (likely(page_pool_atomic_sub_frag_count_return(page,
-+							  drain_count)))
-+		return NULL;
-+
-+	if (page_ref_count(page) == 1 && !page_is_pfmemalloc(page)) {
-+		if (pool->p.flags & PP_FLAG_DMA_SYNC_DEV)
-+			page_pool_dma_sync_for_device(pool, page, -1);
-+
-+		return page;
-+	}
-+
-+	page_pool_return_page(pool, page);
-+	return NULL;
-+}
-+
-+static void page_pool_free_frag(struct page_pool *pool)
-+{
-+	long drain_count = BIAS_MAX - pool->frag_users;
-+	struct page *page = pool->frag_page;
-+
-+	pool->frag_page = NULL;
-+
-+	if (!page ||
-+	    page_pool_atomic_sub_frag_count_return(page, drain_count))
-+		return;
-+
-+	page_pool_return_page(pool, page);
-+}
-+
-+struct page *page_pool_alloc_frag(struct page_pool *pool,
-+				  unsigned int *offset,
-+				  unsigned int size, gfp_t gfp)
-+{
-+	unsigned int max_size = PAGE_SIZE << pool->p.order;
-+	struct page *page = pool->frag_page;
-+
-+	if (WARN_ON(!(pool->p.flags & PP_FLAG_PAGE_FRAG) ||
-+		    size > max_size))
-+		return NULL;
-+
-+	size = ALIGN(size, dma_get_cache_alignment());
-+	*offset = pool->frag_offset;
-+
-+	if (page && *offset + size > max_size) {
-+		page = page_pool_drain_frag(pool, page);
-+		if (page)
-+			goto frag_reset;
-+	}
-+
-+	if (!page) {
-+		page = page_pool_alloc_pages(pool, gfp);
-+		if (unlikely(!page)) {
-+			pool->frag_page = NULL;
-+			return NULL;
-+		}
-+
-+		pool->frag_page = page;
-+
-+frag_reset:
-+		pool->frag_users = 1;
-+		*offset = 0;
-+		pool->frag_offset = size;
-+		page_pool_set_frag_count(page, BIAS_MAX);
-+		return page;
-+	}
-+
-+	pool->frag_users++;
-+	pool->frag_offset = *offset + size;
-+	return page;
-+}
-+EXPORT_SYMBOL(page_pool_alloc_frag);
-+
- static void page_pool_empty_ring(struct page_pool *pool)
- {
- 	struct page *page;
-@@ -515,6 +617,8 @@ void page_pool_destroy(struct page_pool
- 	if (!page_pool_put(pool))
- 		return;
- 
-+	page_pool_free_frag(pool);
-+
- 	if (!page_pool_release(pool))
- 		return;
- 
-@@ -541,3 +645,32 @@ void page_pool_update_nid(struct page_po
- 	}
- }
- EXPORT_SYMBOL(page_pool_update_nid);
-+
-+bool page_pool_return_skb_page(struct page *page)
-+{
-+	struct page_pool *pp;
-+
-+	page = compound_head(page);
-+
-+	/* page->pp_magic is OR'ed with PP_SIGNATURE after the allocation
-+	 * in order to preserve any existing bits, such as bit 0 for the
-+	 * head page of compound page and bit 1 for pfmemalloc page, so
-+	 * mask those bits for freeing side when doing below checking,
-+	 * and page_is_pfmemalloc() is checked in __page_pool_put_page()
-+	 * to avoid recycling the pfmemalloc page.
-+	 */
-+	if (unlikely((page->pp_magic & ~0x3UL) != PP_SIGNATURE))
-+		return false;
-+
-+	pp = page->pp;
-+
-+	/* Driver set this to memory recycling info. Reset it on recycle.
-+	 * This will *not* work for NIC using a split-page memory model.
-+	 * The page will be returned to the pool here regardless of the
-+	 * 'flipped' fragment being in use or not.
-+	 */
-+	page_pool_put_full_page(pp, page, false);
-+
-+	return true;
-+}
-+EXPORT_SYMBOL(page_pool_return_skb_page);
---- a/include/linux/mm_types.h
-+++ b/include/linux/mm_types.h
-@@ -97,10 +97,25 @@ struct page {
- 		};
- 		struct {	/* page_pool used by netstack */
- 			/**
--			 * @dma_addr: might require a 64-bit value on
--			 * 32-bit architectures.
-+			 * @pp_magic: magic value to avoid recycling non
-+			 * page_pool allocated pages.
- 			 */
--			unsigned long dma_addr[2];
-+			unsigned long pp_magic;
-+			struct page_pool *pp;
-+			unsigned long _pp_mapping_pad;
-+			unsigned long dma_addr;
-+			union {
-+				/**
-+				 * dma_addr_upper: might require a 64-bit
-+				 * value on 32-bit architectures.
-+				 */
-+				unsigned long dma_addr_upper;
-+				/**
-+				 * For frag page support, not supported in
-+				 * 32-bit architectures with 64-bit DMA.
-+				 */
-+				atomic_long_t pp_frag_count;
-+			};
- 		};
- 		struct {	/* slab, slob and slub */
- 			union {
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -594,13 +594,22 @@ static void skb_clone_fraglist(struct sk
- 		skb_get(list);
- }
- 
-+static bool skb_pp_recycle(struct sk_buff *skb, void *data)
-+{
-+	if (!IS_ENABLED(CONFIG_PAGE_POOL) || !skb->pp_recycle)
-+		return false;
-+	return page_pool_return_skb_page(virt_to_page(data));
-+}
-+
- static void skb_free_head(struct sk_buff *skb)
- {
- 	unsigned char *head = skb->head;
- 
--	if (skb->head_frag)
-+	if (skb->head_frag) {
-+		if (skb_pp_recycle(skb, head))
-+			return;
- 		skb_free_frag(head);
--	else
-+	} else
- 		kfree(head);
- }
- 
-@@ -612,16 +621,27 @@ static void skb_release_data(struct sk_b
- 	if (skb->cloned &&
- 	    atomic_sub_return(skb->nohdr ? (1 << SKB_DATAREF_SHIFT) + 1 : 1,
- 			      &shinfo->dataref))
--		return;
-+		goto exit;
- 
- 	for (i = 0; i < shinfo->nr_frags; i++)
--		__skb_frag_unref(&shinfo->frags[i]);
-+		__skb_frag_unref(&shinfo->frags[i], skb->pp_recycle);
- 
- 	if (shinfo->frag_list)
- 		kfree_skb_list(shinfo->frag_list);
- 
- 	skb_zcopy_clear(skb, true);
- 	skb_free_head(skb);
-+exit:
-+	/* When we clone an SKB we copy the reycling bit. The pp_recycle
-+	 * bit is only set on the head though, so in order to avoid races
-+	 * while trying to recycle fragments on __skb_frag_unref() we need
-+	 * to make one SKB responsible for triggering the recycle path.
-+	 * So disable the recycling bit if an SKB is cloned and we have
-+	 * additional references to to the fragmented part of the SKB.
-+	 * Eventually the last SKB will have the recycling bit set and it's
-+	 * dataref set to 0, which will trigger the recycling
-+	 */
-+	skb->pp_recycle = 0;
- }
- 
- /*
-@@ -1002,6 +1022,7 @@ static struct sk_buff *__skb_clone(struc
- 	n->nohdr = 0;
- 	n->peeked = 0;
- 	C(pfmemalloc);
-+	C(pp_recycle);
- 	n->destructor = NULL;
- 	C(tail);
- 	C(end);
-@@ -3420,7 +3441,7 @@ int skb_shift(struct sk_buff *tgt, struc
- 		fragto = &skb_shinfo(tgt)->frags[merge];
- 
- 		skb_frag_size_add(fragto, skb_frag_size(fragfrom));
--		__skb_frag_unref(fragfrom);
-+		__skb_frag_unref(fragfrom, skb->pp_recycle);
- 	}
- 
- 	/* Reposition in the original skb */
-@@ -5187,6 +5208,20 @@ bool skb_try_coalesce(struct sk_buff *to
- 	if (skb_cloned(to))
- 		return false;
- 
-+	/* In general, avoid mixing slab allocated and page_pool allocated
-+	 * pages within the same SKB. However when @to is not pp_recycle and
-+	 * @from is cloned, we can transition frag pages from page_pool to
-+	 * reference counted.
-+	 *
-+	 * On the other hand, don't allow coalescing two pp_recycle SKBs if
-+	 * @from is cloned, in case the SKB is using page_pool fragment
-+	 * references (PP_FLAG_PAGE_FRAG). Since we only take full page
-+	 * references for cloned SKBs at the moment that would result in
-+	 * inconsistent reference counts.
-+	 */
-+	if (to->pp_recycle != (from->pp_recycle && !skb_cloned(from)))
-+		return false;
-+
- 	if (len <= skb_tailroom(to)) {
- 		if (len)
- 			BUG_ON(skb_copy_bits(from, 0, skb_put(to, len), len));
---- a/include/linux/skbuff.h
-+++ b/include/linux/skbuff.h
-@@ -37,6 +37,7 @@
- #include <linux/in6.h>
- #include <linux/if_packet.h>
- #include <net/flow.h>
-+#include <net/page_pool.h>
- #if IS_ENABLED(CONFIG_NF_CONNTRACK)
- #include <linux/netfilter/nf_conntrack_common.h>
- #endif
-@@ -786,7 +787,8 @@ struct sk_buff {
- 				fclone:2,
- 				peeked:1,
- 				head_frag:1,
--				pfmemalloc:1;
-+				pfmemalloc:1,
-+				pp_recycle:1; /* page_pool recycle indicator */
- #ifdef CONFIG_SKB_EXTENSIONS
- 	__u8			active_extensions;
- #endif
-@@ -3029,9 +3031,15 @@ static inline void skb_frag_ref(struct s
-  *
-  * Releases a reference on the paged fragment @frag.
-  */
--static inline void __skb_frag_unref(skb_frag_t *frag)
-+static inline void __skb_frag_unref(skb_frag_t *frag, bool recycle)
- {
--	put_page(skb_frag_page(frag));
-+	struct page *page = skb_frag_page(frag);
-+
-+#ifdef CONFIG_PAGE_POOL
-+	if (recycle && page_pool_return_skb_page(page))
-+		return;
-+#endif
-+	put_page(page);
- }
- 
- /**
-@@ -3043,7 +3051,7 @@ static inline void __skb_frag_unref(skb_
-  */
- static inline void skb_frag_unref(struct sk_buff *skb, int f)
- {
--	__skb_frag_unref(&skb_shinfo(skb)->frags[f]);
-+	__skb_frag_unref(&skb_shinfo(skb)->frags[f], skb->pp_recycle);
- }
- 
- /**
-@@ -4642,5 +4650,12 @@ static inline u64 skb_get_kcov_handle(st
- #endif
- }
- 
-+#ifdef CONFIG_PAGE_POOL
-+static inline void skb_mark_for_recycle(struct sk_buff *skb)
-+{
-+	skb->pp_recycle = 1;
-+}
-+#endif
-+
- #endif	/* __KERNEL__ */
- #endif	/* _LINUX_SKBUFF_H */
---- a/drivers/net/ethernet/marvell/sky2.c
-+++ b/drivers/net/ethernet/marvell/sky2.c
-@@ -2501,7 +2501,7 @@ static void skb_put_frags(struct sk_buff
- 
- 		if (length == 0) {
- 			/* don't need this page */
--			__skb_frag_unref(frag);
-+			__skb_frag_unref(frag, false);
- 			--skb_shinfo(skb)->nr_frags;
- 		} else {
- 			size = min(length, (unsigned) PAGE_SIZE);
---- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c
-+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
-@@ -526,7 +526,7 @@ static int mlx4_en_complete_rx_desc(stru
- fail:
- 	while (nr > 0) {
- 		nr--;
--		__skb_frag_unref(skb_shinfo(skb)->frags + nr);
-+		__skb_frag_unref(skb_shinfo(skb)->frags + nr, false);
- 	}
- 	return 0;
- }
---- a/net/tls/tls_device.c
-+++ b/net/tls/tls_device.c
-@@ -131,7 +131,7 @@ static void destroy_record(struct tls_re
- 	int i;
- 
- 	for (i = 0; i < record->num_frags; i++)
--		__skb_frag_unref(&record->frags[i]);
-+		__skb_frag_unref(&record->frags[i], false);
- 	kfree(record);
- }
- 
---- a/include/linux/poison.h
-+++ b/include/linux/poison.h
-@@ -82,4 +82,7 @@
- /********** security/ **********/
- #define KEY_DESTROY		0xbd
- 
-+/********** net/core/page_pool.c **********/
-+#define PP_SIGNATURE		(0x40 + POISON_POINTER_DELTA)
-+
- #endif
---- a/include/linux/mm.h
-+++ b/include/linux/mm.h
-@@ -1602,7 +1602,7 @@ static inline bool page_is_pfmemalloc(st
- 	 * Page index cannot be this large so this must be
- 	 * a pfmemalloc page.
- 	 */
--	return page->index == -1UL;
-+	return (uintptr_t)page->lru.next & BIT(1);
- }
- 
- /*
-@@ -1611,12 +1611,12 @@ static inline bool page_is_pfmemalloc(st
-  */
- static inline void set_page_pfmemalloc(struct page *page)
- {
--	page->index = -1UL;
-+	page->lru.next = (void *)BIT(1);
- }
- 
- static inline void clear_page_pfmemalloc(struct page *page)
- {
--	page->index = 0;
-+	page->lru.next = NULL;
- }
- 
- /*
diff -uprN a/target/linux/generic/backport-5.10/631-v6.3-net-page_pool-use-in_softirq-instead.patch b/target/linux/generic/backport-5.10/631-v6.3-net-page_pool-use-in_softirq-instead.patch
--- a/target/linux/generic/backport-5.10/631-v6.3-net-page_pool-use-in_softirq-instead.patch	2024-03-18 15:15:10.789419098 +0800
+++ b/target/linux/generic/backport-5.10/631-v6.3-net-page_pool-use-in_softirq-instead.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,56 +0,0 @@
-From: Qingfang DENG <qingfang.deng@siflower.com.cn>
-Date: Fri, 3 Feb 2023 09:16:11 +0800
-Subject: [PATCH] net: page_pool: use in_softirq() instead
-
-We use BH context only for synchronization, so we don't care if it's
-actually serving softirq or not.
-
-As a side node, in case of threaded NAPI, in_serving_softirq() will
-return false because it's in process context with BH off, making
-page_pool_recycle_in_cache() unreachable.
-
-Signed-off-by: Qingfang DENG <qingfang.deng@siflower.com.cn>
----
-
---- a/include/net/page_pool.h
-+++ b/include/net/page_pool.h
-@@ -295,7 +295,7 @@ static inline void page_pool_nid_changed
- static inline void page_pool_ring_lock(struct page_pool *pool)
- 	__acquires(&pool->ring.producer_lock)
- {
--	if (in_serving_softirq())
-+	if (in_softirq())
- 		spin_lock(&pool->ring.producer_lock);
- 	else
- 		spin_lock_bh(&pool->ring.producer_lock);
-@@ -304,7 +304,7 @@ static inline void page_pool_ring_lock(s
- static inline void page_pool_ring_unlock(struct page_pool *pool)
- 	__releases(&pool->ring.producer_lock)
- {
--	if (in_serving_softirq())
-+	if (in_softirq())
- 		spin_unlock(&pool->ring.producer_lock);
- 	else
- 		spin_unlock_bh(&pool->ring.producer_lock);
---- a/net/core/page_pool.c
-+++ b/net/core/page_pool.c
-@@ -338,8 +338,8 @@ static void page_pool_return_page(struct
- static bool page_pool_recycle_in_ring(struct page_pool *pool, struct page *page)
- {
- 	int ret;
--	/* BH protection not needed if current is serving softirq */
--	if (in_serving_softirq())
-+	/* BH protection not needed if current is softirq */
-+	if (in_softirq())
- 		ret = ptr_ring_produce(&pool->ring, page);
- 	else
- 		ret = ptr_ring_produce_bh(&pool->ring, page);
-@@ -397,7 +397,7 @@ __page_pool_put_page(struct page_pool *p
- 			page_pool_dma_sync_for_device(pool, page,
- 						      dma_sync_size);
- 
--		if (allow_direct && in_serving_softirq() &&
-+		if (allow_direct && in_softirq() &&
- 		    page_pool_recycle_in_cache(page, pool))
- 			return NULL;
- 
diff -uprN a/target/linux/generic/backport-5.10/632-v6.3-net-add-helper-eth_addr_add.patch b/target/linux/generic/backport-5.10/632-v6.3-net-add-helper-eth_addr_add.patch
--- a/target/linux/generic/backport-5.10/632-v6.3-net-add-helper-eth_addr_add.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/632-v6.3-net-add-helper-eth_addr_add.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From 7390609b0121a1b982c5ecdfcd72dc328e5784ee Mon Sep 17 00:00:00 2001
-From: Michael Walle <michael@walle.cc>
-Date: Mon, 6 Feb 2023 13:43:42 +0000
-Subject: [PATCH] net: add helper eth_addr_add()
-
-Add a helper to add an offset to a ethernet address. This comes in handy
-if you have a base ethernet address for multiple interfaces.
-
-Signed-off-by: Michael Walle <michael@walle.cc>
-Reviewed-by: Andrew Lunn <andrew@lunn.ch>
-Acked-by: Jakub Kicinski <kuba@kernel.org>
-Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
-Link: https://lore.kernel.org/r/20230206134356.839737-9-srinivas.kandagatla@linaro.org
-Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
----
- include/linux/etherdevice.h | 14 ++++++++++++++
- 1 file changed, 14 insertions(+)
-
---- a/include/linux/etherdevice.h
-+++ b/include/linux/etherdevice.h
-@@ -466,6 +466,20 @@ static inline void eth_addr_inc(u8 *addr
- }
- 
- /**
-+ * eth_addr_add() - Add (or subtract) an offset to/from the given MAC address.
-+ *
-+ * @offset: Offset to add.
-+ * @addr: Pointer to a six-byte array containing Ethernet address to increment.
-+ */
-+static inline void eth_addr_add(u8 *addr, long offset)
-+{
-+	u64 u = ether_addr_to_u64(addr);
-+
-+	u += offset;
-+	u64_to_ether_addr(u, addr);
-+}
-+
-+/**
-  * is_etherdev_addr - Tell if given Ethernet address belongs to the device.
-  * @dev: Pointer to a device structure
-  * @addr: Pointer to a six-byte array containing the Ethernet address
diff -uprN a/target/linux/generic/backport-5.10/633-v6.3-skbuff-Fix-a-race-between-coalescing-and-releasing-S.patch b/target/linux/generic/backport-5.10/633-v6.3-skbuff-Fix-a-race-between-coalescing-and-releasing-S.patch
--- a/target/linux/generic/backport-5.10/633-v6.3-skbuff-Fix-a-race-between-coalescing-and-releasing-S.patch	2024-03-18 15:15:10.669423677 +0800
+++ b/target/linux/generic/backport-5.10/633-v6.3-skbuff-Fix-a-race-between-coalescing-and-releasing-S.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,85 +0,0 @@
-From: Liang Chen <liangchen.linux@gmail.com>
-Date: Thu, 13 Apr 2023 17:03:53 +0800
-Subject: [PATCH] skbuff: Fix a race between coalescing and releasing SKBs
-
-Commit 1effe8ca4e34 ("skbuff: fix coalescing for page_pool fragment
-recycling") allowed coalescing to proceed with non page pool page and page
-pool page when @from is cloned, i.e.
-
-to->pp_recycle    --> false
-from->pp_recycle  --> true
-skb_cloned(from)  --> true
-
-However, it actually requires skb_cloned(@from) to hold true until
-coalescing finishes in this situation. If the other cloned SKB is
-released while the merging is in process, from_shinfo->nr_frags will be
-set to 0 toward the end of the function, causing the increment of frag
-page _refcount to be unexpectedly skipped resulting in inconsistent
-reference counts. Later when SKB(@to) is released, it frees the page
-directly even though the page pool page is still in use, leading to
-use-after-free or double-free errors. So it should be prohibited.
-
-The double-free error message below prompted us to investigate:
-BUG: Bad page state in process swapper/1  pfn:0e0d1
-page:00000000c6548b28 refcount:-1 mapcount:0 mapping:0000000000000000
-index:0x2 pfn:0xe0d1
-flags: 0xfffffc0000000(node=0|zone=1|lastcpupid=0x1fffff)
-raw: 000fffffc0000000 0000000000000000 ffffffff00000101 0000000000000000
-raw: 0000000000000002 0000000000000000 ffffffffffffffff 0000000000000000
-page dumped because: nonzero _refcount
-
-CPU: 1 PID: 0 Comm: swapper/1 Tainted: G            E      6.2.0+
-Call Trace:
- <IRQ>
-dump_stack_lvl+0x32/0x50
-bad_page+0x69/0xf0
-free_pcp_prepare+0x260/0x2f0
-free_unref_page+0x20/0x1c0
-skb_release_data+0x10b/0x1a0
-napi_consume_skb+0x56/0x150
-net_rx_action+0xf0/0x350
-? __napi_schedule+0x79/0x90
-__do_softirq+0xc8/0x2b1
-__irq_exit_rcu+0xb9/0xf0
-common_interrupt+0x82/0xa0
-</IRQ>
-<TASK>
-asm_common_interrupt+0x22/0x40
-RIP: 0010:default_idle+0xb/0x20
-
-Fixes: 53e0961da1c7 ("page_pool: add frag page recycling support in page pool")
-Signed-off-by: Liang Chen <liangchen.linux@gmail.com>
-Reviewed-by: Eric Dumazet <edumazet@google.com>
-Link: https://lore.kernel.org/r/20230413090353.14448-1-liangchen.linux@gmail.com
-Signed-off-by: Jakub Kicinski <kuba@kernel.org>
----
-
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -5208,18 +5208,18 @@ bool skb_try_coalesce(struct sk_buff *to
- 	if (skb_cloned(to))
- 		return false;
- 
--	/* In general, avoid mixing slab allocated and page_pool allocated
--	 * pages within the same SKB. However when @to is not pp_recycle and
--	 * @from is cloned, we can transition frag pages from page_pool to
--	 * reference counted.
--	 *
--	 * On the other hand, don't allow coalescing two pp_recycle SKBs if
--	 * @from is cloned, in case the SKB is using page_pool fragment
-+	/* In general, avoid mixing page_pool and non-page_pool allocated
-+	 * pages within the same SKB. Additionally avoid dealing with clones
-+	 * with page_pool pages, in case the SKB is using page_pool fragment
- 	 * references (PP_FLAG_PAGE_FRAG). Since we only take full page
- 	 * references for cloned SKBs at the moment that would result in
- 	 * inconsistent reference counts.
-+	 * In theory we could take full references if @from is cloned and
-+	 * !@to->pp_recycle but its tricky (due to potential race with
-+	 * the clone disappearing) and rare, so not worth dealing with.
- 	 */
--	if (to->pp_recycle != (from->pp_recycle && !skb_cloned(from)))
-+	if (to->pp_recycle != from->pp_recycle ||
-+	    (from->pp_recycle && skb_cloned(from)))
- 		return false;
- 
- 	if (len <= skb_tailroom(to)) {
diff -uprN a/target/linux/generic/backport-5.10/711-v5.12-sfp-add-support-for-100-base-x-SFPs.patch b/target/linux/generic/backport-5.10/711-v5.12-sfp-add-support-for-100-base-x-SFPs.patch
--- a/target/linux/generic/backport-5.10/711-v5.12-sfp-add-support-for-100-base-x-SFPs.patch	2024-03-18 15:15:10.677423372 +0800
+++ b/target/linux/generic/backport-5.10/711-v5.12-sfp-add-support-for-100-base-x-SFPs.patch	2024-03-18 15:16:23.642639590 +0800
@@ -15,7 +15,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/phy/sfp-bus.c
 +++ b/drivers/net/phy/sfp-bus.c
-@@ -286,6 +286,12 @@ void sfp_parse_support(struct sfp_bus *b
+@@ -280,6 +280,12 @@ void sfp_parse_support(struct sfp_bus *b
  	    br_min <= 1300 && br_max >= 1200)
  		phylink_set(modes, 1000baseX_Full);
  
@@ -28,7 +28,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	/* For active or passive cables, select the link modes
  	 * based on the bit rates and the cable compliance bytes.
  	 */
-@@ -405,6 +411,9 @@ phy_interface_t sfp_select_interface(str
+@@ -399,6 +405,9 @@ phy_interface_t sfp_select_interface(str
  	if (phylink_test(link_modes, 1000baseX_Full))
  		return PHY_INTERFACE_MODE_1000BASEX;
  
diff -uprN a/target/linux/generic/backport-5.10/731-v5.12-net-dsa-mt7530-MT7530-optional-GPIO-support.patch b/target/linux/generic/backport-5.10/731-v5.12-net-dsa-mt7530-MT7530-optional-GPIO-support.patch
--- a/target/linux/generic/backport-5.10/731-v5.12-net-dsa-mt7530-MT7530-optional-GPIO-support.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/731-v5.12-net-dsa-mt7530-MT7530-optional-GPIO-support.patch	2024-03-18 15:16:23.706637149 +0800
@@ -27,7 +27,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  #include <net/dsa.h>
  
  #include "mt7530.h"
-@@ -1537,6 +1538,109 @@ mtk_get_tag_protocol(struct dsa_switch *
+@@ -1534,6 +1535,109 @@ mtk_get_tag_protocol(struct dsa_switch *
  	}
  }
  
@@ -137,7 +137,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  static int
  mt7530_setup(struct dsa_switch *ds)
  {
-@@ -1679,6 +1783,12 @@ mt7530_setup(struct dsa_switch *ds)
+@@ -1675,6 +1779,12 @@ mt7530_setup(struct dsa_switch *ds)
  		}
  	}
  
diff -uprN a/target/linux/generic/backport-5.10/731-v5.13-net-dsa-mt7530-Add-support-for-EEE-features.patch b/target/linux/generic/backport-5.10/731-v5.13-net-dsa-mt7530-Add-support-for-EEE-features.patch
--- a/target/linux/generic/backport-5.10/731-v5.13-net-dsa-mt7530-Add-support-for-EEE-features.patch	2024-03-18 15:15:10.677423372 +0800
+++ b/target/linux/generic/backport-5.10/731-v5.13-net-dsa-mt7530-Add-support-for-EEE-features.patch	2024-03-18 15:16:23.642639590 +0800
@@ -35,7 +35,7 @@ Signed-off-by: David S. Miller <davem@da
  	mt7530_set(priv, MT7530_PMCR_P(port), mcr);
  }
  
-@@ -2599,6 +2610,36 @@ mt753x_phy_write(struct dsa_switch *ds,
+@@ -2601,6 +2612,36 @@ mt753x_phy_write(struct dsa_switch *ds,
  	return priv->info->phy_write(ds, port, regnum, val);
  }
  
@@ -72,7 +72,7 @@ Signed-off-by: David S. Miller <davem@da
  static const struct dsa_switch_ops mt7530_switch_ops = {
  	.get_tag_protocol	= mtk_get_tag_protocol,
  	.setup			= mt753x_setup,
-@@ -2627,6 +2668,8 @@ static const struct dsa_switch_ops mt753
+@@ -2629,6 +2670,8 @@ static const struct dsa_switch_ops mt753
  	.phylink_mac_an_restart	= mt753x_phylink_mac_an_restart,
  	.phylink_mac_link_down	= mt753x_phylink_mac_link_down,
  	.phylink_mac_link_up	= mt753x_phylink_mac_link_up,
diff -uprN a/target/linux/generic/backport-5.10/732-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch b/target/linux/generic/backport-5.10/732-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch
--- a/target/linux/generic/backport-5.10/732-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch	2024-03-18 15:15:10.693422762 +0800
+++ b/target/linux/generic/backport-5.10/732-net-next-1-of-net-pass-the-dst-buffer-to-of_get_mac_address.patch	2024-03-18 15:16:23.662638827 +0800
@@ -222,7 +222,7 @@ Signed-off-by: David S. Miller <davem@da
  		mdio = of_find_node_by_phandle(*ph);
 --- a/drivers/net/ethernet/aeroflex/greth.c
 +++ b/drivers/net/ethernet/aeroflex/greth.c
-@@ -1450,10 +1450,10 @@ static int greth_of_probe(struct platfor
+@@ -1449,10 +1449,10 @@ static int greth_of_probe(struct platfor
  			break;
  	}
  	if (i == 6) {
@@ -264,7 +264,7 @@ Signed-off-by: David S. Miller <davem@da
  			 ndev->dev_addr);
 --- a/drivers/net/ethernet/altera/altera_tse_main.c
 +++ b/drivers/net/ethernet/altera/altera_tse_main.c
-@@ -1355,7 +1355,6 @@ static int altera_tse_probe(struct platf
+@@ -1351,7 +1351,6 @@ static int altera_tse_probe(struct platf
  	struct resource *control_port;
  	struct resource *dma_res;
  	struct altera_tse_private *priv;
@@ -272,7 +272,7 @@ Signed-off-by: David S. Miller <davem@da
  	void __iomem *descmap;
  	const struct of_device_id *of_id = NULL;
  
-@@ -1532,10 +1531,8 @@ static int altera_tse_probe(struct platf
+@@ -1528,10 +1527,8 @@ static int altera_tse_probe(struct platf
  	priv->rx_dma_buf_sz = ALTERA_RXDMABUFFER_SIZE;
  
  	/* get default MAC address from device tree */
@@ -311,7 +311,7 @@ Signed-off-by: David S. Miller <davem@da
  	arc_emac_set_address_internal(ndev);
 --- a/drivers/net/ethernet/atheros/ag71xx.c
 +++ b/drivers/net/ethernet/atheros/ag71xx.c
-@@ -1857,7 +1857,6 @@ static int ag71xx_probe(struct platform_
+@@ -1856,7 +1856,6 @@ static int ag71xx_probe(struct platform_
  	const struct ag71xx_dcfg *dcfg;
  	struct net_device *ndev;
  	struct resource *res;
@@ -319,7 +319,7 @@ Signed-off-by: David S. Miller <davem@da
  	int tx_size, err, i;
  	struct ag71xx *ag;
  
-@@ -1953,10 +1952,8 @@ static int ag71xx_probe(struct platform_
+@@ -1952,10 +1951,8 @@ static int ag71xx_probe(struct platform_
  	ag->stop_desc->ctrl = 0;
  	ag->stop_desc->next = (u32)ag->stop_desc_dma;
  
@@ -423,7 +423,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (bgmac->irq < 0)
 --- a/drivers/net/ethernet/cadence/macb_main.c
 +++ b/drivers/net/ethernet/cadence/macb_main.c
-@@ -4480,7 +4480,6 @@ static int macb_probe(struct platform_de
+@@ -4479,7 +4479,6 @@ static int macb_probe(struct platform_de
  	struct net_device *dev;
  	struct resource *regs;
  	void __iomem *mem;
@@ -431,7 +431,7 @@ Signed-off-by: David S. Miller <davem@da
  	struct macb *bp;
  	int err, val;
  
-@@ -4593,15 +4592,11 @@ static int macb_probe(struct platform_de
+@@ -4592,15 +4591,11 @@ static int macb_probe(struct platform_de
  	if (bp->caps & MACB_CAPS_NEEDS_RSTONUBR)
  		bp->rx_intr_mask |= MACB_BIT(RXUBR);
  
@@ -476,7 +476,7 @@ Signed-off-by: David S. Miller <davem@da
  	p->phy_np = of_parse_phandle(pdev->dev.of_node, "phy-handle", 0);
 --- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
 +++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c
-@@ -1476,7 +1476,6 @@ static int bgx_init_of_phy(struct bgx *b
+@@ -1474,7 +1474,6 @@ static int bgx_init_of_phy(struct bgx *b
  	device_for_each_child_node(&bgx->pdev->dev, fwn) {
  		struct phy_device *pd;
  		struct device_node *phy_np;
@@ -484,7 +484,7 @@ Signed-off-by: David S. Miller <davem@da
  
  		/* Should always be an OF node.  But if it is not, we
  		 * cannot handle it, so exit the loop.
-@@ -1485,9 +1484,7 @@ static int bgx_init_of_phy(struct bgx *b
+@@ -1483,9 +1482,7 @@ static int bgx_init_of_phy(struct bgx *b
  		if (!node)
  			break;
  
@@ -775,7 +775,7 @@ Signed-off-by: David S. Miller <davem@da
  	/* bring up the dma engine and IP core */
 --- a/drivers/net/ethernet/marvell/mv643xx_eth.c
 +++ b/drivers/net/ethernet/marvell/mv643xx_eth.c
-@@ -2701,7 +2701,6 @@ static int mv643xx_eth_shared_of_add_por
+@@ -2700,7 +2700,6 @@ static int mv643xx_eth_shared_of_add_por
  	struct platform_device *ppdev;
  	struct mv643xx_eth_platform_data ppd;
  	struct resource res;
@@ -783,7 +783,7 @@ Signed-off-by: David S. Miller <davem@da
  	int ret;
  	int dev_num = 0;
  
-@@ -2732,9 +2731,7 @@ static int mv643xx_eth_shared_of_add_por
+@@ -2731,9 +2730,7 @@ static int mv643xx_eth_shared_of_add_por
  		return -EINVAL;
  	}
  
@@ -895,7 +895,7 @@ Signed-off-by: David S. Miller <davem@da
  
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2604,14 +2604,11 @@ static int __init mtk_init(struct net_de
+@@ -2580,14 +2580,11 @@ static int __init mtk_init(struct net_de
  {
  	struct mtk_mac *mac = netdev_priv(dev);
  	struct mtk_eth *eth = mac->hw;
@@ -1162,7 +1162,7 @@ Signed-off-by: David S. Miller <davem@da
  
 --- a/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c
 +++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-dwc-qos-eth.c
-@@ -445,7 +445,7 @@ static int dwc_eth_dwmac_probe(struct pl
+@@ -444,7 +444,7 @@ static int dwc_eth_dwmac_probe(struct pl
  	if (IS_ERR(stmmac_res.addr))
  		return PTR_ERR(stmmac_res.addr);
  
@@ -1250,7 +1250,7 @@ Signed-off-by: David S. Miller <davem@da
  
 --- a/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
 +++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-meson8b.c
-@@ -370,7 +370,7 @@ static int meson8b_dwmac_probe(struct pl
+@@ -372,7 +372,7 @@ static int meson8b_dwmac_probe(struct pl
  	if (ret)
  		return ret;
  
@@ -1294,7 +1294,7 @@ Signed-off-by: David S. Miller <davem@da
  
 --- a/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c
 +++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-socfpga.c
-@@ -397,7 +397,7 @@ static int socfpga_dwmac_probe(struct pl
+@@ -398,7 +398,7 @@ static int socfpga_dwmac_probe(struct pl
  	if (ret)
  		return ret;
  
@@ -1327,7 +1327,7 @@ Signed-off-by: David S. Miller <davem@da
  
 --- a/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
 +++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
-@@ -1203,7 +1203,7 @@ static int sun8i_dwmac_probe(struct plat
+@@ -1202,7 +1202,7 @@ static int sun8i_dwmac_probe(struct plat
  	if (ret)
  		return -EINVAL;
  
@@ -1360,7 +1360,7 @@ Signed-off-by: David S. Miller <davem@da
  	int irq;
 --- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
 +++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
-@@ -5015,7 +5015,7 @@ int stmmac_dvr_probe(struct device *devi
+@@ -4988,7 +4988,7 @@ int stmmac_dvr_probe(struct device *devi
  	priv->wol_irq = res->wol_irq;
  	priv->lpi_irq = res->lpi_irq;
  
@@ -1398,7 +1398,7 @@ Signed-off-by: David S. Miller <davem@da
  	}
  
  	phy_mode = device_get_phy_mode(&pdev->dev);
-@@ -643,7 +643,7 @@ void stmmac_remove_config_dt(struct plat
+@@ -644,7 +644,7 @@ void stmmac_remove_config_dt(struct plat
  }
  #else
  struct plat_stmmacenet_data *
@@ -1420,7 +1420,7 @@ Signed-off-by: David S. Miller <davem@da
  
 --- a/drivers/net/ethernet/ti/am65-cpsw-nuss.c
 +++ b/drivers/net/ethernet/ti/am65-cpsw-nuss.c
-@@ -1713,7 +1713,6 @@ static int am65_cpsw_nuss_init_slave_por
+@@ -1741,7 +1741,6 @@ static int am65_cpsw_nuss_init_slave_por
  
  	for_each_child_of_node(node, port_np) {
  		struct am65_cpsw_port *port;
@@ -1428,8 +1428,8 @@ Signed-off-by: David S. Miller <davem@da
  		u32 port_id;
  
  		/* it is not a slave port node, continue */
-@@ -1796,15 +1795,15 @@ static int am65_cpsw_nuss_init_slave_por
- 			goto of_node_put;
+@@ -1820,15 +1819,15 @@ static int am65_cpsw_nuss_init_slave_por
+ 			return ret;
  		}
  
 -		mac_addr = of_get_mac_address(port_np);
@@ -1455,7 +1455,7 @@ Signed-off-by: David S. Miller <davem@da
  	of_node_put(node);
 --- a/drivers/net/ethernet/ti/cpsw.c
 +++ b/drivers/net/ethernet/ti/cpsw.c
-@@ -1308,7 +1308,6 @@ static int cpsw_probe_dt(struct cpsw_pla
+@@ -1306,7 +1306,6 @@ static int cpsw_probe_dt(struct cpsw_pla
  
  	for_each_available_child_of_node(node, slave_node) {
  		struct cpsw_slave_data *slave_data = data->slave_data + i;
@@ -1463,7 +1463,7 @@ Signed-off-by: David S. Miller <davem@da
  		int lenp;
  		const __be32 *parp;
  
-@@ -1380,10 +1379,8 @@ static int cpsw_probe_dt(struct cpsw_pla
+@@ -1378,10 +1377,8 @@ static int cpsw_probe_dt(struct cpsw_pla
  		}
  
  no_phy_slave:
@@ -1478,7 +1478,7 @@ Signed-off-by: David S. Miller <davem@da
  			if (ret)
 --- a/drivers/net/ethernet/ti/cpsw_new.c
 +++ b/drivers/net/ethernet/ti/cpsw_new.c
-@@ -1269,7 +1269,6 @@ static int cpsw_probe_dt(struct cpsw_com
+@@ -1267,7 +1267,6 @@ static int cpsw_probe_dt(struct cpsw_com
  
  	for_each_child_of_node(tmp_node, port_np) {
  		struct cpsw_slave_data *slave_data;
@@ -1486,7 +1486,7 @@ Signed-off-by: David S. Miller <davem@da
  		u32 port_id;
  
  		ret = of_property_read_u32(port_np, "reg", &port_id);
-@@ -1328,10 +1327,8 @@ static int cpsw_probe_dt(struct cpsw_com
+@@ -1326,10 +1325,8 @@ static int cpsw_probe_dt(struct cpsw_com
  			goto err_node_put;
  		}
  
@@ -1608,7 +1608,7 @@ Signed-off-by: David S. Miller <davem@da
  		}
 --- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
 +++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
-@@ -1843,8 +1843,8 @@ static int axienet_probe(struct platform
+@@ -1831,8 +1831,8 @@ static int axienet_probe(struct platform
  	struct device_node *np;
  	struct axienet_local *lp;
  	struct net_device *ndev;
@@ -1618,7 +1618,7 @@ Signed-off-by: David S. Miller <davem@da
  	int addr_width = 32;
  	u32 value;
  
-@@ -2044,13 +2044,14 @@ static int axienet_probe(struct platform
+@@ -2032,13 +2032,14 @@ static int axienet_probe(struct platform
  		dev_info(&pdev->dev, "Ethernet core IRQ not defined\n");
  
  	/* Retrieve the MAC address */
@@ -1641,7 +1641,7 @@ Signed-off-by: David S. Miller <davem@da
  	lp->coalesce_count_tx = XAXIDMA_DFT_TX_THRESHOLD;
 --- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c
 +++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c
-@@ -1107,7 +1107,6 @@ static int xemaclite_of_probe(struct pla
+@@ -1113,7 +1113,6 @@ static int xemaclite_of_probe(struct pla
  	struct net_device *ndev = NULL;
  	struct net_local *lp = NULL;
  	struct device *dev = &ofdev->dev;
@@ -1649,7 +1649,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	int rc = 0;
  
-@@ -1149,12 +1148,9 @@ static int xemaclite_of_probe(struct pla
+@@ -1155,12 +1154,9 @@ static int xemaclite_of_probe(struct pla
  	lp->next_rx_buf_to_use = 0x0;
  	lp->tx_ping_pong = get_bool(ofdev, "xlnx,tx-ping-pong");
  	lp->rx_ping_pong = get_bool(ofdev, "xlnx,rx-ping-pong");
@@ -1834,7 +1834,7 @@ Signed-off-by: David S. Miller <davem@da
  	/*
 --- a/drivers/staging/wfx/main.c
 +++ b/drivers/staging/wfx/main.c
-@@ -339,7 +339,6 @@ int wfx_probe(struct wfx_dev *wdev)
+@@ -334,7 +334,6 @@ int wfx_probe(struct wfx_dev *wdev)
  {
  	int i;
  	int err;
@@ -1842,7 +1842,7 @@ Signed-off-by: David S. Miller <davem@da
  	struct gpio_desc *gpio_saved;
  
  	// During first part of boot, gpio_wakeup cannot yet been used. So
-@@ -428,9 +427,9 @@ int wfx_probe(struct wfx_dev *wdev)
+@@ -423,9 +422,9 @@ int wfx_probe(struct wfx_dev *wdev)
  
  	for (i = 0; i < ARRAY_SIZE(wdev->addresses); i++) {
  		eth_zero_addr(wdev->addresses[i].addr);
diff -uprN a/target/linux/generic/backport-5.10/744-v5.15-net-dsa-don-t-set-skb-offload_fwd_mark-when-not-offl.patch b/target/linux/generic/backport-5.10/744-v5.15-net-dsa-don-t-set-skb-offload_fwd_mark-when-not-offl.patch
--- a/target/linux/generic/backport-5.10/744-v5.15-net-dsa-don-t-set-skb-offload_fwd_mark-when-not-offl.patch	2024-03-18 15:15:10.677423372 +0800
+++ b/target/linux/generic/backport-5.10/744-v5.15-net-dsa-don-t-set-skb-offload_fwd_mark-when-not-offl.patch	2024-03-18 15:16:23.642639590 +0800
@@ -82,9 +82,9 @@ Signed-off-by: David S. Miller <davem@da
  	memmove(skb->data - ETH_HLEN,
 --- a/net/dsa/tag_ksz.c
 +++ b/net/dsa/tag_ksz.c
-@@ -25,7 +25,7 @@ static struct sk_buff *ksz_common_rcv(st
- 	if (pskb_trim_rcsum(skb, skb->len - len))
- 		return NULL;
+@@ -24,7 +24,7 @@ static struct sk_buff *ksz_common_rcv(st
+ 
+ 	pskb_trim_rcsum(skb, skb->len - len);
  
 -	skb->offload_fwd_mark = true;
 +	dsa_default_offload_fwd_mark(skb);
diff -uprN a/target/linux/generic/backport-5.10/762-v5.11-net-dsa-mt7530-support-setting-MTU.patch b/target/linux/generic/backport-5.10/762-v5.11-net-dsa-mt7530-support-setting-MTU.patch
--- a/target/linux/generic/backport-5.10/762-v5.11-net-dsa-mt7530-support-setting-MTU.patch	2024-03-18 15:15:10.761420167 +0800
+++ b/target/linux/generic/backport-5.10/762-v5.11-net-dsa-mt7530-support-setting-MTU.patch	2024-03-18 15:16:23.678638217 +0800
@@ -19,7 +19,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/dsa/mt7530.c
 +++ b/drivers/net/dsa/mt7530.c
-@@ -1018,6 +1018,53 @@ mt7530_port_disable(struct dsa_switch *d
+@@ -1015,6 +1015,53 @@ mt7530_port_disable(struct dsa_switch *d
  	mutex_unlock(&priv->reg_mutex);
  }
  
@@ -73,7 +73,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  static void
  mt7530_stp_state_set(struct dsa_switch *ds, int port, u8 state)
  {
-@@ -2650,6 +2697,8 @@ static const struct dsa_switch_ops mt753
+@@ -2652,6 +2699,8 @@ static const struct dsa_switch_ops mt753
  	.get_sset_count		= mt7530_get_sset_count,
  	.port_enable		= mt7530_port_enable,
  	.port_disable		= mt7530_port_disable,
diff -uprN a/target/linux/generic/backport-5.10/763-v5.11-net-dsa-mt7530-enable-MTU-normalization.patch b/target/linux/generic/backport-5.10/763-v5.11-net-dsa-mt7530-enable-MTU-normalization.patch
--- a/target/linux/generic/backport-5.10/763-v5.11-net-dsa-mt7530-enable-MTU-normalization.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/763-v5.11-net-dsa-mt7530-enable-MTU-normalization.patch	2024-03-18 15:16:23.702637301 +0800
@@ -18,7 +18,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/dsa/mt7530.c
 +++ b/drivers/net/dsa/mt7530.c
-@@ -1706,6 +1706,7 @@ mt7530_setup(struct dsa_switch *ds)
+@@ -1703,6 +1703,7 @@ mt7530_setup(struct dsa_switch *ds)
  	 */
  	dn = dsa_to_port(ds, MT7530_CPU_PORT)->master->dev.of_node->parent;
  	ds->configure_vlan_while_not_filtering = true;
@@ -26,7 +26,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	if (priv->id == ID_MT7530) {
  		regulator_set_voltage(priv->core_pwr, 1000000, 1000000);
-@@ -1953,6 +1954,7 @@ mt7531_setup(struct dsa_switch *ds)
+@@ -1947,6 +1948,7 @@ mt7531_setup(struct dsa_switch *ds)
  	}
  
  	ds->configure_vlan_while_not_filtering = true;
diff -uprN a/target/linux/generic/backport-5.10/764-v5.11-net-dsa-mt7530-support-setting-ageing-time.patch b/target/linux/generic/backport-5.10/764-v5.11-net-dsa-mt7530-support-setting-ageing-time.patch
--- a/target/linux/generic/backport-5.10/764-v5.11-net-dsa-mt7530-support-setting-ageing-time.patch	2024-03-18 15:15:10.789419098 +0800
+++ b/target/linux/generic/backport-5.10/764-v5.11-net-dsa-mt7530-support-setting-ageing-time.patch	2024-03-18 15:16:23.706637149 +0800
@@ -20,7 +20,7 @@ Signed-off-by: David S. Miller <davem@da
 
 --- a/drivers/net/dsa/mt7530.c
 +++ b/drivers/net/dsa/mt7530.c
-@@ -873,6 +873,46 @@ mt7530_get_sset_count(struct dsa_switch
+@@ -870,6 +870,46 @@ mt7530_get_sset_count(struct dsa_switch
  	return ARRAY_SIZE(mt7530_mib);
  }
  
@@ -67,7 +67,7 @@ Signed-off-by: David S. Miller <davem@da
  static void mt7530_setup_port5(struct dsa_switch *ds, phy_interface_t interface)
  {
  	struct mt7530_priv *priv = ds->priv;
-@@ -2697,6 +2737,7 @@ static const struct dsa_switch_ops mt753
+@@ -2699,6 +2739,7 @@ static const struct dsa_switch_ops mt753
  	.phy_write		= mt753x_phy_write,
  	.get_ethtool_stats	= mt7530_get_ethtool_stats,
  	.get_sset_count		= mt7530_get_sset_count,
diff -uprN a/target/linux/generic/backport-5.10/770-v5.15-net-dsa-mt7530-support-MDB-operations.patch b/target/linux/generic/backport-5.10/770-v5.15-net-dsa-mt7530-support-MDB-operations.patch
--- a/target/linux/generic/backport-5.10/770-v5.15-net-dsa-mt7530-support-MDB-operations.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/770-v5.15-net-dsa-mt7530-support-MDB-operations.patch	2024-03-18 15:16:23.702637301 +0800
@@ -14,7 +14,7 @@ Signed-off-by: DENG Qingfang <dqfext@gma
 
 --- a/drivers/net/dsa/mt7530.c
 +++ b/drivers/net/dsa/mt7530.c
-@@ -1001,9 +1001,6 @@ mt753x_cpu_port_enable(struct dsa_switch
+@@ -1000,9 +1000,6 @@ mt753x_cpu_port_enable(struct dsa_switch
  	mt7530_write(priv, MT7530_PVC_P(port),
  		     PORT_SPEC_TAG);
  
@@ -24,7 +24,7 @@ Signed-off-by: DENG Qingfang <dqfext@gma
  	/* Set CPU port number */
  	if (priv->id == ID_MT7621)
  		mt7530_rmw(priv, MT7530_MFC, CPU_MASK, CPU_EN | CPU_PORT(port));
-@@ -1134,6 +1131,20 @@ mt7530_stp_state_set(struct dsa_switch *
+@@ -1138,6 +1135,20 @@ mt7530_stp_state_set(struct dsa_switch *
  }
  
  static int
@@ -45,7 +45,7 @@ Signed-off-by: DENG Qingfang <dqfext@gma
  mt7530_port_bridge_join(struct dsa_switch *ds, int port,
  			struct net_device *bridge)
  {
-@@ -1334,6 +1345,63 @@ err:
+@@ -1357,6 +1368,63 @@ err:
  }
  
  static int
@@ -109,7 +109,7 @@ Signed-off-by: DENG Qingfang <dqfext@gma
  mt7530_vlan_cmd(struct mt7530_priv *priv, enum mt7530_vlan_cmd cmd, u16 vid)
  {
  	struct mt7530_dummy_poll p;
-@@ -2743,11 +2811,15 @@ static const struct dsa_switch_ops mt753
+@@ -2794,11 +2862,15 @@ static const struct dsa_switch_ops mt753
  	.port_change_mtu	= mt7530_port_change_mtu,
  	.port_max_mtu		= mt7530_port_max_mtu,
  	.port_stp_state_set	= mt7530_stp_state_set,
diff -uprN a/target/linux/generic/backport-5.10/772-v5.14-net-dsa-mt7530-add-interrupt-support.patch b/target/linux/generic/backport-5.10/772-v5.14-net-dsa-mt7530-add-interrupt-support.patch
--- a/target/linux/generic/backport-5.10/772-v5.14-net-dsa-mt7530-add-interrupt-support.patch	2024-03-18 15:15:10.677423372 +0800
+++ b/target/linux/generic/backport-5.10/772-v5.14-net-dsa-mt7530-add-interrupt-support.patch	2024-03-18 15:16:23.642639590 +0800
@@ -27,7 +27,7 @@ Signed-off-by: David S. Miller <davem@da
  #include <linux/of_mdio.h>
  #include <linux/of_net.h>
  #include <linux/of_platform.h>
-@@ -603,18 +604,14 @@ mt7530_mib_reset(struct dsa_switch *ds)
+@@ -602,18 +603,14 @@ mt7530_mib_reset(struct dsa_switch *ds)
  	mt7530_write(priv, MT7530_MIB_CCR, CCR_MIB_ACTIVATE);
  }
  
@@ -48,7 +48,7 @@ Signed-off-by: David S. Miller <davem@da
  	return mdiobus_write_nested(priv->bus, port, regnum, val);
  }
  
-@@ -792,9 +789,8 @@ out:
+@@ -791,9 +788,8 @@ out:
  }
  
  static int
@@ -59,7 +59,7 @@ Signed-off-by: David S. Miller <davem@da
  	int devad;
  	int ret;
  
-@@ -810,10 +806,9 @@ mt7531_ind_phy_read(struct dsa_switch *d
+@@ -809,10 +805,9 @@ mt7531_ind_phy_read(struct dsa_switch *d
  }
  
  static int
@@ -71,7 +71,7 @@ Signed-off-by: David S. Miller <davem@da
  	int devad;
  	int ret;
  
-@@ -829,6 +824,22 @@ mt7531_ind_phy_write(struct dsa_switch *
+@@ -828,6 +823,22 @@ mt7531_ind_phy_write(struct dsa_switch *
  	return ret;
  }
  
@@ -94,7 +94,7 @@ Signed-off-by: David S. Miller <davem@da
  static void
  mt7530_get_strings(struct dsa_switch *ds, int port, u32 stringset,
  		   uint8_t *data)
-@@ -1796,6 +1807,210 @@ mt7530_setup_gpio(struct mt7530_priv *pr
+@@ -1824,6 +1835,210 @@ mt7530_setup_gpio(struct mt7530_priv *pr
  	return devm_gpiochip_add_data(dev, gc, priv);
  }
  
@@ -305,7 +305,7 @@ Signed-off-by: David S. Miller <davem@da
  static int
  mt7530_setup(struct dsa_switch *ds)
  {
-@@ -2747,24 +2962,20 @@ static int
+@@ -2798,24 +3013,20 @@ static int
  mt753x_setup(struct dsa_switch *ds)
  {
  	struct mt7530_priv *priv = ds->priv;
@@ -340,7 +340,7 @@ Signed-off-by: David S. Miller <davem@da
  }
  
  static int mt753x_get_mac_eee(struct dsa_switch *ds, int port,
-@@ -2801,8 +3012,6 @@ static const struct dsa_switch_ops mt753
+@@ -2852,8 +3063,6 @@ static const struct dsa_switch_ops mt753
  	.get_tag_protocol	= mtk_get_tag_protocol,
  	.setup			= mt753x_setup,
  	.get_strings		= mt7530_get_strings,
@@ -349,7 +349,7 @@ Signed-off-by: David S. Miller <davem@da
  	.get_ethtool_stats	= mt7530_get_ethtool_stats,
  	.get_sset_count		= mt7530_get_sset_count,
  	.set_ageing_time	= mt7530_set_ageing_time,
-@@ -2985,6 +3194,9 @@ mt7530_remove(struct mdio_device *mdiode
+@@ -3036,6 +3245,9 @@ mt7530_remove(struct mdio_device *mdiode
  		dev_err(priv->dev, "Failed to disable io pwr: %d\n",
  			ret);
  
@@ -369,7 +369,7 @@ Signed-off-by: David S. Miller <davem@da
  #define MT7530_CPU_PORT			6
  #define MT7530_NUM_FDB_RECORDS		2048
  #define MT7530_ALL_MEMBERS		0xff
-@@ -392,6 +393,12 @@ enum mt7531_sgmii_force_duplex {
+@@ -401,6 +402,12 @@ enum mt7531_sgmii_force_duplex {
  #define  SYS_CTRL_SW_RST		BIT(1)
  #define  SYS_CTRL_REG_RST		BIT(0)
  
@@ -382,7 +382,7 @@ Signed-off-by: David S. Miller <davem@da
  /* Register for PHY Indirect Access Control */
  #define MT7531_PHY_IAC			0x701C
  #define  MT7531_PHY_ACS_ST		BIT(31)
-@@ -713,6 +720,8 @@ static const char *p5_intf_modes(unsigne
+@@ -722,6 +729,8 @@ static const char *p5_intf_modes(unsigne
  	}
  }
  
@@ -391,7 +391,7 @@ Signed-off-by: David S. Miller <davem@da
  /* struct mt753x_info -	This is the main data structure for holding the specific
   *			part for each supported device
   * @sw_setup:		Holding the handler to a device initialization
-@@ -737,8 +746,8 @@ struct mt753x_info {
+@@ -746,8 +755,8 @@ struct mt753x_info {
  	enum mt753x_id id;
  
  	int (*sw_setup)(struct dsa_switch *ds);
@@ -402,7 +402,7 @@ Signed-off-by: David S. Miller <davem@da
  	int (*pad_setup)(struct dsa_switch *ds, phy_interface_t interface);
  	int (*cpu_port_config)(struct dsa_switch *ds, int port);
  	bool (*phy_mode_supported)(struct dsa_switch *ds, int port,
-@@ -772,6 +781,10 @@ struct mt753x_info {
+@@ -781,6 +790,10 @@ struct mt753x_info {
   *			registers
   * @p6_interface	Holding the current port 6 interface
   * @p5_intf_sel:	Holding the current port 5 interface select
@@ -413,7 +413,7 @@ Signed-off-by: David S. Miller <davem@da
   */
  struct mt7530_priv {
  	struct device		*dev;
-@@ -793,6 +806,9 @@ struct mt7530_priv {
+@@ -802,6 +815,9 @@ struct mt7530_priv {
  	struct mt7530_port	ports[MT7530_NUM_PORTS];
  	/* protect among processes for registers access*/
  	struct mutex reg_mutex;
diff -uprN a/target/linux/generic/backport-5.10/774-v5.15-1-igc-remove-_I_PHY_ID-checking.patch b/target/linux/generic/backport-5.10/774-v5.15-1-igc-remove-_I_PHY_ID-checking.patch
--- a/target/linux/generic/backport-5.10/774-v5.15-1-igc-remove-_I_PHY_ID-checking.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-5.10/774-v5.15-1-igc-remove-_I_PHY_ID-checking.patch	2024-03-18 15:16:23.682638064 +0800
@@ -0,0 +1,73 @@
+From 7c496de538eebd8212dc2a3c9a468386b264d0d4 Mon Sep 17 00:00:00 2001
+From: Sasha Neftin <sasha.neftin@intel.com>
+Date: Wed, 7 Jul 2021 08:14:40 +0300
+Subject: igc: Remove _I_PHY_ID checking
+
+i225 devices have only one PHY vendor. There is no point checking
+_I_PHY_ID during the link establishment and auto-negotiation process.
+This patch comes to clean up these pointless checkings.
+
+Signed-off-by: Sasha Neftin <sasha.neftin@intel.com>
+Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
+Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
+---
+ drivers/net/ethernet/intel/igc/igc_base.c | 10 +---------
+ drivers/net/ethernet/intel/igc/igc_main.c |  3 +--
+ drivers/net/ethernet/intel/igc/igc_phy.c  |  6 ++----
+ 3 files changed, 4 insertions(+), 15 deletions(-)
+
+(limited to 'drivers/net/ethernet/intel/igc')
+
+--- a/drivers/net/ethernet/intel/igc/igc_base.c
++++ b/drivers/net/ethernet/intel/igc/igc_base.c
+@@ -187,15 +187,7 @@ static s32 igc_init_phy_params_base(stru
+ 
+ 	igc_check_for_copper_link(hw);
+ 
+-	/* Verify phy id and set remaining function pointers */
+-	switch (phy->id) {
+-	case I225_I_PHY_ID:
+-		phy->type	= igc_phy_i225;
+-		break;
+-	default:
+-		ret_val = -IGC_ERR_PHY;
+-		goto out;
+-	}
++	phy->type = igc_phy_i225;
+ 
+ out:
+ 	return ret_val;
+--- a/drivers/net/ethernet/intel/igc/igc_main.c
++++ b/drivers/net/ethernet/intel/igc/igc_main.c
+@@ -4189,8 +4189,7 @@ bool igc_has_link(struct igc_adapter *ad
+ 		break;
+ 	}
+ 
+-	if (hw->mac.type == igc_i225 &&
+-	    hw->phy.id == I225_I_PHY_ID) {
++	if (hw->mac.type == igc_i225) {
+ 		if (!netif_carrier_ok(adapter->netdev)) {
+ 			adapter->flags &= ~IGC_FLAG_NEED_LINK_UPDATE;
+ 		} else if (!(adapter->flags & IGC_FLAG_NEED_LINK_UPDATE)) {
+--- a/drivers/net/ethernet/intel/igc/igc_phy.c
++++ b/drivers/net/ethernet/intel/igc/igc_phy.c
+@@ -249,8 +249,7 @@ static s32 igc_phy_setup_autoneg(struct
+ 			return ret_val;
+ 	}
+ 
+-	if ((phy->autoneg_mask & ADVERTISE_2500_FULL) &&
+-	    hw->phy.id == I225_I_PHY_ID) {
++	if (phy->autoneg_mask & ADVERTISE_2500_FULL) {
+ 		/* Read the MULTI GBT AN Control Register - reg 7.32 */
+ 		ret_val = phy->ops.read_reg(hw, (STANDARD_AN_REG_MASK <<
+ 					    MMD_DEVADDR_SHIFT) |
+@@ -390,8 +389,7 @@ static s32 igc_phy_setup_autoneg(struct
+ 		ret_val = phy->ops.write_reg(hw, PHY_1000T_CTRL,
+ 					     mii_1000t_ctrl_reg);
+ 
+-	if ((phy->autoneg_mask & ADVERTISE_2500_FULL) &&
+-	    hw->phy.id == I225_I_PHY_ID)
++	if (phy->autoneg_mask & ADVERTISE_2500_FULL)
+ 		ret_val = phy->ops.write_reg(hw,
+ 					     (STANDARD_AN_REG_MASK <<
+ 					     MMD_DEVADDR_SHIFT) |
diff -uprN a/target/linux/generic/backport-5.10/774-v5.15-2-igc-remove-phy-type-checking.patch b/target/linux/generic/backport-5.10/774-v5.15-2-igc-remove-phy-type-checking.patch
--- a/target/linux/generic/backport-5.10/774-v5.15-2-igc-remove-phy-type-checking.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-5.10/774-v5.15-2-igc-remove-phy-type-checking.patch	2024-03-18 15:16:23.674638369 +0800
@@ -0,0 +1,43 @@
+From 47bca7de6a4fb8dcb564c7ca14d885c91ed19e03 Mon Sep 17 00:00:00 2001
+From: Sasha Neftin <sasha.neftin@intel.com>
+Date: Sat, 10 Jul 2021 20:57:50 +0300
+Subject: igc: Remove phy->type checking
+
+i225 devices have only one phy->type: copper. There is no point checking
+phy->type during the igc_has_link method from the watchdog that
+invoked every 2 seconds.
+This patch comes to clean up these pointless checkings.
+
+Signed-off-by: Sasha Neftin <sasha.neftin@intel.com>
+Tested-by: Dvora Fuxbrumer <dvorax.fuxbrumer@linux.intel.com>
+Signed-off-by: Tony Nguyen <anthony.l.nguyen@intel.com>
+---
+ drivers/net/ethernet/intel/igc/igc_main.c | 15 ++++-----------
+ 1 file changed, 4 insertions(+), 11 deletions(-)
+
+(limited to 'drivers/net/ethernet/intel/igc')
+
+--- a/drivers/net/ethernet/intel/igc/igc_main.c
++++ b/drivers/net/ethernet/intel/igc/igc_main.c
+@@ -4177,17 +4177,10 @@ bool igc_has_link(struct igc_adapter *ad
+ 	 * false until the igc_check_for_link establishes link
+ 	 * for copper adapters ONLY
+ 	 */
+-	switch (hw->phy.media_type) {
+-	case igc_media_type_copper:
+-		if (!hw->mac.get_link_status)
+-			return true;
+-		hw->mac.ops.check_for_link(hw);
+-		link_active = !hw->mac.get_link_status;
+-		break;
+-	default:
+-	case igc_media_type_unknown:
+-		break;
+-	}
++	if (!hw->mac.get_link_status)
++		return true;
++	hw->mac.ops.check_for_link(hw);
++	link_active = !hw->mac.get_link_status;
+ 
+ 	if (hw->mac.type == igc_i225) {
+ 		if (!netif_carrier_ok(adapter->netdev)) {
diff -uprN a/target/linux/generic/backport-5.10/774-v5.15-net-dsa-mv88e6xxx-keep-the-pvid-at-0-when-VLAN-unawa.patch b/target/linux/generic/backport-5.10/774-v5.15-net-dsa-mv88e6xxx-keep-the-pvid-at-0-when-VLAN-unawa.patch
--- a/target/linux/generic/backport-5.10/774-v5.15-net-dsa-mv88e6xxx-keep-the-pvid-at-0-when-VLAN-unawa.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/774-v5.15-net-dsa-mv88e6xxx-keep-the-pvid-at-0-when-VLAN-unawa.patch	2024-03-18 15:16:23.702637301 +0800
@@ -63,7 +63,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/dsa/mv88e6xxx/chip.c
 +++ b/drivers/net/dsa/mv88e6xxx/chip.c
-@@ -1590,6 +1590,26 @@ static int mv88e6xxx_port_check_hw_vlan(
+@@ -1586,6 +1586,26 @@ static int mv88e6xxx_port_check_hw_vlan(
  	return 0;
  }
  
@@ -90,7 +90,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  static int mv88e6xxx_port_vlan_filtering(struct dsa_switch *ds, int port,
  					 bool vlan_filtering,
  					 struct switchdev_trans *trans)
-@@ -1603,7 +1623,16 @@ static int mv88e6xxx_port_vlan_filtering
+@@ -1599,7 +1619,16 @@ static int mv88e6xxx_port_vlan_filtering
  		return chip->info->max_vid ? 0 : -EOPNOTSUPP;
  
  	mv88e6xxx_reg_lock(chip);
@@ -107,7 +107,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	mv88e6xxx_reg_unlock(chip);
  
  	return err;
-@@ -1986,8 +2015,10 @@ static void mv88e6xxx_port_vlan_add(stru
+@@ -1982,8 +2011,10 @@ static void mv88e6xxx_port_vlan_add(stru
  	struct mv88e6xxx_chip *chip = ds->priv;
  	bool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;
  	bool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;
@@ -118,7 +118,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	u16 vid;
  
  	if (!chip->info->max_vid)
-@@ -2012,9 +2043,23 @@ static void mv88e6xxx_port_vlan_add(stru
+@@ -2008,9 +2039,23 @@ static void mv88e6xxx_port_vlan_add(stru
  			dev_err(ds->dev, "p%d: failed to add VLAN %d%c\n", port,
  				vid, untagged ? 'u' : 't');
  
@@ -145,7 +145,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	mv88e6xxx_reg_unlock(chip);
  }
-@@ -2065,6 +2110,7 @@ static int mv88e6xxx_port_vlan_del(struc
+@@ -2061,6 +2106,7 @@ static int mv88e6xxx_port_vlan_del(struc
  				   const struct switchdev_obj_port_vlan *vlan)
  {
  	struct mv88e6xxx_chip *chip = ds->priv;
@@ -153,7 +153,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	u16 pvid, vid;
  	int err = 0;
  
-@@ -2083,7 +2129,9 @@ static int mv88e6xxx_port_vlan_del(struc
+@@ -2079,7 +2125,9 @@ static int mv88e6xxx_port_vlan_del(struc
  			goto unlock;
  
  		if (vid == pvid) {
diff -uprN a/target/linux/generic/backport-5.10/782-v5.11-net-usb-r8153_ecm-support-ECM-mode-for-RTL8153.patch b/target/linux/generic/backport-5.10/782-v5.11-net-usb-r8153_ecm-support-ECM-mode-for-RTL8153.patch
--- a/target/linux/generic/backport-5.10/782-v5.11-net-usb-r8153_ecm-support-ECM-mode-for-RTL8153.patch	2024-03-18 15:15:10.705422304 +0800
+++ b/target/linux/generic/backport-5.10/782-v5.11-net-usb-r8153_ecm-support-ECM-mode-for-RTL8153.patch	2024-03-18 15:16:23.662638827 +0800
@@ -89,7 +89,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  struct tally_counter {
  	__le64	tx_packets;
  	__le64	rx_packets;
-@@ -6604,7 +6581,7 @@ static int rtl_fw_init(struct r8152 *tp)
+@@ -6602,7 +6579,7 @@ static int rtl_fw_init(struct r8152 *tp)
  	return 0;
  }
  
@@ -98,7 +98,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  {
  	struct usb_device *udev = interface_to_usbdev(intf);
  	u32 ocp_data = 0;
-@@ -6662,12 +6639,13 @@ static u8 rtl_get_version(struct usb_int
+@@ -6660,12 +6637,13 @@ static u8 rtl_get_version(struct usb_int
  
  	return version;
  }
diff -uprN a/target/linux/generic/backport-5.10/783-v5.12-net-usb-r8152-use-new-tasklet-API.patch b/target/linux/generic/backport-5.10/783-v5.12-net-usb-r8152-use-new-tasklet-API.patch
--- a/target/linux/generic/backport-5.10/783-v5.12-net-usb-r8152-use-new-tasklet-API.patch	2024-03-18 15:15:10.701422456 +0800
+++ b/target/linux/generic/backport-5.10/783-v5.12-net-usb-r8152-use-new-tasklet-API.patch	2024-03-18 15:16:23.662638827 +0800
@@ -16,7 +16,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/usb/r8152.c
 +++ b/drivers/net/usb/r8152.c
-@@ -2395,11 +2395,9 @@ static void tx_bottom(struct r8152 *tp)
+@@ -2393,11 +2393,9 @@ static void tx_bottom(struct r8152 *tp)
  	} while (res == 0);
  }
  
@@ -30,7 +30,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	if (test_bit(RTL8152_UNPLUG, &tp->flags))
  		return;
-@@ -6697,7 +6695,7 @@ static int rtl8152_probe(struct usb_inte
+@@ -6695,7 +6693,7 @@ static int rtl8152_probe(struct usb_inte
  	mutex_init(&tp->control);
  	INIT_DELAYED_WORK(&tp->schedule, rtl_work_func_t);
  	INIT_DELAYED_WORK(&tp->hw_phy_work, rtl_hw_phy_work_func_t);
diff -uprN a/target/linux/generic/backport-5.10/784-v5.12-r8152-replace-several-functions-about-phy-patch-requ.patch b/target/linux/generic/backport-5.10/784-v5.12-r8152-replace-several-functions-about-phy-patch-requ.patch
--- a/target/linux/generic/backport-5.10/784-v5.12-r8152-replace-several-functions-about-phy-patch-requ.patch	2024-03-18 15:15:10.761420167 +0800
+++ b/target/linux/generic/backport-5.10/784-v5.12-r8152-replace-several-functions-about-phy-patch-requ.patch	2024-03-18 15:16:23.678638217 +0800
@@ -25,7 +25,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/usb/r8152.c
 +++ b/drivers/net/usb/r8152.c
-@@ -3445,59 +3445,76 @@ static void rtl_clear_bp(struct r8152 *t
+@@ -3443,59 +3443,76 @@ static void rtl_clear_bp(struct r8152 *t
  	ocp_write_word(tp, type, PLA_BP_BA, 0);
  }
  
@@ -127,7 +127,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_OCP_GPHY_BASE, tp->ocp_base);
  
-@@ -3982,7 +3999,7 @@ static void rtl8152_fw_mac_apply(struct
+@@ -3980,7 +3997,7 @@ static void rtl8152_fw_mac_apply(struct
  	dev_dbg(&tp->intf->dev, "successfully applied %s\n", mac->info);
  }
  
@@ -136,7 +136,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  {
  	struct rtl_fw *rtl_fw = &tp->rtl_fw;
  	const struct firmware *fw;
-@@ -4013,12 +4030,11 @@ static void rtl8152_apply_firmware(struc
+@@ -4011,12 +4028,11 @@ static void rtl8152_apply_firmware(struc
  		case RTL_FW_PHY_START:
  			key = (struct fw_phy_patch_key *)block;
  			key_addr = __le16_to_cpu(key->key_reg);
@@ -151,7 +151,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  			break;
  		case RTL_FW_PHY_NC:
  			rtl8152_fw_phy_nc_apply(tp, (struct fw_phy_nc *)block);
-@@ -4223,7 +4239,7 @@ static void rtl8152_disable(struct r8152
+@@ -4221,7 +4237,7 @@ static void rtl8152_disable(struct r8152
  
  static void r8152b_hw_phy_cfg(struct r8152 *tp)
  {
@@ -160,7 +160,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	rtl_eee_enable(tp, tp->eee_en);
  	r8152_aldps_en(tp, true);
  	r8152b_enable_fc(tp);
-@@ -4505,7 +4521,7 @@ static void r8153_hw_phy_cfg(struct r815
+@@ -4503,7 +4519,7 @@ static void r8153_hw_phy_cfg(struct r815
  	/* disable EEE before updating the PHY parameters */
  	rtl_eee_enable(tp, false);
  
@@ -169,7 +169,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	if (tp->version == RTL_VER_03) {
  		data = ocp_reg_read(tp, OCP_EEE_CFG);
-@@ -4579,7 +4595,7 @@ static void r8153b_hw_phy_cfg(struct r81
+@@ -4577,7 +4593,7 @@ static void r8153b_hw_phy_cfg(struct r81
  	/* disable EEE before updating the PHY parameters */
  	rtl_eee_enable(tp, false);
  
@@ -178,7 +178,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	r8153b_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
  
-@@ -4620,7 +4636,7 @@ static void r8153b_hw_phy_cfg(struct r81
+@@ -4618,7 +4634,7 @@ static void r8153b_hw_phy_cfg(struct r81
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_PHY_PWR, ocp_data);
  
  	/* Advnace EEE */
@@ -187,7 +187,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  		data = ocp_reg_read(tp, OCP_POWER_CFG);
  		data |= EEE_CLKDIV_EN;
  		ocp_reg_write(tp, OCP_POWER_CFG, data);
-@@ -4637,7 +4653,7 @@ static void r8153b_hw_phy_cfg(struct r81
+@@ -4635,7 +4651,7 @@ static void r8153b_hw_phy_cfg(struct r81
  		ocp_reg_write(tp, OCP_SYSCLK_CFG, clk_div_expo(5));
  		tp->ups_info._250m_ckdiv = true;
  
diff -uprN a/target/linux/generic/backport-5.10/785-v5.12-r8152-adjust-the-flow-of-power-cut-for-RTL8153B.patch b/target/linux/generic/backport-5.10/785-v5.12-r8152-adjust-the-flow-of-power-cut-for-RTL8153B.patch
--- a/target/linux/generic/backport-5.10/785-v5.12-r8152-adjust-the-flow-of-power-cut-for-RTL8153B.patch	2024-03-18 15:15:10.669423677 +0800
+++ b/target/linux/generic/backport-5.10/785-v5.12-r8152-adjust-the-flow-of-power-cut-for-RTL8153B.patch	2024-03-18 15:16:23.638639742 +0800
@@ -31,7 +31,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  static int rtl8152_set_mac_address(struct net_device *netdev, void *p)
  {
  	struct r8152 *tp = netdev_priv(netdev);
-@@ -3184,8 +3188,6 @@ static void r8153b_ups_en(struct r8152 *
+@@ -3182,8 +3186,6 @@ static void r8153b_ups_en(struct r8152 *
  		ocp_data |= BIT(0);
  		ocp_write_byte(tp, MCU_TYPE_USB, 0xcfff, ocp_data);
  	} else {
@@ -40,7 +40,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  		ocp_data &= ~(UPS_EN | USP_PREWAKE);
  		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
  
-@@ -3193,31 +3195,20 @@ static void r8153b_ups_en(struct r8152 *
+@@ -3191,31 +3193,20 @@ static void r8153b_ups_en(struct r8152 *
  		ocp_data &= ~BIT(0);
  		ocp_write_byte(tp, MCU_TYPE_USB, 0xcfff, ocp_data);
  
@@ -83,7 +83,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  		}
  	}
  }
-@@ -4589,13 +4580,37 @@ static void r8153b_hw_phy_cfg(struct r81
+@@ -4587,13 +4578,37 @@ static void r8153b_hw_phy_cfg(struct r81
  	u32 ocp_data;
  	u16 data;
  
@@ -122,7 +122,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  
  	r8153b_green_en(tp, test_bit(GREEN_ETHERNET, &tp->flags));
  
-@@ -5524,9 +5539,6 @@ static void r8153b_init(struct r8152 *tp
+@@ -5522,9 +5537,6 @@ static void r8153b_init(struct r8152 *tp
  	/* MSC timer = 0xfff * 8ms = 32760 ms */
  	ocp_write_word(tp, MCU_TYPE_USB, USB_MSC_TIMER, 0x0fff);
  
diff -uprN a/target/linux/generic/backport-5.10/786-v5.12-r8152-enable-U1-U2-for-USB_SPEED_SUPER.patch b/target/linux/generic/backport-5.10/786-v5.12-r8152-enable-U1-U2-for-USB_SPEED_SUPER.patch
--- a/target/linux/generic/backport-5.10/786-v5.12-r8152-enable-U1-U2-for-USB_SPEED_SUPER.patch	2024-03-18 15:15:10.701422456 +0800
+++ b/target/linux/generic/backport-5.10/786-v5.12-r8152-enable-U1-U2-for-USB_SPEED_SUPER.patch	2024-03-18 15:16:23.662638827 +0800
@@ -16,7 +16,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/usb/r8152.c
 +++ b/drivers/net/usb/r8152.c
-@@ -3337,7 +3337,7 @@ static void rtl8153b_runtime_enable(stru
+@@ -3335,7 +3335,7 @@ static void rtl8153b_runtime_enable(stru
  		r8153b_ups_en(tp, false);
  		r8153_queue_wake(tp, false);
  		rtl_runtime_suspend_enable(tp, false);
@@ -25,7 +25,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  			r8153b_u1u2en(tp, true);
  	}
  }
-@@ -5030,7 +5030,7 @@ static void rtl8153b_up(struct r8152 *tp
+@@ -5028,7 +5028,7 @@ static void rtl8153b_up(struct r8152 *tp
  
  	r8153_aldps_en(tp, true);
  
@@ -34,7 +34,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  		r8153b_u1u2en(tp, true);
  }
  
-@@ -5552,8 +5552,9 @@ static void r8153b_init(struct r8152 *tp
+@@ -5550,8 +5550,9 @@ static void r8153b_init(struct r8152 *tp
  	ocp_data |= POLL_LINK_CHG;
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_EXTRA_STATUS, ocp_data);
  
diff -uprN a/target/linux/generic/backport-5.10/787-v5.12-r8152-check-if-the-pointer-of-the-function-exists.patch b/target/linux/generic/backport-5.10/787-v5.12-r8152-check-if-the-pointer-of-the-function-exists.patch
--- a/target/linux/generic/backport-5.10/787-v5.12-r8152-check-if-the-pointer-of-the-function-exists.patch	2024-03-18 15:15:10.769419862 +0800
+++ b/target/linux/generic/backport-5.10/787-v5.12-r8152-check-if-the-pointer-of-the-function-exists.patch	2024-03-18 15:16:23.682638064 +0800
@@ -15,7 +15,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/usb/r8152.c
 +++ b/drivers/net/usb/r8152.c
-@@ -5737,6 +5737,9 @@ static int rtl8152_runtime_suspend(struc
+@@ -5735,6 +5735,9 @@ static int rtl8152_runtime_suspend(struc
  	struct net_device *netdev = tp->netdev;
  	int ret = 0;
  
@@ -25,7 +25,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	set_bit(SELECTIVE_SUSPEND, &tp->flags);
  	smp_mb__after_atomic();
  
-@@ -6136,6 +6139,11 @@ rtl_ethtool_get_eee(struct net_device *n
+@@ -6134,6 +6137,11 @@ rtl_ethtool_get_eee(struct net_device *n
  	struct r8152 *tp = netdev_priv(net);
  	int ret;
  
@@ -37,7 +37,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	ret = usb_autopm_get_interface(tp->intf);
  	if (ret < 0)
  		goto out;
-@@ -6158,6 +6166,11 @@ rtl_ethtool_set_eee(struct net_device *n
+@@ -6156,6 +6164,11 @@ rtl_ethtool_set_eee(struct net_device *n
  	struct r8152 *tp = netdev_priv(net);
  	int ret;
  
diff -uprN a/target/linux/generic/backport-5.10/788-v5.12-r8152-replace-netif_err-with-dev_err.patch b/target/linux/generic/backport-5.10/788-v5.12-r8152-replace-netif_err-with-dev_err.patch
--- a/target/linux/generic/backport-5.10/788-v5.12-r8152-replace-netif_err-with-dev_err.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/788-v5.12-r8152-replace-netif_err-with-dev_err.patch	2024-03-18 15:16:23.702637301 +0800
@@ -16,7 +16,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/usb/r8152.c
 +++ b/drivers/net/usb/r8152.c
-@@ -6573,7 +6573,7 @@ static int rtl_ops_init(struct r8152 *tp
+@@ -6571,7 +6571,7 @@ static int rtl_ops_init(struct r8152 *tp
  
  	default:
  		ret = -ENODEV;
@@ -25,7 +25,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  		break;
  	}
  
-@@ -6830,7 +6830,7 @@ static int rtl8152_probe(struct usb_inte
+@@ -6828,7 +6828,7 @@ static int rtl8152_probe(struct usb_inte
  
  	ret = register_netdev(netdev);
  	if (ret != 0) {
diff -uprN a/target/linux/generic/backport-5.10/789-v5.12-r8152-spilt-rtl_set_eee_plus-and-r8153b_green_en.patch b/target/linux/generic/backport-5.10/789-v5.12-r8152-spilt-rtl_set_eee_plus-and-r8153b_green_en.patch
--- a/target/linux/generic/backport-5.10/789-v5.12-r8152-spilt-rtl_set_eee_plus-and-r8153b_green_en.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/789-v5.12-r8152-spilt-rtl_set_eee_plus-and-r8153b_green_en.patch	2024-03-18 15:16:23.706637149 +0800
@@ -15,7 +15,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
 
 --- a/drivers/net/usb/r8152.c
 +++ b/drivers/net/usb/r8152.c
-@@ -2634,21 +2634,24 @@ static inline u8 rtl8152_get_speed(struc
+@@ -2632,21 +2632,24 @@ static inline u8 rtl8152_get_speed(struc
  	return ocp_read_byte(tp, MCU_TYPE_PLA, PLA_PHYSTATUS);
  }
  
@@ -50,7 +50,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  }
  
  static void rxdy_gated_en(struct r8152 *tp, bool enable)
-@@ -3129,10 +3132,22 @@ static void r8153b_ups_flags(struct r815
+@@ -3127,10 +3130,22 @@ static void r8153b_ups_flags(struct r815
  	ocp_write_dword(tp, MCU_TYPE_USB, USB_UPS_FLAGS, ups_flags);
  }
  
@@ -74,7 +74,7 @@ Signed-off-by: Jakub Kicinski <kuba@kern
  	if (enable) {
  		sram_write(tp, 0x8045, 0);	/* 10M abiq&ldvbias */
  		sram_write(tp, 0x804d, 0x1222);	/* 100M short abiq&ldvbias */
-@@ -3143,11 +3158,7 @@ static void r8153b_green_en(struct r8152
+@@ -3141,11 +3156,7 @@ static void r8153b_green_en(struct r8152
  		sram_write(tp, 0x805d, 0x2444);	/* 1000M short abiq&ldvbias */
  	}
  
diff -uprN a/target/linux/generic/backport-5.10/790-v5.13-r8152-set-inter-fram-gap-time-depending-on-speed.patch b/target/linux/generic/backport-5.10/790-v5.13-r8152-set-inter-fram-gap-time-depending-on-speed.patch
--- a/target/linux/generic/backport-5.10/790-v5.13-r8152-set-inter-fram-gap-time-depending-on-speed.patch	2024-03-18 15:15:10.773419710 +0800
+++ b/target/linux/generic/backport-5.10/790-v5.13-r8152-set-inter-fram-gap-time-depending-on-speed.patch	2024-03-18 15:16:23.702637301 +0800
@@ -34,7 +34,7 @@ Signed-off-by: David S. Miller <davem@da
  
  /* PLA_MTPS */
  #define MTPS_JUMBO		(12 * 1024 / 64)
-@@ -2749,6 +2752,29 @@ static int rtl_stop_rx(struct r8152 *tp)
+@@ -2747,6 +2750,29 @@ static int rtl_stop_rx(struct r8152 *tp)
  	return 0;
  }
  
@@ -64,7 +64,7 @@ Signed-off-by: David S. Miller <davem@da
  static inline void r8153b_rx_agg_chg_indicate(struct r8152 *tp)
  {
  	ocp_write_byte(tp, MCU_TYPE_USB, USB_UPT_RXDMA_OWN,
-@@ -2852,6 +2878,8 @@ static int rtl8153_enable(struct r8152 *
+@@ -2850,6 +2876,8 @@ static int rtl8153_enable(struct r8152 *
  	r8153_set_rx_early_timeout(tp);
  	r8153_set_rx_early_size(tp);
  
diff -uprN a/target/linux/generic/backport-5.10/791-v5.13-r8152-adjust-rtl8152_check_firmware-function.patch b/target/linux/generic/backport-5.10/791-v5.13-r8152-adjust-rtl8152_check_firmware-function.patch
--- a/target/linux/generic/backport-5.10/791-v5.13-r8152-adjust-rtl8152_check_firmware-function.patch	2024-03-18 15:15:10.793418947 +0800
+++ b/target/linux/generic/backport-5.10/791-v5.13-r8152-adjust-rtl8152_check_firmware-function.patch	2024-03-18 15:16:23.710636995 +0800
@@ -30,7 +30,7 @@ Signed-off-by: David S. Miller <davem@da
  /**
   * struct fw_mac - a firmware block used by RTL_FW_PLA and RTL_FW_USB.
   *	The layout of the firmware block is:
-@@ -3802,10 +3810,7 @@ static long rtl8152_check_firmware(struc
+@@ -3800,10 +3808,7 @@ static long rtl8152_check_firmware(struc
  {
  	const struct firmware *fw = rtl_fw->fw;
  	struct fw_header *fw_hdr = (struct fw_header *)fw->data;
@@ -42,7 +42,7 @@ Signed-off-by: David S. Miller <davem@da
  	long ret = -EFAULT;
  	int i;
  
-@@ -3834,50 +3839,52 @@ static long rtl8152_check_firmware(struc
+@@ -3832,50 +3837,52 @@ static long rtl8152_check_firmware(struc
  				goto fail;
  			goto fw_end;
  		case RTL_FW_PLA:
@@ -106,7 +106,7 @@ Signed-off-by: David S. Miller <davem@da
  				dev_err(&tp->intf->dev,
  					"Check PHY_STOP fail\n");
  				goto fail;
-@@ -3888,28 +3895,28 @@ static long rtl8152_check_firmware(struc
+@@ -3886,28 +3893,28 @@ static long rtl8152_check_firmware(struc
  					"Invalid length for PHY_STOP\n");
  				goto fail;
  			}
@@ -141,7 +141,7 @@ Signed-off-by: David S. Miller <davem@da
  
  			break;
  		default:
-@@ -3923,7 +3930,7 @@ static long rtl8152_check_firmware(struc
+@@ -3921,7 +3928,7 @@ static long rtl8152_check_firmware(struc
  	}
  
  fw_end:
diff -uprN a/target/linux/generic/backport-5.10/792-v5.13-r8152-add-help-function-to-change-mtu.patch b/target/linux/generic/backport-5.10/792-v5.13-r8152-add-help-function-to-change-mtu.patch
--- a/target/linux/generic/backport-5.10/792-v5.13-r8152-add-help-function-to-change-mtu.patch	2024-03-18 15:15:10.789419098 +0800
+++ b/target/linux/generic/backport-5.10/792-v5.13-r8152-add-help-function-to-change-mtu.patch	2024-03-18 15:16:23.706637149 +0800
@@ -57,7 +57,7 @@ Signed-off-by: David S. Miller <davem@da
  
  static
  int get_registers(struct r8152 *tp, u16 value, u16 index, u16 size, void *data)
-@@ -2634,10 +2632,7 @@ static void rtl8152_nic_reset(struct r81
+@@ -2632,10 +2630,7 @@ static void rtl8152_nic_reset(struct r81
  
  static void set_tx_qlen(struct r8152 *tp)
  {
@@ -69,7 +69,7 @@ Signed-off-by: David S. Miller <davem@da
  }
  
  static inline u8 rtl8152_get_speed(struct r8152 *tp)
-@@ -4726,6 +4721,12 @@ static void r8153b_hw_phy_cfg(struct r81
+@@ -4724,6 +4719,12 @@ static void r8153b_hw_phy_cfg(struct r81
  	set_bit(PHY_RESET, &tp->flags);
  }
  
@@ -82,7 +82,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8153_first_init(struct r8152 *tp)
  {
  	u32 ocp_data;
-@@ -4758,9 +4759,7 @@ static void r8153_first_init(struct r815
+@@ -4756,9 +4757,7 @@ static void r8153_first_init(struct r815
  
  	rtl_rx_vlan_en(tp, tp->netdev->features & NETIF_F_HW_VLAN_CTAG_RX);
  
@@ -93,7 +93,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_TCR0);
  	ocp_data |= TCR0_AUTO_FIFO;
-@@ -4795,8 +4794,7 @@ static void r8153_enter_oob(struct r8152
+@@ -4793,8 +4792,7 @@ static void r8153_enter_oob(struct r8152
  
  	wait_oob_link_list_ready(tp);
  
@@ -103,7 +103,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	switch (tp->version) {
  	case RTL_VER_03:
-@@ -6497,12 +6495,21 @@ static int rtl8152_change_mtu(struct net
+@@ -6495,12 +6493,21 @@ static int rtl8152_change_mtu(struct net
  	dev->mtu = new_mtu;
  
  	if (netif_running(dev)) {
@@ -130,7 +130,7 @@ Signed-off-by: David S. Miller <davem@da
  	}
  
  	mutex_unlock(&tp->control);
-@@ -6591,6 +6598,7 @@ static int rtl_ops_init(struct r8152 *tp
+@@ -6589,6 +6596,7 @@ static int rtl_ops_init(struct r8152 *tp
  		ops->in_nway		= rtl8153_in_nway;
  		ops->hw_phy_cfg		= r8153_hw_phy_cfg;
  		ops->autosuspend_en	= rtl8153_runtime_enable;
@@ -138,7 +138,7 @@ Signed-off-by: David S. Miller <davem@da
  		if (tp->udev->speed < USB_SPEED_SUPER)
  			tp->rx_buf_sz	= 16 * 1024;
  		else
-@@ -6612,6 +6620,7 @@ static int rtl_ops_init(struct r8152 *tp
+@@ -6610,6 +6618,7 @@ static int rtl_ops_init(struct r8152 *tp
  		ops->in_nway		= rtl8153_in_nway;
  		ops->hw_phy_cfg		= r8153b_hw_phy_cfg;
  		ops->autosuspend_en	= rtl8153b_runtime_enable;
@@ -146,7 +146,7 @@ Signed-off-by: David S. Miller <davem@da
  		tp->rx_buf_sz		= 32 * 1024;
  		tp->eee_en		= true;
  		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
-@@ -6832,7 +6841,7 @@ static int rtl8152_probe(struct usb_inte
+@@ -6830,7 +6839,7 @@ static int rtl8152_probe(struct usb_inte
  		netdev->max_mtu = ETH_DATA_LEN;
  		break;
  	default:
diff -uprN a/target/linux/generic/backport-5.10/793-v5.13-r8152-support-new-chips.patch b/target/linux/generic/backport-5.10/793-v5.13-r8152-support-new-chips.patch
--- a/target/linux/generic/backport-5.10/793-v5.13-r8152-support-new-chips.patch	2024-03-18 15:15:10.725421540 +0800
+++ b/target/linux/generic/backport-5.10/793-v5.13-r8152-support-new-chips.patch	2024-03-18 15:16:23.674638369 +0800
@@ -379,7 +379,7 @@ Signed-off-by: David S. Miller <davem@da
  
  /* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
   * The RTL chips use a 64 element hash table based on the Ethernet CRC.
-@@ -2608,7 +2713,7 @@ static netdev_tx_t rtl8152_start_xmit(st
+@@ -2606,7 +2711,7 @@ static netdev_tx_t rtl8152_start_xmit(st
  
  static void r8152b_reset_packet_filter(struct r8152 *tp)
  {
@@ -388,7 +388,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_FMC);
  	ocp_data &= ~FMC_FCR_MCU_EN;
-@@ -2619,14 +2724,47 @@ static void r8152b_reset_packet_filter(s
+@@ -2617,14 +2722,47 @@ static void r8152b_reset_packet_filter(s
  
  static void rtl8152_nic_reset(struct r8152 *tp)
  {
@@ -442,7 +442,7 @@ Signed-off-by: David S. Miller <davem@da
  	}
  }
  
-@@ -2635,9 +2773,9 @@ static void set_tx_qlen(struct r8152 *tp
+@@ -2633,9 +2771,9 @@ static void set_tx_qlen(struct r8152 *tp
  	tp->tx_qlen = agg_buf_sz / (mtu_to_size(tp->netdev->mtu) + sizeof(struct tx_desc));
  }
  
@@ -454,7 +454,7 @@ Signed-off-by: David S. Miller <davem@da
  }
  
  static void rtl_eee_plus_en(struct r8152 *tp, bool enable)
-@@ -2797,6 +2935,7 @@ static int rtl_enable(struct r8152 *tp)
+@@ -2795,6 +2933,7 @@ static int rtl_enable(struct r8152 *tp)
  	switch (tp->version) {
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -462,7 +462,7 @@ Signed-off-by: David S. Miller <davem@da
  		r8153b_rx_agg_chg_indicate(tp);
  		break;
  	default:
-@@ -2834,6 +2973,7 @@ static void r8153_set_rx_early_timeout(s
+@@ -2832,6 +2971,7 @@ static void r8153_set_rx_early_timeout(s
  
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -470,7 +470,7 @@ Signed-off-by: David S. Miller <davem@da
  		/* The RTL8153B uses USB_RX_EXTRA_AGGR_TMR for rx timeout
  		 * primarily. For USB_RX_EARLY_TIMEOUT, we fix it to 128ns.
  		 */
-@@ -2843,6 +2983,18 @@ static void r8153_set_rx_early_timeout(s
+@@ -2841,6 +2981,18 @@ static void r8153_set_rx_early_timeout(s
  			       ocp_data);
  		break;
  
@@ -489,7 +489,7 @@ Signed-off-by: David S. Miller <davem@da
  	default:
  		break;
  	}
-@@ -2862,8 +3014,19 @@ static void r8153_set_rx_early_size(stru
+@@ -2860,8 +3012,19 @@ static void r8153_set_rx_early_size(stru
  		break;
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -509,7 +509,7 @@ Signed-off-by: David S. Miller <davem@da
  		break;
  	default:
  		WARN_ON_ONCE(1);
-@@ -2873,6 +3036,8 @@ static void r8153_set_rx_early_size(stru
+@@ -2871,6 +3034,8 @@ static void r8153_set_rx_early_size(stru
  
  static int rtl8153_enable(struct r8152 *tp)
  {
@@ -518,7 +518,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (test_bit(RTL8152_UNPLUG, &tp->flags))
  		return -ENODEV;
  
-@@ -2883,15 +3048,18 @@ static int rtl8153_enable(struct r8152 *
+@@ -2881,15 +3046,18 @@ static int rtl8153_enable(struct r8152 *
  
  	rtl_set_ifg(tp, rtl8152_get_speed(tp));
  
@@ -540,7 +540,7 @@ Signed-off-by: David S. Miller <davem@da
  	}
  
  	return rtl_enable(tp);
-@@ -2956,12 +3124,40 @@ static void rtl_rx_vlan_en(struct r8152
+@@ -2954,12 +3122,40 @@ static void rtl_rx_vlan_en(struct r8152
  {
  	u32 ocp_data;
  
@@ -587,7 +587,7 @@ Signed-off-by: David S. Miller <davem@da
  }
  
  static int rtl8152_set_features(struct net_device *dev,
-@@ -3054,6 +3250,40 @@ static void __rtl_set_wol(struct r8152 *
+@@ -3052,6 +3248,40 @@ static void __rtl_set_wol(struct r8152 *
  		device_set_wakeup_enable(&tp->udev->dev, false);
  }
  
@@ -628,7 +628,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8153_u1u2en(struct r8152 *tp, bool enable)
  {
  	u8 u1u2[8];
-@@ -3113,6 +3343,9 @@ static void r8153b_ups_flags(struct r815
+@@ -3111,6 +3341,9 @@ static void r8153b_ups_flags(struct r815
  	if (tp->ups_info.eee_cmod_lv)
  		ups_flags |= UPS_FLAGS_EEE_CMOD_LV_EN;
  
@@ -638,7 +638,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (tp->ups_info._10m_ckdiv)
  		ups_flags |= UPS_FLAGS_EN_10M_CKDIV;
  
-@@ -3163,6 +3396,88 @@ static void r8153b_ups_flags(struct r815
+@@ -3161,6 +3394,88 @@ static void r8153b_ups_flags(struct r815
  	ocp_write_dword(tp, MCU_TYPE_USB, USB_UPS_FLAGS, ups_flags);
  }
  
@@ -727,7 +727,7 @@ Signed-off-by: David S. Miller <davem@da
  static void rtl_green_en(struct r8152 *tp, bool enable)
  {
  	u16 data;
-@@ -3226,16 +3541,16 @@ static void r8153b_ups_en(struct r8152 *
+@@ -3224,16 +3539,16 @@ static void r8153b_ups_en(struct r8152 *
  		ocp_data |= UPS_EN | USP_PREWAKE | PHASE2_EN;
  		ocp_write_byte(tp, MCU_TYPE_USB, USB_POWER_CUT, ocp_data);
  
@@ -750,7 +750,7 @@ Signed-off-by: David S. Miller <davem@da
  
  		if (ocp_read_word(tp, MCU_TYPE_USB, USB_MISC_0) & PCUT_STATUS) {
  			int i;
-@@ -3255,6 +3570,95 @@ static void r8153b_ups_en(struct r8152 *
+@@ -3253,6 +3568,95 @@ static void r8153b_ups_en(struct r8152 *
  	}
  }
  
@@ -846,7 +846,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8153_power_cut_en(struct r8152 *tp, bool enable)
  {
  	u32 ocp_data;
-@@ -3384,6 +3788,38 @@ static void rtl8153b_runtime_enable(stru
+@@ -3382,6 +3786,38 @@ static void rtl8153b_runtime_enable(stru
  	}
  }
  
@@ -885,7 +885,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8153_teredo_off(struct r8152 *tp)
  {
  	u32 ocp_data;
-@@ -3404,14 +3840,19 @@ static void r8153_teredo_off(struct r815
+@@ -3402,14 +3838,19 @@ static void r8153_teredo_off(struct r815
  
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -908,7 +908,7 @@ Signed-off-by: David S. Miller <davem@da
  	}
  
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_WDT6_CTRL, WDT6_SET_MODE);
-@@ -3446,6 +3887,12 @@ static void rtl_clear_bp(struct r8152 *t
+@@ -3444,6 +3885,12 @@ static void rtl_clear_bp(struct r8152 *t
  		break;
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -921,7 +921,7 @@ Signed-off-by: David S. Miller <davem@da
  	default:
  		if (type == MCU_TYPE_USB) {
  			ocp_write_word(tp, MCU_TYPE_USB, USB_BP2_EN, 0);
-@@ -3655,6 +4102,11 @@ static bool rtl8152_is_fw_mac_ok(struct
+@@ -3653,6 +4100,11 @@ static bool rtl8152_is_fw_mac_ok(struct
  		case RTL_VER_06:
  		case RTL_VER_08:
  		case RTL_VER_09:
@@ -933,7 +933,7 @@ Signed-off-by: David S. Miller <davem@da
  			fw_reg = 0xf800;
  			bp_ba_addr = PLA_BP_BA;
  			bp_en_addr = PLA_BP_EN;
-@@ -3678,6 +4130,11 @@ static bool rtl8152_is_fw_mac_ok(struct
+@@ -3676,6 +4128,11 @@ static bool rtl8152_is_fw_mac_ok(struct
  			break;
  		case RTL_VER_08:
  		case RTL_VER_09:
@@ -945,7 +945,7 @@ Signed-off-by: David S. Miller <davem@da
  			fw_reg = 0xe600;
  			bp_ba_addr = USB_BP_BA;
  			bp_en_addr = USB_BP2_EN;
-@@ -4217,6 +4674,22 @@ static void r8153_eee_en(struct r8152 *t
+@@ -4215,6 +4672,22 @@ static void r8153_eee_en(struct r8152 *t
  	tp->ups_info.eee = enable;
  }
  
@@ -968,7 +968,7 @@ Signed-off-by: David S. Miller <davem@da
  static void rtl_eee_enable(struct r8152 *tp, bool enable)
  {
  	switch (tp->version) {
-@@ -4238,6 +4711,7 @@ static void rtl_eee_enable(struct r8152
+@@ -4236,6 +4709,7 @@ static void rtl_eee_enable(struct r8152
  	case RTL_VER_06:
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -976,7 +976,7 @@ Signed-off-by: David S. Miller <davem@da
  		if (enable) {
  			r8153_eee_en(tp, true);
  			ocp_reg_write(tp, OCP_EEE_ADV, tp->eee_adv);
-@@ -4246,6 +4720,19 @@ static void rtl_eee_enable(struct r8152
+@@ -4244,6 +4718,19 @@ static void rtl_eee_enable(struct r8152
  			ocp_reg_write(tp, OCP_EEE_ADV, 0);
  		}
  		break;
@@ -996,7 +996,7 @@ Signed-off-by: David S. Miller <davem@da
  	default:
  		break;
  	}
-@@ -4292,6 +4779,20 @@ static void wait_oob_link_list_ready(str
+@@ -4290,6 +4777,20 @@ static void wait_oob_link_list_ready(str
  	}
  }
  
@@ -1017,7 +1017,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8152b_exit_oob(struct r8152 *tp)
  {
  	u32 ocp_data;
-@@ -4342,7 +4843,7 @@ static void r8152b_exit_oob(struct r8152
+@@ -4340,7 +4841,7 @@ static void r8152b_exit_oob(struct r8152
  	}
  
  	/* TX share fifo free credit full threshold */
@@ -1026,7 +1026,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	ocp_write_byte(tp, MCU_TYPE_USB, USB_TX_AGG, TX_AGG_MAX_THRESHOLD);
  	ocp_write_dword(tp, MCU_TYPE_USB, USB_RX_BUF_TH, RX_THR_HIGH);
-@@ -4519,6 +5020,21 @@ static int r8153b_post_firmware_1(struct
+@@ -4517,6 +5018,21 @@ static int r8153b_post_firmware_1(struct
  	return 0;
  }
  
@@ -1048,7 +1048,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8153_aldps_en(struct r8152 *tp, bool enable)
  {
  	u16 data;
-@@ -4721,6 +5237,13 @@ static void r8153b_hw_phy_cfg(struct r81
+@@ -4719,6 +5235,13 @@ static void r8153b_hw_phy_cfg(struct r81
  	set_bit(PHY_RESET, &tp->flags);
  }
  
@@ -1062,7 +1062,7 @@ Signed-off-by: David S. Miller <davem@da
  static void rtl8153_change_mtu(struct r8152 *tp)
  {
  	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RMS, mtu_to_size(tp->netdev->mtu));
-@@ -4808,6 +5331,7 @@ static void r8153_enter_oob(struct r8152
+@@ -4806,6 +5329,7 @@ static void r8153_enter_oob(struct r8152
  
  	case RTL_VER_08:
  	case RTL_VER_09:
@@ -1070,7 +1070,7 @@ Signed-off-by: David S. Miller <davem@da
  		/* Clear teredo wake event. bit[15:8] is the teredo wakeup
  		 * type. Set it to zero. bits[7:0] are the W1C bits about
  		 * the events. Set them to all 1 to clear them.
-@@ -4844,6 +5368,96 @@ static void rtl8153_disable(struct r8152
+@@ -4842,6 +5366,96 @@ static void rtl8153_disable(struct r8152
  	r8153_aldps_en(tp, true);
  }
  
@@ -1167,7 +1167,7 @@ Signed-off-by: David S. Miller <davem@da
  static int rtl8152_set_speed(struct r8152 *tp, u8 autoneg, u32 speed, u8 duplex,
  			     u32 advertising)
  {
-@@ -4892,58 +5506,73 @@ static int rtl8152_set_speed(struct r815
+@@ -4890,58 +5504,73 @@ static int rtl8152_set_speed(struct r815
  
  		tp->mii.force_media = 1;
  	} else {
@@ -1259,7 +1259,7 @@ Signed-off-by: David S. Miller <davem@da
  		}
  
  		bmcr = BMCR_ANENABLE | BMCR_ANRESTART;
-@@ -5099,6 +5728,253 @@ static void rtl8153b_down(struct r8152 *
+@@ -5097,6 +5726,253 @@ static void rtl8153b_down(struct r8152 *
  	r8153_aldps_en(tp, true);
  }
  
@@ -1513,7 +1513,7 @@ Signed-off-by: David S. Miller <davem@da
  static bool rtl8152_in_nway(struct r8152 *tp)
  {
  	u16 nway_state;
-@@ -5129,7 +6005,7 @@ static void set_carrier(struct r8152 *tp
+@@ -5127,7 +6003,7 @@ static void set_carrier(struct r8152 *tp
  {
  	struct net_device *netdev = tp->netdev;
  	struct napi_struct *napi = &tp->napi;
@@ -1522,7 +1522,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	speed = rtl8152_get_speed(tp);
  
-@@ -5142,7 +6018,7 @@ static void set_carrier(struct r8152 *tp
+@@ -5140,7 +6016,7 @@ static void set_carrier(struct r8152 *tp
  			rtl_start_rx(tp);
  			clear_bit(RTL8152_SET_RX_MODE, &tp->flags);
  			_rtl8152_set_rx_mode(netdev);
@@ -1531,7 +1531,7 @@ Signed-off-by: David S. Miller <davem@da
  			netif_wake_queue(netdev);
  			netif_info(tp, link, netdev, "carrier on\n");
  		} else if (netif_queue_stopped(netdev) &&
-@@ -5504,14 +6380,9 @@ static void r8153_init(struct r8152 *tp)
+@@ -5502,14 +6378,9 @@ static void r8153_init(struct r8152 *tp)
  
  	ocp_write_word(tp, MCU_TYPE_USB, USB_CONNECT_TIMER, 0x0001);
  
@@ -1547,7 +1547,7 @@ Signed-off-by: David S. Miller <davem@da
  	r8153_u1u2en(tp, true);
  	usb_enable_lpm(tp->udev);
  
-@@ -5602,9 +6473,7 @@ static void r8153b_init(struct r8152 *tp
+@@ -5600,9 +6471,7 @@ static void r8153b_init(struct r8152 *tp
  	usb_enable_lpm(tp->udev);
  
  	/* MAC clock speed down */
@@ -1558,7 +1558,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	ocp_data = ocp_read_word(tp, MCU_TYPE_PLA, PLA_MAC_PWR_CTRL3);
  	ocp_data &= ~PLA_MCU_SPDWN_EN;
-@@ -5631,6 +6500,1069 @@ static void r8153b_init(struct r8152 *tp
+@@ -5629,6 +6498,1069 @@ static void r8153b_init(struct r8152 *tp
  	tp->coalesce = 15000;	/* 15 us */
  }
  
@@ -2628,7 +2628,7 @@ Signed-off-by: David S. Miller <davem@da
  static int rtl8152_pre_reset(struct usb_interface *intf)
  {
  	struct r8152 *tp = usb_get_intfdata(intf);
-@@ -5994,6 +7926,22 @@ int rtl8152_get_link_ksettings(struct ne
+@@ -5992,6 +7924,22 @@ int rtl8152_get_link_ksettings(struct ne
  
  	mii_ethtool_get_link_ksettings(&tp->mii, cmd);
  
@@ -2651,7 +2651,7 @@ Signed-off-by: David S. Miller <davem@da
  	mutex_unlock(&tp->control);
  
  	usb_autopm_put_interface(tp->intf);
-@@ -6037,6 +7985,10 @@ static int rtl8152_set_link_ksettings(st
+@@ -6035,6 +7983,10 @@ static int rtl8152_set_link_ksettings(st
  		     cmd->link_modes.advertising))
  		advertising |= RTL_ADVERTISED_1000_FULL;
  
@@ -2662,7 +2662,7 @@ Signed-off-by: David S. Miller <davem@da
  	mutex_lock(&tp->control);
  
  	ret = rtl8152_set_speed(tp, cmd->base.autoneg, cmd->base.speed,
-@@ -6626,6 +8578,67 @@ static int rtl_ops_init(struct r8152 *tp
+@@ -6624,6 +8576,67 @@ static int rtl_ops_init(struct r8152 *tp
  		tp->eee_adv		= MDIO_EEE_1000T | MDIO_EEE_100TX;
  		break;
  
@@ -2730,7 +2730,7 @@ Signed-off-by: David S. Miller <davem@da
  	default:
  		ret = -ENODEV;
  		dev_err(&tp->intf->dev, "Unknown Device\n");
-@@ -6639,11 +8652,13 @@ static int rtl_ops_init(struct r8152 *tp
+@@ -6637,11 +8650,13 @@ static int rtl_ops_init(struct r8152 *tp
  #define FIRMWARE_8153A_3	"rtl_nic/rtl8153a-3.fw"
  #define FIRMWARE_8153A_4	"rtl_nic/rtl8153a-4.fw"
  #define FIRMWARE_8153B_2	"rtl_nic/rtl8153b-2.fw"
@@ -2744,7 +2744,7 @@ Signed-off-by: David S. Miller <davem@da
  
  static int rtl_fw_init(struct r8152 *tp)
  {
-@@ -6669,6 +8684,11 @@ static int rtl_fw_init(struct r8152 *tp)
+@@ -6667,6 +8682,11 @@ static int rtl_fw_init(struct r8152 *tp)
  		rtl_fw->pre_fw		= r8153b_pre_firmware_1;
  		rtl_fw->post_fw		= r8153b_post_firmware_1;
  		break;
@@ -2756,7 +2756,7 @@ Signed-off-by: David S. Miller <davem@da
  	default:
  		break;
  	}
-@@ -6724,6 +8744,27 @@ u8 rtl8152_get_version(struct usb_interf
+@@ -6722,6 +8742,27 @@ u8 rtl8152_get_version(struct usb_interf
  	case 0x6010:
  		version = RTL_VER_09;
  		break;
@@ -2784,7 +2784,7 @@ Signed-off-by: David S. Miller <davem@da
  	default:
  		version = RTL_VER_UNKNOWN;
  		dev_info(&intf->dev, "Unknown version 0x%04x\n", ocp_data);
-@@ -6836,12 +8877,29 @@ static int rtl8152_probe(struct usb_inte
+@@ -6834,12 +8875,29 @@ static int rtl8152_probe(struct usb_inte
  	/* MTU range: 68 - 1500 or 9194 */
  	netdev->min_mtu = ETH_MIN_MTU;
  	switch (tp->version) {
@@ -2817,7 +2817,7 @@ Signed-off-by: David S. Miller <davem@da
  		break;
  	}
  
-@@ -6857,7 +8915,13 @@ static int rtl8152_probe(struct usb_inte
+@@ -6855,7 +8913,13 @@ static int rtl8152_probe(struct usb_inte
  	tp->advertising = RTL_ADVERTISED_10_HALF | RTL_ADVERTISED_10_FULL |
  			  RTL_ADVERTISED_100_HALF | RTL_ADVERTISED_100_FULL;
  	if (tp->mii.supports_gmii) {
@@ -2832,7 +2832,7 @@ Signed-off-by: David S. Miller <davem@da
  		tp->advertising |= RTL_ADVERTISED_1000_FULL;
  	}
  	tp->duplex = DUPLEX_FULL;
-@@ -6881,7 +8945,11 @@ static int rtl8152_probe(struct usb_inte
+@@ -6879,7 +8943,11 @@ static int rtl8152_probe(struct usb_inte
  	set_ethernet_addr(tp);
  
  	usb_set_intfdata(intf, tp);
@@ -2845,7 +2845,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	ret = register_netdev(netdev);
  	if (ret != 0) {
-@@ -6917,7 +8985,8 @@ static void rtl8152_disconnect(struct us
+@@ -6915,7 +8983,8 @@ static void rtl8152_disconnect(struct us
  		unregister_netdev(tp->netdev);
  		tasklet_kill(&tp->tx_tl);
  		cancel_delayed_work_sync(&tp->hw_phy_work);
@@ -2855,7 +2855,7 @@ Signed-off-by: David S. Miller <davem@da
  		rtl8152_release_firmware(tp);
  		free_netdev(tp->netdev);
  	}
-@@ -6937,13 +9006,28 @@ static void rtl8152_disconnect(struct us
+@@ -6935,13 +9004,28 @@ static void rtl8152_disconnect(struct us
  	.idProduct = (prod), \
  	.bInterfaceClass = USB_CLASS_COMM, \
  	.bInterfaceSubClass = USB_CDC_SUBCLASS_ETHERNET, \
diff -uprN a/target/linux/generic/backport-5.10/794-v5.13-r8152-support-PHY-firmware-for-RTL8156-series.patch b/target/linux/generic/backport-5.10/794-v5.13-r8152-support-PHY-firmware-for-RTL8156-series.patch
--- a/target/linux/generic/backport-5.10/794-v5.13-r8152-support-PHY-firmware-for-RTL8156-series.patch	2024-03-18 15:15:10.789419098 +0800
+++ b/target/linux/generic/backport-5.10/794-v5.13-r8152-support-PHY-firmware-for-RTL8156-series.patch	2024-03-18 15:16:23.706637149 +0800
@@ -92,7 +92,7 @@ Signed-off-by: David S. Miller <davem@da
  };
  
  enum rtl_version {
-@@ -4001,6 +4062,162 @@ static int rtl_post_ram_code(struct r815
+@@ -3999,6 +4060,162 @@ static int rtl_post_ram_code(struct r815
  	return 0;
  }
  
@@ -255,7 +255,7 @@ Signed-off-by: David S. Miller <davem@da
  static bool rtl8152_is_fw_phy_nc_ok(struct r8152 *tp, struct fw_phy_nc *phy)
  {
  	u32 length;
-@@ -4321,6 +4538,10 @@ static long rtl8152_check_firmware(struc
+@@ -4319,6 +4536,10 @@ static long rtl8152_check_firmware(struc
  		case RTL_FW_PHY_START:
  			if (test_bit(FW_FLAGS_START, &fw_flags) ||
  			    test_bit(FW_FLAGS_NC, &fw_flags) ||
@@ -266,7 +266,7 @@ Signed-off-by: David S. Miller <davem@da
  			    test_bit(FW_FLAGS_STOP, &fw_flags)) {
  				dev_err(&tp->intf->dev,
  					"check PHY_START fail\n");
-@@ -4369,7 +4590,153 @@ static long rtl8152_check_firmware(struc
+@@ -4367,7 +4588,153 @@ static long rtl8152_check_firmware(struc
  				goto fail;
  			}
  			__set_bit(FW_FLAGS_NC, &fw_flags);
@@ -420,7 +420,7 @@ Signed-off-by: David S. Miller <davem@da
  			break;
  		default:
  			dev_warn(&tp->intf->dev, "Unknown type %u is found\n",
-@@ -4392,6 +4759,143 @@ fail:
+@@ -4390,6 +4757,143 @@ fail:
  	return ret;
  }
  
@@ -564,7 +564,7 @@ Signed-off-by: David S. Miller <davem@da
  static void rtl8152_fw_phy_nc_apply(struct r8152 *tp, struct fw_phy_nc *phy)
  {
  	u16 mode_reg, bp_index;
-@@ -4445,6 +4949,12 @@ static void rtl8152_fw_mac_apply(struct
+@@ -4443,6 +4947,12 @@ static void rtl8152_fw_mac_apply(struct
  		return;
  	}
  
@@ -577,7 +577,7 @@ Signed-off-by: David S. Miller <davem@da
  	rtl_clear_bp(tp, type);
  
  	/* Enable backup/restore of MACDBG. This is required after clearing PLA
-@@ -4480,7 +4990,6 @@ static void rtl8152_fw_mac_apply(struct
+@@ -4478,7 +4988,6 @@ static void rtl8152_fw_mac_apply(struct
  		ocp_write_word(tp, type, bp_en_addr,
  			       __le16_to_cpu(mac->bp_en_value));
  
@@ -585,7 +585,7 @@ Signed-off-by: David S. Miller <davem@da
  	if (fw_ver_reg)
  		ocp_write_byte(tp, MCU_TYPE_USB, fw_ver_reg,
  			       mac->fw_ver_data);
-@@ -4495,7 +5004,7 @@ static void rtl8152_apply_firmware(struc
+@@ -4493,7 +5002,7 @@ static void rtl8152_apply_firmware(struc
  	struct fw_header *fw_hdr;
  	struct fw_phy_patch_key *key;
  	u16 key_addr = 0;
@@ -594,7 +594,7 @@ Signed-off-by: David S. Miller <davem@da
  
  	if (IS_ERR_OR_NULL(rtl_fw->fw))
  		return;
-@@ -4517,17 +5026,40 @@ static void rtl8152_apply_firmware(struc
+@@ -4515,17 +5024,40 @@ static void rtl8152_apply_firmware(struc
  			rtl8152_fw_mac_apply(tp, (struct fw_mac *)block);
  			break;
  		case RTL_FW_PHY_START:
@@ -635,7 +635,7 @@ Signed-off-by: David S. Miller <davem@da
  		default:
  			break;
  		}
-@@ -5035,6 +5567,21 @@ static int r8153c_post_firmware_1(struct
+@@ -5033,6 +5565,21 @@ static int r8153c_post_firmware_1(struct
  	return 0;
  }
  
@@ -657,7 +657,7 @@ Signed-off-by: David S. Miller <davem@da
  static void r8153_aldps_en(struct r8152 *tp, bool enable)
  {
  	u16 data;
-@@ -8653,12 +9200,16 @@ static int rtl_ops_init(struct r8152 *tp
+@@ -8651,12 +9198,16 @@ static int rtl_ops_init(struct r8152 *tp
  #define FIRMWARE_8153A_4	"rtl_nic/rtl8153a-4.fw"
  #define FIRMWARE_8153B_2	"rtl_nic/rtl8153b-2.fw"
  #define FIRMWARE_8153C_1	"rtl_nic/rtl8153c-1.fw"
@@ -674,7 +674,7 @@ Signed-off-by: David S. Miller <davem@da
  
  static int rtl_fw_init(struct r8152 *tp)
  {
-@@ -8684,6 +9235,14 @@ static int rtl_fw_init(struct r8152 *tp)
+@@ -8682,6 +9233,14 @@ static int rtl_fw_init(struct r8152 *tp)
  		rtl_fw->pre_fw		= r8153b_pre_firmware_1;
  		rtl_fw->post_fw		= r8153b_post_firmware_1;
  		break;
diff -uprN a/target/linux/generic/backport-5.10/795-v5.13-r8152-search-the-configuration-of-vendor-mode.patch b/target/linux/generic/backport-5.10/795-v5.13-r8152-search-the-configuration-of-vendor-mode.patch
--- a/target/linux/generic/backport-5.10/795-v5.13-r8152-search-the-configuration-of-vendor-mode.patch	2024-03-18 15:15:10.705422304 +0800
+++ b/target/linux/generic/backport-5.10/795-v5.13-r8152-search-the-configuration-of-vendor-mode.patch	2024-03-18 15:16:23.662638827 +0800
@@ -25,7 +25,7 @@ Signed-off-by: David S. Miller <davem@da
  
  /* Information for net */
  #define NET_VERSION		"11"
-@@ -8110,6 +8110,39 @@ static void r8156b_init(struct r8152 *tp
+@@ -8108,6 +8108,39 @@ static void r8156b_init(struct r8152 *tp
  	tp->coalesce = 15000;	/* 15 us */
  }
  
@@ -65,7 +65,7 @@ Signed-off-by: David S. Miller <davem@da
  static int rtl8152_pre_reset(struct usb_interface *intf)
  {
  	struct r8152 *tp = usb_get_intfdata(intf);
-@@ -9348,10 +9381,8 @@ static int rtl8152_probe(struct usb_inte
+@@ -9346,10 +9379,8 @@ static int rtl8152_probe(struct usb_inte
  	if (version == RTL_VER_UNKNOWN)
  		return -ENODEV;
  
diff -uprN a/target/linux/generic/backport-5.10/796-v5.14-net-phy-realtek-add-dt-property-to-disable-CLKOUT-cl.patch b/target/linux/generic/backport-5.10/796-v5.14-net-phy-realtek-add-dt-property-to-disable-CLKOUT-cl.patch
--- a/target/linux/generic/backport-5.10/796-v5.14-net-phy-realtek-add-dt-property-to-disable-CLKOUT-cl.patch	2024-03-18 15:15:10.741420930 +0800
+++ b/target/linux/generic/backport-5.10/796-v5.14-net-phy-realtek-add-dt-property-to-disable-CLKOUT-cl.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,119 +0,0 @@
-From 0a4355c2b7f8ecd5e61cc262ecdbd4a2cce1ea7e Mon Sep 17 00:00:00 2001
-From: Joakim Zhang <qiangqing.zhang@nxp.com>
-Date: Tue, 8 Jun 2021 11:15:33 +0800
-Subject: [PATCH] net: phy: realtek: add dt property to disable CLKOUT clock
-
-CLKOUT is enabled by default after PHY hardware reset, this patch adds
-"realtek,clkout-disable" property for user to disable CLKOUT clock
-to save PHY power.
-
-Per RTL8211F guide, a PHY reset should be issued after setting these
-bits in PHYCR2 register. After this patch, CLKOUT clock output to be
-disabled.
-
-Signed-off-by: Joakim Zhang <qiangqing.zhang@nxp.com>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/phy/realtek.c | 42 ++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 41 insertions(+), 1 deletion(-)
-
---- a/drivers/net/phy/realtek.c
-+++ b/drivers/net/phy/realtek.c
-@@ -8,6 +8,7 @@
-  * Copyright (c) 2004 Freescale Semiconductor, Inc.
-  */
- #include <linux/bitops.h>
-+#include <linux/of.h>
- #include <linux/phy.h>
- #include <linux/module.h>
- #include <linux/delay.h>
-@@ -27,6 +28,7 @@
- #define RTL821x_PAGE_SELECT			0x1f
- 
- #define RTL8211F_PHYCR1				0x18
-+#define RTL8211F_PHYCR2				0x19
- #define RTL8211F_INSR				0x1d
- 
- #define RTL8211F_TX_DELAY			BIT(8)
-@@ -40,6 +42,8 @@
- #define RTL8211E_TX_DELAY			BIT(12)
- #define RTL8211E_RX_DELAY			BIT(11)
- 
-+#define RTL8211F_CLKOUT_EN			BIT(0)
-+
- #define RTL8201F_ISR				0x1e
- #define RTL8201F_IER				0x13
- 
-@@ -62,6 +66,10 @@ MODULE_DESCRIPTION("Realtek PHY driver")
- MODULE_AUTHOR("Johnson Leung");
- MODULE_LICENSE("GPL");
- 
-+struct rtl821x_priv {
-+	u16 phycr2;
-+};
-+
- static int rtl821x_read_page(struct phy_device *phydev)
- {
- 	return __phy_read(phydev, RTL821x_PAGE_SELECT);
-@@ -72,6 +80,28 @@ static int rtl821x_write_page(struct phy
- 	return __phy_write(phydev, RTL821x_PAGE_SELECT, page);
- }
- 
-+static int rtl821x_probe(struct phy_device *phydev)
-+{
-+	struct device *dev = &phydev->mdio.dev;
-+	struct rtl821x_priv *priv;
-+
-+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-+	if (!priv)
-+		return -ENOMEM;
-+
-+	priv->phycr2 = phy_read_paged(phydev, 0xa43, RTL8211F_PHYCR2);
-+	if (priv->phycr2 < 0)
-+		return priv->phycr2;
-+
-+	priv->phycr2 &= RTL8211F_CLKOUT_EN;
-+	if (of_property_read_bool(dev->of_node, "realtek,clkout-disable"))
-+		priv->phycr2 &= ~RTL8211F_CLKOUT_EN;
-+
-+	phydev->priv = priv;
-+
-+	return 0;
-+}
-+
- static int rtl8201_ack_interrupt(struct phy_device *phydev)
- {
- 	int err;
-@@ -180,6 +210,7 @@ static int rtl8211c_config_init(struct p
- 
- static int rtl8211f_config_init(struct phy_device *phydev)
- {
-+	struct rtl821x_priv *priv = phydev->priv;
- 	struct device *dev = &phydev->mdio.dev;
- 	u16 val_txdly, val_rxdly;
- 	u16 val;
-@@ -243,7 +274,15 @@ static int rtl8211f_config_init(struct p
- 			val_rxdly ? "enabled" : "disabled");
- 	}
- 
--	return 0;
-+	ret = phy_modify_paged(phydev, 0xa43, RTL8211F_PHYCR2,
-+			       RTL8211F_CLKOUT_EN, priv->phycr2);
-+	if (ret < 0) {
-+		dev_err(dev, "clkout configuration failed: %pe\n",
-+			ERR_PTR(ret));
-+		return ret;
-+	}
-+
-+	return genphy_soft_reset(phydev);
- }
- 
- static int rtl821x_resume(struct phy_device *phydev)
-@@ -633,6 +672,7 @@ static struct phy_driver realtek_drvs[]
- 	}, {
- 		PHY_ID_MATCH_EXACT(0x001cc916),
- 		.name		= "RTL8211F Gigabit Ethernet",
-+		.probe		= rtl821x_probe,
- 		.config_init	= &rtl8211f_config_init,
- 		.ack_interrupt	= &rtl8211f_ack_interrupt,
- 		.config_intr	= &rtl8211f_config_intr,
diff -uprN a/target/linux/generic/backport-5.10/797-v5.17-net-usb-ax88179_178a-add-TSO-feature.patch b/target/linux/generic/backport-5.10/797-v5.17-net-usb-ax88179_178a-add-TSO-feature.patch
--- a/target/linux/generic/backport-5.10/797-v5.17-net-usb-ax88179_178a-add-TSO-feature.patch	2024-03-18 15:15:10.701422456 +0800
+++ b/target/linux/generic/backport-5.10/797-v5.17-net-usb-ax88179_178a-add-TSO-feature.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,68 +0,0 @@
-From 16b1c4e01c89ba07367461e0bc4cb84993c2d027 Mon Sep 17 00:00:00 2001
-From: Jacky Chou <jackychou@asix.com.tw>
-Date: Mon, 15 Nov 2021 11:49:41 +0800
-Subject: [PATCH] net: usb: ax88179_178a: add TSO feature
-
-On low-effciency embedded platforms, transmission performance is poor
-due to on Bulk-out with single packet.
-Adding TSO feature improves the transmission performance and reduces
-the number of interrupt caused by Bulk-out complete.
-
-Reference to module, net: usb: aqc111.
-
-Signed-off-by: Jacky Chou <jackychou@asix.com.tw>
-Signed-off-by: David S. Miller <davem@davemloft.net>
----
- drivers/net/usb/ax88179_178a.c | 17 +++++++++++------
- 1 file changed, 11 insertions(+), 6 deletions(-)
-
---- a/drivers/net/usb/ax88179_178a.c
-+++ b/drivers/net/usb/ax88179_178a.c
-@@ -1377,11 +1377,12 @@ static int ax88179_bind(struct usbnet *d
- 	dev->mii.phy_id = 0x03;
- 	dev->mii.supports_gmii = 1;
- 
--	dev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
--			      NETIF_F_RXCSUM;
-+	dev->net->features |= NETIF_F_SG | NETIF_F_IP_CSUM |
-+			      NETIF_F_IPV6_CSUM | NETIF_F_RXCSUM | NETIF_F_TSO;
- 
--	dev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
--				 NETIF_F_RXCSUM;
-+	dev->net->hw_features |= dev->net->features;
-+
-+	netif_set_gso_max_size(dev->net, 16384);
- 
- 	/* Enable checksum offload */
- 	*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
-@@ -1587,17 +1588,19 @@ ax88179_tx_fixup(struct usbnet *dev, str
- {
- 	u32 tx_hdr1, tx_hdr2;
- 	int frame_size = dev->maxpacket;
--	int mss = skb_shinfo(skb)->gso_size;
- 	int headroom;
- 	void *ptr;
- 
- 	tx_hdr1 = skb->len;
--	tx_hdr2 = mss;
-+	tx_hdr2 = skb_shinfo(skb)->gso_size; /* Set TSO mss */
- 	if (((skb->len + 8) % frame_size) == 0)
- 		tx_hdr2 |= 0x80008000;	/* Enable padding */
- 
- 	headroom = skb_headroom(skb) - 8;
- 
-+	if ((dev->net->features & NETIF_F_SG) && skb_linearize(skb))
-+		return NULL;
-+
- 	if ((skb_header_cloned(skb) || headroom < 0) &&
- 	    pskb_expand_head(skb, headroom < 0 ? 8 : 0, 0, GFP_ATOMIC)) {
- 		dev_kfree_skb_any(skb);
-@@ -1608,6 +1611,8 @@ ax88179_tx_fixup(struct usbnet *dev, str
- 	put_unaligned_le32(tx_hdr1, ptr);
- 	put_unaligned_le32(tx_hdr2, ptr + 4);
- 
-+	usbnet_set_skb_tx_stats(skb, (skb_shinfo(skb)->gso_segs ?: 1), 0);
-+
- 	return skb;
- }
- 
diff -uprN a/target/linux/generic/backport-5.10/801-v6.1-nvmem-add-driver-handling-U-Boot-environment-variabl.patch b/target/linux/generic/backport-5.10/801-v6.1-nvmem-add-driver-handling-U-Boot-environment-variabl.patch
--- a/target/linux/generic/backport-5.10/801-v6.1-nvmem-add-driver-handling-U-Boot-environment-variabl.patch	2024-03-18 15:15:10.777419557 +0800
+++ b/target/linux/generic/backport-5.10/801-v6.1-nvmem-add-driver-handling-U-Boot-environment-variabl.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,278 +0,0 @@
-From f955dc14450695564926711cf9fa8e1d5d854302 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Wed, 15 Jun 2022 21:43:00 +0200
-Subject: [PATCH] nvmem: add driver handling U-Boot environment variables
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-U-Boot stores its setup as environment variables. It's a list of
-key-value pairs stored on flash device with a custom header.
-
-This commit adds an NVMEM driver that:
-1. Provides NVMEM access to environment vars binary data
-2. Extracts variables as NVMEM cells
-
-Current Linux's NVMEM sysfs API allows reading whole NVMEM data block.
-It can be used by user-space tools for reading U-Boot env vars block
-without the hassle of finding its location. Parsing will still need to
-be re-done there.
-
-Kernel-parsed NVMEM cells can be read however by Linux drivers. This may
-be useful for Ethernet drivers for reading device MAC address which is
-often stored as U-Boot env variable.
-
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
-Reviewed-by: Ahmad Fatoum <a.fatoum@pengutronix.de>
-Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
----
-
---- a/drivers/nvmem/Kconfig
-+++ b/drivers/nvmem/Kconfig
-@@ -270,4 +270,17 @@ config SPRD_EFUSE
- 	  This driver can also be built as a module. If so, the module
- 	  will be called nvmem-sprd-efuse.
- 
-+config NVMEM_U_BOOT_ENV
-+	tristate "U-Boot environment variables support"
-+	depends on OF && MTD
-+	select CRC32
-+	help
-+	  U-Boot stores its setup as environment variables. This driver adds
-+	  support for verifying & exporting such data. It also exposes variables
-+	  as NVMEM cells so they can be referenced by other drivers.
-+
-+	  Currently this drivers works only with env variables on top of MTD.
-+
-+	  If compiled as module it will be called nvmem_u-boot-env.
-+
- endif
---- a/drivers/nvmem/Makefile
-+++ b/drivers/nvmem/Makefile
-@@ -55,3 +55,5 @@ obj-$(CONFIG_NVMEM_ZYNQMP)	+= nvmem_zynq
- nvmem_zynqmp_nvmem-y		:= zynqmp_nvmem.o
- obj-$(CONFIG_SPRD_EFUSE)	+= nvmem_sprd_efuse.o
- nvmem_sprd_efuse-y		:= sprd-efuse.o
-+obj-$(CONFIG_NVMEM_U_BOOT_ENV)	+= nvmem_u-boot-env.o
-+nvmem_u-boot-env-y		:= u-boot-env.o
---- /dev/null
-+++ b/drivers/nvmem/u-boot-env.c
-@@ -0,0 +1,218 @@
-+// SPDX-License-Identifier: GPL-2.0-only
-+/*
-+ * Copyright (C) 2022 Rafał Miłecki <rafal@milecki.pl>
-+ */
-+
-+#include <linux/crc32.h>
-+#include <linux/mod_devicetable.h>
-+#include <linux/module.h>
-+#include <linux/mtd/mtd.h>
-+#include <linux/nvmem-consumer.h>
-+#include <linux/nvmem-provider.h>
-+#include <linux/of_device.h>
-+#include <linux/platform_device.h>
-+#include <linux/slab.h>
-+
-+enum u_boot_env_format {
-+	U_BOOT_FORMAT_SINGLE,
-+	U_BOOT_FORMAT_REDUNDANT,
-+};
-+
-+struct u_boot_env {
-+	struct device *dev;
-+	enum u_boot_env_format format;
-+
-+	struct mtd_info *mtd;
-+
-+	/* Cells */
-+	struct nvmem_cell_info *cells;
-+	int ncells;
-+};
-+
-+struct u_boot_env_image_single {
-+	__le32 crc32;
-+	uint8_t data[];
-+} __packed;
-+
-+struct u_boot_env_image_redundant {
-+	__le32 crc32;
-+	u8 mark;
-+	uint8_t data[];
-+} __packed;
-+
-+static int u_boot_env_read(void *context, unsigned int offset, void *val,
-+			   size_t bytes)
-+{
-+	struct u_boot_env *priv = context;
-+	struct device *dev = priv->dev;
-+	size_t bytes_read;
-+	int err;
-+
-+	err = mtd_read(priv->mtd, offset, bytes, &bytes_read, val);
-+	if (err && !mtd_is_bitflip(err)) {
-+		dev_err(dev, "Failed to read from mtd: %d\n", err);
-+		return err;
-+	}
-+
-+	if (bytes_read != bytes) {
-+		dev_err(dev, "Failed to read %zu bytes\n", bytes);
-+		return -EIO;
-+	}
-+
-+	return 0;
-+}
-+
-+static int u_boot_env_add_cells(struct u_boot_env *priv, uint8_t *buf,
-+				size_t data_offset, size_t data_len)
-+{
-+	struct device *dev = priv->dev;
-+	char *data = buf + data_offset;
-+	char *var, *value, *eq;
-+	int idx;
-+
-+	priv->ncells = 0;
-+	for (var = data; var < data + data_len && *var; var += strlen(var) + 1)
-+		priv->ncells++;
-+
-+	priv->cells = devm_kcalloc(dev, priv->ncells, sizeof(*priv->cells), GFP_KERNEL);
-+	if (!priv->cells)
-+		return -ENOMEM;
-+
-+	for (var = data, idx = 0;
-+	     var < data + data_len && *var;
-+	     var = value + strlen(value) + 1, idx++) {
-+		eq = strchr(var, '=');
-+		if (!eq)
-+			break;
-+		*eq = '\0';
-+		value = eq + 1;
-+
-+		priv->cells[idx].name = devm_kstrdup(dev, var, GFP_KERNEL);
-+		if (!priv->cells[idx].name)
-+			return -ENOMEM;
-+		priv->cells[idx].offset = data_offset + value - data;
-+		priv->cells[idx].bytes = strlen(value);
-+	}
-+
-+	if (WARN_ON(idx != priv->ncells))
-+		priv->ncells = idx;
-+
-+	return 0;
-+}
-+
-+static int u_boot_env_parse(struct u_boot_env *priv)
-+{
-+	struct device *dev = priv->dev;
-+	size_t crc32_data_offset;
-+	size_t crc32_data_len;
-+	size_t crc32_offset;
-+	size_t data_offset;
-+	size_t data_len;
-+	uint32_t crc32;
-+	uint32_t calc;
-+	size_t bytes;
-+	uint8_t *buf;
-+	int err;
-+
-+	buf = kcalloc(1, priv->mtd->size, GFP_KERNEL);
-+	if (!buf) {
-+		err = -ENOMEM;
-+		goto err_out;
-+	}
-+
-+	err = mtd_read(priv->mtd, 0, priv->mtd->size, &bytes, buf);
-+	if ((err && !mtd_is_bitflip(err)) || bytes != priv->mtd->size) {
-+		dev_err(dev, "Failed to read from mtd: %d\n", err);
-+		goto err_kfree;
-+	}
-+
-+	switch (priv->format) {
-+	case U_BOOT_FORMAT_SINGLE:
-+		crc32_offset = offsetof(struct u_boot_env_image_single, crc32);
-+		crc32_data_offset = offsetof(struct u_boot_env_image_single, data);
-+		data_offset = offsetof(struct u_boot_env_image_single, data);
-+		break;
-+	case U_BOOT_FORMAT_REDUNDANT:
-+		crc32_offset = offsetof(struct u_boot_env_image_redundant, crc32);
-+		crc32_data_offset = offsetof(struct u_boot_env_image_redundant, mark);
-+		data_offset = offsetof(struct u_boot_env_image_redundant, data);
-+		break;
-+	}
-+	crc32 = le32_to_cpu(*(uint32_t *)(buf + crc32_offset));
-+	crc32_data_len = priv->mtd->size - crc32_data_offset;
-+	data_len = priv->mtd->size - data_offset;
-+
-+	calc = crc32(~0, buf + crc32_data_offset, crc32_data_len) ^ ~0L;
-+	if (calc != crc32) {
-+		dev_err(dev, "Invalid calculated CRC32: 0x%08x (expected: 0x%08x)\n", calc, crc32);
-+		err = -EINVAL;
-+		goto err_kfree;
-+	}
-+
-+	buf[priv->mtd->size - 1] = '\0';
-+	err = u_boot_env_add_cells(priv, buf, data_offset, data_len);
-+	if (err)
-+		dev_err(dev, "Failed to add cells: %d\n", err);
-+
-+err_kfree:
-+	kfree(buf);
-+err_out:
-+	return err;
-+}
-+
-+static int u_boot_env_probe(struct platform_device *pdev)
-+{
-+	struct nvmem_config config = {
-+		.name = "u-boot-env",
-+		.reg_read = u_boot_env_read,
-+	};
-+	struct device *dev = &pdev->dev;
-+	struct device_node *np = dev->of_node;
-+	struct u_boot_env *priv;
-+	int err;
-+
-+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
-+	if (!priv)
-+		return -ENOMEM;
-+	priv->dev = dev;
-+
-+	priv->format = (uintptr_t)of_device_get_match_data(dev);
-+
-+	priv->mtd = of_get_mtd_device_by_node(np);
-+	if (IS_ERR(priv->mtd)) {
-+		dev_err_probe(dev, PTR_ERR(priv->mtd), "Failed to get %pOF MTD\n", np);
-+		return PTR_ERR(priv->mtd);
-+	}
-+
-+	err = u_boot_env_parse(priv);
-+	if (err)
-+		return err;
-+
-+	config.dev = dev;
-+	config.cells = priv->cells;
-+	config.ncells = priv->ncells;
-+	config.priv = priv;
-+	config.size = priv->mtd->size;
-+
-+	return PTR_ERR_OR_ZERO(devm_nvmem_register(dev, &config));
-+}
-+
-+static const struct of_device_id u_boot_env_of_match_table[] = {
-+	{ .compatible = "u-boot,env", .data = (void *)U_BOOT_FORMAT_SINGLE, },
-+	{ .compatible = "u-boot,env-redundant-bool", .data = (void *)U_BOOT_FORMAT_REDUNDANT, },
-+	{ .compatible = "u-boot,env-redundant-count", .data = (void *)U_BOOT_FORMAT_REDUNDANT, },
-+	{},
-+};
-+
-+static struct platform_driver u_boot_env_driver = {
-+	.probe = u_boot_env_probe,
-+	.driver = {
-+		.name = "u_boot_env",
-+		.of_match_table = u_boot_env_of_match_table,
-+	},
-+};
-+module_platform_driver(u_boot_env_driver);
-+
-+MODULE_AUTHOR("Rafał Miłecki");
-+MODULE_LICENSE("GPL");
-+MODULE_DEVICE_TABLE(of, u_boot_env_of_match_table);
diff -uprN a/target/linux/generic/backport-5.10/802-v5.19-nvmem-core-support-passing-DT-node-in-cell-info.patch b/target/linux/generic/backport-5.10/802-v5.19-nvmem-core-support-passing-DT-node-in-cell-info.patch
--- a/target/linux/generic/backport-5.10/802-v5.19-nvmem-core-support-passing-DT-node-in-cell-info.patch	2024-03-18 15:15:10.781419404 +0800
+++ b/target/linux/generic/backport-5.10/802-v5.19-nvmem-core-support-passing-DT-node-in-cell-info.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,41 +0,0 @@
-From dbc2f62061c6bfba0aee93161ee3194dcee84bd0 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Fri, 29 Apr 2022 17:26:46 +0100
-Subject: [PATCH] nvmem: core: support passing DT node in cell info
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Some hardware may have NVMEM cells described in Device Tree using
-individual nodes. Let drivers pass such nodes to the NVMEM subsystem so
-they can be later used by NVMEM consumers.
-
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
-Signed-off-by: Srinivas Kandagatla <srinivas.kandagatla@linaro.org>
-Link: https://lore.kernel.org/r/20220429162701.2222-2-srinivas.kandagatla@linaro.org
-Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
----
- drivers/nvmem/core.c           | 1 +
- include/linux/nvmem-consumer.h | 1 +
- 2 files changed, 2 insertions(+)
-
---- a/drivers/nvmem/core.c
-+++ b/drivers/nvmem/core.c
-@@ -374,6 +374,7 @@ static int nvmem_cell_info_to_nvmem_cell
- 
- 	cell->bit_offset = info->bit_offset;
- 	cell->nbits = info->nbits;
-+	cell->np = info->np;
- 
- 	if (cell->nbits)
- 		cell->bytes = DIV_ROUND_UP(cell->nbits + cell->bit_offset,
---- a/include/linux/nvmem-consumer.h
-+++ b/include/linux/nvmem-consumer.h
-@@ -25,6 +25,7 @@ struct nvmem_cell_info {
- 	unsigned int		bytes;
- 	unsigned int		bit_offset;
- 	unsigned int		nbits;
-+	struct device_node	*np;
- };
- 
- /**
diff -uprN a/target/linux/generic/backport-5.10/821-v5.13-let-pci-host-bridges-declar-their-reliance-on-msi-domains.patch b/target/linux/generic/backport-5.10/821-v5.13-let-pci-host-bridges-declar-their-reliance-on-msi-domains.patch
--- a/target/linux/generic/backport-5.10/821-v5.13-let-pci-host-bridges-declar-their-reliance-on-msi-domains.patch	2024-03-18 15:15:10.697422608 +0800
+++ b/target/linux/generic/backport-5.10/821-v5.13-let-pci-host-bridges-declar-their-reliance-on-msi-domains.patch	2024-03-18 15:16:23.662638827 +0800
@@ -34,7 +34,7 @@ Acked-by: Bjorn Helgaas <bhelgaas@google
  		set_dev_node(bus->bridge, pcibus_to_node(bus));
 --- a/include/linux/pci.h
 +++ b/include/linux/pci.h
-@@ -548,6 +548,7 @@ struct pci_host_bridge {
+@@ -547,6 +547,7 @@ struct pci_host_bridge {
  	unsigned int	native_dpc:1;		/* OS may use PCIe DPC */
  	unsigned int	preserve_config:1;	/* Preserve FW resource setup */
  	unsigned int	size_windows:1;		/* Enable root bus sizing */
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0003-PCI-aardvark-Add-support-for-DEVCAP2-DEVCTL2-LNKCAP2.patch b/target/linux/generic/backport-5.10/850-v5.17-0003-PCI-aardvark-Add-support-for-DEVCAP2-DEVCTL2-LNKCAP2.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0003-PCI-aardvark-Add-support-for-DEVCAP2-DEVCTL2-LNKCAP2.patch	2024-03-18 15:15:10.673423525 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0003-PCI-aardvark-Add-support-for-DEVCAP2-DEVCTL2-LNKCAP2.patch	2024-03-18 15:16:23.642639590 +0800
@@ -21,7 +21,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -885,8 +885,13 @@ advk_pci_bridge_emul_pcie_conf_read(stru
+@@ -881,8 +881,13 @@ advk_pci_bridge_emul_pcie_conf_read(stru
  
  	case PCI_EXP_DEVCAP:
  	case PCI_EXP_DEVCTL:
@@ -35,7 +35,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
  	default:
  		return PCI_BRIDGE_EMUL_NOT_HANDLED;
  	}
-@@ -900,10 +905,6 @@ advk_pci_bridge_emul_pcie_conf_write(str
+@@ -896,10 +901,6 @@ advk_pci_bridge_emul_pcie_conf_write(str
  	struct advk_pcie *pcie = bridge->data;
  
  	switch (reg) {
@@ -46,7 +46,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
  	case PCI_EXP_LNKCTL:
  		advk_writel(pcie, new, PCIE_CORE_PCIEXP_CAP + reg);
  		if (new & PCI_EXP_LNKCTL_RL)
-@@ -925,6 +926,12 @@ advk_pci_bridge_emul_pcie_conf_write(str
+@@ -921,6 +922,12 @@ advk_pci_bridge_emul_pcie_conf_write(str
  		advk_writel(pcie, new, PCIE_ISR0_REG);
  		break;
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0004-PCI-aardvark-Clear-all-MSIs-at-setup.patch b/target/linux/generic/backport-5.10/850-v5.17-0004-PCI-aardvark-Clear-all-MSIs-at-setup.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0004-PCI-aardvark-Clear-all-MSIs-at-setup.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0004-PCI-aardvark-Clear-all-MSIs-at-setup.patch	2024-03-18 15:16:23.678638217 +0800
@@ -0,0 +1,59 @@
+From 7d8dc1f7cd007a7ce94c5b4c20d63a8b8d6d7751 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Tue, 30 Nov 2021 18:29:06 +0100
+Subject: [PATCH] PCI: aardvark: Clear all MSIs at setup
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+We already clear all the other interrupts (ISR0, ISR1, HOST_CTRL_INT).
+
+Define a new macro PCIE_MSI_ALL_MASK and do the same clearing for MSIs,
+to ensure that we don't start receiving spurious interrupts.
+
+Use this new mask in advk_pcie_handle_msi();
+
+Link: https://lore.kernel.org/r/20211130172913.9727-5-kabel@kernel.org
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 6 ++++--
+ 1 file changed, 4 insertions(+), 2 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -114,6 +114,7 @@
+ #define PCIE_MSI_ADDR_HIGH_REG			(CONTROL_BASE_ADDR + 0x54)
+ #define PCIE_MSI_STATUS_REG			(CONTROL_BASE_ADDR + 0x58)
+ #define PCIE_MSI_MASK_REG			(CONTROL_BASE_ADDR + 0x5C)
++#define     PCIE_MSI_ALL_MASK			GENMASK(31, 0)
+ #define PCIE_MSI_PAYLOAD_REG			(CONTROL_BASE_ADDR + 0x9C)
+ #define     PCIE_MSI_DATA_MASK			GENMASK(15, 0)
+ 
+@@ -577,6 +578,7 @@ static void advk_pcie_setup_hw(struct ad
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL2_REG);
+ 
+ 	/* Clear all interrupts */
++	advk_writel(pcie, PCIE_MSI_ALL_MASK, PCIE_MSI_STATUS_REG);
+ 	advk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_REG);
+ 	advk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_REG);
+ 	advk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);
+@@ -589,7 +591,7 @@ static void advk_pcie_setup_hw(struct ad
+ 	advk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_MASK_REG);
+ 
+ 	/* Unmask all MSIs */
+-	advk_writel(pcie, 0, PCIE_MSI_MASK_REG);
++	advk_writel(pcie, ~(u32)PCIE_MSI_ALL_MASK, PCIE_MSI_MASK_REG);
+ 
+ 	/* Enable summary interrupt for GIC SPI source */
+ 	reg = PCIE_IRQ_ALL_MASK & (~PCIE_IRQ_ENABLE_INTS_MASK);
+@@ -1399,7 +1401,7 @@ static void advk_pcie_handle_msi(struct
+ 
+ 	msi_mask = advk_readl(pcie, PCIE_MSI_MASK_REG);
+ 	msi_val = advk_readl(pcie, PCIE_MSI_STATUS_REG);
+-	msi_status = msi_val & ~msi_mask;
++	msi_status = msi_val & ((~msi_mask) & PCIE_MSI_ALL_MASK);
+ 
+ 	for (msi_idx = 0; msi_idx < MSI_IRQ_NUM; msi_idx++) {
+ 		if (!(BIT(msi_idx) & msi_status))
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0005-PCI-aardvark-Comment-actions-in-driver-remove-method.patch b/target/linux/generic/backport-5.10/850-v5.17-0005-PCI-aardvark-Comment-actions-in-driver-remove-method.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0005-PCI-aardvark-Comment-actions-in-driver-remove-method.patch	2024-03-18 15:15:10.701422456 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0005-PCI-aardvark-Comment-actions-in-driver-remove-method.patch	2024-03-18 15:16:23.662638827 +0800
@@ -18,7 +18,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1692,11 +1692,13 @@ static int advk_pcie_remove(struct platf
+@@ -1698,11 +1698,13 @@ static int advk_pcie_remove(struct platf
  	struct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);
  	int i;
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0006-PCI-aardvark-Disable-bus-mastering-when-unbinding-dr.patch b/target/linux/generic/backport-5.10/850-v5.17-0006-PCI-aardvark-Disable-bus-mastering-when-unbinding-dr.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0006-PCI-aardvark-Disable-bus-mastering-when-unbinding-dr.patch	2024-03-18 15:15:10.673423525 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0006-PCI-aardvark-Disable-bus-mastering-when-unbinding-dr.patch	2024-03-18 15:16:23.642639590 +0800
@@ -19,7 +19,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1690,6 +1690,7 @@ static int advk_pcie_remove(struct platf
+@@ -1696,6 +1696,7 @@ static int advk_pcie_remove(struct platf
  {
  	struct advk_pcie *pcie = platform_get_drvdata(pdev);
  	struct pci_host_bridge *bridge = pci_host_bridge_from_priv(pcie);
@@ -27,7 +27,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
  	int i;
  
  	/* Remove PCI bus with all devices */
-@@ -1698,6 +1699,11 @@ static int advk_pcie_remove(struct platf
+@@ -1704,6 +1705,11 @@ static int advk_pcie_remove(struct platf
  	pci_remove_root_bus(bridge->bus);
  	pci_unlock_rescan_remove();
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0007-PCI-aardvark-Mask-all-interrupts-when-unbinding-driv.patch b/target/linux/generic/backport-5.10/850-v5.17-0007-PCI-aardvark-Mask-all-interrupts-when-unbinding-driv.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0007-PCI-aardvark-Mask-all-interrupts-when-unbinding-driv.patch	2024-03-18 15:15:10.785419252 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0007-PCI-aardvark-Mask-all-interrupts-when-unbinding-driv.patch	2024-03-18 15:16:23.706637149 +0800
@@ -18,7 +18,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1704,6 +1704,27 @@ static int advk_pcie_remove(struct platf
+@@ -1710,6 +1710,27 @@ static int advk_pcie_remove(struct platf
  	val &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
  	advk_writel(pcie, val, PCIE_CORE_CMD_STATUS_REG);
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0008-PCI-aardvark-Fix-memory-leak-in-driver-unbind.patch b/target/linux/generic/backport-5.10/850-v5.17-0008-PCI-aardvark-Fix-memory-leak-in-driver-unbind.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0008-PCI-aardvark-Fix-memory-leak-in-driver-unbind.patch	2024-03-18 15:15:10.773419710 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0008-PCI-aardvark-Fix-memory-leak-in-driver-unbind.patch	2024-03-18 15:16:23.702637301 +0800
@@ -21,7 +21,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1729,6 +1729,9 @@ static int advk_pcie_remove(struct platf
+@@ -1735,6 +1735,9 @@ static int advk_pcie_remove(struct platf
  	advk_pcie_remove_msi_irq_domain(pcie);
  	advk_pcie_remove_irq_domain(pcie);
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0009-PCI-aardvark-Assert-PERST-when-unbinding-driver.patch b/target/linux/generic/backport-5.10/850-v5.17-0009-PCI-aardvark-Assert-PERST-when-unbinding-driver.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0009-PCI-aardvark-Assert-PERST-when-unbinding-driver.patch	2024-03-18 15:15:10.769419862 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0009-PCI-aardvark-Assert-PERST-when-unbinding-driver.patch	2024-03-18 15:16:23.678638217 +0800
@@ -20,7 +20,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1732,6 +1732,10 @@ static int advk_pcie_remove(struct platf
+@@ -1738,6 +1738,10 @@ static int advk_pcie_remove(struct platf
  	/* Free config space for emulated root bridge */
  	pci_bridge_emul_cleanup(&pcie->bridge);
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0010-PCI-aardvark-Disable-link-training-when-unbinding-dr.patch b/target/linux/generic/backport-5.10/850-v5.17-0010-PCI-aardvark-Disable-link-training-when-unbinding-dr.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0010-PCI-aardvark-Disable-link-training-when-unbinding-dr.patch	2024-03-18 15:15:10.765420015 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0010-PCI-aardvark-Disable-link-training-when-unbinding-dr.patch	2024-03-18 15:16:23.678638217 +0800
@@ -20,7 +20,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1736,6 +1736,11 @@ static int advk_pcie_remove(struct platf
+@@ -1742,6 +1742,11 @@ static int advk_pcie_remove(struct platf
  	if (pcie->reset_gpio)
  		gpiod_set_value_cansleep(pcie->reset_gpio, 1);
  
diff -uprN a/target/linux/generic/backport-5.10/850-v5.17-0011-PCI-aardvark-Disable-common-PHY-when-unbinding-drive.patch b/target/linux/generic/backport-5.10/850-v5.17-0011-PCI-aardvark-Disable-common-PHY-when-unbinding-drive.patch
--- a/target/linux/generic/backport-5.10/850-v5.17-0011-PCI-aardvark-Disable-common-PHY-when-unbinding-drive.patch	2024-03-18 15:15:10.757420320 +0800
+++ b/target/linux/generic/backport-5.10/850-v5.17-0011-PCI-aardvark-Disable-common-PHY-when-unbinding-drive.patch	2024-03-18 15:16:23.674638369 +0800
@@ -18,7 +18,7 @@ Signed-off-by: Lorenzo Pieralisi <lorenz
 
 --- a/drivers/pci/controller/pci-aardvark.c
 +++ b/drivers/pci/controller/pci-aardvark.c
-@@ -1745,6 +1745,9 @@ static int advk_pcie_remove(struct platf
+@@ -1751,6 +1751,9 @@ static int advk_pcie_remove(struct platf
  	for (i = 0; i < OB_WIN_COUNT; i++)
  		advk_pcie_disable_ob_win(pcie, i);
  
diff -uprN a/target/linux/generic/config-5.10 b/target/linux/generic/config-5.10
--- a/target/linux/generic/config-5.10	2024-03-18 15:15:11.337398193 +0800
+++ b/target/linux/generic/config-5.10	2024-03-18 15:16:24.526605865 +0800
@@ -126,7 +126,6 @@ CONFIG_AEABI=y
 # CONFIG_AF_RXRPC_INJECT_LOSS is not set
 # CONFIG_AF_RXRPC_IPV6 is not set
 # CONFIG_AGP is not set
-# CONFIG_AHCI_BRCM is not set
 # CONFIG_AHCI_CEVA is not set
 # CONFIG_AHCI_IMX is not set
 # CONFIG_AHCI_MVEBU is not set
@@ -314,7 +313,10 @@ CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=8
 # CONFIG_ARM64_CRYPTO is not set
 # CONFIG_ARM64_E0PD is not set
 # CONFIG_ARM64_ERRATUM_1024718 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
 # CONFIG_ARM64_ERRATUM_1319367 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
 # CONFIG_ARM64_ERRATUM_1463225 is not set
 # CONFIG_ARM64_ERRATUM_1508412 is not set
 # CONFIG_ARM64_ERRATUM_1530923 is not set
@@ -412,10 +414,12 @@ CONFIG_ARM_GIC_MAX_NR=1
 # CONFIG_AS3935 is not set
 # CONFIG_AS73211 is not set
 # CONFIG_ASM9260_TIMER is not set
+# CONFIG_ASN1 is not set
 # CONFIG_ASUS_LAPTOP is not set
 # CONFIG_ASUS_WIRELESS is not set
 # CONFIG_ASYMMETRIC_KEY_TYPE is not set
 # CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE is not set
+# CONFIG_ASYMMETRIC_TPM_KEY_SUBTYPE is not set
 # CONFIG_ASYNC_RAID6_TEST is not set
 # CONFIG_ASYNC_TX_DMA is not set
 # CONFIG_AT76C50X_USB is not set
@@ -496,6 +500,11 @@ CONFIG_ATM_CLIP_NO_ICMP=y
 # CONFIG_B43LEGACY is not set
 # CONFIG_B44 is not set
 # CONFIG_B53 is not set
+# CONFIG_B53_MDIO_DRIVER is not set
+# CONFIG_B53_MMAP_DRIVER is not set
+# CONFIG_B53_SERDES is not set
+# CONFIG_B53_SPI_DRIVER is not set
+# CONFIG_B53_SRAB_DRIVER is not set
 # CONFIG_BACKLIGHT_ADP8860 is not set
 # CONFIG_BACKLIGHT_ADP8870 is not set
 # CONFIG_BACKLIGHT_APPLE is not set
@@ -683,6 +692,8 @@ CONFIG_BLOCK=y
 # CONFIG_BONDING is not set
 # CONFIG_BOOKE_WDT is not set
 CONFIG_BOOKE_WDT_DEFAULT_TIMEOUT=3
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
 # CONFIG_BOOTTIME_TRACING is not set
 # CONFIG_BOOT_CONFIG is not set
 # CONFIG_BOOT_PRINTK_DELAY is not set
@@ -830,6 +841,7 @@ CONFIG_CARDBUS=y
 # CONFIG_CAVIUM_ERRATUM_30115 is not set
 # CONFIG_CAVIUM_OCTEON_SOC is not set
 # CONFIG_CAVIUM_PTP is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
 # CONFIG_CB710_CORE is not set
 # CONFIG_CC10001_ADC is not set
 # CONFIG_CCS811 is not set
@@ -891,7 +903,6 @@ CONFIG_CIFS_POSIX=y
 # CONFIG_CIFS_WEAK_PW_HASH is not set
 CONFIG_CIFS_XATTR=y
 # CONFIG_CIO_DAC is not set
-CONFIG_CLANG_VERSION=0
 # CONFIG_CLEANCACHE is not set
 # CONFIG_CLKSRC_VERSATILE is not set
 # CONFIG_CLK_HSDK is not set
@@ -1060,6 +1071,7 @@ CONFIG_CRYPTO_CCM=y
 # CONFIG_CRYPTO_CRC32_ARM_CE is not set
 # CONFIG_CRYPTO_CRCT10DIF is not set
 # CONFIG_CRYPTO_CRCT10DIF_ARM64_CE is not set
+# CONFIG_CRYPTO_CRCT10DIF_ARM_CE is not set
 # CONFIG_CRYPTO_CRYPTD is not set
 CONFIG_CRYPTO_CTR=y
 # CONFIG_CRYPTO_CTS is not set
@@ -1090,6 +1102,7 @@ CONFIG_CRYPTO_CTR=y
 # CONFIG_CRYPTO_DEV_MXC_SCC is not set
 # CONFIG_CRYPTO_DEV_MXS_DCP is not set
 # CONFIG_CRYPTO_DEV_NITROX_CNN55XX is not set
+# CONFIG_CRYPTO_DEV_OCTEONTX_CPT is not set
 # CONFIG_CRYPTO_DEV_QAT_C3XXX is not set
 # CONFIG_CRYPTO_DEV_QAT_C3XXXVF is not set
 # CONFIG_CRYPTO_DEV_QAT_C62X is not set
@@ -1115,7 +1128,7 @@ CONFIG_CRYPTO_CTR=y
 # CONFIG_CRYPTO_FCRYPT is not set
 # CONFIG_CRYPTO_FIPS is not set
 CONFIG_CRYPTO_GCM=y
-# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_GF128MUL=y
 CONFIG_CRYPTO_GHASH=y
 # CONFIG_CRYPTO_GHASH_ARM64_CE is not set
 # CONFIG_CRYPTO_GHASH_ARM_CE is not set
@@ -1131,6 +1144,7 @@ CONFIG_CRYPTO_KPP=y
 CONFIG_CRYPTO_KPP2=y
 CONFIG_CRYPTO_LIB_AES=y
 CONFIG_CRYPTO_LIB_ARC4=y
+# CONFIG_CRYPTO_LIB_BLAKE2S is not set
 # CONFIG_CRYPTO_LIB_CHACHA is not set
 # CONFIG_CRYPTO_LIB_CHACHA20POLY1305 is not set
 # CONFIG_CRYPTO_LIB_CURVE25519 is not set
@@ -1154,6 +1168,7 @@ CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
 # CONFIG_CRYPTO_MORUS640_SSE2 is not set
 # CONFIG_CRYPTO_NHPOLY1305_NEON is not set
 CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
 # CONFIG_CRYPTO_OFB is not set
 # CONFIG_CRYPTO_PCBC is not set
 # CONFIG_CRYPTO_PCOMP is not set
@@ -1261,6 +1276,7 @@ CONFIG_DEBUG_FS_ALLOW_ALL=y
 # CONFIG_DEBUG_INFO_BTF is not set
 # CONFIG_DEBUG_INFO_COMPRESSED is not set
 # CONFIG_DEBUG_INFO_DWARF4 is not set
+CONFIG_DEBUG_INFO_REDUCED=y
 # CONFIG_DEBUG_INFO_SPLIT is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_KMEMLEAK is not set
@@ -1315,16 +1331,23 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_WX is not set
 # CONFIG_DEBUG_ZBOOT is not set
 # CONFIG_DECNET is not set
+# CONFIG_DEFAULT_CODEL is not set
 CONFIG_DEFAULT_CUBIC=y
 CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_DEFAULT_FQ is not set
+CONFIG_DEFAULT_FQ_CODEL=y
 CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
 CONFIG_DEFAULT_INIT=""
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_DEFAULT_NET_SCH="fq_codel"
 # CONFIG_DEFAULT_NOOP is not set
+# CONFIG_DEFAULT_PFIFO_FAST is not set
 # CONFIG_DEFAULT_RENO is not set
 CONFIG_DEFAULT_SECURITY=""
 CONFIG_DEFAULT_SECURITY_DAC=y
 # CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SFQ is not set
 CONFIG_DEFAULT_TCP_CONG="cubic"
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 # CONFIG_DEFERRED_STRUCT_PAGE_INIT is not set
@@ -1476,16 +1499,25 @@ CONFIG_DQL=y
 # CONFIG_DRM_NXP_PTN3460 is not set
 # CONFIG_DRM_OMAP is not set
 # CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_ASUS_Z00T_TM5P5_NT35596 is not set
+# CONFIG_DRM_PANEL_BOE_HIMAX8279D is not set
+# CONFIG_DRM_PANEL_BOE_TV101WUM_NL6 is not set
+# CONFIG_DRM_PANEL_ELIDA_KD35T133 is not set
+# CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02 is not set
 # CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D is not set
 # CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
 # CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
 # CONFIG_DRM_PANEL_INNOLUX_P079ZCA is not set
 # CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
 # CONFIG_DRM_PANEL_KINGDISPLAY_KD097D04 is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK050H3146W is not set
+# CONFIG_DRM_PANEL_LEADTEK_LTK500HD1829 is not set
 # CONFIG_DRM_PANEL_LG_LB035Q02 is not set
 # CONFIG_DRM_PANEL_LG_LG4573 is not set
 # CONFIG_DRM_PANEL_LVDS is not set
+# CONFIG_DRM_PANEL_MANTIX_MLAF057WE51 is not set
 # CONFIG_DRM_PANEL_NEC_NL8048HL11 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT35510 is not set
 # CONFIG_DRM_PANEL_NOVATEK_NT39016 is not set
 # CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO is not set
 # CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
@@ -1509,13 +1541,16 @@ CONFIG_DQL=y
 # CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
 # CONFIG_DRM_PANEL_SIMPLE is not set
 # CONFIG_DRM_PANEL_SITRONIX_ST7701 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7703 is not set
 # CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+# CONFIG_DRM_PANEL_SONY_ACX424AKP is not set
 # CONFIG_DRM_PANEL_SONY_ACX565AKM is not set
 # CONFIG_DRM_PANEL_TPO_TD028TTEC1 is not set
 # CONFIG_DRM_PANEL_TPO_TD043MTEA1 is not set
 # CONFIG_DRM_PANEL_TPO_TPG110 is not set
 # CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA is not set
 # CONFIG_DRM_PANEL_VISIONOX_RM69299 is not set
+# CONFIG_DRM_PANEL_XINPENG_XPP055C272 is not set
 # CONFIG_DRM_PANFROST is not set
 # CONFIG_DRM_PARADE_PS8622 is not set
 # CONFIG_DRM_PARADE_PS8640 is not set
@@ -1684,6 +1719,7 @@ CONFIG_DVB_MAX_ADAPTERS=16
 # CONFIG_DVB_TUNER_DIB0090 is not set
 # CONFIG_DVB_TUNER_ITD1000 is not set
 # CONFIG_DVB_ULE_DEBUG is not set
+# CONFIG_DVB_USB is not set
 # CONFIG_DVB_USB_V2 is not set
 # CONFIG_DVB_VES1820 is not set
 # CONFIG_DVB_VES1X93 is not set
@@ -1730,6 +1766,7 @@ CONFIG_DYNAMIC_DEBUG_CORE=y
 # CONFIG_EEPROM_MAX6875 is not set
 # CONFIG_EFI is not set
 CONFIG_EFI_PARTITION=y
+# CONFIG_EFI_VARS_PSTORE is not set
 # CONFIG_EFS_FS is not set
 CONFIG_ELFCORE=y
 # CONFIG_ELF_CORE is not set
@@ -1833,6 +1870,7 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 # CONFIG_FB_DDC is not set
 # CONFIG_FB_FLEX is not set
 # CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_FSL_DIU is not set
 # CONFIG_FB_GEODE is not set
 # CONFIG_FB_GOLDFISH is not set
 # CONFIG_FB_HGA is not set
@@ -1956,11 +1994,15 @@ CONFIG_FORTIFY_SOURCE=y
 # CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
 # CONFIG_FRAMEBUFFER_CONSOLE_LEGACY_ACCELERATION is not set
 # CONFIG_FRAME_POINTER is not set
+CONFIG_FRAME_WARN=1024
 # CONFIG_FREEZER is not set
 # CONFIG_FRONTSWAP is not set
 # CONFIG_FSCACHE is not set
 # CONFIG_FSI is not set
 # CONFIG_FSL_EDMA is not set
+# CONFIG_FSL_ENETC is not set
+# CONFIG_FSL_ENETC_MDIO is not set
+# CONFIG_FSL_ENETC_VF is not set
 # CONFIG_FSL_ERRATUM_A008585 is not set
 # CONFIG_FSL_MC_BUS is not set
 # CONFIG_FSL_PQ_MDIO is not set
@@ -1979,10 +2021,10 @@ CONFIG_FSNOTIFY=y
 # CONFIG_FTRACE_STARTUP_TEST is not set
 # CONFIG_FTR_FIXUP_SELFTEST is not set
 # CONFIG_FTWDT010_WATCHDOG is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
 # CONFIG_FUJITSU_ES is not set
 # CONFIG_FUJITSU_LAPTOP is not set
 # CONFIG_FUJITSU_TABLET is not set
-# CONFIG_FUNCTION_ERROR_INJECTION is not set
 # CONFIG_FUNCTION_TRACER is not set
 # CONFIG_FUSE_FS is not set
 # CONFIG_FUSION is not set
@@ -2029,7 +2071,13 @@ CONFIG_GENERIC_VDSO_TIME_NS=y
 # CONFIG_GLOB_SELFTEST is not set
 # CONFIG_GNSS is not set
 # CONFIG_GOLDFISH is not set
+# CONFIG_GOOGLE_COREBOOT_TABLE is not set
 # CONFIG_GOOGLE_FIRMWARE is not set
+# CONFIG_GOOGLE_FRAMEBUFFER_COREBOOT is not set
+# CONFIG_GOOGLE_MEMCONSOLE_COREBOOT is not set
+# CONFIG_GOOGLE_MEMCONSOLE_X86_LEGACY is not set
+# CONFIG_GOOGLE_SMI is not set
+# CONFIG_GOOGLE_VPD is not set
 # CONFIG_GP2AP002 is not set
 # CONFIG_GP2AP020A00F is not set
 # CONFIG_GPD_POCKET_FAN is not set
@@ -2050,6 +2098,7 @@ CONFIG_GPIOLIB_FASTPATH_LIMIT=512
 # CONFIG_GPIO_BCM_KONA is not set
 # CONFIG_GPIO_BT8XX is not set
 # CONFIG_GPIO_CADENCE is not set
+# CONFIG_GPIO_CASCADE is not set
 # CONFIG_GPIO_CDEV is not set
 # CONFIG_GPIO_CDEV_V1 is not set
 # CONFIG_GPIO_CS5535 is not set
@@ -2120,6 +2169,7 @@ CONFIG_GPIO_SYSFS=y
 CONFIG_HARDENED_USERCOPY=y
 # CONFIG_HARDENED_USERCOPY_FALLBACK is not set
 # CONFIG_HARDENED_USERCOPY_PAGESPAN is not set
+CONFIG_HARDEN_BRANCH_HISTORY=y
 CONFIG_HARDEN_EL2_VECTORS=y
 # CONFIG_HARDLOCKUP_DETECTOR is not set
 # CONFIG_HAVE_ARM_ARCH_TIMER is not set
@@ -2340,7 +2390,6 @@ CONFIG_HZ_100=y
 # CONFIG_I2C_AU1550 is not set
 # CONFIG_I2C_BCM2835 is not set
 # CONFIG_I2C_BCM_IPROC is not set
-# CONFIG_I2C_BRCMSTB is not set
 # CONFIG_I2C_CADENCE is not set
 # CONFIG_I2C_CBUS_GPIO is not set
 # CONFIG_I2C_CHARDEV is not set
@@ -2503,7 +2552,6 @@ CONFIG_INET=y
 # CONFIG_INET_ESPINTCP is not set
 # CONFIG_INET_IPCOMP is not set
 # CONFIG_INET_LRO is not set
-CONFIG_INET_TABLE_PERTURB_ORDER=16
 # CONFIG_INET_TCP_DIAG is not set
 # CONFIG_INET_TUNNEL is not set
 # CONFIG_INET_UDP_DIAG is not set
@@ -2734,22 +2782,40 @@ CONFIG_IP_VS_MH_TAB_INDEX=10
 # CONFIG_IRQ_DOMAIN_DEBUG is not set
 # CONFIG_IRQ_POLL is not set
 # CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_IR_ENE is not set
+# CONFIG_IR_FINTEK is not set
 # CONFIG_IR_GPIO_CIR is not set
+# CONFIG_IR_GPIO_TX is not set
 # CONFIG_IR_HIX5HD2 is not set
 # CONFIG_IR_IGORPLUGUSB is not set
 # CONFIG_IR_IGUANA is not set
 # CONFIG_IR_IMG is not set
 # CONFIG_IR_IMON is not set
+# CONFIG_IR_IMON_DECODER is not set
+# CONFIG_IR_IMON_RAW is not set
+# CONFIG_IR_ITE_CIR is not set
 # CONFIG_IR_JVC_DECODER is not set
 # CONFIG_IR_LIRC_CODEC is not set
+# CONFIG_IR_MCE_KBD_DECODER is not set
 # CONFIG_IR_MCEUSB is not set
 # CONFIG_IR_NEC_DECODER is not set
+# CONFIG_IR_NUVOTON is not set
+# CONFIG_IR_PWM_TX is not set
 # CONFIG_IR_RC5_DECODER is not set
 # CONFIG_IR_RC6_DECODER is not set
+# CONFIG_IR_RCMM_DECODER is not set
 # CONFIG_IR_REDRAT3 is not set
+# CONFIG_IR_SANYO_DECODER is not set
+# CONFIG_IR_SERIAL is not set
+# CONFIG_IR_SHARP_DECODER is not set
+# CONFIG_IR_SIR is not set
 # CONFIG_IR_SONY_DECODER is not set
+# CONFIG_IR_SPI is not set
 # CONFIG_IR_STREAMZAP is not set
+# CONFIG_IR_TOY is not set
 # CONFIG_IR_TTUSBIR is not set
+# CONFIG_IR_WINBOND_CIR is not set
+# CONFIG_IR_XMP_DECODER is not set
 # CONFIG_ISA_BUS is not set
 # CONFIG_ISA_BUS_API is not set
 # CONFIG_ISCSI_BOOT_SYSFS is not set
@@ -2833,6 +2899,7 @@ CONFIG_KERNEL_XZ=y
 CONFIG_KERNFS=y
 # CONFIG_KEXEC is not set
 # CONFIG_KEXEC_FILE is not set
+# CONFIG_KEXEC_SIG is not set
 # CONFIG_KEYBOARD_ADC is not set
 # CONFIG_KEYBOARD_ADP5588 is not set
 # CONFIG_KEYBOARD_ADP5589 is not set
@@ -2875,6 +2942,7 @@ CONFIG_KERNFS=y
 # CONFIG_KGDB is not set
 # CONFIG_KMEMCHECK is not set
 # CONFIG_KMX61 is not set
+# CONFIG_KPC2000 is not set
 # CONFIG_KPROBES is not set
 # CONFIG_KPROBES_SANITY_TEST is not set
 # CONFIG_KPROBE_EVENTS_ON_NOTRACE is not set
@@ -2923,7 +2991,6 @@ CONFIG_LBDAF=y
 CONFIG_LDISC_AUTOLOAD=y
 # CONFIG_LDM_PARTITION is not set
 CONFIG_LD_DEAD_CODE_DATA_ELIMINATION=y
-# CONFIG_LD_HEAD_STUB_CATCH is not set
 # CONFIG_LEDS_AN30259A is not set
 # CONFIG_LEDS_APU is not set
 # CONFIG_LEDS_AW2013 is not set
@@ -3067,6 +3134,7 @@ CONFIG_LZMA_DECOMPRESS=y
 # CONFIG_MAC80211_MESSAGE_TRACING is not set
 CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
 # CONFIG_MACB is not set
+# CONFIG_MACB_USE_HWSTAMP is not set
 # CONFIG_MACH_ASM9260 is not set
 # CONFIG_MACH_DECSTATION is not set
 # CONFIG_MACH_INGENIC is not set
@@ -3153,6 +3221,7 @@ CONFIG_MAY_USE_DEVLINK=y
 # CONFIG_MEDIA_ATTACH is not set
 # CONFIG_MEDIA_CAMERA_SUPPORT is not set
 # CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_MEDIA_CEC_RC is not set
 # CONFIG_MEDIA_CONTROLLER is not set
 # CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
 # CONFIG_MEDIA_PCI_SUPPORT is not set
@@ -3340,8 +3409,6 @@ CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
 # CONFIG_MICROCHIP_T1_PHY is not set
 # CONFIG_MICROSEMI_PHY is not set
 # CONFIG_MIGRATION is not set
-CONFIG_HARDEN_BRANCH_HISTORY=y
-CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY=y
 CONFIG_MII=y
 # CONFIG_MIKROTIK is not set
 # CONFIG_MIKROTIK_RB532 is not set
@@ -3372,6 +3439,7 @@ CONFIG_MISC_FILESYSTEMS=y
 # CONFIG_MISDN_NETJET is not set
 # CONFIG_MISDN_SPEEDFAX is not set
 # CONFIG_MISDN_W6692 is not set
+CONFIG_MITIGATE_SPECTRE_BRANCH_HISTORY=y
 # CONFIG_MKISS is not set
 # CONFIG_MLX4_CORE is not set
 # CONFIG_MLX4_EN is not set
@@ -3409,7 +3477,6 @@ CONFIG_MMC_BLOCK_MINORS=8
 # CONFIG_MMC_SDHCI_ACPI is not set
 # CONFIG_MMC_SDHCI_AM654 is not set
 # CONFIG_MMC_SDHCI_BCM_KONA is not set
-# CONFIG_MMC_SDHCI_BRCMSTB is not set
 # CONFIG_MMC_SDHCI_CADENCE is not set
 # CONFIG_MMC_SDHCI_F_SDH30 is not set
 # CONFIG_MMC_SDHCI_IPROC is not set
@@ -3560,6 +3627,7 @@ CONFIG_MTD_NAND_IDS=y
 # CONFIG_MTD_NAND_JZ4740 is not set
 # CONFIG_MTD_NAND_MPC5121_NFC is not set
 # CONFIG_MTD_NAND_MTK is not set
+# CONFIG_MTD_NAND_MTK_BMT is not set
 # CONFIG_MTD_NAND_MXC is not set
 # CONFIG_MTD_NAND_MXIC is not set
 # CONFIG_MTD_NAND_NANDSIM is not set
@@ -3585,6 +3653,7 @@ CONFIG_MTD_OF_PARTS=y
 # CONFIG_MTD_ONENAND is not set
 # CONFIG_MTD_OOPS is not set
 # CONFIG_MTD_OTP is not set
+# CONFIG_MTD_PARSER_TRX is not set
 # CONFIG_MTD_PARTITIONED_MASTER is not set
 # CONFIG_MTD_PCI is not set
 # CONFIG_MTD_PCMCIA is not set
@@ -3609,6 +3678,7 @@ CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
 # CONFIG_MTD_ROM is not set
 CONFIG_MTD_ROOTFS_ROOT_DEV=y
 # CONFIG_MTD_ROUTERBOOT_PARTS is not set
+# CONFIG_MTD_SBC_GXX is not set
 # CONFIG_MTD_SLRAM is not set
 # CONFIG_MTD_SM_COMMON is not set
 # CONFIG_MTD_SPINAND_MT29F is not set
@@ -3616,6 +3686,7 @@ CONFIG_MTD_ROOTFS_ROOT_DEV=y
 # CONFIG_MTD_SPI_NOR is not set
 # CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
 CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT=4096
+# CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE is not set
 CONFIG_MTD_SPLIT=y
 # CONFIG_MTD_SPLIT_BCM63XX_FW is not set
 # CONFIG_MTD_SPLIT_BCM_WFI_FW is not set
@@ -3645,13 +3716,17 @@ CONFIG_MTD_SPLIT_SUPPORT=y
 # CONFIG_MTD_VIRT_CONCAT is not set
 # CONFIG_MTK_MMC is not set
 # CONFIG_MTK_MMSYS is not set
+# CONFIG_MULTIPLEXER is not set
 CONFIG_MULTIUSER=y
 # CONFIG_MUTEX_SPIN_ON_OWNER is not set
+# CONFIG_MUX_ADG792A is not set
+# CONFIG_MUX_ADGS1408 is not set
+# CONFIG_MUX_GPIO is not set
+# CONFIG_MUX_MMIO is not set
 # CONFIG_MV643XX_ETH is not set
 # CONFIG_MVMDIO is not set
 # CONFIG_MVNETA_BM is not set
 # CONFIG_MVSW61XX_PHY is not set
-# CONFIG_MVSWITCH_PHY is not set
 # CONFIG_MV_XOR_V2 is not set
 # CONFIG_MWAVE is not set
 # CONFIG_MWL8K is not set
@@ -3808,6 +3883,7 @@ CONFIG_NET_CORE=y
 # CONFIG_NET_DSA_LOOP is not set
 # CONFIG_NET_DSA_MICROCHIP_KSZ8795 is not set
 # CONFIG_NET_DSA_MICROCHIP_KSZ9477 is not set
+# CONFIG_NET_DSA_MSCC_FELIX is not set
 # CONFIG_NET_DSA_MSCC_SEVILLE is not set
 # CONFIG_NET_DSA_MT7530 is not set
 # CONFIG_NET_DSA_MV88E6060 is not set
@@ -3826,6 +3902,7 @@ CONFIG_NET_CORE=y
 # CONFIG_NET_DSA_TAG_8021Q is not set
 # CONFIG_NET_DSA_TAG_AR9331 is not set
 # CONFIG_NET_DSA_TAG_BRCM is not set
+# CONFIG_NET_DSA_TAG_BRCM_LEGACY is not set
 # CONFIG_NET_DSA_TAG_BRCM_PREPEND is not set
 # CONFIG_NET_DSA_TAG_DSA is not set
 # CONFIG_NET_DSA_TAG_EDSA is not set
@@ -3881,7 +3958,7 @@ CONFIG_NET_SCHED=y
 # CONFIG_NET_SCH_CBS is not set
 # CONFIG_NET_SCH_CHOKE is not set
 # CONFIG_NET_SCH_CODEL is not set
-# CONFIG_NET_SCH_DEFAULT is not set
+CONFIG_NET_SCH_DEFAULT=y
 # CONFIG_NET_SCH_DRR is not set
 # CONFIG_NET_SCH_DSMARK is not set
 # CONFIG_NET_SCH_ETF is not set
@@ -4031,6 +4108,7 @@ CONFIG_NFS_V3=y
 # CONFIG_NF_CONNTRACK is not set
 # CONFIG_NF_CONNTRACK_AMANDA is not set
 # CONFIG_NF_CONNTRACK_BRIDGE is not set
+# CONFIG_NF_CONNTRACK_CHAIN_EVENTS is not set
 # CONFIG_NF_CONNTRACK_EVENTS is not set
 # CONFIG_NF_CONNTRACK_FTP is not set
 # CONFIG_NF_CONNTRACK_H323 is not set
@@ -4166,7 +4244,6 @@ CONFIG_NMI_LOG_BUF_SHIFT=13
 # CONFIG_NO_HZ_IDLE is not set
 # CONFIG_NS83820 is not set
 # CONFIG_NTB is not set
-# CONFIG_NTFS3_FS is not set
 # CONFIG_NTFS_DEBUG is not set
 # CONFIG_NTFS_FS is not set
 # CONFIG_NTFS_RW is not set
@@ -4179,7 +4256,6 @@ CONFIG_NMI_LOG_BUF_SHIFT=13
 # CONFIG_NVMEM_IMX_OCOTP is not set
 # CONFIG_NVMEM_REBOOT_MODE is not set
 # CONFIG_NVMEM_SYSFS is not set
-# CONFIG_NVMEM_U_BOOT_ENV is not set
 # CONFIG_NVME_FC is not set
 # CONFIG_NVME_TARGET is not set
 # CONFIG_NVME_TCP is not set
@@ -4227,7 +4303,6 @@ CONFIG_PACKET=y
 # CONFIG_PAGE_EXTENSION is not set
 # CONFIG_PAGE_OWNER is not set
 # CONFIG_PAGE_POISONING is not set
-# CONFIG_PAGE_POOL is not set
 # CONFIG_PAGE_REPORTING is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_32KB is not set
@@ -4479,6 +4554,7 @@ CONFIG_POSIX_TIMERS=y
 # CONFIG_POWER_RESET_LINKSTATION is not set
 # CONFIG_POWER_RESET_LTC2952 is not set
 # CONFIG_POWER_RESET_PIIX4_POWEROFF is not set
+# CONFIG_POWER_RESET_QNAP is not set
 # CONFIG_POWER_RESET_RESTART is not set
 # CONFIG_POWER_RESET_SYSCON is not set
 # CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
@@ -4495,6 +4571,7 @@ CONFIG_PPC_4K_PAGES=y
 # CONFIG_PPC_DISABLE_WERROR is not set
 # CONFIG_PPC_EMULATED_STATS is not set
 # CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
+# CONFIG_PPC_QUEUED_SPINLOCKS is not set
 # CONFIG_PPP is not set
 # CONFIG_PPPOATM is not set
 # CONFIG_PPPOE is not set
@@ -4549,6 +4626,18 @@ CONFIG_PROC_SYSCTL=y
 # CONFIG_PSB6970_PHY is not set
 # CONFIG_PSI is not set
 # CONFIG_PSTORE is not set
+# CONFIG_PSTORE_842_COMPRESS is not set
+# CONFIG_PSTORE_COMPRESS is not set
+# CONFIG_PSTORE_COMPRESS_DEFAULT is not set
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_DEFLATE_COMPRESS is not set
+# CONFIG_PSTORE_DEFLATE_COMPRESS_DEFAULT is not set
+# CONFIG_PSTORE_LZ4HC_COMPRESS is not set
+# CONFIG_PSTORE_LZ4_COMPRESS is not set
+# CONFIG_PSTORE_LZO_COMPRESS is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_PSTORE_ZSTD_COMPRESS is not set
 # CONFIG_PTDUMP_DEBUGFS is not set
 # CONFIG_PTP_1588_CLOCK is not set
 # CONFIG_PTP_1588_CLOCK_IDT82P33 is not set
@@ -4562,9 +4651,7 @@ CONFIG_PROC_SYSCTL=y
 # CONFIG_PWM is not set
 # CONFIG_PWM_DEBUG is not set
 # CONFIG_PWM_FSL_FTM is not set
-# CONFIG_PWM_IMG is not set
 # CONFIG_PWM_JZ4740 is not set
-# CONFIG_PWM_MEDIATEK is not set
 # CONFIG_PWM_PCA9685 is not set
 CONFIG_PWRSEQ_EMMC=y
 # CONFIG_PWRSEQ_SD8787 is not set
@@ -4629,18 +4716,16 @@ CONFIG_PWRSEQ_SIMPLE=y
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_RBTREE_TEST is not set
 # CONFIG_RCU_BOOST is not set
-CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
 # CONFIG_RCU_EQS_DEBUG is not set
 # CONFIG_RCU_EXPEDITE_BOOT is not set
-CONFIG_RCU_EXPERT=y
-CONFIG_RCU_FANOUT=32
-CONFIG_RCU_FANOUT_LEAF=16
-# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_RCU_EXPERT is not set
 CONFIG_RCU_KTHREAD_PRIO=0
-# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_RCU_NEED_SEGCBLIST=y
 # CONFIG_RCU_PERF_TEST is not set
 # CONFIG_RCU_REF_SCALE_TEST is not set
 # CONFIG_RCU_SCALE_TEST is not set
+CONFIG_RCU_STALL_COMMON=y
 # CONFIG_RCU_STRICT_GRACE_PERIOD is not set
 # CONFIG_RCU_TORTURE_TEST is not set
 CONFIG_RCU_TORTURE_TEST_SLOW_INIT_DELAY=3
@@ -4650,6 +4735,7 @@ CONFIG_RCU_TORTURE_TEST_SLOW_INIT_DELAY=
 # CONFIG_RC_DECODERS is not set
 # CONFIG_RC_LOOPBACK is not set
 # CONFIG_RC_MAP is not set
+# CONFIG_RC_XBOX_DVD is not set
 # CONFIG_RDS is not set
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_GZIP is not set
@@ -4662,6 +4748,9 @@ CONFIG_RCU_TORTURE_TEST_SLOW_INIT_DELAY=
 # CONFIG_READ_ONLY_THP_FOR_FS is not set
 # CONFIG_REALTEK_PHY is not set
 # CONFIG_REDWOOD is not set
+# CONFIG_REED_SOLOMON is not set
+# CONFIG_REED_SOLOMON_DEC8 is not set
+# CONFIG_REED_SOLOMON_ENC8 is not set
 # CONFIG_REED_SOLOMON_TEST is not set
 # CONFIG_REGMAP is not set
 # CONFIG_REGMAP_I2C is not set
@@ -5037,6 +5126,7 @@ CONFIG_SECTION_MISMATCH_WARN_ONLY=y
 CONFIG_SECURITY_DMESG_RESTRICT=y
 # CONFIG_SECURITY_LOADPIN is not set
 # CONFIG_SECURITY_LOCKDOWN_LSM is not set
+# CONFIG_SECURITY_NETWORK_XFRM is not set
 # CONFIG_SECURITY_PATH is not set
 # CONFIG_SECURITY_SAFESETID is not set
 # CONFIG_SECURITY_SELINUX_AVC_STATS is not set
@@ -5255,7 +5345,7 @@ CONFIG_SELECT_MEMORY_MODEL=y
 # CONFIG_SENSORS_XGENE is not set
 # CONFIG_SENSORS_ZL6100 is not set
 CONFIG_SERIAL_8250=y
-# CONFIG_SERIAL_8250_16550A_VARIANTS is not set
+CONFIG_SERIAL_8250_16550A_VARIANTS=y
 # CONFIG_SERIAL_8250_ACCENT is not set
 # CONFIG_SERIAL_8250_ASPEED_VUART is not set
 # CONFIG_SERIAL_8250_BOCA is not set
@@ -5997,7 +6087,6 @@ CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_TARGET_CORE is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_TASKS_RCU is not set
-CONFIG_TASKS_TRACE_RCU_READ_MB=y
 # CONFIG_TASK_XACCT is not set
 # CONFIG_TC35815 is not set
 # CONFIG_TCG_ATMEL is not set
@@ -6053,6 +6142,7 @@ CONFIG_TCP_CONG_CUBIC=y
 # CONFIG_TEST_HASH is not set
 # CONFIG_TEST_HEXDUMP is not set
 # CONFIG_TEST_IDA is not set
+# CONFIG_TEST_KASAN_MODULE is not set
 # CONFIG_TEST_KMOD is not set
 # CONFIG_TEST_KSTRTOX is not set
 # CONFIG_TEST_LIST_SORT is not set
@@ -6071,6 +6161,7 @@ CONFIG_TCP_CONG_CUBIC=y
 # CONFIG_TEST_STRING_HELPERS is not set
 # CONFIG_TEST_STRSCPY is not set
 # CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UBSAN is not set
 # CONFIG_TEST_UDELAY is not set
 # CONFIG_TEST_USER_COPY is not set
 # CONFIG_TEST_UUID is not set
@@ -6337,6 +6428,7 @@ CONFIG_UBIFS_FS_ZLIB=y
 CONFIG_UBIFS_FS_ZSTD=y
 # CONFIG_UBSAN is not set
 CONFIG_UBSAN_ALIGNMENT=y
+# CONFIG_UBSAN_MISC is not set
 # CONFIG_UCB1400_CORE is not set
 # CONFIG_UCSI is not set
 # CONFIG_UDF_FS is not set
@@ -6432,6 +6524,7 @@ CONFIG_USB_EHCI_TT_NEWSCHED=y
 # CONFIG_USB_EMI26 is not set
 # CONFIG_USB_EMI62 is not set
 # CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_ETH is not set
 # CONFIG_USB_EZUSB_FX2 is not set
 # CONFIG_USB_FEW_INIT_RETRIES is not set
 # CONFIG_USB_FOTG210_HCD is not set
@@ -6783,7 +6876,10 @@ CONFIG_VHOST_MENU=y
 # CONFIG_VIDEO_ADV_DEBUG is not set
 # CONFIG_VIDEO_AK7375 is not set
 # CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_AM437X_VPFE is not set
 # CONFIG_VIDEO_ASPEED is not set
+# CONFIG_VIDEO_ATMEL_ISC is not set
+# CONFIG_VIDEO_ATMEL_ISI is not set
 # CONFIG_VIDEO_AU0828 is not set
 # CONFIG_VIDEO_BT819 is not set
 # CONFIG_VIDEO_BT848 is not set
@@ -6821,6 +6917,8 @@ CONFIG_VHOST_MENU=y
 # CONFIG_VIDEO_IMX290 is not set
 # CONFIG_VIDEO_IMX319 is not set
 # CONFIG_VIDEO_IMX355 is not set
+# CONFIG_VIDEO_IMX477 is not set
+# CONFIG_VIDEO_IRS1125 is not set
 # CONFIG_VIDEO_IR_I2C is not set
 # CONFIG_VIDEO_IVTV is not set
 # CONFIG_VIDEO_KS0127 is not set
@@ -6863,6 +6961,7 @@ CONFIG_VHOST_MENU=y
 # CONFIG_VIDEO_OV772X is not set
 # CONFIG_VIDEO_OV7740 is not set
 # CONFIG_VIDEO_OV8856 is not set
+# CONFIG_VIDEO_OV9281 is not set
 # CONFIG_VIDEO_OV9640 is not set
 # CONFIG_VIDEO_OV9650 is not set
 # CONFIG_VIDEO_PVRUSB2 is not set
diff -uprN a/target/linux/generic/hack-5.10/100-update-mtk_wed_h.patch b/target/linux/generic/hack-5.10/100-update-mtk_wed_h.patch
--- a/target/linux/generic/hack-5.10/100-update-mtk_wed_h.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/100-update-mtk_wed_h.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,248 +0,0 @@
---- a/include/linux/soc/mediatek/mtk_wed.h
-+++ b/include/linux/soc/mediatek/mtk_wed.h
-@@ -5,21 +5,77 @@
- #include <linux/rcupdate.h>
- #include <linux/regmap.h>
- #include <linux/pci.h>
-+#include <linux/skbuff.h>
-+#include <linux/netdevice.h>
- 
- #define MTK_WED_TX_QUEUES		2
-+#define MTK_WED_RX_QUEUES		2
-+
-+#define WED_WO_STA_REC			0x6
- 
- struct mtk_wed_hw;
- struct mtk_wdma_desc;
- 
-+enum mtk_wed_wo_cmd {
-+	MTK_WED_WO_CMD_WED_CFG,
-+	MTK_WED_WO_CMD_WED_RX_STAT,
-+	MTK_WED_WO_CMD_RRO_SER,
-+	MTK_WED_WO_CMD_DBG_INFO,
-+	MTK_WED_WO_CMD_DEV_INFO,
-+	MTK_WED_WO_CMD_BSS_INFO,
-+	MTK_WED_WO_CMD_STA_REC,
-+	MTK_WED_WO_CMD_DEV_INFO_DUMP,
-+	MTK_WED_WO_CMD_BSS_INFO_DUMP,
-+	MTK_WED_WO_CMD_STA_REC_DUMP,
-+	MTK_WED_WO_CMD_BA_INFO_DUMP,
-+	MTK_WED_WO_CMD_FBCMD_Q_DUMP,
-+	MTK_WED_WO_CMD_FW_LOG_CTRL,
-+	MTK_WED_WO_CMD_LOG_FLUSH,
-+	MTK_WED_WO_CMD_CHANGE_STATE,
-+	MTK_WED_WO_CMD_CPU_STATS_ENABLE,
-+	MTK_WED_WO_CMD_CPU_STATS_DUMP,
-+	MTK_WED_WO_CMD_EXCEPTION_INIT,
-+	MTK_WED_WO_CMD_PROF_CTRL,
-+	MTK_WED_WO_CMD_STA_BA_DUMP,
-+	MTK_WED_WO_CMD_BA_CTRL_DUMP,
-+	MTK_WED_WO_CMD_RXCNT_CTRL,
-+	MTK_WED_WO_CMD_RXCNT_INFO,
-+	MTK_WED_WO_CMD_SET_CAP,
-+	MTK_WED_WO_CMD_CCIF_RING_DUMP,
-+	MTK_WED_WO_CMD_WED_END
-+};
-+
-+struct mtk_rxbm_desc {
-+	__le32 buf0;
-+	__le32 token;
-+} __packed __aligned(4);
-+
-+enum mtk_wed_bus_tye {
-+	MTK_WED_BUS_PCIE,
-+	MTK_WED_BUS_AXI,
-+};
-+
-+#define MTK_WED_RING_CONFIGURED		BIT(0)
- struct mtk_wed_ring {
- 	struct mtk_wdma_desc *desc;
- 	dma_addr_t desc_phys;
-+	u32 desc_size;
- 	int size;
-+	u32 flags;
- 
- 	u32 reg_base;
- 	void __iomem *wpdma;
- };
- 
-+struct mtk_wed_wo_rx_stats {
-+	__le16 wlan_idx;
-+	__le16 tid;
-+	__le32 rx_pkt_cnt;
-+	__le32 rx_byte_cnt;
-+	__le32 rx_err_cnt;
-+	__le32 rx_drop_cnt;
-+};
-+
- struct mtk_wed_device {
- #ifdef CONFIG_NET_MEDIATEK_SOC_WED
- 	const struct mtk_wed_ops *ops;
-@@ -28,30 +84,76 @@ struct mtk_wed_device {
- 	bool init_done, running;
- 	int wdma_idx;
- 	int irq;
-+	u8 version;
-+
-+	/* used by wlan driver */
-+	u32 rev_id;
- 
- 	struct mtk_wed_ring tx_ring[MTK_WED_TX_QUEUES];
-+	struct mtk_wed_ring rx_ring[MTK_WED_RX_QUEUES];
- 	struct mtk_wed_ring txfree_ring;
- 	struct mtk_wed_ring tx_wdma[MTK_WED_TX_QUEUES];
-+	struct mtk_wed_ring rx_wdma[MTK_WED_RX_QUEUES];
- 
- 	struct {
- 		int size;
- 		void **pages;
- 		struct mtk_wdma_desc *desc;
- 		dma_addr_t desc_phys;
--	} buf_ring;
-+	} tx_buf_ring;
-+
-+	struct {
-+		int size;
-+		struct page_frag_cache rx_page;
-+		struct mtk_rxbm_desc *desc;
-+		dma_addr_t desc_phys;
-+	} rx_buf_ring;
-+
-+	struct {
-+		struct mtk_wed_ring ring;
-+		dma_addr_t miod_phys;
-+		dma_addr_t fdbk_phys;
-+	} rro;
- 
- 	/* filled by driver: */
- 	struct {
--		struct pci_dev *pci_dev;
-+		union {
-+			struct platform_device *platform_dev;
-+			struct pci_dev *pci_dev;
-+		};
-+		enum mtk_wed_bus_tye bus_type;
-+		void __iomem *base;
-+		u32 phy_base;
- 
- 		u32 wpdma_phys;
-+		u32 wpdma_int;
-+		u32 wpdma_mask;
-+		u32 wpdma_tx;
-+		u32 wpdma_txfree;
-+		u32 wpdma_rx_glo;
-+		u32 wpdma_rx;
-+
-+		bool wcid_512;
- 
- 		u16 token_start;
- 		unsigned int nbuf;
-+		unsigned int rx_nbuf;
-+		unsigned int rx_npkt;
-+		unsigned int rx_size;
-+
-+		u8 tx_tbit[MTK_WED_TX_QUEUES];
-+		u8 rx_tbit[MTK_WED_RX_QUEUES];
-+		u8 txfree_tbit;
- 
- 		u32 (*init_buf)(void *ptr, dma_addr_t phys, int token_id);
- 		int (*offload_enable)(struct mtk_wed_device *wed);
- 		void (*offload_disable)(struct mtk_wed_device *wed);
-+		u32 (*init_rx_buf)(struct mtk_wed_device *wed, int size);
-+		void (*release_rx_buf)(struct mtk_wed_device *wed);
-+		void (*update_wo_rx_stats)(struct mtk_wed_device *wed,
-+					   struct mtk_wed_wo_rx_stats *stats);
-+		int (*reset)(struct mtk_wed_device *wed);
-+		void (*reset_complete)(struct mtk_wed_device *wed);
- 	} wlan;
- #endif
- };
-@@ -59,10 +161,16 @@ struct mtk_wed_device {
- struct mtk_wed_ops {
- 	int (*attach)(struct mtk_wed_device *dev);
- 	int (*tx_ring_setup)(struct mtk_wed_device *dev, int ring,
--			     void __iomem *regs);
-+			     void __iomem *regs, bool reset);
-+	int (*rx_ring_setup)(struct mtk_wed_device *dev, int ring,
-+			     void __iomem *regs, bool reset);
- 	int (*txfree_ring_setup)(struct mtk_wed_device *dev,
- 				 void __iomem *regs);
-+	int (*msg_update)(struct mtk_wed_device *dev, int cmd_id,
-+			  void *data, int len);
- 	void (*detach)(struct mtk_wed_device *dev);
-+	void (*ppe_check)(struct mtk_wed_device *dev, struct sk_buff *skb,
-+			  u32 reason, u32 hash);
- 
- 	void (*stop)(struct mtk_wed_device *dev);
- 	void (*start)(struct mtk_wed_device *dev, u32 irq_mask);
-@@ -73,6 +181,8 @@ struct mtk_wed_ops {
- 
- 	u32 (*irq_get)(struct mtk_wed_device *dev, u32 mask);
- 	void (*irq_set_mask)(struct mtk_wed_device *dev, u32 mask);
-+	int (*setup_tc)(struct mtk_wed_device *wed, struct net_device *dev,
-+			enum tc_setup_type type, void *type_data);
- };
- 
- extern const struct mtk_wed_ops __rcu *mtk_soc_wed_ops;
-@@ -97,12 +207,22 @@ mtk_wed_device_attach(struct mtk_wed_dev
- 	return ret;
- }
- 
-+static inline bool
-+mtk_wed_get_rx_capa(struct mtk_wed_device *dev)
-+{
-+#ifdef CONFIG_NET_MEDIATEK_SOC_WED
-+	return dev->version != 1;
-+#else
-+	return false;
-+#endif
-+}
-+
- #ifdef CONFIG_NET_MEDIATEK_SOC_WED
- #define mtk_wed_device_active(_dev) !!(_dev)->ops
- #define mtk_wed_device_detach(_dev) (_dev)->ops->detach(_dev)
- #define mtk_wed_device_start(_dev, _mask) (_dev)->ops->start(_dev, _mask)
--#define mtk_wed_device_tx_ring_setup(_dev, _ring, _regs) \
--	(_dev)->ops->tx_ring_setup(_dev, _ring, _regs)
-+#define mtk_wed_device_tx_ring_setup(_dev, _ring, _regs, _reset) \
-+	(_dev)->ops->tx_ring_setup(_dev, _ring, _regs, _reset)
- #define mtk_wed_device_txfree_ring_setup(_dev, _regs) \
- 	(_dev)->ops->txfree_ring_setup(_dev, _regs)
- #define mtk_wed_device_reg_read(_dev, _reg) \
-@@ -113,6 +233,16 @@ mtk_wed_device_attach(struct mtk_wed_dev
- 	(_dev)->ops->irq_get(_dev, _mask)
- #define mtk_wed_device_irq_set_mask(_dev, _mask) \
- 	(_dev)->ops->irq_set_mask(_dev, _mask)
-+#define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs, _reset) \
-+	(_dev)->ops->rx_ring_setup(_dev, _ring, _regs, _reset)
-+#define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash) \
-+	(_dev)->ops->ppe_check(_dev, _skb, _reason, _hash)
-+#define mtk_wed_device_update_msg(_dev, _id, _msg, _len) \
-+	(_dev)->ops->msg_update(_dev, _id, _msg, _len)
-+#define mtk_wed_device_stop(_dev) (_dev)->ops->stop(_dev)
-+#define mtk_wed_device_dma_reset(_dev) (_dev)->ops->reset_dma(_dev)
-+#define mtk_wed_device_setup_tc(_dev, _netdev, _type, _type_data) \
-+	(_dev)->ops->setup_tc(_dev, _netdev, _type, _type_data)
- #else
- static inline bool mtk_wed_device_active(struct mtk_wed_device *dev)
- {
-@@ -120,12 +250,18 @@ static inline bool mtk_wed_device_active
- }
- #define mtk_wed_device_detach(_dev) do {} while (0)
- #define mtk_wed_device_start(_dev, _mask) do {} while (0)
--#define mtk_wed_device_tx_ring_setup(_dev, _ring, _regs) -ENODEV
-+#define mtk_wed_device_tx_ring_setup(_dev, _ring, _regs, _reset) -ENODEV
- #define mtk_wed_device_txfree_ring_setup(_dev, _ring, _regs) -ENODEV
- #define mtk_wed_device_reg_read(_dev, _reg) 0
- #define mtk_wed_device_reg_write(_dev, _reg, _val) do {} while (0)
- #define mtk_wed_device_irq_get(_dev, _mask) 0
- #define mtk_wed_device_irq_set_mask(_dev, _mask) do {} while (0)
-+#define mtk_wed_device_rx_ring_setup(_dev, _ring, _regs, _reset) -ENODEV
-+#define mtk_wed_device_ppe_check(_dev, _skb, _reason, _hash)  do {} while (0)
-+#define mtk_wed_device_update_msg(_dev, _id, _msg, _len) -ENODEV
-+#define mtk_wed_device_stop(_dev) do {} while (0)
-+#define mtk_wed_device_dma_reset(_dev) do {} while (0)
-+#define mtk_wed_device_setup_tc(_dev, _netdev, _type, _type_data) -EOPNOTSUPP
- #endif
- 
- #endif
diff -uprN a/target/linux/generic/hack-5.10/204-module_strip.patch b/target/linux/generic/hack-5.10/204-module_strip.patch
--- a/target/linux/generic/hack-5.10/204-module_strip.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/204-module_strip.patch	2024-03-18 15:16:24.578603881 +0800
@@ -88,7 +88,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
 --- a/init/Kconfig
 +++ b/init/Kconfig
-@@ -2352,6 +2352,13 @@ config UNUSED_KSYMS_WHITELIST
+@@ -2347,6 +2347,13 @@ config UNUSED_KSYMS_WHITELIST
  	  one per line. The path can be absolute, or relative to the kernel
  	  source tree.
  
@@ -104,7 +104,23 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  config MODULES_TREE_LOOKUP
 --- a/kernel/module.c
 +++ b/kernel/module.c
-@@ -3251,9 +3251,11 @@ static int setup_load_info(struct load_i
+@@ -1285,6 +1285,7 @@ static struct module_attribute *modinfo_
+ 
+ static const char vermagic[] = VERMAGIC_STRING;
+ 
++#if defined(CONFIG_MODVERSIONS) || !defined(CONFIG_MODULE_STRIPPED)
+ static int try_to_force_load(struct module *mod, const char *reason)
+ {
+ #ifdef CONFIG_MODULE_FORCE_LOAD
+@@ -1296,6 +1297,7 @@ static int try_to_force_load(struct modu
+ 	return -ENOEXEC;
+ #endif
+ }
++#endif
+ 
+ #ifdef CONFIG_MODVERSIONS
+ 
+@@ -3247,9 +3249,11 @@ static int setup_load_info(struct load_i
  
  static int check_modinfo(struct module *mod, struct load_info *info, int flags)
  {
@@ -117,7 +133,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
  		modmagic = NULL;
  
-@@ -3274,6 +3276,7 @@ static int check_modinfo(struct module *
+@@ -3270,6 +3274,7 @@ static int check_modinfo(struct module *
  				mod->name);
  		add_taint_module(mod, TAINT_OOT_MODULE, LOCKDEP_STILL_OK);
  	}
@@ -127,7 +143,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
 --- a/scripts/mod/modpost.c
 +++ b/scripts/mod/modpost.c
-@@ -2038,7 +2038,9 @@ static void read_symbols(const char *mod
+@@ -2037,7 +2037,9 @@ static void read_symbols(const char *mod
  		symname = remove_dot(info.strtab + sym->st_name);
  
  		handle_symbol(mod, &info, sym, symname);
@@ -137,7 +153,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	}
  
  	for (sym = info.symtab_start; sym < info.symtab_stop; sym++) {
-@@ -2251,8 +2253,10 @@ static void add_header(struct buffer *b,
+@@ -2250,8 +2252,10 @@ static void add_header(struct buffer *b,
  	buf_printf(b, "\n");
  	buf_printf(b, "BUILD_SALT;\n");
  	buf_printf(b, "\n");
@@ -148,7 +164,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	buf_printf(b, "\n");
  	buf_printf(b, "__visible struct module __this_module\n");
  	buf_printf(b, "__section(\".gnu.linkonce.this_module\") = {\n");
-@@ -2269,8 +2273,10 @@ static void add_header(struct buffer *b,
+@@ -2268,8 +2272,10 @@ static void add_header(struct buffer *b,
  
  static void add_intree_flag(struct buffer *b, int is_intree)
  {
@@ -159,7 +175,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  }
  
  /* Cannot check for assembler */
-@@ -2283,8 +2289,10 @@ static void add_retpoline(struct buffer
+@@ -2282,8 +2288,10 @@ static void add_retpoline(struct buffer
  
  static void add_staging_flag(struct buffer *b, const char *name)
  {
@@ -170,7 +186,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  }
  
  /**
-@@ -2368,11 +2376,13 @@ static void add_depends(struct buffer *b
+@@ -2367,11 +2375,13 @@ static void add_depends(struct buffer *b
  
  static void add_srcversion(struct buffer *b, struct module *mod)
  {
@@ -184,7 +200,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  }
  
  static void write_buf(struct buffer *b, const char *fname)
-@@ -2631,7 +2641,9 @@ int main(int argc, char **argv)
+@@ -2630,7 +2640,9 @@ int main(int argc, char **argv)
  		add_staging_flag(&buf, mod->name);
  		err |= add_versions(&buf, mod);
  		add_depends(&buf, mod);
diff -uprN a/target/linux/generic/hack-5.10/205-kconfig-exit.patch b/target/linux/generic/hack-5.10/205-kconfig-exit.patch
--- a/target/linux/generic/hack-5.10/205-kconfig-exit.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/205-kconfig-exit.patch	2024-03-18 15:16:24.554604797 +0800
@@ -0,0 +1,11 @@
+--- a/scripts/kconfig/conf.c
++++ b/scripts/kconfig/conf.c
+@@ -215,6 +215,8 @@ static int conf_sym(struct menu *menu)
+ 				break;
+ 			continue;
+ 		case 0:
++			if (!sym_has_value(sym) && !tty_stdio && getenv("FAIL_ON_UNCONFIGURED"))
++				exit(1);
+ 			newval = oldval;
+ 			break;
+ 		case '?':
diff -uprN a/target/linux/generic/hack-5.10/220-arm-gc_sections.patch b/target/linux/generic/hack-5.10/220-arm-gc_sections.patch
--- a/target/linux/generic/hack-5.10/220-arm-gc_sections.patch	2024-03-18 15:15:11.365397125 +0800
+++ b/target/linux/generic/hack-5.10/220-arm-gc_sections.patch	2024-03-18 15:16:24.554604797 +0800
@@ -12,14 +12,14 @@ Signed-off-by: Gabor Juhos <juhosg@openw
 ---
 --- a/arch/arm/Kconfig
 +++ b/arch/arm/Kconfig
-@@ -99,6 +99,7 @@ config ARM
- 	select HAVE_KERNEL_XZ
- 	select HAVE_KPROBES if !XIP_KERNEL && !CPU_ENDIAN_BE32 && !CPU_V7M
- 	select HAVE_KRETPROBES if HAVE_KPROBES
+@@ -114,6 +114,7 @@ config ARM
+ 	select HAVE_UID16
+ 	select HAVE_VIRT_CPU_ACCOUNTING_GEN
+ 	select IRQ_FORCED_THREADING
 +	select HAVE_LD_DEAD_CODE_DATA_ELIMINATION
- 	select HAVE_MOD_ARCH_SPECIFIC
- 	select HAVE_NMI
- 	select HAVE_OPROFILE if HAVE_PERF_EVENTS
+ 	select MODULES_USE_ELF_REL
+ 	select NEED_DMA_MAP_STATE
+ 	select OF_EARLY_FLATTREE if OF
 --- a/arch/arm/boot/compressed/Makefile
 +++ b/arch/arm/boot/compressed/Makefile
 @@ -100,6 +100,7 @@ $(foreach o, $(libfdt_objs) atags_to_fdt
diff -uprN a/target/linux/generic/hack-5.10/221-module_exports.patch b/target/linux/generic/hack-5.10/221-module_exports.patch
--- a/target/linux/generic/hack-5.10/221-module_exports.patch	2024-03-18 15:15:11.369396972 +0800
+++ b/target/linux/generic/hack-5.10/221-module_exports.patch	2024-03-18 15:16:24.554604797 +0800
@@ -30,7 +30,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  /* Align . to a 8 byte boundary equals to maximum function alignment. */
  #define ALIGN_FUNCTION()  . = ALIGN(8)
  
-@@ -474,14 +484,14 @@
+@@ -473,14 +483,14 @@
  	/* Kernel symbol table: Normal symbols */			\
  	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
  		__start___ksymtab = .;					\
@@ -47,7 +47,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		__stop___ksymtab_gpl = .;				\
  	}								\
  									\
-@@ -543,7 +553,7 @@
+@@ -542,7 +552,7 @@
  									\
  	/* Kernel symbol table: strings */				\
          __ksymtab_strings : AT(ADDR(__ksymtab_strings) - LOAD_OFFSET) {	\
@@ -56,7 +56,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	}								\
  									\
  	/* __*init sections */						\
-@@ -1024,6 +1034,8 @@
+@@ -1019,6 +1029,8 @@
  
  #define COMMON_DISCARDS							\
  	SANITIZER_DISCARDS						\
@@ -89,33 +89,9 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	    "__kstrtab_" #sym ":					\n"	\
  	    "	.asciz 	\"" #sym "\"					\n"	\
  	    "__kstrtabns_" #sym ":					\n"	\
---- a/include/asm-generic/export.h
-+++ b/include/asm-generic/export.h
-@@ -26,6 +26,12 @@
- #endif
- .endm
- 
-+#ifdef MODULE
-+#define __EXPORT_SUFFIX(name)
-+#else
-+#define __EXPORT_SUFFIX(name) + #name
-+#endif
-+
- /*
-  * note on .section use: we specify progbits since usage of the "M" (SHF_MERGE)
-  * section flag requires it. Use '%progbits' instead of '@progbits' since the
-@@ -39,7 +45,7 @@
- __ksymtab_\name:
- 	__put \val, __kstrtab_\name
- 	.previous
--	.section __ksymtab_strings,"aMS",%progbits,1
-+	.section __ksymtab_strings __EXPORT_SUFFIX(name),"aMS",%progbits,1
- __kstrtab_\name:
- 	.asciz "\name"
- 	.previous
 --- a/scripts/Makefile.build
 +++ b/scripts/Makefile.build
-@@ -373,7 +373,7 @@ targets += $(lib-y) $(always-y) $(MAKECM
+@@ -367,7 +367,7 @@ targets += $(lib-y) $(always-y) $(MAKECM
  # Linker scripts preprocessor (.lds.S -> .lds)
  # ---------------------------------------------------------------------------
  quiet_cmd_cpp_lds_S = LDS     $@
diff -uprN a/target/linux/generic/hack-5.10/250-netfilter_depends.patch b/target/linux/generic/hack-5.10/250-netfilter_depends.patch
--- a/target/linux/generic/hack-5.10/250-netfilter_depends.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/250-netfilter_depends.patch	2024-03-18 15:16:24.574604033 +0800
@@ -9,7 +9,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/net/netfilter/Kconfig
 +++ b/net/netfilter/Kconfig
-@@ -227,7 +227,6 @@ config NF_CONNTRACK_FTP
+@@ -228,7 +228,6 @@ config NF_CONNTRACK_FTP
  
  config NF_CONNTRACK_H323
  	tristate "H.323 protocol support"
@@ -17,7 +17,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	depends on NETFILTER_ADVANCED
  	help
  	  H.323 is a VoIP signalling protocol from ITU-T. As one of the most
-@@ -1071,7 +1070,6 @@ config NETFILTER_XT_TARGET_SECMARK
+@@ -1072,7 +1071,6 @@ config NETFILTER_XT_TARGET_SECMARK
  
  config NETFILTER_XT_TARGET_TCPMSS
  	tristate '"TCPMSS" target support'
diff -uprN a/target/linux/generic/hack-5.10/251-kconfig.patch b/target/linux/generic/hack-5.10/251-kconfig.patch
--- a/target/linux/generic/hack-5.10/251-kconfig.patch	2024-03-18 15:15:11.365397125 +0800
+++ b/target/linux/generic/hack-5.10/251-kconfig.patch	2024-03-18 15:16:24.554604797 +0800
@@ -16,7 +16,7 @@ Signed-off-by: John Crispin <john@phroze
 
 --- a/crypto/Kconfig
 +++ b/crypto/Kconfig
-@@ -34,7 +34,7 @@ config CRYPTO_FIPS
+@@ -33,7 +33,7 @@ config CRYPTO_FIPS
  	  this is.
  
  config CRYPTO_ALGAPI
@@ -25,7 +25,7 @@ Signed-off-by: John Crispin <john@phroze
  	select CRYPTO_ALGAPI2
  	help
  	  This option provides the API for cryptographic algorithms.
-@@ -43,7 +43,7 @@ config CRYPTO_ALGAPI2
+@@ -42,7 +42,7 @@ config CRYPTO_ALGAPI2
  	tristate
  
  config CRYPTO_AEAD
@@ -34,7 +34,7 @@ Signed-off-by: John Crispin <john@phroze
  	select CRYPTO_AEAD2
  	select CRYPTO_ALGAPI
  
-@@ -54,7 +54,7 @@ config CRYPTO_AEAD2
+@@ -53,7 +53,7 @@ config CRYPTO_AEAD2
  	select CRYPTO_RNG2
  
  config CRYPTO_SKCIPHER
@@ -43,7 +43,7 @@ Signed-off-by: John Crispin <john@phroze
  	select CRYPTO_SKCIPHER2
  	select CRYPTO_ALGAPI
  
-@@ -64,7 +64,7 @@ config CRYPTO_SKCIPHER2
+@@ -63,7 +63,7 @@ config CRYPTO_SKCIPHER2
  	select CRYPTO_RNG2
  
  config CRYPTO_HASH
@@ -52,7 +52,7 @@ Signed-off-by: John Crispin <john@phroze
  	select CRYPTO_HASH2
  	select CRYPTO_ALGAPI
  
-@@ -73,7 +73,7 @@ config CRYPTO_HASH2
+@@ -72,7 +72,7 @@ config CRYPTO_HASH2
  	select CRYPTO_ALGAPI2
  
  config CRYPTO_RNG
@@ -92,7 +92,7 @@ Signed-off-by: John Crispin <john@phroze
  	bool
 --- a/lib/Kconfig
 +++ b/lib/Kconfig
-@@ -423,16 +423,16 @@ config BCH_CONST_T
+@@ -418,16 +418,16 @@ config BCH_CONST_T
  # Textsearch support is select'ed if needed
  #
  config TEXTSEARCH
@@ -197,14 +197,3 @@ Signed-off-by: John Crispin <john@phroze
  
  config SND_JACK
  	bool
---- a/net/Kconfig
-+++ b/net/Kconfig
-@@ -436,7 +436,7 @@ config NET_DEVLINK
- 	default n
- 
- config PAGE_POOL
--	bool
-+	bool "Page pool support"
- 
- config FAILOVER
- 	tristate "Generic failover module"
diff -uprN a/target/linux/generic/hack-5.10/252-SATA_PMP.patch b/target/linux/generic/hack-5.10/252-SATA_PMP.patch
--- a/target/linux/generic/hack-5.10/252-SATA_PMP.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/252-SATA_PMP.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,23 @@
+From 8c817e33be829c7249c2cfd59ff48ad5fac6a31d Mon Sep 17 00:00:00 2001
+From: Sungbo Eo <mans0n@gorani.run>
+Date: Fri, 7 Jul 2017 17:09:21 +0200
+Subject: [PATCH] kconfig: solidify SATA_PMP config
+
+SATA_PMP option in kernel config file disappears for every kernel_oldconfig refresh.
+To prevent this, SATA_HOST is now selected automatically when SATA_PMP is enabled.
+This patch can be dropped if SATA_MV is ever re-added into the config.
+---
+ drivers/ata/Kconfig | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/ata/Kconfig
++++ b/drivers/ata/Kconfig
+@@ -112,7 +112,7 @@ config SATA_ZPODD
+ 
+ config SATA_PMP
+ 	bool "SATA Port Multiplier support"
+-	depends on SATA_HOST
++	select SATA_HOST
+ 	default y
+ 	help
+ 	  This option adds support for SATA Port Multipliers
diff -uprN a/target/linux/generic/hack-5.10/253-ksmbd-config.patch b/target/linux/generic/hack-5.10/253-ksmbd-config.patch
--- a/target/linux/generic/hack-5.10/253-ksmbd-config.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/253-ksmbd-config.patch	2024-03-18 15:16:24.574604033 +0800
@@ -1,6 +1,6 @@
 --- a/init/Kconfig
 +++ b/init/Kconfig
-@@ -2384,7 +2384,7 @@ config PADATA
+@@ -2379,7 +2379,7 @@ config PADATA
  	bool
  
  config ASN1
@@ -11,7 +11,7 @@
  	  that can be interpreted by the ASN.1 stream decoder and used to
 --- a/lib/Kconfig
 +++ b/lib/Kconfig
-@@ -594,7 +594,7 @@ config LIBFDT
+@@ -589,7 +589,7 @@ config LIBFDT
  	bool
  
  config OID_REGISTRY
diff -uprN a/target/linux/generic/hack-5.10/260-crypto_test_dependencies.patch b/target/linux/generic/hack-5.10/260-crypto_test_dependencies.patch
--- a/target/linux/generic/hack-5.10/260-crypto_test_dependencies.patch	2024-03-18 15:15:11.389396208 +0800
+++ b/target/linux/generic/hack-5.10/260-crypto_test_dependencies.patch	2024-03-18 15:16:24.578603881 +0800
@@ -14,7 +14,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/crypto/Kconfig
 +++ b/crypto/Kconfig
-@@ -121,13 +121,13 @@ config CRYPTO_MANAGER
+@@ -120,13 +120,13 @@ config CRYPTO_MANAGER
  	  cbc(aes).
  
  config CRYPTO_MANAGER2
diff -uprN a/target/linux/generic/hack-5.10/261-lib-arc4-unhide.patch b/target/linux/generic/hack-5.10/261-lib-arc4-unhide.patch
--- a/target/linux/generic/hack-5.10/261-lib-arc4-unhide.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/261-lib-arc4-unhide.patch	2024-03-18 15:16:24.574604033 +0800
@@ -12,4 +12,4 @@ from backports.
 +	tristate "ARC4 cipher library"
  
  config CRYPTO_ARCH_HAVE_LIB_BLAKE2S
- 	bool
+ 	tristate
diff -uprN a/target/linux/generic/hack-5.10/312-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch b/target/linux/generic/hack-5.10/312-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch
--- a/target/linux/generic/hack-5.10/312-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/312-arm64-cpuinfo-Add-model-name-in-proc-cpuinfo-for-64bit-ta.patch	2024-03-18 15:16:24.550604950 +0800
@@ -0,0 +1,38 @@
+From: Sumit Gupta <sumitg@nvidia.com>
+To: <catalin.marinas@arm.com>, <linux-arm-kernel@lists.infradead.org>,
+	<linux-kernel@vger.kernel.org>
+Cc: <will.deacon@arm.com>, <suzuki.poulose@arm.com>,
+	<james.morse@arm.com>, <mark.rutland@arm.com>,
+	<yang.shi@linaro.org>, <julien.grall@arm.com>,
+	<steve.capper@linaro.org>, <bbasu@nvidia.com>,
+	<linux-tegra@vger.kernel.org>, Sumit Gupta <sumitg@nvidia.com>
+Subject: [PATCH] arm64: cpuinfo: Add "model name" in /proc/cpuinfo for 64bit tasks also
+Date: Mon, 29 Aug 2016 14:32:25 +0530
+Message-ID: <1472461345-28219-1-git-send-email-sumitg@nvidia.com> (raw)
+
+Removed restriction of displaying model name for 32 bit tasks only.
+Because of this Processor details were not displayed in
+"System setting -> Details" in Ubuntu model name display is generic
+and can be printed for 64 bit also.
+
+model name : ARMv8 Processor rev X (v8l)
+
+Signed-off-by: Sumit Gupta <sumitg@nvidia.com>
+---
+ arch/arm64/kernel/cpuinfo.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/arch/arm64/kernel/cpuinfo.c
++++ b/arch/arm64/kernel/cpuinfo.c
+@@ -148,9 +148,8 @@ static int c_show(struct seq_file *m, vo
+ 		 * "processor".  Give glibc what it expects.
+ 		 */
+ 		seq_printf(m, "processor\t: %d\n", i);
+-		if (compat)
+-			seq_printf(m, "model name\t: ARMv8 Processor rev %d (%s)\n",
+-				   MIDR_REVISION(midr), COMPAT_ELF_PLATFORM);
++		seq_printf(m, "model name\t: ARMv8 Processor rev %d (%s)\n",
++			   MIDR_REVISION(midr), COMPAT_ELF_PLATFORM);
+ 
+ 		seq_printf(m, "BogoMIPS\t: %lu.%02lu\n",
+ 			   loops_per_jiffy / (500000UL/HZ),
diff -uprN a/target/linux/generic/hack-5.10/321-powerpc_crtsavres_prereq.patch b/target/linux/generic/hack-5.10/321-powerpc_crtsavres_prereq.patch
--- a/target/linux/generic/hack-5.10/321-powerpc_crtsavres_prereq.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/321-powerpc_crtsavres_prereq.patch	2024-03-18 15:16:24.574604033 +0800
@@ -16,7 +16,7 @@ Signed-off-by: Alexandros C. Couloumbis
 
 --- a/arch/powerpc/Makefile
 +++ b/arch/powerpc/Makefile
-@@ -44,19 +44,6 @@ machine-$(CONFIG_PPC64) += 64
+@@ -61,19 +61,6 @@ machine-$(CONFIG_PPC64) += 64
  machine-$(CONFIG_CPU_LITTLE_ENDIAN) += le
  UTS_MACHINE := $(subst $(space),,$(machine-y))
  
diff -uprN a/target/linux/generic/hack-5.10/402-mtd-blktrans-call-add-disks-after-mtd-device.patch b/target/linux/generic/hack-5.10/402-mtd-blktrans-call-add-disks-after-mtd-device.patch
--- a/target/linux/generic/hack-5.10/402-mtd-blktrans-call-add-disks-after-mtd-device.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/402-mtd-blktrans-call-add-disks-after-mtd-device.patch	2024-03-18 15:16:24.578603881 +0800
@@ -77,7 +77,7 @@ Signed-off-by: Daniel Golle <daniel@makr
  
  #include "mtdcore.h"
  
-@@ -853,6 +854,8 @@ int mtd_device_parse_register(struct mtd
+@@ -851,6 +852,8 @@ int mtd_device_parse_register(struct mtd
  		register_reboot_notifier(&mtd->reboot_notifier);
  	}
  
diff -uprN a/target/linux/generic/hack-5.10/410-block-fit-partition-parser.patch b/target/linux/generic/hack-5.10/410-block-fit-partition-parser.patch
--- a/target/linux/generic/hack-5.10/410-block-fit-partition-parser.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/410-block-fit-partition-parser.patch	2024-03-18 15:16:24.574604033 +0800
@@ -1,10 +1,11 @@
 --- a/block/blk.h
 +++ b/block/blk.h
-@@ -361,6 +361,7 @@ char *disk_name(struct gendisk *hd, int
+@@ -361,6 +361,8 @@ char *disk_name(struct gendisk *hd, int
  #define ADDPART_FLAG_NONE	0
  #define ADDPART_FLAG_RAID	1
  #define ADDPART_FLAG_WHOLEDISK	2
-+#define ADDPART_FLAG_ROOTDEV	4
++#define ADDPART_FLAG_READONLY	4
++#define ADDPART_FLAG_ROOTDEV	8
  void delete_partition(struct hd_struct *part);
  int bdev_add_partition(struct block_device *bdev, int partno,
  		sector_t start, sector_t length);
@@ -73,48 +74,16 @@
  #ifdef CONFIG_SGI_PARTITION
  	sgi_partition,
  #endif
-@@ -215,6 +222,18 @@ static ssize_t part_discard_alignment_sh
- 				p->start_sect));
- }
- 
-+static ssize_t part_name_show(struct device *dev,
-+			      struct device_attribute *attr, char *buf)
-+{
-+	struct hd_struct *p = dev_to_part(dev);
-+
-+	if (p->info && p->info->volname)
-+		return sprintf(buf, "%s\n", p->info->volname);
-+
-+	buf[0] = '\0';
-+	return 0;
-+}
-+
- static DEVICE_ATTR(partition, 0444, part_partition_show, NULL);
- static DEVICE_ATTR(start, 0444, part_start_show, NULL);
- static DEVICE_ATTR(size, 0444, part_size_show, NULL);
-@@ -223,6 +242,7 @@ static DEVICE_ATTR(alignment_offset, 044
- static DEVICE_ATTR(discard_alignment, 0444, part_discard_alignment_show, NULL);
- static DEVICE_ATTR(stat, 0444, part_stat_show, NULL);
- static DEVICE_ATTR(inflight, 0444, part_inflight_show, NULL);
-+static DEVICE_ATTR(name, 0444, part_name_show, NULL);
- #ifdef CONFIG_FAIL_MAKE_REQUEST
- static struct device_attribute dev_attr_fail =
- 	__ATTR(make-it-fail, 0644, part_fail_show, part_fail_store);
-@@ -237,6 +257,7 @@ static struct attribute *part_attrs[] =
- 	&dev_attr_discard_alignment.attr,
- 	&dev_attr_stat.attr,
- 	&dev_attr_inflight.attr,
-+	&dev_attr_name.attr,
- #ifdef CONFIG_FAIL_MAKE_REQUEST
- 	&dev_attr_fail.attr,
- #endif
-@@ -701,6 +722,11 @@ static bool blk_add_partition(struct gen
+@@ -694,6 +701,14 @@ static bool blk_add_partition(struct gen
  	    (state->parts[p].flags & ADDPART_FLAG_RAID))
  		md_autodetect_dev(part_to_dev(part)->devt);
  
 +#ifdef CONFIG_FIT_PARTITION
 +	if ((state->parts[p].flags & ADDPART_FLAG_ROOTDEV) && ROOT_DEV == 0)
 +		ROOT_DEV = part_to_dev(part)->devt;
++
++	if (state->parts[p].flags & ADDPART_FLAG_READONLY)
++		part->policy = true;
 +#endif
 +
  	return true;
@@ -187,7 +156,7 @@
  	.name		= "mtdblock",
  	.major		= MTD_BLOCK_MAJOR,
 +#ifdef CONFIG_FIT_PARTITION
-+	.part_bits	= 1,
++	.part_bits	= 2,
 +#else
  	.part_bits	= 0,
 +#endif
diff -uprN a/target/linux/generic/hack-5.10/420-mtd-set-rootfs-to-be-root-dev.patch b/target/linux/generic/hack-5.10/420-mtd-set-rootfs-to-be-root-dev.patch
--- a/target/linux/generic/hack-5.10/420-mtd-set-rootfs-to-be-root-dev.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/420-mtd-set-rootfs-to-be-root-dev.patch	2024-03-18 15:16:24.574604033 +0800
@@ -20,7 +20,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
  #include <linux/nvmem-provider.h>
  
  #include <linux/mtd/mtd.h>
-@@ -696,6 +697,19 @@ int add_mtd_device(struct mtd_info *mtd)
+@@ -694,6 +695,19 @@ int add_mtd_device(struct mtd_info *mtd)
  	   of this try_ nonsense, and no bitching about it
  	   either. :) */
  	__module_get(THIS_MODULE);
@@ -32,7 +32,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
 +		pr_notice("mtd: device %d (%s) set to be root filesystem\n",
 +			  mtd->index, mtd->name);
 +#ifdef CONFIG_FIT_PARTITION
-+		index <<= 1;
++		index <<= 2;
 +#endif
 +		ROOT_DEV = MKDEV(MTD_BLOCK_MAJOR, index);
 +	}
diff -uprN a/target/linux/generic/hack-5.10/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch b/target/linux/generic/hack-5.10/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch
--- a/target/linux/generic/hack-5.10/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/421-drivers-mtd-parsers-add-nvmem-support-to-cmdlinepart.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,120 @@
+From 6fa9e3678eb002246df1280322b6a024853950a5 Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Mon, 11 Oct 2021 00:53:14 +0200
+Subject: [PATCH] drivers: mtd: parsers: add nvmem support to cmdlinepart
+
+Assuming cmdlinepart is only one level deep partition scheme and that
+static partition are also defined in DTS, we can assign an of_node for
+partition declared from bootargs. cmdlinepart have priority than
+fiexed-partition parser so in this specific case the parser doesn't
+assign an of_node. Fix this by searching a defined of_node using a
+similar fixed_partition parser and if a partition is found with the same
+label, check that it has the same offset and size and return the DT
+of_node to correctly use NVMEM cells.
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ drivers/mtd/parsers/cmdlinepart.c | 71 +++++++++++++++++++++++++++++++
+ 1 file changed, 71 insertions(+)
+
+--- a/drivers/mtd/parsers/cmdlinepart.c
++++ b/drivers/mtd/parsers/cmdlinepart.c
+@@ -43,6 +43,7 @@
+ #include <linux/mtd/partitions.h>
+ #include <linux/module.h>
+ #include <linux/err.h>
++#include <linux/of.h>
+ 
+ /* debug macro */
+ #if 0
+@@ -323,6 +324,68 @@ static int mtdpart_setup_real(char *s)
+ 	return 0;
+ }
+ 
++static int search_fixed_partition(struct mtd_info *master,
++				  struct mtd_partition *target_part,
++				  struct mtd_partition *fixed_part)
++{
++	struct device_node *mtd_node;
++	struct device_node *ofpart_node;
++	struct device_node *pp;
++	struct mtd_partition part;
++	const char *partname;
++
++	mtd_node = mtd_get_of_node(master);
++	if (!mtd_node)
++		return -EINVAL;
++
++	ofpart_node = of_get_child_by_name(mtd_node, "partitions");
++
++	for_each_child_of_node(ofpart_node,  pp) {
++		const __be32 *reg;
++		int len;
++		int a_cells, s_cells;
++
++		reg = of_get_property(pp, "reg", &len);
++		if (!reg) {
++			pr_debug("%s: ofpart partition %pOF (%pOF) missing reg property.\n",
++				 master->name, pp,
++				 mtd_node);
++			continue;
++		}
++
++		a_cells = of_n_addr_cells(pp);
++		s_cells = of_n_size_cells(pp);
++		if (len / 4 != a_cells + s_cells) {
++			pr_debug("%s: ofpart partition %pOF (%pOF) error parsing reg property.\n",
++				 master->name, pp,
++				 mtd_node);
++			continue;
++		}
++
++		part.offset = of_read_number(reg, a_cells);
++		part.size = of_read_number(reg + a_cells, s_cells);
++		part.of_node = pp;
++
++		partname = of_get_property(pp, "label", &len);
++		if (!partname)
++			partname = of_get_property(pp, "name", &len);
++		part.name = partname;
++
++		if (!strncmp(target_part->name, part.name, len)) {
++			if (part.offset != target_part->offset)
++				return -EINVAL;
++
++			if (part.size != target_part->size)
++				return -EINVAL;
++
++			memcpy(fixed_part, &part, sizeof(struct mtd_partition));
++			return 0;
++		}
++	}
++
++	return -EINVAL;
++}
++
+ /*
+  * Main function to be called from the MTD mapping driver/device to
+  * obtain the partitioning information. At this point the command line
+@@ -338,6 +401,7 @@ static int parse_cmdline_partitions(stru
+ 	int i, err;
+ 	struct cmdline_mtd_partition *part;
+ 	const char *mtd_id = master->name;
++	struct mtd_partition fixed_part;
+ 
+ 	/* parse command line */
+ 	if (!cmdline_parsed) {
+@@ -382,6 +446,13 @@ static int parse_cmdline_partitions(stru
+ 				sizeof(*part->parts) * (part->num_parts - i));
+ 			i--;
+ 		}
++
++		err = search_fixed_partition(master, &part->parts[i], &fixed_part);
++		if (!err) {
++			part->parts[i].of_node = fixed_part.of_node;
++			pr_info("Found partition defined in DT for %s. Assigning OF node to support nvmem.",
++				part->parts[i].name);
++		}
+ 	}
+ 
+ 	*pparts = kmemdup(part->parts, sizeof(*part->parts) * part->num_parts,
diff -uprN a/target/linux/generic/hack-5.10/430-mtk-bmt-support.patch b/target/linux/generic/hack-5.10/430-mtk-bmt-support.patch
--- a/target/linux/generic/hack-5.10/430-mtk-bmt-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/430-mtk-bmt-support.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,23 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -15,6 +15,10 @@ config MTD_NAND_ECC
+        bool
+        depends on MTD_NAND_CORE
+ 
++config MTD_NAND_MTK_BMT
++	bool "Support MediaTek NAND Bad-block Management Table"
++	default n
++
+ endmenu
+ 
+ endmenu
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -2,6 +2,7 @@
+ 
+ nandcore-objs := core.o bbt.o
+ obj-$(CONFIG_MTD_NAND_CORE) += nandcore.o
++obj-$(CONFIG_MTD_NAND_MTK_BMT)	+= mtk_bmt.o mtk_bmt_v2.o mtk_bmt_bbt.o mtk_bmt_nmbm.o
+ 
+ obj-y	+= onenand/
+ obj-y	+= raw/
diff -uprN a/target/linux/generic/hack-5.10/531-debloat_lzma.patch b/target/linux/generic/hack-5.10/531-debloat_lzma.patch
--- a/target/linux/generic/hack-5.10/531-debloat_lzma.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/531-debloat_lzma.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,1040 @@
+From 3fd297761ac246c54d7723c57fca95c112b99465 Mon Sep 17 00:00:00 2001
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 15 Jul 2017 21:15:44 +0200
+Subject: lzma: de-bloat the lzma library used by jffs2
+
+lede-commit: 3fd1dd08fbcbb78b34efefd32c3032e5c99108d6
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+ include/linux/lzma/LzFind.h  |  17 ---
+ include/linux/lzma/LzmaDec.h | 101 ---------------
+ include/linux/lzma/LzmaEnc.h |  20 ---
+ lib/lzma/LzFind.c            | 287 ++++---------------------------------------
+ lib/lzma/LzmaDec.c           |  86 +------------
+ lib/lzma/LzmaEnc.c           | 172 ++------------------------
+ 6 files changed, 42 insertions(+), 641 deletions(-)
+
+--- a/include/linux/lzma/LzFind.h
++++ b/include/linux/lzma/LzFind.h
+@@ -55,11 +55,6 @@ typedef struct _CMatchFinder
+ 
+ #define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
+ 
+-int MatchFinder_NeedMove(CMatchFinder *p);
+-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
+-void MatchFinder_MoveBlock(CMatchFinder *p);
+-void MatchFinder_ReadIfRequired(CMatchFinder *p);
+-
+ void MatchFinder_Construct(CMatchFinder *p);
+ 
+ /* Conditions:
+@@ -70,12 +65,6 @@ int MatchFinder_Create(CMatchFinder *p,
+     UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
+     ISzAlloc *alloc);
+ void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
+-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
+-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
+-
+-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
+-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
+-    UInt32 *distances, UInt32 maxLen);
+ 
+ /*
+ Conditions:
+@@ -102,12 +91,6 @@ typedef struct _IMatchFinder
+ 
+ void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
+ 
+-void MatchFinder_Init(CMatchFinder *p);
+-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
+-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
+-
+ #ifdef __cplusplus
+ }
+ #endif
+--- a/include/linux/lzma/LzmaDec.h
++++ b/include/linux/lzma/LzmaDec.h
+@@ -31,14 +31,6 @@ typedef struct _CLzmaProps
+   UInt32 dicSize;
+ } CLzmaProps;
+ 
+-/* LzmaProps_Decode - decodes properties
+-Returns:
+-  SZ_OK
+-  SZ_ERROR_UNSUPPORTED - Unsupported properties
+-*/
+-
+-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
+-
+ 
+ /* ---------- LZMA Decoder state ---------- */
+ 
+@@ -70,8 +62,6 @@ typedef struct
+ 
+ #define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
+ 
+-void LzmaDec_Init(CLzmaDec *p);
+-
+ /* There are two types of LZMA streams:
+      0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
+      1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
+@@ -108,97 +98,6 @@ typedef enum
+ 
+ /* ELzmaStatus is used only as output value for function call */
+ 
+-
+-/* ---------- Interfaces ---------- */
+-
+-/* There are 3 levels of interfaces:
+-     1) Dictionary Interface
+-     2) Buffer Interface
+-     3) One Call Interface
+-   You can select any of these interfaces, but don't mix functions from different
+-   groups for same object. */
+-
+-
+-/* There are two variants to allocate state for Dictionary Interface:
+-     1) LzmaDec_Allocate / LzmaDec_Free
+-     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
+-   You can use variant 2, if you set dictionary buffer manually.
+-   For Buffer Interface you must always use variant 1.
+-
+-LzmaDec_Allocate* can return:
+-  SZ_OK
+-  SZ_ERROR_MEM         - Memory allocation error
+-  SZ_ERROR_UNSUPPORTED - Unsupported properties
+-*/
+-
+-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
+-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
+-
+-SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
+-void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
+-
+-/* ---------- Dictionary Interface ---------- */
+-
+-/* You can use it, if you want to eliminate the overhead for data copying from
+-   dictionary to some other external buffer.
+-   You must work with CLzmaDec variables directly in this interface.
+-
+-   STEPS:
+-     LzmaDec_Constr()
+-     LzmaDec_Allocate()
+-     for (each new stream)
+-     {
+-       LzmaDec_Init()
+-       while (it needs more decompression)
+-       {
+-         LzmaDec_DecodeToDic()
+-         use data from CLzmaDec::dic and update CLzmaDec::dicPos
+-       }
+-     }
+-     LzmaDec_Free()
+-*/
+-
+-/* LzmaDec_DecodeToDic
+-
+-   The decoding to internal dictionary buffer (CLzmaDec::dic).
+-   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
+-
+-finishMode:
+-  It has meaning only if the decoding reaches output limit (dicLimit).
+-  LZMA_FINISH_ANY - Decode just dicLimit bytes.
+-  LZMA_FINISH_END - Stream must be finished after dicLimit.
+-
+-Returns:
+-  SZ_OK
+-    status:
+-      LZMA_STATUS_FINISHED_WITH_MARK
+-      LZMA_STATUS_NOT_FINISHED
+-      LZMA_STATUS_NEEDS_MORE_INPUT
+-      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
+-  SZ_ERROR_DATA - Data error
+-*/
+-
+-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
+-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+-
+-
+-/* ---------- Buffer Interface ---------- */
+-
+-/* It's zlib-like interface.
+-   See LzmaDec_DecodeToDic description for information about STEPS and return results,
+-   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
+-   to work with CLzmaDec variables manually.
+-
+-finishMode:
+-  It has meaning only if the decoding reaches output limit (*destLen).
+-  LZMA_FINISH_ANY - Decode just destLen bytes.
+-  LZMA_FINISH_END - Stream must be finished after (*destLen).
+-*/
+-
+-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
+-    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
+-
+-
+ /* ---------- One Call Interface ---------- */
+ 
+ /* LzmaDecode
+--- a/include/linux/lzma/LzmaEnc.h
++++ b/include/linux/lzma/LzmaEnc.h
+@@ -31,9 +31,6 @@ typedef struct _CLzmaEncProps
+ } CLzmaEncProps;
+ 
+ void LzmaEncProps_Init(CLzmaEncProps *p);
+-void LzmaEncProps_Normalize(CLzmaEncProps *p);
+-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
+-
+ 
+ /* ---------- CLzmaEncHandle Interface ---------- */
+ 
+@@ -53,26 +50,9 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
+ void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
+ SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
+ SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
+-SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+ SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+     int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+ 
+-/* ---------- One Call Interface ---------- */
+-
+-/* LzmaEncode
+-Return code:
+-  SZ_OK               - OK
+-  SZ_ERROR_MEM        - Memory allocation error
+-  SZ_ERROR_PARAM      - Incorrect paramater
+-  SZ_ERROR_OUTPUT_EOF - output buffer overflow
+-  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
+-*/
+-
+-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
+-
+ #ifdef __cplusplus
+ }
+ #endif
+--- a/lib/lzma/LzFind.c
++++ b/lib/lzma/LzFind.c
+@@ -14,9 +14,15 @@
+ 
+ #define kStartMaxLen 3
+ 
++#if 0
++#define DIRECT_INPUT	p->directInput
++#else
++#define DIRECT_INPUT	1
++#endif
++
+ static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
+ {
+-  if (!p->directInput)
++  if (!DIRECT_INPUT)
+   {
+     alloc->Free(alloc, p->bufferBase);
+     p->bufferBase = 0;
+@@ -28,7 +34,7 @@ static void LzInWindow_Free(CMatchFinder
+ static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
+ {
+   UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+   {
+     p->blockSize = blockSize;
+     return 1;
+@@ -42,12 +48,12 @@ static int LzInWindow_Create(CMatchFinde
+   return (p->bufferBase != 0);
+ }
+ 
+-Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
+-Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
+ 
+-UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
+ 
+-void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
+ {
+   p->posLimit -= subValue;
+   p->pos -= subValue;
+@@ -58,7 +64,7 @@ static void MatchFinder_ReadBlock(CMatch
+ {
+   if (p->streamEndWasReached || p->result != SZ_OK)
+     return;
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+   {
+     UInt32 curSize = 0xFFFFFFFF - p->streamPos;
+     if (curSize > p->directInputRem)
+@@ -89,7 +95,7 @@ static void MatchFinder_ReadBlock(CMatch
+   }
+ }
+ 
+-void MatchFinder_MoveBlock(CMatchFinder *p)
++static void MatchFinder_MoveBlock(CMatchFinder *p)
+ {
+   memmove(p->bufferBase,
+     p->buffer - p->keepSizeBefore,
+@@ -97,22 +103,14 @@ void MatchFinder_MoveBlock(CMatchFinder
+   p->buffer = p->bufferBase + p->keepSizeBefore;
+ }
+ 
+-int MatchFinder_NeedMove(CMatchFinder *p)
++static int MatchFinder_NeedMove(CMatchFinder *p)
+ {
+-  if (p->directInput)
++  if (DIRECT_INPUT)
+     return 0;
+   /* if (p->streamEndWasReached) return 0; */
+   return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
+ }
+ 
+-void MatchFinder_ReadIfRequired(CMatchFinder *p)
+-{
+-  if (p->streamEndWasReached)
+-    return;
+-  if (p->keepSizeAfter >= p->streamPos - p->pos)
+-    MatchFinder_ReadBlock(p);
+-}
+-
+ static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
+ {
+   if (MatchFinder_NeedMove(p))
+@@ -268,7 +266,7 @@ static void MatchFinder_SetLimits(CMatch
+   p->posLimit = p->pos + limit;
+ }
+ 
+-void MatchFinder_Init(CMatchFinder *p)
++static void MatchFinder_Init(CMatchFinder *p)
+ {
+   UInt32 i;
+   for (i = 0; i < p->hashSizeSum; i++)
+@@ -287,7 +285,7 @@ static UInt32 MatchFinder_GetSubValue(CM
+   return (p->pos - p->historySize - 1) & kNormalizeMask;
+ }
+ 
+-void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
+ {
+   UInt32 i;
+   for (i = 0; i < numItems; i++)
+@@ -319,38 +317,7 @@ static void MatchFinder_CheckLimits(CMat
+   MatchFinder_SetLimits(p);
+ }
+ 
+-static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+-    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+-    UInt32 *distances, UInt32 maxLen)
+-{
+-  son[_cyclicBufferPos] = curMatch;
+-  for (;;)
+-  {
+-    UInt32 delta = pos - curMatch;
+-    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
+-      return distances;
+-    {
+-      const Byte *pb = cur - delta;
+-      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
+-      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
+-      {
+-        UInt32 len = 0;
+-        while (++len != lenLimit)
+-          if (pb[len] != cur[len])
+-            break;
+-        if (maxLen < len)
+-        {
+-          *distances++ = maxLen = len;
+-          *distances++ = delta - 1;
+-          if (len == lenLimit)
+-            return distances;
+-        }
+-      }
+-    }
+-  }
+-}
+-
+-UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
+     UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
+     UInt32 *distances, UInt32 maxLen)
+ {
+@@ -460,10 +427,10 @@ static void SkipMatchesSpec(UInt32 lenLi
+   p->buffer++; \
+   if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
+ 
+-#define MOVE_POS_RET MOVE_POS return offset;
+-
+ static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
+ 
++#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
++
+ #define GET_MATCHES_HEADER2(minLen, ret_op) \
+   UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
+   lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
+@@ -479,62 +446,7 @@ static void MatchFinder_MovePos(CMatchFi
+   distances + offset, maxLen) - distances); MOVE_POS_RET;
+ 
+ #define SKIP_FOOTER \
+-  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
+-
+-static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(2)
+-  HASH2_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = 0;
+-  GET_MATCHES_FOOTER(offset, 1)
+-}
+-
+-UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(3)
+-  HASH_ZIP_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = 0;
+-  GET_MATCHES_FOOTER(offset, 2)
+-}
+-
+-static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 hash2Value, delta2, maxLen, offset;
+-  GET_MATCHES_HEADER(3)
+-
+-  HASH3_CALC;
+-
+-  delta2 = p->pos - p->hash[hash2Value];
+-  curMatch = p->hash[kFix3HashSize + hashValue];
+-
+-  p->hash[hash2Value] =
+-  p->hash[kFix3HashSize + hashValue] = p->pos;
+-
+-
+-  maxLen = 2;
+-  offset = 0;
+-  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+-  {
+-    for (; maxLen != lenLimit; maxLen++)
+-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+-        break;
+-    distances[0] = maxLen;
+-    distances[1] = delta2 - 1;
+-    offset = 2;
+-    if (maxLen == lenLimit)
+-    {
+-      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
+-      MOVE_POS_RET;
+-    }
+-  }
+-  GET_MATCHES_FOOTER(offset, maxLen)
+-}
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
+ 
+ static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+ {
+@@ -583,108 +495,6 @@ static UInt32 Bt4_MatchFinder_GetMatches
+   GET_MATCHES_FOOTER(offset, maxLen)
+ }
+ 
+-static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
+-  GET_MATCHES_HEADER(4)
+-
+-  HASH4_CALC;
+-
+-  delta2 = p->pos - p->hash[                hash2Value];
+-  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
+-  curMatch = p->hash[kFix4HashSize + hashValue];
+-
+-  p->hash[                hash2Value] =
+-  p->hash[kFix3HashSize + hash3Value] =
+-  p->hash[kFix4HashSize + hashValue] = p->pos;
+-
+-  maxLen = 1;
+-  offset = 0;
+-  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
+-  {
+-    distances[0] = maxLen = 2;
+-    distances[1] = delta2 - 1;
+-    offset = 2;
+-  }
+-  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
+-  {
+-    maxLen = 3;
+-    distances[offset + 1] = delta3 - 1;
+-    offset += 2;
+-    delta2 = delta3;
+-  }
+-  if (offset != 0)
+-  {
+-    for (; maxLen != lenLimit; maxLen++)
+-      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
+-        break;
+-    distances[offset - 2] = maxLen;
+-    if (maxLen == lenLimit)
+-    {
+-      p->son[p->cyclicBufferPos] = curMatch;
+-      MOVE_POS_RET;
+-    }
+-  }
+-  if (maxLen < 3)
+-    maxLen = 3;
+-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+-    distances + offset, maxLen) - (distances));
+-  MOVE_POS_RET
+-}
+-
+-UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
+-{
+-  UInt32 offset;
+-  GET_MATCHES_HEADER(3)
+-  HASH_ZIP_CALC;
+-  curMatch = p->hash[hashValue];
+-  p->hash[hashValue] = p->pos;
+-  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
+-    distances, 2) - (distances));
+-  MOVE_POS_RET
+-}
+-
+-static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(2)
+-    HASH2_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+-void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(3)
+-    HASH_ZIP_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+-static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    UInt32 hash2Value;
+-    SKIP_HEADER(3)
+-    HASH3_CALC;
+-    curMatch = p->hash[kFix3HashSize + hashValue];
+-    p->hash[hash2Value] =
+-    p->hash[kFix3HashSize + hashValue] = p->pos;
+-    SKIP_FOOTER
+-  }
+-  while (--num != 0);
+-}
+-
+ static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+ {
+   do
+@@ -701,61 +511,12 @@ static void Bt4_MatchFinder_Skip(CMatchF
+   while (--num != 0);
+ }
+ 
+-static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    UInt32 hash2Value, hash3Value;
+-    SKIP_HEADER(4)
+-    HASH4_CALC;
+-    curMatch = p->hash[kFix4HashSize + hashValue];
+-    p->hash[                hash2Value] =
+-    p->hash[kFix3HashSize + hash3Value] =
+-    p->hash[kFix4HashSize + hashValue] = p->pos;
+-    p->son[p->cyclicBufferPos] = curMatch;
+-    MOVE_POS
+-  }
+-  while (--num != 0);
+-}
+-
+-void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
+-{
+-  do
+-  {
+-    SKIP_HEADER(3)
+-    HASH_ZIP_CALC;
+-    curMatch = p->hash[hashValue];
+-    p->hash[hashValue] = p->pos;
+-    p->son[p->cyclicBufferPos] = curMatch;
+-    MOVE_POS
+-  }
+-  while (--num != 0);
+-}
+-
+ void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
+ {
+   vTable->Init = (Mf_Init_Func)MatchFinder_Init;
+   vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
+   vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
+   vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
+-  if (!p->btMode)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
+-  }
+-  else if (p->numHashBytes == 2)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
+-  }
+-  else if (p->numHashBytes == 3)
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
+-  }
+-  else
+-  {
+-    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
+-    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+-  }
++  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
+ }
+--- a/lib/lzma/LzmaDec.c
++++ b/lib/lzma/LzmaDec.c
+@@ -682,7 +682,7 @@ static void LzmaDec_InitRc(CLzmaDec *p,
+   p->needFlush = 0;
+ }
+ 
+-void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
+ {
+   p->needFlush = 1;
+   p->remainLen = 0;
+@@ -698,7 +698,7 @@ void LzmaDec_InitDicAndState(CLzmaDec *p
+     p->needInitState = 1;
+ }
+ 
+-void LzmaDec_Init(CLzmaDec *p)
++static void LzmaDec_Init(CLzmaDec *p)
+ {
+   p->dicPos = 0;
+   LzmaDec_InitDicAndState(p, True, True);
+@@ -716,7 +716,7 @@ static void LzmaDec_InitStateReal(CLzmaD
+   p->needInitState = 0;
+ }
+ 
+-SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
+     ELzmaFinishMode finishMode, ELzmaStatus *status)
+ {
+   SizeT inSize = *srcLen;
+@@ -837,65 +837,13 @@ SRes LzmaDec_DecodeToDic(CLzmaDec *p, Si
+   return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
+ }
+ 
+-SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
+-{
+-  SizeT outSize = *destLen;
+-  SizeT inSize = *srcLen;
+-  *srcLen = *destLen = 0;
+-  for (;;)
+-  {
+-    SizeT inSizeCur = inSize, outSizeCur, dicPos;
+-    ELzmaFinishMode curFinishMode;
+-    SRes res;
+-    if (p->dicPos == p->dicBufSize)
+-      p->dicPos = 0;
+-    dicPos = p->dicPos;
+-    if (outSize > p->dicBufSize - dicPos)
+-    {
+-      outSizeCur = p->dicBufSize;
+-      curFinishMode = LZMA_FINISH_ANY;
+-    }
+-    else
+-    {
+-      outSizeCur = dicPos + outSize;
+-      curFinishMode = finishMode;
+-    }
+-
+-    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
+-    src += inSizeCur;
+-    inSize -= inSizeCur;
+-    *srcLen += inSizeCur;
+-    outSizeCur = p->dicPos - dicPos;
+-    memcpy(dest, p->dic + dicPos, outSizeCur);
+-    dest += outSizeCur;
+-    outSize -= outSizeCur;
+-    *destLen += outSizeCur;
+-    if (res != 0)
+-      return res;
+-    if (outSizeCur == 0 || outSize == 0)
+-      return SZ_OK;
+-  }
+-}
+-
+-void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
+ {
+   alloc->Free(alloc, p->probs);
+   p->probs = 0;
+ }
+ 
+-static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
+-{
+-  alloc->Free(alloc, p->dic);
+-  p->dic = 0;
+-}
+-
+-void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
+-{
+-  LzmaDec_FreeProbs(p, alloc);
+-  LzmaDec_FreeDict(p, alloc);
+-}
+-
+-SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
+ {
+   UInt32 dicSize;
+   Byte d;
+@@ -935,7 +883,7 @@ static SRes LzmaDec_AllocateProbs2(CLzma
+   return SZ_OK;
+ }
+ 
+-SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+ {
+   CLzmaProps propNew;
+   RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+@@ -943,28 +891,6 @@ SRes LzmaDec_AllocateProbs(CLzmaDec *p,
+   p->prop = propNew;
+   return SZ_OK;
+ }
+-
+-SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
+-{
+-  CLzmaProps propNew;
+-  SizeT dicBufSize;
+-  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
+-  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
+-  dicBufSize = propNew.dicSize;
+-  if (p->dic == 0 || dicBufSize != p->dicBufSize)
+-  {
+-    LzmaDec_FreeDict(p, alloc);
+-    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
+-    if (p->dic == 0)
+-    {
+-      LzmaDec_FreeProbs(p, alloc);
+-      return SZ_ERROR_MEM;
+-    }
+-  }
+-  p->dicBufSize = dicBufSize;
+-  p->prop = propNew;
+-  return SZ_OK;
+-}
+ 
+ SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
+     const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
+--- a/lib/lzma/LzmaEnc.c
++++ b/lib/lzma/LzmaEnc.c
+@@ -53,7 +53,7 @@ void LzmaEncProps_Init(CLzmaEncProps *p)
+   p->writeEndMark = 0;
+ }
+ 
+-void LzmaEncProps_Normalize(CLzmaEncProps *p)
++static void LzmaEncProps_Normalize(CLzmaEncProps *p)
+ {
+   int level = p->level;
+   if (level < 0) level = 5;
+@@ -76,7 +76,7 @@ void LzmaEncProps_Normalize(CLzmaEncProp
+       #endif
+ }
+ 
+-UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
+ {
+   CLzmaEncProps props = *props2;
+   LzmaEncProps_Normalize(&props);
+@@ -93,7 +93,7 @@ UInt32 LzmaEncProps_GetDictSize(const CL
+ 
+ #define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
+ 
+-UInt32 GetPosSlot1(UInt32 pos)
++static UInt32 GetPosSlot1(UInt32 pos)
+ {
+   UInt32 res;
+   BSR2_RET(pos, res);
+@@ -107,7 +107,7 @@ UInt32 GetPosSlot1(UInt32 pos)
+ #define kNumLogBits (9 + (int)sizeof(size_t) / 2)
+ #define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
+ 
+-void LzmaEnc_FastPosInit(Byte *g_FastPos)
++static void LzmaEnc_FastPosInit(Byte *g_FastPos)
+ {
+   int c = 2, slotFast;
+   g_FastPos[0] = 0;
+@@ -339,58 +339,6 @@ typedef struct
+   CSaveState saveState;
+ } CLzmaEnc;
+ 
+-void LzmaEnc_SaveState(CLzmaEncHandle pp)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  CSaveState *dest = &p->saveState;
+-  int i;
+-  dest->lenEnc = p->lenEnc;
+-  dest->repLenEnc = p->repLenEnc;
+-  dest->state = p->state;
+-
+-  for (i = 0; i < kNumStates; i++)
+-  {
+-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+-  }
+-  for (i = 0; i < kNumLenToPosStates; i++)
+-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+-  memcpy(dest->reps, p->reps, sizeof(p->reps));
+-  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
+-}
+-
+-void LzmaEnc_RestoreState(CLzmaEncHandle pp)
+-{
+-  CLzmaEnc *dest = (CLzmaEnc *)pp;
+-  const CSaveState *p = &dest->saveState;
+-  int i;
+-  dest->lenEnc = p->lenEnc;
+-  dest->repLenEnc = p->repLenEnc;
+-  dest->state = p->state;
+-
+-  for (i = 0; i < kNumStates; i++)
+-  {
+-    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
+-    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
+-  }
+-  for (i = 0; i < kNumLenToPosStates; i++)
+-    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
+-  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
+-  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
+-  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
+-  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
+-  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
+-  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
+-  memcpy(dest->reps, p->reps, sizeof(p->reps));
+-  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
+-}
+-
+ SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -600,7 +548,7 @@ static void LitEnc_EncodeMatched(CRangeE
+   while (symbol < 0x10000);
+ }
+ 
+-void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
+ {
+   UInt32 i;
+   for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
+@@ -1676,7 +1624,7 @@ static void FillDistancesPrices(CLzmaEnc
+   p->matchPriceCount = 0;
+ }
+ 
+-void LzmaEnc_Construct(CLzmaEnc *p)
++static void LzmaEnc_Construct(CLzmaEnc *p)
+ {
+   RangeEnc_Construct(&p->rc);
+   MatchFinder_Construct(&p->matchFinderBase);
+@@ -1709,7 +1657,7 @@ CLzmaEncHandle LzmaEnc_Create(ISzAlloc *
+   return p;
+ }
+ 
+-void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
+ {
+   alloc->Free(alloc, p->litProbs);
+   alloc->Free(alloc, p->saveState.litProbs);
+@@ -1717,7 +1665,7 @@ void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAl
+   p->saveState.litProbs = 0;
+ }
+ 
+-void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
+ {
+   #ifndef _7ZIP_ST
+   MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
+@@ -1947,7 +1895,7 @@ static SRes LzmaEnc_Alloc(CLzmaEnc *p, U
+   return SZ_OK;
+ }
+ 
+-void LzmaEnc_Init(CLzmaEnc *p)
++static void LzmaEnc_Init(CLzmaEnc *p)
+ {
+   UInt32 i;
+   p->state = 0;
+@@ -2005,7 +1953,7 @@ void LzmaEnc_Init(CLzmaEnc *p)
+   p->lpMask = (1 << p->lp) - 1;
+ }
+ 
+-void LzmaEnc_InitPrices(CLzmaEnc *p)
++static void LzmaEnc_InitPrices(CLzmaEnc *p)
+ {
+   if (!p->fastMode)
+   {
+@@ -2037,26 +1985,6 @@ static SRes LzmaEnc_AllocAndInit(CLzmaEn
+   return SZ_OK;
+ }
+ 
+-static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  p->matchFinderBase.stream = inStream;
+-  p->needInit = 1;
+-  p->rc.outStream = outStream;
+-  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
+-}
+-
+-SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
+-    ISeqInStream *inStream, UInt32 keepWindowSize,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  p->matchFinderBase.stream = inStream;
+-  p->needInit = 1;
+-  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+-}
+-
+ static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
+ {
+   p->matchFinderBase.directInput = 1;
+@@ -2064,7 +1992,7 @@ static void LzmaEnc_SetInputBuf(CLzmaEnc
+   p->matchFinderBase.directInputRem = srcLen;
+ }
+ 
+-SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
+     UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2074,7 +2002,7 @@ SRes LzmaEnc_MemPrepare(CLzmaEncHandle p
+   return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
+ }
+ 
+-void LzmaEnc_Finish(CLzmaEncHandle pp)
++static void LzmaEnc_Finish(CLzmaEncHandle pp)
+ {
+   #ifndef _7ZIP_ST
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2107,53 +2035,6 @@ static size_t MyWrite(void *pp, const vo
+   return size;
+ }
+ 
+-
+-UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
+-{
+-  const CLzmaEnc *p = (CLzmaEnc *)pp;
+-  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
+-}
+-
+-const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
+-{
+-  const CLzmaEnc *p = (CLzmaEnc *)pp;
+-  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
+-}
+-
+-SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
+-    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)pp;
+-  UInt64 nowPos64;
+-  SRes res;
+-  CSeqOutStreamBuf outStream;
+-
+-  outStream.funcTable.Write = MyWrite;
+-  outStream.data = dest;
+-  outStream.rem = *destLen;
+-  outStream.overflow = False;
+-
+-  p->writeEndMark = False;
+-  p->finished = False;
+-  p->result = SZ_OK;
+-
+-  if (reInit)
+-    LzmaEnc_Init(p);
+-  LzmaEnc_InitPrices(p);
+-  nowPos64 = p->nowPos64;
+-  RangeEnc_Init(&p->rc);
+-  p->rc.outStream = &outStream.funcTable;
+-
+-  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
+-
+-  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
+-  *destLen -= outStream.rem;
+-  if (outStream.overflow)
+-    return SZ_ERROR_OUTPUT_EOF;
+-
+-  return res;
+-}
+-
+ static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
+ {
+   SRes res = SZ_OK;
+@@ -2184,13 +2065,6 @@ static SRes LzmaEnc_Encode2(CLzmaEnc *p,
+   return res;
+ }
+ 
+-SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
+-    ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
+-  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
+-}
+-
+ SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
+ {
+   CLzmaEnc *p = (CLzmaEnc *)pp;
+@@ -2247,25 +2121,3 @@ SRes LzmaEnc_MemEncode(CLzmaEncHandle pp
+     return SZ_ERROR_OUTPUT_EOF;
+   return res;
+ }
+-
+-SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
+-    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
+-    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
+-{
+-  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
+-  SRes res;
+-  if (p == 0)
+-    return SZ_ERROR_MEM;
+-
+-  res = LzmaEnc_SetProps(p, props);
+-  if (res == SZ_OK)
+-  {
+-    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
+-    if (res == SZ_OK)
+-      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
+-          writeEndMark, progress, alloc, allocBig);
+-  }
+-
+-  LzmaEnc_Destroy(p, alloc, allocBig);
+-  return res;
+-}
diff -uprN a/target/linux/generic/hack-5.10/601-netfilter-export-udp_get_timeouts-function.patch b/target/linux/generic/hack-5.10/601-netfilter-export-udp_get_timeouts-function.patch
--- a/target/linux/generic/hack-5.10/601-netfilter-export-udp_get_timeouts-function.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/601-netfilter-export-udp_get_timeouts-function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From e38488fd0a8a11b4bae4ccad9a7a8cfcf9eb5ab7 Mon Sep 17 00:00:00 2001
-From: Murat Sezgin <msezgin@codeaurora.org>
-Date: Mon, 6 Apr 2020 11:08:09 -0700
-Subject: [PATCH] netfilter: export udp_get_timeouts function
-
-This function is required for acceleration support.
-
-Signed-off-by: Murat Sezgin <msezgin@codeaurora.org>
-Change-Id: Ibca4f402735764e7e6fb3ce2678e670753c6ef9c
----
- include/net/netfilter/nf_conntrack_timeout.h | 1 +
- net/netfilter/nf_conntrack_proto_udp.c       | 3 ++-
- 2 files changed, 3 insertions(+), 1 deletion(-)
-
---- a/include/net/netfilter/nf_conntrack_timeout.h
-+++ b/include/net/netfilter/nf_conntrack_timeout.h
-@@ -123,5 +123,6 @@ static inline void nf_ct_destroy_timeout
- extern struct nf_ct_timeout *(*nf_ct_timeout_find_get_hook)(struct net *net, const char *name);
- extern void (*nf_ct_timeout_put_hook)(struct nf_ct_timeout *timeout);
- #endif
-+extern unsigned int *udp_get_timeouts(struct net *net);
- 
- #endif /* _NF_CONNTRACK_TIMEOUT_H */
---- a/net/netfilter/nf_conntrack_proto_udp.c
-+++ b/net/netfilter/nf_conntrack_proto_udp.c
-@@ -29,10 +29,11 @@ static const unsigned int udp_timeouts[U
- 	[UDP_CT_REPLIED]	= 120*HZ,
- };
- 
--static unsigned int *udp_get_timeouts(struct net *net)
-+unsigned int *udp_get_timeouts(struct net *net)
- {
- 	return nf_udp_pernet(net)->timeouts;
- }
-+EXPORT_SYMBOL(udp_get_timeouts);
- 
- static void udp_error_log(const struct sk_buff *skb,
- 			  const struct nf_hook_state *state,
diff -uprN a/target/linux/generic/hack-5.10/640-bridge-only-accept-EAP-locally.patch b/target/linux/generic/hack-5.10/640-bridge-only-accept-EAP-locally.patch
--- a/target/linux/generic/hack-5.10/640-bridge-only-accept-EAP-locally.patch	2024-03-18 15:15:11.389396208 +0800
+++ b/target/linux/generic/hack-5.10/640-bridge-only-accept-EAP-locally.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,82 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:18:54 +0200
-Subject: bridge: only accept EAP locally
-
-When bridging, do not forward EAP frames to other ports, only deliver
-them locally, regardless of the state.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-[add disable_eap_hack sysfs attribute]
-Signed-off-by: Etienne Champetier <champetier.etienne@gmail.com>
----
-
---- a/net/bridge/br_input.c
-+++ b/net/bridge/br_input.c
-@@ -114,10 +114,14 @@ int br_handle_frame_finish(struct net *n
- 		}
- 	}
- 
-+	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
-+
-+	if (skb->protocol == htons(ETH_P_PAE) && !br->disable_eap_hack)
-+		return br_pass_frame_up(skb);
-+
- 	if (state == BR_STATE_LEARNING)
- 		goto drop;
- 
--	BR_INPUT_SKB_CB(skb)->brdev = br->dev;
- 	BR_INPUT_SKB_CB(skb)->src_port_isolated = !!(p->flags & BR_ISOLATED);
- 
- 	if (IS_ENABLED(CONFIG_INET) &&
---- a/net/bridge/br_private.h
-+++ b/net/bridge/br_private.h
-@@ -404,6 +404,8 @@ struct net_bridge {
- 	u16				group_fwd_mask;
- 	u16				group_fwd_mask_required;
- 
-+	bool				disable_eap_hack;
-+
- 	/* STP */
- 	bridge_id			designated_root;
- 	bridge_id			bridge_id;
---- a/net/bridge/br_sysfs_br.c
-+++ b/net/bridge/br_sysfs_br.c
-@@ -164,6 +164,30 @@ static ssize_t group_fwd_mask_store(stru
- }
- static DEVICE_ATTR_RW(group_fwd_mask);
- 
-+static ssize_t disable_eap_hack_show(struct device *d,
-+				   struct device_attribute *attr,
-+				   char *buf)
-+{
-+	struct net_bridge *br = to_bridge(d);
-+	return sprintf(buf, "%u\n", br->disable_eap_hack);
-+}
-+
-+static int set_disable_eap_hack(struct net_bridge *br, unsigned long val)
-+{
-+	br->disable_eap_hack = !!val;
-+
-+	return 0;
-+}
-+
-+static ssize_t disable_eap_hack_store(struct device *d,
-+				    struct device_attribute *attr,
-+				    const char *buf,
-+				    size_t len)
-+{
-+	return store_bridge_parm(d, buf, len, set_disable_eap_hack);
-+}
-+static DEVICE_ATTR_RW(disable_eap_hack);
-+
- static ssize_t priority_show(struct device *d, struct device_attribute *attr,
- 			     char *buf)
- {
-@@ -849,6 +873,7 @@ static struct attribute *bridge_attrs[]
- 	&dev_attr_ageing_time.attr,
- 	&dev_attr_stp_state.attr,
- 	&dev_attr_group_fwd_mask.attr,
-+	&dev_attr_disable_eap_hack.attr,
- 	&dev_attr_priority.attr,
- 	&dev_attr_bridge_id.attr,
- 	&dev_attr_root_id.attr,
diff -uprN a/target/linux/generic/hack-5.10/645-netfilter-connmark-introduce-set-dscpmark.patch b/target/linux/generic/hack-5.10/645-netfilter-connmark-introduce-set-dscpmark.patch
--- a/target/linux/generic/hack-5.10/645-netfilter-connmark-introduce-set-dscpmark.patch	2024-03-18 15:15:11.369396972 +0800
+++ b/target/linux/generic/hack-5.10/645-netfilter-connmark-introduce-set-dscpmark.patch	2024-03-18 15:16:24.554604797 +0800
@@ -109,7 +109,7 @@ Signed-off-by: Kevin Darbyshire-Bryant <
  	__u8 invert;
 --- a/net/netfilter/xt_connmark.c
 +++ b/net/netfilter/xt_connmark.c
-@@ -24,13 +24,13 @@ MODULE_ALIAS("ipt_connmark");
+@@ -24,12 +24,13 @@ MODULE_ALIAS("ipt_connmark");
  MODULE_ALIAS("ip6t_connmark");
  
  static unsigned int
@@ -120,22 +120,20 @@ Signed-off-by: Kevin Darbyshire-Bryant <
  	u_int32_t new_targetmark;
  	struct nf_conn *ct;
  	u_int32_t newmark;
--	u_int32_t oldmark;
 +	u_int8_t dscp;
  
  	ct = nf_ct_get(skb, &ctinfo);
  	if (ct == NULL)
-@@ -38,13 +38,24 @@ connmark_tg_shift(struct sk_buff *skb, c
+@@ -37,12 +38,24 @@ connmark_tg_shift(struct sk_buff *skb, c
  
  	switch (info->mode) {
  	case XT_CONNMARK_SET:
--		oldmark = READ_ONCE(ct->mark);
--		newmark = (oldmark & ~info->ctmask) ^ info->ctmark;
+-		newmark = (ct->mark & ~info->ctmask) ^ info->ctmark;
 -		if (info->shift_dir == D_SHIFT_RIGHT)
 -			newmark >>= info->shift_bits;
 -		else
 -			newmark <<= info->shift_bits;
-+		newmark = READ_ONCE(ct->mark);
++		newmark = ct->mark;
 +		if (info->func & XT_CONNMARK_VALUE) {
 +			newmark = (newmark & ~info->ctmask) ^ info->ctmark;
 +			if (info->shift_dir == D_SHIFT_RIGHT)
@@ -153,10 +151,10 @@ Signed-off-by: Kevin Darbyshire-Bryant <
 +			newmark = (newmark & ~info->ctmark) |
 +				  (info->ctmask | (dscp << info->shift_bits));
 +		}
- 		if (READ_ONCE(ct->mark) != newmark) {
- 			WRITE_ONCE(ct->mark, newmark);
+ 		if (ct->mark != newmark) {
+ 			ct->mark = newmark;
  			nf_conntrack_event_cache(IPCT_MARK, ct);
-@@ -83,20 +94,36 @@ static unsigned int
+@@ -81,20 +94,36 @@ static unsigned int
  connmark_tg(struct sk_buff *skb, const struct xt_action_param *par)
  {
  	const struct xt_connmark_tginfo1 *info = par->targinfo;
@@ -195,7 +193,7 @@ Signed-off-by: Kevin Darbyshire-Bryant <
  
  	return connmark_tg_shift(skb, info);
  }
-@@ -167,6 +194,16 @@ static struct xt_target connmark_tg_reg[
+@@ -165,6 +194,16 @@ static struct xt_target connmark_tg_reg[
  		.targetsize     = sizeof(struct xt_connmark_tginfo2),
  		.destroy        = connmark_tg_destroy,
  		.me             = THIS_MODULE,
diff -uprN a/target/linux/generic/hack-5.10/650-netfilter-add-xt_FLOWOFFLOAD-target.patch b/target/linux/generic/hack-5.10/650-netfilter-add-xt_FLOWOFFLOAD-target.patch
--- a/target/linux/generic/hack-5.10/650-netfilter-add-xt_FLOWOFFLOAD-target.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/650-netfilter-add-xt_FLOWOFFLOAD-target.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,819 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 20 Feb 2018 15:56:02 +0100
-Subject: [PATCH] netfilter: add xt_FLOWOFFLOAD target
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- create mode 100644 net/netfilter/xt_OFFLOAD.c
-
---- a/net/ipv4/netfilter/Kconfig
-+++ b/net/ipv4/netfilter/Kconfig
-@@ -56,8 +56,6 @@ config NF_TABLES_ARP
- 	help
- 	  This option enables the ARP support for nf_tables.
- 
--endif # NF_TABLES
--
- config NF_FLOW_TABLE_IPV4
- 	tristate "Netfilter flow table IPv4 module"
- 	depends on NF_FLOW_TABLE
-@@ -66,6 +64,8 @@ config NF_FLOW_TABLE_IPV4
- 
- 	  To compile it as a module, choose M here.
- 
-+endif # NF_TABLES
-+
- config NF_DUP_IPV4
- 	tristate "Netfilter IPv4 packet duplication to alternate destination"
- 	depends on !NF_CONNTRACK || NF_CONNTRACK
---- a/net/ipv6/netfilter/Kconfig
-+++ b/net/ipv6/netfilter/Kconfig
-@@ -45,7 +45,6 @@ config NFT_FIB_IPV6
- 	  multicast or blackhole.
- 
- endif # NF_TABLES_IPV6
--endif # NF_TABLES
- 
- config NF_FLOW_TABLE_IPV6
- 	tristate "Netfilter flow table IPv6 module"
-@@ -55,6 +54,8 @@ config NF_FLOW_TABLE_IPV6
- 
- 	  To compile it as a module, choose M here.
- 
-+endif # NF_TABLES
-+
- config NF_DUP_IPV6
- 	tristate "Netfilter IPv6 packet duplication to alternate destination"
- 	depends on !NF_CONNTRACK || NF_CONNTRACK
---- a/net/netfilter/Kconfig
-+++ b/net/netfilter/Kconfig
-@@ -682,8 +682,6 @@ config NFT_FIB_NETDEV
- 
- endif # NF_TABLES_NETDEV
- 
--endif # NF_TABLES
--
- config NF_FLOW_TABLE_INET
- 	tristate "Netfilter flow table mixed IPv4/IPv6 module"
- 	depends on NF_FLOW_TABLE
-@@ -692,11 +690,12 @@ config NF_FLOW_TABLE_INET
- 
- 	  To compile it as a module, choose M here.
- 
-+endif # NF_TABLES
-+
- config NF_FLOW_TABLE
- 	tristate "Netfilter flow table module"
- 	depends on NETFILTER_INGRESS
- 	depends on NF_CONNTRACK
--	depends on NF_TABLES
- 	help
- 	  This option adds the flow table core infrastructure.
- 
-@@ -976,6 +975,15 @@ config NETFILTER_XT_TARGET_NOTRACK
- 	depends on NETFILTER_ADVANCED
- 	select NETFILTER_XT_TARGET_CT
- 
-+config NETFILTER_XT_TARGET_FLOWOFFLOAD
-+	tristate '"FLOWOFFLOAD" target support'
-+	depends on NF_FLOW_TABLE
-+	depends on NETFILTER_INGRESS
-+	help
-+	  This option adds a `FLOWOFFLOAD' target, which uses the nf_flow_offload
-+	  module to speed up processing of packets by bypassing the usual
-+	  netfilter chains
-+
- config NETFILTER_XT_TARGET_RATEEST
- 	tristate '"RATEEST" target support'
- 	depends on NETFILTER_ADVANCED
---- a/net/netfilter/Makefile
-+++ b/net/netfilter/Makefile
-@@ -145,6 +145,7 @@ obj-$(CONFIG_NETFILTER_XT_TARGET_CLASSIF
- obj-$(CONFIG_NETFILTER_XT_TARGET_CONNSECMARK) += xt_CONNSECMARK.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_CT) += xt_CT.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_DSCP) += xt_DSCP.o
-+obj-$(CONFIG_NETFILTER_XT_TARGET_FLOWOFFLOAD) += xt_FLOWOFFLOAD.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_HL) += xt_HL.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_HMARK) += xt_HMARK.o
- obj-$(CONFIG_NETFILTER_XT_TARGET_LED) += xt_LED.o
---- /dev/null
-+++ b/net/netfilter/xt_FLOWOFFLOAD.c
-@@ -0,0 +1,657 @@
-+/*
-+ * Copyright (C) 2018-2021 Felix Fietkau <nbd@nbd.name>
-+ *
-+ * This program is free software; you can redistribute it and/or modify
-+ * it under the terms of the GNU General Public License version 2 as
-+ * published by the Free Software Foundation.
-+ */
-+#include <linux/module.h>
-+#include <linux/init.h>
-+#include <linux/netfilter.h>
-+#include <linux/netfilter/xt_FLOWOFFLOAD.h>
-+#include <net/ip.h>
-+#include <net/netfilter/nf_conntrack.h>
-+#include <net/netfilter/nf_conntrack_extend.h>
-+#include <net/netfilter/nf_conntrack_helper.h>
-+#include <net/netfilter/nf_flow_table.h>
-+
-+struct xt_flowoffload_hook {
-+	struct hlist_node list;
-+	struct nf_hook_ops ops;
-+	struct net *net;
-+	bool registered;
-+	bool used;
-+};
-+
-+struct xt_flowoffload_table {
-+	struct nf_flowtable ft;
-+	struct hlist_head hooks;
-+	struct delayed_work work;
-+};
-+
-+static DEFINE_SPINLOCK(hooks_lock);
-+
-+struct xt_flowoffload_table flowtable[2];
-+
-+static unsigned int
-+xt_flowoffload_net_hook(void *priv, struct sk_buff *skb,
-+			const struct nf_hook_state *state)
-+{
-+	struct nf_flowtable *ft = priv;
-+
-+	if (!atomic_read(&ft->rhashtable.nelems))
-+		return NF_ACCEPT;
-+
-+	switch (skb->protocol) {
-+	case htons(ETH_P_IP):
-+		return nf_flow_offload_ip_hook(priv, skb, state);
-+	case htons(ETH_P_IPV6):
-+		return nf_flow_offload_ipv6_hook(priv, skb, state);
-+	}
-+
-+	return NF_ACCEPT;
-+}
-+
-+static int
-+xt_flowoffload_create_hook(struct xt_flowoffload_table *table,
-+			   struct net_device *dev)
-+{
-+	struct xt_flowoffload_hook *hook;
-+	struct nf_hook_ops *ops;
-+
-+	hook = kzalloc(sizeof(*hook), GFP_ATOMIC);
-+	if (!hook)
-+		return -ENOMEM;
-+
-+	ops = &hook->ops;
-+	ops->pf = NFPROTO_NETDEV;
-+	ops->hooknum = NF_NETDEV_INGRESS;
-+	ops->priority = 10;
-+	ops->priv = &table->ft;
-+	ops->hook = xt_flowoffload_net_hook;
-+	ops->dev = dev;
-+
-+	hlist_add_head(&hook->list, &table->hooks);
-+	mod_delayed_work(system_power_efficient_wq, &table->work, 0);
-+
-+	return 0;
-+}
-+
-+static struct xt_flowoffload_hook *
-+flow_offload_lookup_hook(struct xt_flowoffload_table *table,
-+			 struct net_device *dev)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+	hlist_for_each_entry(hook, &table->hooks, list) {
-+		if (hook->ops.dev == dev)
-+			return hook;
-+	}
-+
-+	return NULL;
-+}
-+
-+static void
-+xt_flowoffload_check_device(struct xt_flowoffload_table *table,
-+			    struct net_device *dev)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+	if (!dev)
-+		return;
-+
-+	spin_lock_bh(&hooks_lock);
-+	hook = flow_offload_lookup_hook(table, dev);
-+	if (hook)
-+		hook->used = true;
-+	else
-+		xt_flowoffload_create_hook(table, dev);
-+	spin_unlock_bh(&hooks_lock);
-+}
-+
-+static void
-+xt_flowoffload_register_hooks(struct xt_flowoffload_table *table)
-+{
-+	struct xt_flowoffload_hook *hook;
-+
-+restart:
-+	hlist_for_each_entry(hook, &table->hooks, list) {
-+		if (hook->registered)
-+			continue;
-+
-+		hook->registered = true;
-+		hook->net = dev_net(hook->ops.dev);
-+		spin_unlock_bh(&hooks_lock);
-+		nf_register_net_hook(hook->net, &hook->ops);
-+		if (table->ft.flags & NF_FLOWTABLE_HW_OFFLOAD)
-+			table->ft.type->setup(&table->ft, hook->ops.dev,
-+					      FLOW_BLOCK_BIND);
-+		spin_lock_bh(&hooks_lock);
-+		goto restart;
-+	}
-+
-+}
-+
-+static bool
-+xt_flowoffload_cleanup_hooks(struct xt_flowoffload_table *table)
-+{
-+	struct xt_flowoffload_hook *hook;
-+	bool active = false;
-+
-+restart:
-+	spin_lock_bh(&hooks_lock);
-+	hlist_for_each_entry(hook, &table->hooks, list) {
-+		if (hook->used || !hook->registered) {
-+			active = true;
-+			continue;
-+		}
-+
-+		hlist_del(&hook->list);
-+		spin_unlock_bh(&hooks_lock);
-+		if (table->ft.flags & NF_FLOWTABLE_HW_OFFLOAD)
-+			table->ft.type->setup(&table->ft, hook->ops.dev,
-+					      FLOW_BLOCK_UNBIND);
-+		nf_unregister_net_hook(hook->net, &hook->ops);
-+		kfree(hook);
-+		goto restart;
-+	}
-+	spin_unlock_bh(&hooks_lock);
-+
-+	return active;
-+}
-+
-+static void
-+xt_flowoffload_check_hook(struct flow_offload *flow, void *data)
-+{
-+	struct xt_flowoffload_table *table = data;
-+	struct flow_offload_tuple *tuple0 = &flow->tuplehash[0].tuple;
-+	struct flow_offload_tuple *tuple1 = &flow->tuplehash[1].tuple;
-+	struct xt_flowoffload_hook *hook;
-+
-+	spin_lock_bh(&hooks_lock);
-+	hlist_for_each_entry(hook, &table->hooks, list) {
-+		if (hook->ops.dev->ifindex != tuple0->iifidx &&
-+		    hook->ops.dev->ifindex != tuple1->iifidx)
-+			continue;
-+
-+		hook->used = true;
-+	}
-+	spin_unlock_bh(&hooks_lock);
-+}
-+
-+static void
-+xt_flowoffload_hook_work(struct work_struct *work)
-+{
-+	struct xt_flowoffload_table *table;
-+	struct xt_flowoffload_hook *hook;
-+	int err;
-+
-+	table = container_of(work, struct xt_flowoffload_table, work.work);
-+
-+	spin_lock_bh(&hooks_lock);
-+	xt_flowoffload_register_hooks(table);
-+	hlist_for_each_entry(hook, &table->hooks, list)
-+		hook->used = false;
-+	spin_unlock_bh(&hooks_lock);
-+
-+	err = nf_flow_table_iterate(&table->ft, xt_flowoffload_check_hook,
-+				    table);
-+	if (err && err != -EAGAIN)
-+		goto out;
-+
-+	if (!xt_flowoffload_cleanup_hooks(table))
-+		return;
-+
-+out:
-+	queue_delayed_work(system_power_efficient_wq, &table->work, HZ);
-+}
-+
-+static bool
-+xt_flowoffload_skip(struct sk_buff *skb, int family)
-+{
-+	if (skb_sec_path(skb))
-+		return true;
-+
-+	if (family == NFPROTO_IPV4) {
-+		const struct ip_options *opt = &(IPCB(skb)->opt);
-+
-+		if (unlikely(opt->optlen))
-+			return true;
-+	}
-+
-+	return false;
-+}
-+
-+static bool flow_is_valid_ether_device(const struct net_device *dev)
-+{
-+	if (!dev || (dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||
-+	    dev->addr_len != ETH_ALEN || !is_valid_ether_addr(dev->dev_addr))
-+		return false;
-+
-+	return true;
-+}
-+
-+static void
-+xt_flowoffload_route_check_path(struct nf_flow_route *route,
-+				const struct nf_conn *ct,
-+				enum ip_conntrack_dir dir,
-+				struct net_device **out_dev)
-+{
-+	const struct dst_entry *dst = route->tuple[dir].dst;
-+	const void *daddr = &ct->tuplehash[!dir].tuple.src.u3;
-+	struct net_device_path_stack stack;
-+	enum net_device_path_type prev_type;
-+	struct net_device *dev = dst->dev;
-+	struct neighbour *n;
-+	bool last = false;
-+	u8 nud_state;
-+	int i;
-+
-+	route->tuple[!dir].in.ifindex = dev->ifindex;
-+	route->tuple[dir].out.ifindex = dev->ifindex;
-+
-+	if (route->tuple[dir].xmit_type == FLOW_OFFLOAD_XMIT_XFRM)
-+		return;
-+
-+	if ((dev->flags & IFF_LOOPBACK) ||
-+	    dev->type != ARPHRD_ETHER || dev->addr_len != ETH_ALEN ||
-+	    !is_valid_ether_addr(dev->dev_addr))
-+		{printk("test %d",dev->type); return;}
-+
-+	n = dst_neigh_lookup(dst, daddr);
-+	if (!n)
-+		return;
-+
-+	read_lock_bh(&n->lock);
-+	nud_state = n->nud_state;
-+	memcpy(route->tuple[dir].out.h_dest, n->ha, ETH_ALEN);
-+	read_unlock_bh(&n->lock);
-+	neigh_release(n);
-+
-+	if (!(nud_state & NUD_VALID))
-+		return;
-+
-+	if (dev_fill_forward_path(dev, route->tuple[dir].out.h_dest, &stack) ||
-+	    !stack.num_paths)
-+		return;
-+
-+	prev_type = DEV_PATH_ETHERNET;
-+	for (i = 0; i <= stack.num_paths; i++) {
-+		const struct net_device_path *path = &stack.path[i];
-+		int n_encaps = route->tuple[!dir].in.num_encaps;
-+
-+		dev = (struct net_device *)path->dev;
-+		if (flow_is_valid_ether_device(dev)) {
-+			if (route->tuple[dir].xmit_type != FLOW_OFFLOAD_XMIT_DIRECT) {
-+				memcpy(route->tuple[dir].out.h_source,
-+				       dev->dev_addr, ETH_ALEN);
-+				route->tuple[dir].out.ifindex = dev->ifindex;
-+			}
-+			route->tuple[dir].xmit_type = FLOW_OFFLOAD_XMIT_DIRECT;
-+		}
-+
-+		switch (path->type) {
-+		case DEV_PATH_PPPOE:
-+		case DEV_PATH_VLAN:
-+			if (n_encaps >= NF_FLOW_TABLE_ENCAP_MAX ||
-+			    i == stack.num_paths) {
-+				last = true;
-+				break;
-+			}
-+
-+			route->tuple[!dir].in.num_encaps++;
-+			route->tuple[!dir].in.encap[n_encaps].id = path->encap.id;
-+			route->tuple[!dir].in.encap[n_encaps].proto = path->encap.proto;
-+			if (path->type == DEV_PATH_PPPOE)
-+				memcpy(route->tuple[dir].out.h_dest,
-+				       path->encap.h_dest, ETH_ALEN);
-+			break;
-+		case DEV_PATH_BRIDGE:
-+			switch (path->bridge.vlan_mode) {
-+			case DEV_PATH_BR_VLAN_TAG:
-+				if (n_encaps >= NF_FLOW_TABLE_ENCAP_MAX ||
-+				    i == stack.num_paths) {
-+					last = true;
-+					break;
-+				}
-+
-+				route->tuple[!dir].in.num_encaps++;
-+				route->tuple[!dir].in.encap[n_encaps].id =
-+					path->bridge.vlan_id;
-+				route->tuple[!dir].in.encap[n_encaps].proto =
-+					path->bridge.vlan_proto;
-+				break;
-+			case DEV_PATH_BR_VLAN_UNTAG:
-+				route->tuple[!dir].in.num_encaps--;
-+				break;
-+			case DEV_PATH_BR_VLAN_UNTAG_HW:
-+				route->tuple[!dir].in.ingress_vlans |= BIT(n_encaps - 1);
-+				break;
-+			case DEV_PATH_BR_VLAN_KEEP:
-+				break;
-+			}
-+			break;
-+		default:
-+			last = true;
-+			break;
-+		}
-+
-+		if (last)
-+			break;
-+	}
-+
-+	*out_dev = dev;
-+	route->tuple[dir].out.hw_ifindex = dev->ifindex;
-+	route->tuple[!dir].in.ifindex = dev->ifindex;
-+}
-+
-+static int
-+xt_flowoffload_route_dir(struct nf_flow_route *route, const struct nf_conn *ct,
-+			 enum ip_conntrack_dir dir,
-+			 const struct xt_action_param *par, int ifindex)
-+{
-+	struct dst_entry *dst = NULL;
-+	struct flowi fl;
-+
-+	memset(&fl, 0, sizeof(fl));
-+	switch (xt_family(par)) {
-+	case NFPROTO_IPV4:
-+		fl.u.ip4.daddr = ct->tuplehash[!dir].tuple.src.u3.ip;
-+		fl.u.ip4.flowi4_oif = ifindex;
-+		break;
-+	case NFPROTO_IPV6:
-+		fl.u.ip6.saddr = ct->tuplehash[!dir].tuple.dst.u3.in6;
-+		fl.u.ip6.daddr = ct->tuplehash[!dir].tuple.src.u3.in6;
-+		fl.u.ip6.flowi6_oif = ifindex;
-+		break;
-+	}
-+
-+	nf_route(xt_net(par), &dst, &fl, false, xt_family(par));
-+	if (!dst)
-+		return -ENOENT;
-+
-+	route->tuple[dir].dst = dst;
-+	if (dst_xfrm(dst))
-+		route->tuple[dir].xmit_type = FLOW_OFFLOAD_XMIT_XFRM;
-+	else
-+		route->tuple[dir].xmit_type = FLOW_OFFLOAD_XMIT_NEIGH;
-+
-+	return 0;
-+}
-+
-+static int
-+xt_flowoffload_route(struct sk_buff *skb, const struct nf_conn *ct,
-+		     const struct xt_action_param *par,
-+		     struct nf_flow_route *route, enum ip_conntrack_dir dir,
-+		     struct net_device **dev)
-+{
-+	int ret;
-+
-+	ret = xt_flowoffload_route_dir(route, ct, dir, par,
-+				       dev[dir]->ifindex);
-+	if (ret)
-+		return ret;
-+
-+	ret = xt_flowoffload_route_dir(route, ct, !dir, par,
-+				       dev[!dir]->ifindex);
-+	if (ret)
-+		return ret;
-+
-+	xt_flowoffload_route_check_path(route, ct, dir, &dev[!dir]);
-+	xt_flowoffload_route_check_path(route, ct, !dir, &dev[dir]);
-+
-+	return 0;
-+}
-+
-+static unsigned int
-+flowoffload_tg(struct sk_buff *skb, const struct xt_action_param *par)
-+{
-+	struct xt_flowoffload_table *table;
-+	const struct xt_flowoffload_target_info *info = par->targinfo;
-+	struct tcphdr _tcph, *tcph = NULL;
-+	enum ip_conntrack_info ctinfo;
-+	enum ip_conntrack_dir dir;
-+	struct nf_flow_route route = {};
-+	struct flow_offload *flow = NULL;
-+	struct net_device *devs[2] = {};
-+	struct nf_conn *ct;
-+	struct net *net;
-+
-+	if (xt_flowoffload_skip(skb, xt_family(par)))
-+		return XT_CONTINUE;
-+
-+	ct = nf_ct_get(skb, &ctinfo);
-+	if (ct == NULL)
-+		return XT_CONTINUE;
-+
-+	switch (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum) {
-+	case IPPROTO_TCP:
-+		if (ct->proto.tcp.state != TCP_CONNTRACK_ESTABLISHED)
-+			return XT_CONTINUE;
-+
-+		tcph = skb_header_pointer(skb, par->thoff,
-+					  sizeof(_tcph), &_tcph);
-+		if (unlikely(!tcph || tcph->fin || tcph->rst))
-+			return XT_CONTINUE;
-+		break;
-+	case IPPROTO_UDP:
-+		break;
-+	default:
-+		return XT_CONTINUE;
-+	}
-+
-+	if (nf_ct_ext_exist(ct, NF_CT_EXT_HELPER) ||
-+	    ct->status & IPS_SEQ_ADJUST)
-+		return XT_CONTINUE;
-+
-+	if (!nf_ct_is_confirmed(ct))
-+		return XT_CONTINUE;
-+
-+	devs[dir] = xt_out(par);
-+	devs[!dir] = xt_in(par);
-+
-+	if (!devs[dir] || !devs[!dir])
-+		return XT_CONTINUE;
-+
-+	if (test_and_set_bit(IPS_OFFLOAD_BIT, &ct->status))
-+		return XT_CONTINUE;
-+
-+	dir = CTINFO2DIR(ctinfo);
-+
-+	if (xt_flowoffload_route(skb, ct, par, &route, dir, devs) < 0)
-+		goto err_flow_route;
-+
-+	flow = flow_offload_alloc(ct);
-+	if (!flow)
-+		goto err_flow_alloc;
-+
-+	if (flow_offload_route_init(flow, &route) < 0)
-+		goto err_flow_add;
-+
-+	if (tcph) {
-+		ct->proto.tcp.seen[0].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
-+		ct->proto.tcp.seen[1].flags |= IP_CT_TCP_FLAG_BE_LIBERAL;
-+	}
-+
-+	table = &flowtable[!!(info->flags & XT_FLOWOFFLOAD_HW)];
-+
-+	net = read_pnet(&table->ft.net);
-+	if (!net)
-+		write_pnet(&table->ft.net, xt_net(par));
-+
-+	if (flow_offload_add(&table->ft, flow) < 0)
-+		goto err_flow_add;
-+
-+	xt_flowoffload_check_device(table, devs[0]);
-+	xt_flowoffload_check_device(table, devs[1]);
-+
-+	dst_release(route.tuple[dir].dst);
-+	dst_release(route.tuple[!dir].dst);
-+
-+	return XT_CONTINUE;
-+
-+err_flow_add:
-+	flow_offload_free(flow);
-+err_flow_alloc:
-+	dst_release(route.tuple[dir].dst);
-+	dst_release(route.tuple[!dir].dst);
-+err_flow_route:
-+	clear_bit(IPS_OFFLOAD_BIT, &ct->status);
-+
-+	return XT_CONTINUE;
-+}
-+
-+static int flowoffload_chk(const struct xt_tgchk_param *par)
-+{
-+	struct xt_flowoffload_target_info *info = par->targinfo;
-+
-+	if (info->flags & ~XT_FLOWOFFLOAD_MASK)
-+		return -EINVAL;
-+
-+	return 0;
-+}
-+
-+static struct xt_target offload_tg_reg __read_mostly = {
-+	.family		= NFPROTO_UNSPEC,
-+	.name		= "FLOWOFFLOAD",
-+	.revision	= 0,
-+	.targetsize	= sizeof(struct xt_flowoffload_target_info),
-+	.usersize	= sizeof(struct xt_flowoffload_target_info),
-+	.checkentry	= flowoffload_chk,
-+	.target		= flowoffload_tg,
-+	.me		= THIS_MODULE,
-+};
-+
-+static int flow_offload_netdev_event(struct notifier_block *this,
-+				     unsigned long event, void *ptr)
-+{
-+	struct xt_flowoffload_hook *hook0, *hook1;
-+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
-+
-+	if (event != NETDEV_UNREGISTER)
-+		return NOTIFY_DONE;
-+
-+	spin_lock_bh(&hooks_lock);
-+	hook0 = flow_offload_lookup_hook(&flowtable[0], dev);
-+	if (hook0)
-+		hlist_del(&hook0->list);
-+
-+	hook1 = flow_offload_lookup_hook(&flowtable[1], dev);
-+	if (hook1)
-+		hlist_del(&hook1->list);
-+	spin_unlock_bh(&hooks_lock);
-+
-+	if (hook0) {
-+		nf_unregister_net_hook(hook0->net, &hook0->ops);
-+		kfree(hook0);
-+	}
-+
-+	if (hook1) {
-+		nf_unregister_net_hook(hook1->net, &hook1->ops);
-+		kfree(hook1);
-+	}
-+
-+	nf_flow_table_cleanup(dev);
-+
-+	return NOTIFY_DONE;
-+}
-+
-+static struct notifier_block flow_offload_netdev_notifier = {
-+	.notifier_call	= flow_offload_netdev_event,
-+};
-+
-+static unsigned int
-+nf_flow_offload_inet_hook(void *priv, struct sk_buff *skb,
-+			  const struct nf_hook_state *state)
-+{
-+	switch (skb->protocol) {
-+	case htons(ETH_P_IP):
-+		return nf_flow_offload_ip_hook(priv, skb, state);
-+	case htons(ETH_P_IPV6):
-+		return nf_flow_offload_ipv6_hook(priv, skb, state);
-+	}
-+
-+	return NF_ACCEPT;
-+}
-+
-+static int nf_flow_rule_route_inet(struct net *net,
-+				   const struct flow_offload *flow,
-+				   enum flow_offload_tuple_dir dir,
-+				   struct nf_flow_rule *flow_rule)
-+{
-+	const struct flow_offload_tuple *flow_tuple = &flow->tuplehash[dir].tuple;
-+	int err;
-+
-+	switch (flow_tuple->l3proto) {
-+	case NFPROTO_IPV4:
-+		err = nf_flow_rule_route_ipv4(net, flow, dir, flow_rule);
-+		break;
-+	case NFPROTO_IPV6:
-+		err = nf_flow_rule_route_ipv6(net, flow, dir, flow_rule);
-+		break;
-+	default:
-+		err = -1;
-+		break;
-+	}
-+
-+	return err;
-+}
-+
-+static struct nf_flowtable_type flowtable_inet = {
-+	.family		= NFPROTO_INET,
-+	.init		= nf_flow_table_init,
-+	.setup		= nf_flow_table_offload_setup,
-+	.action		= nf_flow_rule_route_inet,
-+	.free		= nf_flow_table_free,
-+	.hook		= nf_flow_offload_inet_hook,
-+	.owner		= THIS_MODULE,
-+};
-+
-+static int init_flowtable(struct xt_flowoffload_table *tbl)
-+{
-+	INIT_DELAYED_WORK(&tbl->work, xt_flowoffload_hook_work);
-+	tbl->ft.type = &flowtable_inet;
-+
-+	return nf_flow_table_init(&tbl->ft);
-+}
-+
-+static int __init xt_flowoffload_tg_init(void)
-+{
-+	int ret;
-+
-+	register_netdevice_notifier(&flow_offload_netdev_notifier);
-+
-+	ret = init_flowtable(&flowtable[0]);
-+	if (ret)
-+		return ret;
-+
-+	ret = init_flowtable(&flowtable[1]);
-+	if (ret)
-+		goto cleanup;
-+
-+	flowtable[1].ft.flags = NF_FLOWTABLE_HW_OFFLOAD;
-+
-+	ret = xt_register_target(&offload_tg_reg);
-+	if (ret)
-+		goto cleanup2;
-+
-+	return 0;
-+
-+cleanup2:
-+	nf_flow_table_free(&flowtable[1].ft);
-+cleanup:
-+	nf_flow_table_free(&flowtable[0].ft);
-+	return ret;
-+}
-+
-+static void __exit xt_flowoffload_tg_exit(void)
-+{
-+	xt_unregister_target(&offload_tg_reg);
-+	unregister_netdevice_notifier(&flow_offload_netdev_notifier);
-+	nf_flow_table_free(&flowtable[0].ft);
-+	nf_flow_table_free(&flowtable[1].ft);
-+}
-+
-+MODULE_LICENSE("GPL");
-+module_init(xt_flowoffload_tg_init);
-+module_exit(xt_flowoffload_tg_exit);
---- a/net/netfilter/nf_flow_table_core.c
-+++ b/net/netfilter/nf_flow_table_core.c
-@@ -7,7 +7,6 @@
- #include <linux/netdevice.h>
- #include <net/ip.h>
- #include <net/ip6_route.h>
--#include <net/netfilter/nf_tables.h>
- #include <net/netfilter/nf_flow_table.h>
- #include <net/netfilter/nf_conntrack.h>
- #include <net/netfilter/nf_conntrack_core.h>
-@@ -395,8 +394,7 @@ flow_offload_lookup(struct nf_flowtable
- }
- EXPORT_SYMBOL_GPL(flow_offload_lookup);
- 
--static int
--nf_flow_table_iterate(struct nf_flowtable *flow_table,
-+int nf_flow_table_iterate(struct nf_flowtable *flow_table,
- 		      void (*iter)(struct flow_offload *flow, void *data),
- 		      void *data)
- {
-@@ -428,6 +426,7 @@ nf_flow_table_iterate(struct nf_flowtabl
- 
- 	return err;
- }
-+EXPORT_SYMBOL_GPL(nf_flow_table_iterate);
- 
- static void nf_flow_offload_gc_step(struct flow_offload *flow, void *data)
- {
---- /dev/null
-+++ b/include/uapi/linux/netfilter/xt_FLOWOFFLOAD.h
-@@ -0,0 +1,17 @@
-+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
-+#ifndef _XT_FLOWOFFLOAD_H
-+#define _XT_FLOWOFFLOAD_H
-+
-+#include <linux/types.h>
-+
-+enum {
-+	XT_FLOWOFFLOAD_HW	= 1 << 0,
-+
-+	XT_FLOWOFFLOAD_MASK	= XT_FLOWOFFLOAD_HW
-+};
-+
-+struct xt_flowoffload_target_info {
-+	__u32 flags;
-+};
-+
-+#endif /* _XT_FLOWOFFLOAD_H */
---- a/include/net/netfilter/nf_flow_table.h
-+++ b/include/net/netfilter/nf_flow_table.h
-@@ -270,6 +270,10 @@ void nf_flow_table_free(struct nf_flowta
- 
- void flow_offload_teardown(struct flow_offload *flow);
- 
-+int nf_flow_table_iterate(struct nf_flowtable *flow_table,
-+			  void (*iter)(struct flow_offload *flow, void *data),
-+			  void *data);
-+
- void nf_flow_snat_port(const struct flow_offload *flow,
- 		       struct sk_buff *skb, unsigned int thoff,
- 		       u8 protocol, enum flow_offload_tuple_dir dir);
diff -uprN a/target/linux/generic/hack-5.10/660-fq_codel_defaults.patch b/target/linux/generic/hack-5.10/660-fq_codel_defaults.patch
--- a/target/linux/generic/hack-5.10/660-fq_codel_defaults.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/660-fq_codel_defaults.patch	2024-03-18 15:16:24.574604033 +0800
@@ -13,7 +13,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/net/sched/sch_fq_codel.c
 +++ b/net/sched/sch_fq_codel.c
-@@ -467,7 +467,11 @@ static int fq_codel_init(struct Qdisc *s
+@@ -469,7 +469,11 @@ static int fq_codel_init(struct Qdisc *s
  
  	sch->limit = 10*1024;
  	q->flows_cnt = 1024;
diff -uprN a/target/linux/generic/hack-5.10/661-kernel-ct-size-the-hashtable-more-adequately.patch b/target/linux/generic/hack-5.10/661-kernel-ct-size-the-hashtable-more-adequately.patch
--- a/target/linux/generic/hack-5.10/661-kernel-ct-size-the-hashtable-more-adequately.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/661-kernel-ct-size-the-hashtable-more-adequately.patch	2024-03-18 15:16:24.570604187 +0800
@@ -0,0 +1,25 @@
+From 804fbb3f2ec9283f7b778e057a68bfff440a0be6 Mon Sep 17 00:00:00 2001
+From: Rui Salvaterra <rsalvaterra@gmail.com>
+Date: Wed, 30 Mar 2022 22:51:55 +0100
+Subject: [PATCH] kernel: ct: size the hashtable more adequately
+
+To set the default size of the connection tracking hash table, a divider of
+16384 becomes inadequate for a router handling lots of connections. Divide by
+2048 instead, making the default size scale better with the available RAM.
+
+Signed-off-by: Rui Salvaterra <rsalvaterra@gmail.com>
+---
+ net/netfilter/nf_conntrack_core.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/net/netfilter/nf_conntrack_core.c
++++ b/net/netfilter/nf_conntrack_core.c
+@@ -2576,7 +2576,7 @@ int nf_conntrack_init_start(void)
+ 
+ 	if (!nf_conntrack_htable_size) {
+ 		nf_conntrack_htable_size
+-			= (((nr_pages << PAGE_SHIFT) / 16384)
++			= (((nr_pages << PAGE_SHIFT) / 2048)
+ 			   / sizeof(struct hlist_head));
+ 		if (BITS_PER_LONG >= 64 &&
+ 		    nr_pages > (4 * (1024 * 1024 * 1024 / PAGE_SIZE)))
diff -uprN a/target/linux/generic/hack-5.10/661-use_fq_codel_by_default.patch b/target/linux/generic/hack-5.10/661-use_fq_codel_by_default.patch
--- a/target/linux/generic/hack-5.10/661-use_fq_codel_by_default.patch	2024-03-18 15:15:11.381396514 +0800
+++ b/target/linux/generic/hack-5.10/661-use_fq_codel_by_default.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,100 +0,0 @@
-From 1d418f7e88035ed7a94073f6354246c66e9193e9 Mon Sep 17 00:00:00 2001
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 7 Jul 2017 17:22:58 +0200
-Subject: fq_codel: switch default qdisc from pfifo_fast to fq_codel and remove pfifo_fast
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
- include/net/sch_generic.h | 3 ++-
- net/sched/Kconfig         | 3 ++-
- net/sched/sch_api.c       | 2 +-
- net/sched/sch_fq_codel.c  | 3 ++-
- net/sched/sch_generic.c   | 4 ++--
- 5 files changed, 9 insertions(+), 6 deletions(-)
-
---- a/include/net/sch_generic.h
-+++ b/include/net/sch_generic.h
-@@ -611,12 +611,13 @@ extern struct Qdisc_ops noop_qdisc_ops;
- extern struct Qdisc_ops pfifo_fast_ops;
- extern struct Qdisc_ops mq_qdisc_ops;
- extern struct Qdisc_ops noqueue_qdisc_ops;
-+extern struct Qdisc_ops fq_codel_qdisc_ops;
- extern const struct Qdisc_ops *default_qdisc_ops;
- static inline const struct Qdisc_ops *
- get_default_qdisc_ops(const struct net_device *dev, int ntx)
- {
- 	return ntx < dev->real_num_tx_queues ?
--			default_qdisc_ops : &pfifo_fast_ops;
-+			default_qdisc_ops : &fq_codel_qdisc_ops;
- }
- 
- struct Qdisc_class_common {
---- a/net/sched/Kconfig
-+++ b/net/sched/Kconfig
-@@ -4,8 +4,9 @@
- #
- 
- menuconfig NET_SCHED
--	bool "QoS and/or fair queueing"
-+	def_bool y
- 	select NET_SCH_FIFO
-+	select NET_SCH_FQ_CODEL
- 	help
- 	  When the kernel has several packets to send out over a network
- 	  device, it has to decide which ones to send first, which ones to
---- a/net/sched/sch_api.c
-+++ b/net/sched/sch_api.c
-@@ -2296,7 +2296,7 @@ static int __init pktsched_init(void)
- 		return err;
- 	}
- 
--	register_qdisc(&pfifo_fast_ops);
-+	register_qdisc(&fq_codel_qdisc_ops);
- 	register_qdisc(&pfifo_qdisc_ops);
- 	register_qdisc(&bfifo_qdisc_ops);
- 	register_qdisc(&pfifo_head_drop_qdisc_ops);
---- a/net/sched/sch_fq_codel.c
-+++ b/net/sched/sch_fq_codel.c
-@@ -707,7 +707,7 @@ static const struct Qdisc_class_ops fq_c
- 	.walk		=	fq_codel_walk,
- };
- 
--static struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
-+struct Qdisc_ops fq_codel_qdisc_ops __read_mostly = {
- 	.cl_ops		=	&fq_codel_class_ops,
- 	.id		=	"fq_codel",
- 	.priv_size	=	sizeof(struct fq_codel_sched_data),
-@@ -722,6 +722,7 @@ static struct Qdisc_ops fq_codel_qdisc_o
- 	.dump_stats =	fq_codel_dump_stats,
- 	.owner		=	THIS_MODULE,
- };
-+EXPORT_SYMBOL(fq_codel_qdisc_ops);
- 
- static int __init fq_codel_module_init(void)
- {
---- a/net/sched/sch_generic.c
-+++ b/net/sched/sch_generic.c
-@@ -32,7 +32,7 @@
- #include <net/xfrm.h>
- 
- /* Qdisc to use by default */
--const struct Qdisc_ops *default_qdisc_ops = &pfifo_fast_ops;
-+const struct Qdisc_ops *default_qdisc_ops = &fq_codel_qdisc_ops;
- EXPORT_SYMBOL(default_qdisc_ops);
- 
- static void qdisc_maybe_clear_missed(struct Qdisc *q,
-@@ -1077,12 +1077,12 @@ static void attach_one_default_qdisc(str
- 				     void *_unused)
- {
- 	struct Qdisc *qdisc;
--	const struct Qdisc_ops *ops = default_qdisc_ops;
-+	const struct Qdisc_ops *ops = &fq_codel_qdisc_ops;
- 
- 	if (dev->priv_flags & IFF_NO_QUEUE)
- 		ops = &noqueue_qdisc_ops;
- 	else if(dev->type == ARPHRD_CAN)
--		ops = &pfifo_fast_ops;
-+		ops = &fq_codel_qdisc_ops;
- 
- 	qdisc = qdisc_create_dflt(dev_queue, ops, TC_H_ROOT, NULL);
- 	if (!qdisc)
diff -uprN a/target/linux/generic/hack-5.10/700-swconfig_switch_drivers.patch b/target/linux/generic/hack-5.10/700-swconfig_switch_drivers.patch
--- a/target/linux/generic/hack-5.10/700-swconfig_switch_drivers.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/700-swconfig_switch_drivers.patch	2024-03-18 15:16:24.574604033 +0800
@@ -36,7 +36,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 +	  Support for FC is very limited.
 +
 +config AR8216_PHY
-+	tristate "Driver for Atheros AR8216/8327 switches"
++	tristate "Driver for Atheros AR8216 switches"
 +	select SWCONFIG
 +	select ETHERNET_PACKET_MANGLE
 +
@@ -95,15 +95,13 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  config AMD_PHY
 --- a/drivers/net/phy/Makefile
 +++ b/drivers/net/phy/Makefile
-@@ -24,6 +24,21 @@ libphy-$(CONFIG_LED_TRIGGER_PHY)	+= phy_
+@@ -24,6 +24,19 @@ libphy-$(CONFIG_LED_TRIGGER_PHY)	+= phy_
  obj-$(CONFIG_PHYLINK)		+= phylink.o
  obj-$(CONFIG_PHYLIB)		+= libphy.o
  
 +obj-$(CONFIG_SWCONFIG)		+= swconfig.o
 +obj-$(CONFIG_ADM6996_PHY)	+= adm6996.o
-+obj-$(CONFIG_AR8216_PHY)	+= ar8xxx.o
-+ar8xxx-y			+= ar8216.o
-+ar8xxx-y			+= ar8327.o
++obj-$(CONFIG_AR8216_PHY)	+= ar8216.o ar8327.o
 +obj-$(CONFIG_SWCONFIG_B53)	+= b53/
 +obj-$(CONFIG_IP17XX_PHY)	+= ip17xx.o
 +obj-$(CONFIG_PSB6970_PHY)	+= psb6970.o
diff -uprN a/target/linux/generic/hack-5.10/710-net-dsa-mv88e6xxx-default-VID-1.patch b/target/linux/generic/hack-5.10/710-net-dsa-mv88e6xxx-default-VID-1.patch
--- a/target/linux/generic/hack-5.10/710-net-dsa-mv88e6xxx-default-VID-1.patch	2024-03-18 15:15:11.381396514 +0800
+++ b/target/linux/generic/hack-5.10/710-net-dsa-mv88e6xxx-default-VID-1.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,18 +0,0 @@
---- a/drivers/net/dsa/mv88e6xxx/chip.c
-+++ b/drivers/net/dsa/mv88e6xxx/chip.c
-@@ -2149,6 +2149,7 @@ static int mv88e6xxx_port_fdb_add(struct
- 	struct mv88e6xxx_chip *chip = ds->priv;
- 	int err;
- 
-+	vid = vid ? : 1;
- 	mv88e6xxx_reg_lock(chip);
- 	err = mv88e6xxx_port_db_load_purge(chip, port, addr, vid,
- 					   MV88E6XXX_G1_ATU_DATA_STATE_UC_STATIC);
-@@ -2163,6 +2164,7 @@ static int mv88e6xxx_port_fdb_del(struct
- 	struct mv88e6xxx_chip *chip = ds->priv;
- 	int err;
- 
-+	vid = vid ? : 1;
- 	mv88e6xxx_reg_lock(chip);
- 	err = mv88e6xxx_port_db_load_purge(chip, port, addr, vid, 0);
- 	mv88e6xxx_reg_unlock(chip);
diff -uprN a/target/linux/generic/hack-5.10/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch b/target/linux/generic/hack-5.10/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch
--- a/target/linux/generic/hack-5.10/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch	2024-03-18 15:15:11.381396514 +0800
+++ b/target/linux/generic/hack-5.10/711-net-dsa-mv88e6xxx-disable-ATU-violation.patch	2024-03-18 15:16:24.570604187 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/dsa/mv88e6xxx/chip.c
 +++ b/drivers/net/dsa/mv88e6xxx/chip.c
-@@ -2711,6 +2711,9 @@ static int mv88e6xxx_setup_port(struct m
+@@ -2705,6 +2705,9 @@ static int mv88e6xxx_setup_port(struct m
  	if (dsa_is_cpu_port(ds, port))
  		reg = 0;
  
diff -uprN a/target/linux/generic/hack-5.10/720-net-phy-add-aqr-phys.patch b/target/linux/generic/hack-5.10/720-net-phy-add-aqr-phys.patch
--- a/target/linux/generic/hack-5.10/720-net-phy-add-aqr-phys.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/720-net-phy-add-aqr-phys.patch	2024-03-18 15:16:24.578603881 +0800
@@ -0,0 +1,142 @@
+From: Birger Koblitz <git@birger-koblitz.de>
+Date: Sun, 5 Sep 2021 15:13:10 +0200
+Subject: [PATCH] kernel: Add AQR113C and AQR813 support
+
+This hack adds support for the Aquantia 4th generation, 10GBit
+PHYs AQR113C and AQR813.
+
+Signed-off-by: Birger Koblitz <git@birger-koblitz.de>
+
+--- a/drivers/net/phy/aquantia_main.c
++++ b/drivers/net/phy/aquantia_main.c
+@@ -20,8 +20,10 @@
+ #define PHY_ID_AQR105	0x03a1b4a2
+ #define PHY_ID_AQR106	0x03a1b4d0
+ #define PHY_ID_AQR107	0x03a1b4e0
++#define PHY_ID_AQR113C	0x31c31c12
+ #define PHY_ID_AQCS109	0x03a1b5c2
+ #define PHY_ID_AQR405	0x03a1b4b0
++#define PHY_ID_AQR813	0x31c31cb2
+ 
+ #define MDIO_PHYXS_VEND_IF_STATUS		0xe812
+ #define MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK	GENMASK(7, 3)
+@@ -330,6 +332,49 @@ static int aqr107_read_rate(struct phy_d
+ 	return 0;
+ }
+ 
++static int aqr113c_read_status(struct phy_device *phydev)
++{
++	int val, ret;
++
++	ret = aqr_read_status(phydev);
++	if (ret)
++		return ret;
++
++	if (!phydev->link || phydev->autoneg == AUTONEG_DISABLE)
++		return 0;
++
++	// On AQR113C, the speed returned by aqr_read_status is wrong
++	aqr107_read_rate(phydev);
++
++	val = phy_read_mmd(phydev, MDIO_MMD_PHYXS, MDIO_PHYXS_VEND_IF_STATUS);
++	if (val < 0)
++		return val;
++
++	switch (FIELD_GET(MDIO_PHYXS_VEND_IF_STATUS_TYPE_MASK, val)) {
++	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_KR:
++		phydev->interface = PHY_INTERFACE_MODE_10GKR;
++		break;
++	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_XFI:
++		phydev->interface = PHY_INTERFACE_MODE_10GBASER;
++		break;
++	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_USXGMII:
++		phydev->interface = PHY_INTERFACE_MODE_USXGMII;
++		break;
++	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_SGMII:
++		phydev->interface = PHY_INTERFACE_MODE_SGMII;
++		break;
++	case MDIO_PHYXS_VEND_IF_STATUS_TYPE_OCSGMII:
++		phydev->interface = PHY_INTERFACE_MODE_2500BASEX;
++		break;
++	default:
++		phydev->interface = PHY_INTERFACE_MODE_NA;
++		break;
++	}
++
++	/* Read downshifted rate from vendor register */
++	return aqr107_read_rate(phydev);
++}
++
+ static int aqr107_read_status(struct phy_device *phydev)
+ {
+ 	int val, ret;
+@@ -460,7 +505,7 @@ static void aqr107_chip_info(struct phy_
+ 	build_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_FW_BUILD_ID, val);
+ 	prov_id = FIELD_GET(VEND1_GLOBAL_RSVD_STAT1_PROV_ID, val);
+ 
+-	phydev_dbg(phydev, "FW %u.%u, Build %u, Provisioning %u\n",
++	phydev_info(phydev, "FW %u.%u, Build %u, Provisioning %u\n",
+ 		   fw_major, fw_minor, build_id, prov_id);
+ }
+ 
+@@ -632,6 +677,24 @@ static struct phy_driver aqr_driver[] =
+ 	.link_change_notify = aqr107_link_change_notify,
+ },
+ {
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR113C),
++	.name		= "Aquantia AQR113C",
++	.probe		= aqr107_probe,
++	.config_init	= aqr107_config_init,
++	.config_aneg    = aqr_config_aneg,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr113c_read_status,
++	.get_tunable    = aqr107_get_tunable,
++	.set_tunable    = aqr107_set_tunable,
++	.suspend	= aqr107_suspend,
++	.resume		= aqr107_resume,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++	.link_change_notify = aqr107_link_change_notify,
++},
++{
+ 	PHY_ID_MATCH_MODEL(PHY_ID_AQCS109),
+ 	.name		= "Aquantia AQCS109",
+ 	.probe		= aqr107_probe,
+@@ -657,6 +720,24 @@ static struct phy_driver aqr_driver[] =
+ 	.ack_interrupt	= aqr_ack_interrupt,
+ 	.read_status	= aqr_read_status,
+ },
++{
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR813),
++	.name		= "Aquantia AQR813",
++	.probe		= aqr107_probe,
++	.config_init	= aqr107_config_init,
++	.config_aneg    = aqr_config_aneg,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr113c_read_status,
++	.get_tunable    = aqr107_get_tunable,
++	.set_tunable    = aqr107_set_tunable,
++	.suspend	= aqr107_suspend,
++	.resume		= aqr107_resume,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++	.link_change_notify = aqr107_link_change_notify,
++},
+ };
+ 
+ module_phy_driver(aqr_driver);
+@@ -667,8 +748,10 @@ static struct mdio_device_id __maybe_unu
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR105) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113C) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR405) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR813) },
+ 	{ }
+ };
+ 
diff -uprN a/target/linux/generic/hack-5.10/721-net-add-packet-mangeling.patch b/target/linux/generic/hack-5.10/721-net-add-packet-mangeling.patch
--- a/target/linux/generic/hack-5.10/721-net-add-packet-mangeling.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/721-net-add-packet-mangeling.patch	2024-03-18 15:16:24.574604033 +0800
@@ -19,7 +19,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -1648,6 +1648,7 @@ enum netdev_priv_flags {
+@@ -1625,6 +1625,7 @@ enum netdev_priv_flags {
  	IFF_FAILOVER_SLAVE		= 1<<28,
  	IFF_L3MDEV_RX_HANDLER		= 1<<29,
  	IFF_LIVE_RENAME_OK		= 1<<30,
@@ -27,7 +27,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  };
  
  #define IFF_802_1Q_VLAN			IFF_802_1Q_VLAN
-@@ -1680,6 +1681,7 @@ enum netdev_priv_flags {
+@@ -1657,6 +1658,7 @@ enum netdev_priv_flags {
  #define IFF_FAILOVER_SLAVE		IFF_FAILOVER_SLAVE
  #define IFF_L3MDEV_RX_HANDLER		IFF_L3MDEV_RX_HANDLER
  #define IFF_LIVE_RENAME_OK		IFF_LIVE_RENAME_OK
@@ -35,7 +35,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
  /* Specifies the type of the struct net_device::ml_priv pointer */
  enum netdev_ml_priv_type {
-@@ -2020,6 +2022,11 @@ struct net_device {
+@@ -1997,6 +1999,11 @@ struct net_device {
  	const struct tlsdev_ops *tlsdev_ops;
  #endif
  
@@ -47,7 +47,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	const struct header_ops *header_ops;
  
  	unsigned int		flags;
-@@ -2110,6 +2117,10 @@ struct net_device {
+@@ -2087,6 +2094,10 @@ struct net_device {
  	struct mpls_dev __rcu	*mpls_ptr;
  #endif
  
@@ -60,7 +60,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
   */
 --- a/include/linux/skbuff.h
 +++ b/include/linux/skbuff.h
-@@ -2727,6 +2727,10 @@ static inline int pskb_trim(struct sk_bu
+@@ -2710,6 +2710,10 @@ static inline int pskb_trim(struct sk_bu
  	return (len < skb->len) ? __pskb_trim(skb, len) : 0;
  }
  
@@ -71,7 +71,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  /**
   *	pskb_trim_unique - remove end from a paged unique (not cloned) buffer
   *	@skb: buffer to alter
-@@ -2858,16 +2862,6 @@ static inline struct sk_buff *dev_alloc_
+@@ -2841,16 +2845,6 @@ static inline struct sk_buff *dev_alloc_
  }
  
  
@@ -105,7 +105,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	help
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -3656,6 +3656,11 @@ static int xmit_one(struct sk_buff *skb,
+@@ -3650,6 +3650,11 @@ static int xmit_one(struct sk_buff *skb,
  	if (dev_nit_active(dev))
  		dev_queue_xmit_nit(skb, dev);
  
diff -uprN a/target/linux/generic/hack-5.10/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch b/target/linux/generic/hack-5.10/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch
--- a/target/linux/generic/hack-5.10/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/722-net-phy-aquantia-enable-AQR112-and-AQR412.patch	2024-03-18 15:16:24.578603881 +0800
@@ -0,0 +1,154 @@
+From 5f62951fba63a9f9cfff564209426bdea5fcc371 Mon Sep 17 00:00:00 2001
+From: Alex Marginean <alexandru.marginean@nxp.com>
+Date: Tue, 27 Aug 2019 15:16:56 +0300
+Subject: [PATCH] drivers: net: phy: aquantia: enable AQR112 and AQR412
+
+Adds support for AQR112 and AQR412 which is mostly based on existing code
+with the addition of code configuring the protocol on system side.
+This allows changing the system side protocol without having to deploy a
+different firmware on the PHY.
+
+Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
+---
+ drivers/net/phy/aquantia_main.c | 88 +++++++++++++++++++++++++++++++++++++++++
+ 1 file changed, 88 insertions(+)
+
+--- a/drivers/net/phy/aquantia_main.c
++++ b/drivers/net/phy/aquantia_main.c
+@@ -20,9 +20,11 @@
+ #define PHY_ID_AQR105	0x03a1b4a2
+ #define PHY_ID_AQR106	0x03a1b4d0
+ #define PHY_ID_AQR107	0x03a1b4e0
++#define PHY_ID_AQR112	0x03a1b662
+ #define PHY_ID_AQR113C	0x31c31c12
+ #define PHY_ID_AQCS109	0x03a1b5c2
+ #define PHY_ID_AQR405	0x03a1b4b0
++#define PHY_ID_AQR412	0x03a1b712
+ #define PHY_ID_AQR813	0x31c31cb2
+ 
+ #define MDIO_PHYXS_VEND_IF_STATUS		0xe812
+@@ -123,6 +125,29 @@
+ #define VEND1_GLOBAL_INT_VEND_MASK_GLOBAL2	BIT(1)
+ #define VEND1_GLOBAL_INT_VEND_MASK_GLOBAL3	BIT(0)
+ 
++/* registers in MDIO_MMD_VEND1 region */
++#define AQUANTIA_VND1_GLOBAL_SC			0x000
++#define  AQUANTIA_VND1_GLOBAL_SC_LP		BIT(0xb)
++
++/* global start rate, the protocol associated with this speed is used by default
++ * on SI.
++ */
++#define AQUANTIA_VND1_GSTART_RATE		0x31a
++#define  AQUANTIA_VND1_GSTART_RATE_OFF		0
++#define  AQUANTIA_VND1_GSTART_RATE_100M		1
++#define  AQUANTIA_VND1_GSTART_RATE_1G		2
++#define  AQUANTIA_VND1_GSTART_RATE_10G		3
++#define  AQUANTIA_VND1_GSTART_RATE_2_5G		4
++#define  AQUANTIA_VND1_GSTART_RATE_5G		5
++
++/* SYSCFG registers for 100M, 1G, 2.5G, 5G, 10G */
++#define AQUANTIA_VND1_GSYSCFG_BASE		0x31b
++#define AQUANTIA_VND1_GSYSCFG_100M		0
++#define AQUANTIA_VND1_GSYSCFG_1G		1
++#define AQUANTIA_VND1_GSYSCFG_2_5G		2
++#define AQUANTIA_VND1_GSYSCFG_5G		3
++#define AQUANTIA_VND1_GSYSCFG_10G		4
++
+ struct aqr107_hw_stat {
+ 	const char *name;
+ 	int reg;
+@@ -243,6 +268,51 @@ static int aqr_config_aneg(struct phy_de
+ 	return genphy_c45_check_and_restart_aneg(phydev, changed);
+ }
+ 
++static struct {
++	u16 syscfg;
++	int cnt;
++	u16 start_rate;
++} aquantia_syscfg[PHY_INTERFACE_MODE_MAX] = {
++	[PHY_INTERFACE_MODE_SGMII] =      {0x04b, AQUANTIA_VND1_GSYSCFG_1G,
++					   AQUANTIA_VND1_GSTART_RATE_1G},
++	[PHY_INTERFACE_MODE_2500BASEX] = {0x144, AQUANTIA_VND1_GSYSCFG_2_5G,
++					   AQUANTIA_VND1_GSTART_RATE_2_5G},
++	[PHY_INTERFACE_MODE_XGMII] =      {0x100, AQUANTIA_VND1_GSYSCFG_10G,
++					   AQUANTIA_VND1_GSTART_RATE_10G},
++	[PHY_INTERFACE_MODE_USXGMII] =    {0x080, AQUANTIA_VND1_GSYSCFG_10G,
++					   AQUANTIA_VND1_GSTART_RATE_10G},
++};
++
++/* Sets up protocol on system side before calling aqr_config_aneg */
++static int aqr_config_aneg_set_prot(struct phy_device *phydev)
++{
++	int if_type = phydev->interface;
++	int i;
++
++	if (!aquantia_syscfg[if_type].cnt)
++		return 0;
++
++	/* set PHY in low power mode so we can configure protocols */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC,
++		      AQUANTIA_VND1_GLOBAL_SC_LP);
++	mdelay(10);
++
++	/* set the default rate to enable the SI link */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GSTART_RATE,
++		      aquantia_syscfg[if_type].start_rate);
++
++	for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++)
++		phy_write_mmd(phydev, MDIO_MMD_VEND1,
++			      AQUANTIA_VND1_GSYSCFG_BASE + i,
++			      aquantia_syscfg[if_type].syscfg);
++
++	/* wake PHY back up */
++	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC, 0);
++	mdelay(10);
++
++	return aqr_config_aneg(phydev);
++}
++
+ static int aqr_config_intr(struct phy_device *phydev)
+ {
+ 	bool en = phydev->interrupts == PHY_INTERRUPT_ENABLED;
+@@ -738,6 +808,30 @@ static struct phy_driver aqr_driver[] =
+ 	.get_stats	= aqr107_get_stats,
+ 	.link_change_notify = aqr107_link_change_notify,
+ },
++{
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR112),
++	.name		= "Aquantia AQR112",
++	.probe		= aqr107_probe,
++	.config_aneg	= aqr_config_aneg_set_prot,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr107_read_status,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++},
++{
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR412),
++	.name		= "Aquantia AQR412",
++	.probe		= aqr107_probe,
++	.config_aneg	= aqr_config_aneg_set_prot,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr107_read_status,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++},
+ };
+ 
+ module_phy_driver(aqr_driver);
+@@ -748,9 +842,11 @@ static struct mdio_device_id __maybe_unu
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR105) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113C) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR405) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR412) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR813) },
+ 	{ }
+ };
diff -uprN a/target/linux/generic/hack-5.10/723-net-phy-aquantia-fix-system-side-protocol-mi.patch b/target/linux/generic/hack-5.10/723-net-phy-aquantia-fix-system-side-protocol-mi.patch
--- a/target/linux/generic/hack-5.10/723-net-phy-aquantia-fix-system-side-protocol-mi.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/723-net-phy-aquantia-fix-system-side-protocol-mi.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,34 @@
+From 5f008cb22f60da4e10375f22266c1a4e20b1252e Mon Sep 17 00:00:00 2001
+From: Alex Marginean <alexandru.marginean@nxp.com>
+Date: Fri, 20 Sep 2019 18:22:52 +0300
+Subject: [PATCH] drivers: net: phy: aquantia: fix system side protocol
+ misconfiguration
+
+Do not set up protocols for speeds that are not supported by FW.  Enabling
+these protocols leads to link issues on system side.
+
+Signed-off-by: Alex Marginean <alexandru.marginean@nxp.com>
+---
+ drivers/net/phy/aquantia_main.c | 8 +++++++-
+ 1 file changed, 7 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/phy/aquantia_main.c
++++ b/drivers/net/phy/aquantia_main.c
+@@ -301,10 +301,16 @@ static int aqr_config_aneg_set_prot(stru
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GSTART_RATE,
+ 		      aquantia_syscfg[if_type].start_rate);
+ 
+-	for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++)
++	for (i = 0; i <= aquantia_syscfg[if_type].cnt; i++) {
++		u16 reg = phy_read_mmd(phydev, MDIO_MMD_VEND1,
++				       AQUANTIA_VND1_GSYSCFG_BASE + i);
++		if (!reg)
++			continue;
++
+ 		phy_write_mmd(phydev, MDIO_MMD_VEND1,
+ 			      AQUANTIA_VND1_GSYSCFG_BASE + i,
+ 			      aquantia_syscfg[if_type].syscfg);
++	}
+ 
+ 	/* wake PHY back up */
+ 	phy_write_mmd(phydev, MDIO_MMD_VEND1, AQUANTIA_VND1_GLOBAL_SC, 0);
diff -uprN a/target/linux/generic/hack-5.10/724-net-phy-aquantia-Add-AQR113-driver-support.patch b/target/linux/generic/hack-5.10/724-net-phy-aquantia-Add-AQR113-driver-support.patch
--- a/target/linux/generic/hack-5.10/724-net-phy-aquantia-Add-AQR113-driver-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/724-net-phy-aquantia-Add-AQR113-driver-support.patch	2024-03-18 15:16:24.578603881 +0800
@@ -0,0 +1,43 @@
+From 2e677e4ae8f8330f68013163b060d0fda3a43095 Mon Sep 17 00:00:00 2001
+From: "Langer, Thomas" <tlanger@maxlinear.com>
+Date: Fri, 9 Jul 2021 17:36:46 +0200
+Subject: [PATCH] PONRTSYS-8842: aquantia: Add AQR113 driver support
+
+Add a new entry for AQR113 PHY_ID
+---
+ drivers/net/phy/aquantia_main.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/net/phy/aquantia_main.c
++++ b/drivers/net/phy/aquantia_main.c
+@@ -21,6 +21,7 @@
+ #define PHY_ID_AQR106	0x03a1b4d0
+ #define PHY_ID_AQR107	0x03a1b4e0
+ #define PHY_ID_AQR112	0x03a1b662
++#define PHY_ID_AQR113	0x31c31c40
+ #define PHY_ID_AQR113C	0x31c31c12
+ #define PHY_ID_AQCS109	0x03a1b5c2
+ #define PHY_ID_AQR405	0x03a1b4b0
+@@ -827,6 +828,14 @@ static struct phy_driver aqr_driver[] =
+ 	.get_stats	= aqr107_get_stats,
+ },
+ {
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR113),
++	.name		= "Aquantia AQR113",
++	.config_aneg	= aqr_config_aneg,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr107_read_status,
++},
++{
+ 	PHY_ID_MATCH_MODEL(PHY_ID_AQR412),
+ 	.name		= "Aquantia AQR412",
+ 	.probe		= aqr107_probe,
+@@ -849,6 +858,7 @@ static struct mdio_device_id __maybe_unu
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113C) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR405) },
diff -uprN a/target/linux/generic/hack-5.10/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch b/target/linux/generic/hack-5.10/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch
--- a/target/linux/generic/hack-5.10/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/725-net-phy-aquantia-add-PHY_IDs-for-AQR112-variants.patch	2024-03-18 15:16:24.570604187 +0800
@@ -0,0 +1,63 @@
+From 3b92ee7b7899b6beffb2b484c58326e36612a873 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <daniel@makrotopia.org>
+Date: Thu, 23 Dec 2021 14:52:56 +0000
+Subject: [PATCH] net: phy: aquantia: add PHY_ID for AQR112R
+
+As advised by Ian Chang this PHY is used in Puzzle devices.
+
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+---
+ drivers/net/phy/aquantia_main.c | 10 ++++++++++
+ 1 file changed, 10 insertions(+)
+
+--- a/drivers/net/phy/aquantia_main.c
++++ b/drivers/net/phy/aquantia_main.c
+@@ -21,6 +21,8 @@
+ #define PHY_ID_AQR106	0x03a1b4d0
+ #define PHY_ID_AQR107	0x03a1b4e0
+ #define PHY_ID_AQR112	0x03a1b662
++#define PHY_ID_AQR112C	0x03a1b790
++#define PHY_ID_AQR112R	0x31c31d12
+ #define PHY_ID_AQR113	0x31c31c40
+ #define PHY_ID_AQR113C	0x31c31c12
+ #define PHY_ID_AQCS109	0x03a1b5c2
+@@ -828,6 +830,30 @@ static struct phy_driver aqr_driver[] =
+ 	.get_stats	= aqr107_get_stats,
+ },
+ {
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR112C),
++	.name		= "Aquantia AQR112C",
++	.probe		= aqr107_probe,
++	.config_aneg	= aqr_config_aneg_set_prot,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr107_read_status,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++},
++{
++	PHY_ID_MATCH_MODEL(PHY_ID_AQR112R),
++	.name		= "Aquantia AQR112R",
++	.probe		= aqr107_probe,
++	.config_aneg	= aqr_config_aneg_set_prot,
++	.config_intr	= aqr_config_intr,
++	.ack_interrupt	= aqr_ack_interrupt,
++	.read_status	= aqr107_read_status,
++	.get_sset_count	= aqr107_get_sset_count,
++	.get_strings	= aqr107_get_strings,
++	.get_stats	= aqr107_get_stats,
++},
++{
+ 	PHY_ID_MATCH_MODEL(PHY_ID_AQR113),
+ 	.name		= "Aquantia AQR113",
+ 	.config_aneg	= aqr_config_aneg,
+@@ -858,6 +884,8 @@ static struct mdio_device_id __maybe_unu
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR106) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR107) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112C) },
++	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR112R) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQR113C) },
+ 	{ PHY_ID_MATCH_MODEL(PHY_ID_AQCS109) },
diff -uprN a/target/linux/generic/hack-5.10/760-net-usb-r8152-add-LED-configuration-from-OF.patch b/target/linux/generic/hack-5.10/760-net-usb-r8152-add-LED-configuration-from-OF.patch
--- a/target/linux/generic/hack-5.10/760-net-usb-r8152-add-LED-configuration-from-OF.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/760-net-usb-r8152-add-LED-configuration-from-OF.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,74 @@
+From 82985725e071f2a5735052f18e109a32aeac3a0b Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Sun, 26 Jul 2020 02:38:31 +0200
+Subject: [PATCH] net: usb: r8152: add LED configuration from OF
+
+This adds the ability to configure the LED configuration register using
+OF. This way, the correct value for board specific LED configuration can
+be determined.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ drivers/net/usb/r8152.c | 23 +++++++++++++++++++++++
+ 1 file changed, 23 insertions(+)
+
+--- a/drivers/net/usb/r8152.c
++++ b/drivers/net/usb/r8152.c
+@@ -11,6 +11,7 @@
+ #include <linux/mii.h>
+ #include <linux/ethtool.h>
+ #include <linux/usb.h>
++#include <linux/of.h>
+ #include <linux/crc32.h>
+ #include <linux/if_vlan.h>
+ #include <linux/uaccess.h>
+@@ -6780,6 +6781,22 @@ static void rtl_tally_reset(struct r8152
+ 	ocp_write_word(tp, MCU_TYPE_PLA, PLA_RSTTALLY, ocp_data);
+ }
+ 
++static int r8152_led_configuration(struct r8152 *tp)
++{
++	u32 led_data;
++	int ret;
++
++	ret = of_property_read_u32(tp->udev->dev.of_node, "realtek,led-data",
++								&led_data);
++
++	if (ret)
++		return ret;
++
++	ocp_write_word(tp, MCU_TYPE_PLA, PLA_LEDSEL, led_data);
++
++	return 0;
++}
++
+ static void r8152b_init(struct r8152 *tp)
+ {
+ 	u32 ocp_data;
+@@ -6821,6 +6838,8 @@ static void r8152b_init(struct r8152 *tp
+ 	ocp_data = ocp_read_word(tp, MCU_TYPE_USB, USB_USB_CTRL);
+ 	ocp_data &= ~(RX_AGG_DISABLE | RX_ZERO_EN);
+ 	ocp_write_word(tp, MCU_TYPE_USB, USB_USB_CTRL, ocp_data);
++
++	r8152_led_configuration(tp);
+ }
+ 
+ static void r8153_init(struct r8152 *tp)
+@@ -6961,6 +6980,8 @@ static void r8153_init(struct r8152 *tp)
+ 		tp->coalesce = COALESCE_SLOW;
+ 		break;
+ 	}
++
++	r8152_led_configuration(tp);
+ }
+ 
+ static void r8153b_init(struct r8152 *tp)
+@@ -7043,6 +7064,8 @@ static void r8153b_init(struct r8152 *tp
+ 	rtl_tally_reset(tp);
+ 
+ 	tp->coalesce = 15000;	/* 15 us */
++
++	r8152_led_configuration(tp);
+ }
+ 
+ static void r8153c_init(struct r8152 *tp)
diff -uprN a/target/linux/generic/hack-5.10/761-dt-bindings-net-add-RTL8152-binding-documentation.patch b/target/linux/generic/hack-5.10/761-dt-bindings-net-add-RTL8152-binding-documentation.patch
--- a/target/linux/generic/hack-5.10/761-dt-bindings-net-add-RTL8152-binding-documentation.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/761-dt-bindings-net-add-RTL8152-binding-documentation.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,54 @@
+From 3ee05f4aa64fc86af3be5bc176ba5808de9260a7 Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Sun, 26 Jul 2020 15:30:33 +0200
+Subject: [PATCH] dt-bindings: net: add RTL8152 binding documentation
+
+Add binding documentation for the Realtek RTL8152 / RTL8153 USB ethernet
+adapters.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ .../bindings/net/realtek,rtl8152.yaml         | 36 +++++++++++++++++++
+ 1 file changed, 36 insertions(+)
+ create mode 100644 Documentation/devicetree/bindings/net/realtek,rtl8152.yaml
+
+--- /dev/null
++++ b/Documentation/devicetree/bindings/net/realtek,rtl8152.yaml
+@@ -0,0 +1,36 @@
++# SPDX-License-Identifier: GPL-2.0
++%YAML 1.2
++---
++$id: http://devicetree.org/schemas/net/realtek,rtl8152.yaml#
++$schema: http://devicetree.org/meta-schemas/core.yaml#
++
++title: Realtek RTL8152/RTL8153 series USB ethernet
++
++maintainers:
++  - David Bauer <mail@david-bauer.net>
++
++properties:
++  compatible:
++    oneOf:
++      - items:
++          - enum:
++              - realtek,rtl8152
++              - realtek,rtl8153
++
++  reg:
++    description: The device number on the USB bus
++
++  realtek,led-data:
++    description: Value to be written to the LED configuration register.
++
++required:
++  - compatible
++  - reg
++
++examples:
++  - |
++    usb-eth@2 {
++      compatible = "realtek,rtl8153";
++      reg = <2>;
++      realtek,led-data = <0x87>;
++    };
+\ No newline at end of file
diff -uprN a/target/linux/generic/hack-5.10/773-bgmac-add-srab-switch.patch b/target/linux/generic/hack-5.10/773-bgmac-add-srab-switch.patch
--- a/target/linux/generic/hack-5.10/773-bgmac-add-srab-switch.patch	2024-03-18 15:15:11.381396514 +0800
+++ b/target/linux/generic/hack-5.10/773-bgmac-add-srab-switch.patch	2024-03-18 15:16:24.570604187 +0800
@@ -50,9 +50,9 @@ Signed-off-by: Hauke Mehrtens <hauke@hau
  /**************************************************
   * MII
   **************************************************/
-@@ -1546,6 +1558,14 @@ int bgmac_enet_probe(struct bgmac *bgmac
- 
- 	bgmac->in_init = false;
+@@ -1542,6 +1554,14 @@ int bgmac_enet_probe(struct bgmac *bgmac
+ 	/* Omit FCS from max MTU size */
+ 	net_dev->max_mtu = BGMAC_RX_MAX_FRAME_SIZE - ETH_FCS_LEN;
  
 +	if ((bgmac->feature_flags & BGMAC_FEAT_SRAB) && !bgmac_b53_pdata.regs) {
 +		bgmac_b53_pdata.regs = ioremap(0x18007000, 0x1000);
@@ -65,7 +65,7 @@ Signed-off-by: Hauke Mehrtens <hauke@hau
  	err = register_netdev(bgmac->net_dev);
  	if (err) {
  		dev_err(bgmac->dev, "Cannot register net device\n");
-@@ -1568,6 +1588,10 @@ EXPORT_SYMBOL_GPL(bgmac_enet_probe);
+@@ -1564,6 +1584,10 @@ EXPORT_SYMBOL_GPL(bgmac_enet_probe);
  
  void bgmac_enet_remove(struct bgmac *bgmac)
  {
@@ -86,7 +86,7 @@ Signed-off-by: Hauke Mehrtens <hauke@hau
  
  struct bgmac_slot_info {
  	union {
-@@ -535,6 +536,9 @@ struct bgmac {
+@@ -533,6 +534,9 @@ struct bgmac {
  	void (*cmn_maskset32)(struct bgmac *bgmac, u16 offset, u32 mask,
  			      u32 set);
  	int (*phy_connect)(struct bgmac *bgmac);
diff -uprN a/target/linux/generic/hack-5.10/780-usb-net-MeigLink_modem_support.patch b/target/linux/generic/hack-5.10/780-usb-net-MeigLink_modem_support.patch
--- a/target/linux/generic/hack-5.10/780-usb-net-MeigLink_modem_support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/780-usb-net-MeigLink_modem_support.patch	2024-03-18 15:16:24.570604187 +0800
@@ -0,0 +1,33 @@
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -1024,6 +1024,7 @@ static const struct usb_device_id produc
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0512)},	/* Quectel EG12/EM12 */
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0620)},	/* Quectel EM160R-GL */
+ 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0800)},	/* Quectel RM500Q-GL */
++	{QMI_MATCH_FF_FF_FF(0x05c6, 0xf601)},   /* MeigLink SLM750 */
+ 
+ 	/* 3. Combined interface devices matching on interface number */
+ 	{QMI_FIXED_INTF(0x0408, 0xea42, 4)},	/* Yota / Megafon M100-1 */
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -243,6 +243,8 @@ static void option_instat_callback(struc
+ #define UBLOX_PRODUCT_R6XX			0x90fa
+ /* These Yuga products use Qualcomm's vendor ID */
+ #define YUGA_PRODUCT_CLM920_NC5			0x9625
++/* These MeigLink products use Qualcomm's vendor ID */
++#define MEIGLINK_PRODUCT_SLM750			0xf601
+ 
+ #define QUECTEL_VENDOR_ID			0x2c7c
+ /* These Quectel products use Quectel's vendor ID */
+@@ -1127,6 +1129,11 @@ static const struct usb_device_id option
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EG95, 0xff, 0, 0) },
+ 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96),
+ 	  .driver_info = RSVD(4) },
++	/* Meiglink products using Qualcomm vendor ID */
++	// Works OK. In case of some issues check macros that are used by Quectel Products
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, MEIGLINK_PRODUCT_SLM750, 0xff, 0xff, 0xff),
++	  .driver_info = NUMEP2 },
++	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, MEIGLINK_PRODUCT_SLM750, 0xff, 0, 0) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0xff, 0xff),
+ 	  .driver_info = RSVD(1) | RSVD(2) | RSVD(3) | RSVD(4) | NUMEP2 },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0, 0) },
diff -uprN a/target/linux/generic/hack-5.10/800-GPIO-add-named-gpio-exports.patch b/target/linux/generic/hack-5.10/800-GPIO-add-named-gpio-exports.patch
--- a/target/linux/generic/hack-5.10/800-GPIO-add-named-gpio-exports.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/800-GPIO-add-named-gpio-exports.patch	2024-03-18 15:16:24.578603881 +0800
@@ -15,7 +15,7 @@ Signed-off-by: John Crispin <blogic@open
  
  #include "gpiolib.h"
  #include "gpiolib-of.h"
-@@ -1046,3 +1048,72 @@ void of_gpiochip_remove(struct gpio_chip
+@@ -1039,3 +1041,72 @@ void of_gpiochip_remove(struct gpio_chip
  {
  	of_node_put(chip->of_node);
  }
diff -uprN a/target/linux/generic/hack-5.10/901-debloat_sock_diag.patch b/target/linux/generic/hack-5.10/901-debloat_sock_diag.patch
--- a/target/linux/generic/hack-5.10/901-debloat_sock_diag.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/901-debloat_sock_diag.patch	2024-03-18 15:16:24.574604033 +0800
@@ -122,7 +122,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	u64 res;
 --- a/net/ipv4/Kconfig
 +++ b/net/ipv4/Kconfig
-@@ -424,6 +424,7 @@ config INET_TUNNEL
+@@ -414,6 +414,7 @@ config INET_TUNNEL
  
  config INET_DIAG
  	tristate "INET: socket monitoring interface"
diff -uprN a/target/linux/generic/hack-5.10/902-debloat_proc.patch b/target/linux/generic/hack-5.10/902-debloat_proc.patch
--- a/target/linux/generic/hack-5.10/902-debloat_proc.patch	2024-03-18 15:15:11.365397125 +0800
+++ b/target/linux/generic/hack-5.10/902-debloat_proc.patch	2024-03-18 15:16:24.550604950 +0800
@@ -29,7 +29,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/fs/locks.c
 +++ b/fs/locks.c
-@@ -3016,6 +3016,8 @@ static const struct seq_operations locks
+@@ -2993,6 +2993,8 @@ static const struct seq_operations locks
  
  static int __init proc_locks_init(void)
  {
@@ -246,7 +246,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				&vmalloc_op,
 --- a/mm/vmstat.c
 +++ b/mm/vmstat.c
-@@ -2040,10 +2040,12 @@ void __init init_mm_internals(void)
+@@ -2044,10 +2044,12 @@ void __init init_mm_internals(void)
  	start_shepherd_timer();
  #endif
  #ifdef CONFIG_PROC_FS
@@ -330,7 +330,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
 --- a/net/core/sock.c
 +++ b/net/core/sock.c
-@@ -3710,6 +3710,8 @@ static __net_initdata struct pernet_oper
+@@ -3699,6 +3699,8 @@ static __net_initdata struct pernet_oper
  
  static int __init proto_init(void)
  {
@@ -341,7 +341,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
 --- a/net/ipv4/fib_trie.c
 +++ b/net/ipv4/fib_trie.c
-@@ -2988,11 +2988,13 @@ static const struct seq_operations fib_r
+@@ -2986,11 +2986,13 @@ static const struct seq_operations fib_r
  
  int __net_init fib_proc_init(struct net *net)
  {
@@ -357,7 +357,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  			fib_triestat_seq_show, NULL))
  		goto out2;
  
-@@ -3003,17 +3005,21 @@ int __net_init fib_proc_init(struct net
+@@ -3001,17 +3003,21 @@ int __net_init fib_proc_init(struct net
  	return 0;
  
  out3:
diff -uprN a/target/linux/generic/hack-5.10/904-debloat_dma_buf.patch b/target/linux/generic/hack-5.10/904-debloat_dma_buf.patch
--- a/target/linux/generic/hack-5.10/904-debloat_dma_buf.patch	2024-03-18 15:15:11.365397125 +0800
+++ b/target/linux/generic/hack-5.10/904-debloat_dma_buf.patch	2024-03-18 15:16:24.554604797 +0800
@@ -72,7 +72,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 +MODULE_LICENSE("GPL");
 --- a/kernel/sched/core.c
 +++ b/kernel/sched/core.c
-@@ -3071,6 +3071,7 @@ int wake_up_state(struct task_struct *p,
+@@ -3065,6 +3065,7 @@ int wake_up_state(struct task_struct *p,
  {
  	return try_to_wake_up(p, state, 0);
  }
diff -uprN a/target/linux/generic/hack-5.10/920-device_tree_cmdline.patch b/target/linux/generic/hack-5.10/920-device_tree_cmdline.patch
--- a/target/linux/generic/hack-5.10/920-device_tree_cmdline.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/920-device_tree_cmdline.patch	2024-03-18 15:16:24.554604797 +0800
@@ -0,0 +1,12 @@
+--- a/drivers/of/fdt.c
++++ b/drivers/of/fdt.c
+@@ -1055,6 +1055,9 @@ int __init early_init_dt_scan_chosen(uns
+ 	p = of_get_flat_dt_prop(node, "bootargs", &l);
+ 	if (p != NULL && l > 0)
+ 		strlcpy(data, p, min(l, COMMAND_LINE_SIZE));
++	p = of_get_flat_dt_prop(node, "bootargs-append", &l);
++	if (p != NULL && l > 0)
++		strlcat(data, p, min_t(int, strlen(data) + (int)l, COMMAND_LINE_SIZE));
+ 
+ 	/*
+ 	 * CONFIG_CMDLINE is meant to be a default in case nothing else
diff -uprN a/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch b/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch
--- a/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch	2024-03-18 15:15:11.385396362 +0800
+++ b/target/linux/generic/hack-5.10/952-net-conntrack-events-support-multiple-registrant.patch	2024-03-18 15:16:24.574604033 +0800
@@ -98,7 +98,7 @@ Signed-off-by: Zhi Chen <zhichen@codeaur
  #if defined(CONFIG_NF_CONNTRACK_LABELS)
 --- a/net/netfilter/Kconfig
 +++ b/net/netfilter/Kconfig
-@@ -135,6 +135,14 @@ config NF_CONNTRACK_EVENTS
+@@ -136,6 +136,14 @@ config NF_CONNTRACK_EVENTS
  
  	  If unsure, say `N'.
  
@@ -274,7 +274,7 @@ Signed-off-by: Zhi Chen <zhichen@codeaur
  int nf_ct_expect_register_notifier(struct net *net,
 --- a/net/netfilter/nf_conntrack_netlink.c
 +++ b/net/netfilter/nf_conntrack_netlink.c
-@@ -707,12 +707,19 @@ static size_t ctnetlink_nlmsg_size(const
+@@ -706,13 +706,20 @@ static size_t ctnetlink_nlmsg_size(const
  }
  
  static int
@@ -287,6 +287,7 @@ Signed-off-by: Zhi Chen <zhichen@codeaur
  	const struct nf_conntrack_zone *zone;
  	struct net *net;
  	struct nlmsghdr *nlh;
+ 	struct nfgenmsg *nfmsg;
  	struct nlattr *nest_parms;
 +#ifdef CONFIG_NF_CONNTRACK_CHAIN_EVENTS
 +	struct nf_ct_event *item = (struct nf_ct_event *)ptr;
@@ -294,7 +295,7 @@ Signed-off-by: Zhi Chen <zhichen@codeaur
  	struct nf_conn *ct = item->ct;
  	struct sk_buff *skb;
  	unsigned int type;
-@@ -3760,9 +3767,15 @@ static int ctnetlink_stat_exp_cpu(struct
+@@ -3786,9 +3793,15 @@ static int ctnetlink_stat_exp_cpu(struct
  }
  
  #ifdef CONFIG_NF_CONNTRACK_EVENTS
diff -uprN a/target/linux/generic/hack-5.10/953-net-patch-linux-kernel-to-support-shortcut-fe.patch b/target/linux/generic/hack-5.10/953-net-patch-linux-kernel-to-support-shortcut-fe.patch
--- a/target/linux/generic/hack-5.10/953-net-patch-linux-kernel-to-support-shortcut-fe.patch	2024-03-18 15:15:11.365397125 +0800
+++ b/target/linux/generic/hack-5.10/953-net-patch-linux-kernel-to-support-shortcut-fe.patch	2024-03-18 15:16:24.554604797 +0800
@@ -1,6 +1,6 @@
 --- a/include/linux/if_bridge.h
 +++ b/include/linux/if_bridge.h
-@@ -61,6 +61,9 @@ struct br_ip_list {
+@@ -62,6 +62,9 @@ struct br_ip_list {
  
  extern void brioctl_set(int (*ioctl_hook)(struct net *, unsigned int, void __user *));
  
@@ -12,8 +12,8 @@
  			       struct list_head *br_ip_list);
 --- a/include/linux/skbuff.h
 +++ b/include/linux/skbuff.h
-@@ -865,6 +865,10 @@ struct sk_buff {
- 	__u8			scm_io_uring:1;
+@@ -860,6 +860,10 @@ struct sk_buff {
+ #endif
  	__u8			gro_skip:1;
  
 +#ifdef CONFIG_SHORTCUT_FE
@@ -80,11 +80,10 @@
  	struct net_bridge_port *p;
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -3652,9 +3652,17 @@ static int xmit_one(struct sk_buff *skb,
- {
+@@ -3643,8 +3643,17 @@ static int xmit_one(struct sk_buff *skb,
  	unsigned int len;
  	int rc;
--
+ 
 +#ifdef CONFIG_SHORTCUT_FE
 +	/* If this skb has been fast forwarded then we don't want it to
 +	 * go to any taps (by definition we're trying to bypass them).
@@ -99,7 +98,7 @@
  
  #ifdef CONFIG_ETHERNET_PACKET_MANGLE
  	if (dev->eth_mangle_tx && !(skb = dev->eth_mangle_tx(dev, skb)))
-@@ -5206,6 +5214,11 @@ void netdev_rx_handler_unregister(struct
+@@ -5195,6 +5204,11 @@ void netdev_rx_handler_unregister(struct
  }
  EXPORT_SYMBOL_GPL(netdev_rx_handler_unregister);
  
@@ -111,7 +110,7 @@
  /*
   * Limit the use of PFMEMALLOC reserves to those protocols that implement
   * the special handling of PFMEMALLOC skbs.
-@@ -5254,6 +5267,10 @@ static int __netif_receive_skb_core(stru
+@@ -5243,6 +5257,10 @@ static int __netif_receive_skb_core(stru
  	int ret = NET_RX_DROP;
  	__be16 type;
  
@@ -119,10 +118,10 @@
 +	int (*fast_recv)(struct sk_buff *skb);
 +#endif
 +
- 	net_timestamp_check(!READ_ONCE(netdev_tstamp_prequeue), skb);
+ 	net_timestamp_check(!netdev_tstamp_prequeue, skb);
  
  	trace_netif_receive_skb(skb);
-@@ -5293,6 +5310,15 @@ another_round:
+@@ -5282,6 +5300,16 @@ another_round:
  			goto out;
  	}
  
@@ -135,6 +134,7 @@
 +		}
 +	}
 +#endif
++
  	if (skb_skip_tc_classify(skb))
  		goto skip_classify;
  
diff -uprN a/target/linux/generic/hack-5.10/992-add-ndo-do-ioctl.patch b/target/linux/generic/hack-5.10/992-add-ndo-do-ioctl.patch
--- a/target/linux/generic/hack-5.10/992-add-ndo-do-ioctl.patch	2024-03-18 15:15:11.381396514 +0800
+++ b/target/linux/generic/hack-5.10/992-add-ndo-do-ioctl.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,12 +0,0 @@
---- a/net/wireless/wext-core.c
-+++ b/net/wireless/wext-core.c
-@@ -956,6 +956,9 @@ static int wireless_process_ioctl(struct
- 		else if (private)
- 			return private(dev, iwr, cmd, info, handler);
- 	}
-+	/* Old driver API : call driver ioctl handler */
-+	if (dev->netdev_ops->ndo_do_ioctl)
-+		return dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *) iwr, cmd);
- 	return -EOPNOTSUPP;
- }
- 
diff -uprN a/target/linux/generic/hack-5.10/993-usb-serial-option-add-u9300.patch b/target/linux/generic/hack-5.10/993-usb-serial-option-add-u9300.patch
--- a/target/linux/generic/hack-5.10/993-usb-serial-option-add-u9300.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/993-usb-serial-option-add-u9300.patch	2024-03-18 15:16:24.574604033 +0800
@@ -0,0 +1,46 @@
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -1337,6 +1337,7 @@ static const struct usb_device_id produc
+ 	{QMI_FIXED_INTF(0x03f0, 0x9d1d, 1)},	/* HP lt4120 Snapdragon X5 LTE */
+ 	{QMI_FIXED_INTF(0x22de, 0x9061, 3)},	/* WeTelecom WPD-600N */
+ 	{QMI_QUIRK_SET_DTR(0x1e0e, 0x9001, 5)},	/* SIMCom 7100E, 7230E, 7600E ++ */
++	{QMI_FIXED_INTF(0x1c9e, 0x9b3c, 4)},	/* LONGSUNG_U9300 */
+ 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0121, 4)},	/* Quectel EC21 Mini PCIe */
+ 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0191, 4)},	/* Quectel EG91 */
+ 	{QMI_QUIRK_SET_DTR(0x2c7c, 0x0195, 4)},	/* Quectel EG95 */
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -386,6 +386,7 @@ static void option_instat_callback(struc
+  * Mobidata, etc sell under their own brand names.
+  */
+ #define LONGCHEER_VENDOR_ID			0x1c9e
++#define LONGSUNG_U9300_PRODUCT_ID		0x9b3c
+ 
+ /* 4G Systems products */
+ /* This is the 4G XS Stick W14 a.k.a. Mobilcom Debitel Surf-Stick *
+@@ -583,6 +584,16 @@ static void option_instat_callback(struc
+ /* Device needs ZLP */
+ #define ZLP		BIT(17)
+ 
++struct option_blacklist_info {
++	/* bitfield of interface numbers for OPTION_BLACKLIST_SENDSETUP */
++	const unsigned long sendsetup;
++	/* bitfield of interface numbers for OPTION_BLACKLIST_RESERVED_IF */
++	const unsigned long reserved;
++};
++
++static const struct option_blacklist_info longsung_u9300_blacklist = {
++	.reserved = BIT(4),
++};
+ 
+ static const struct usb_device_id option_ids[] = {
+ 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
+@@ -617,6 +628,8 @@ static const struct usb_device_id option
+ 	{ USB_DEVICE(QUANTA_VENDOR_ID, QUANTA_PRODUCT_GLE) },
+ 	{ USB_DEVICE(QUANTA_VENDOR_ID, 0xea42),
+ 	  .driver_info = RSVD(4) },
++	{ USB_DEVICE(LONGCHEER_VENDOR_ID,LONGSUNG_U9300_PRODUCT_ID),
++	  .driver_info = (kernel_ulong_t)&longsung_u9300_blacklist},
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1c05, USB_CLASS_COMM, 0x02, 0xff) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1c1f, USB_CLASS_COMM, 0x02, 0xff) },
+ 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0x1c23, USB_CLASS_COMM, 0x02, 0xff) },
diff -uprN a/target/linux/generic/hack-5.10/994-mhi-use-irq-flags.patch b/target/linux/generic/hack-5.10/994-mhi-use-irq-flags.patch
--- a/target/linux/generic/hack-5.10/994-mhi-use-irq-flags.patch	2024-03-18 15:15:11.381396514 +0800
+++ b/target/linux/generic/hack-5.10/994-mhi-use-irq-flags.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,48 +0,0 @@
---- a/drivers/bus/mhi/core/init.c
-+++ b/drivers/bus/mhi/core/init.c
-@@ -148,12 +148,17 @@ int mhi_init_irq_setup(struct mhi_contro
- {
- 	struct mhi_event *mhi_event = mhi_cntrl->mhi_event;
- 	struct device *dev = &mhi_cntrl->mhi_dev->dev;
-+	unsigned long irq_flags = IRQF_SHARED | IRQF_NO_SUSPEND;
- 	int i, ret;
- 
-+	/* if controller driver has set irq_flags, use it */
-+	if (mhi_cntrl->irq_flags)
-+		irq_flags = mhi_cntrl->irq_flags;
-+
- 	/* Setup BHI_INTVEC IRQ */
- 	ret = request_threaded_irq(mhi_cntrl->irq[0], mhi_intvec_handler,
- 				   mhi_intvec_threaded_handler,
--				   IRQF_SHARED | IRQF_NO_SUSPEND,
-+				   irq_flags,
- 				   "bhi", mhi_cntrl);
- 	if (ret)
- 		return ret;
-@@ -171,7 +176,7 @@ int mhi_init_irq_setup(struct mhi_contro
- 
- 		ret = request_irq(mhi_cntrl->irq[mhi_event->irq],
- 				  mhi_irq_handler,
--				  IRQF_SHARED | IRQF_NO_SUSPEND,
-+				  irq_flags,
- 				  "mhi", mhi_event);
- 		if (ret) {
- 			dev_err(dev, "Error requesting irq:%d for ev:%d\n",
---- a/include/linux/mhi.h
-+++ b/include/linux/mhi.h
-@@ -353,6 +353,7 @@ struct mhi_controller_config {
-  * @fbc_download: MHI host needs to do complete image transfer (optional)
-  * @pre_init: MHI host needs to do pre-initialization before power up
-  * @wake_set: Device wakeup set flag
-+ * @irq_flags: irq flags passed to request_irq (optional)
-  *
-  * Fields marked as (required) need to be populated by the controller driver
-  * before calling mhi_register_controller(). For the fields marked as (optional)
-@@ -442,6 +443,7 @@ struct mhi_controller {
- 	bool fbc_download;
- 	bool pre_init;
- 	bool wake_set;
-+	unsigned long irq_flags;
- };
- 
- /**
diff -uprN a/target/linux/generic/hack-5.10/995-add-support-for-forced-PM-resume.patch b/target/linux/generic/hack-5.10/995-add-support-for-forced-PM-resume.patch
--- a/target/linux/generic/hack-5.10/995-add-support-for-forced-PM-resume.patch	2024-03-18 15:15:11.365397125 +0800
+++ b/target/linux/generic/hack-5.10/995-add-support-for-forced-PM-resume.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,81 +0,0 @@
---- a/drivers/bus/mhi/core/pm.c
-+++ b/drivers/bus/mhi/core/pm.c
-@@ -768,7 +768,7 @@ int mhi_pm_suspend(struct mhi_controller
- }
- EXPORT_SYMBOL_GPL(mhi_pm_suspend);
- 
--int mhi_pm_resume(struct mhi_controller *mhi_cntrl)
-+static int __mhi_pm_resume(struct mhi_controller *mhi_cntrl, bool force)
- {
- 	struct mhi_chan *itr, *tmp;
- 	struct device *dev = &mhi_cntrl->mhi_dev->dev;
-@@ -784,6 +784,13 @@ int mhi_pm_resume(struct mhi_controller
- 
- 	if (MHI_PM_IN_ERROR_STATE(mhi_cntrl->pm_state))
- 		return -EIO;
-+		
-+	if (mhi_get_mhi_state(mhi_cntrl) != MHI_STATE_M3) {
-+		dev_warn(dev, "Resuming from non M3 state (%s)\n",
-+			 TO_MHI_STATE_STR(mhi_get_mhi_state(mhi_cntrl)));
-+		if (!force)
-+			return -EINVAL;
-+	}
- 
- 	/* Notify clients about exiting LPM */
- 	list_for_each_entry_safe(itr, tmp, &mhi_cntrl->lpm_chans, node) {
-@@ -824,8 +831,19 @@ int mhi_pm_resume(struct mhi_controller
- 
- 	return 0;
- }
-+
-+int mhi_pm_resume(struct mhi_controller *mhi_cntrl)
-+{
-+	return __mhi_pm_resume(mhi_cntrl, false);
-+}
- EXPORT_SYMBOL_GPL(mhi_pm_resume);
- 
-+int mhi_pm_resume_force(struct mhi_controller *mhi_cntrl)
-+{
-+	return __mhi_pm_resume(mhi_cntrl, true);
-+}
-+EXPORT_SYMBOL_GPL(mhi_pm_resume_force);
-+
- int __mhi_device_get_sync(struct mhi_controller *mhi_cntrl)
- {
- 	int ret;
---- a/drivers/net/wireless/ath/ath11k/mhi.c
-+++ b/drivers/net/wireless/ath/ath11k/mhi.c
-@@ -415,6 +415,11 @@ static int ath11k_mhi_set_state(struct a
- 	case ATH11K_MHI_SUSPEND:
- 		break;
- 	case ATH11K_MHI_RESUME:
-+		/* Do force MHI resume as some devices like QCA6390, WCN6855
-+		 * are not in M3 state but they are functional. So just ignore
-+		 * the MHI state while resuming.
-+		 */
-+		ret = mhi_pm_resume_force(ab_pci->mhi_ctrl);
- 		break;
- 	case ATH11K_MHI_TRIGGER_RDDM:
- 		ret = mhi_force_rddm_mode(ab_pci->mhi_ctrl);
---- a/include/linux/mhi.h
-+++ b/include/linux/mhi.h
-@@ -647,6 +647,19 @@ int mhi_pm_suspend(struct mhi_controller
- int mhi_pm_resume(struct mhi_controller *mhi_cntrl);
- 
- /**
-+ * mhi_pm_resume_force - Force resume MHI from suspended state
-+ * @mhi_cntrl: MHI controller
-+ *
-+ * Resume the device irrespective of its MHI state. As per the MHI spec, devices
-+ * has to be in M3 state during resume. But some devices seem to be in a
-+ * different MHI state other than M3 but they continue working fine if allowed.
-+ * This API is intented to be used for such devices.
-+ *
-+ * Return: 0 if the resume succeeds, a negative error code otherwise
-+ */
-+int mhi_pm_resume_force(struct mhi_controller *mhi_cntrl);
-+
-+/**
-  * mhi_download_rddm_img - Download ramdump image from device for
-  *                         debugging purpose.
-  * @mhi_cntrl: MHI controller
diff -uprN a/target/linux/generic/hack-5.10/998-add-ndo-do-ioctl.patch b/target/linux/generic/hack-5.10/998-add-ndo-do-ioctl.patch
--- a/target/linux/generic/hack-5.10/998-add-ndo-do-ioctl.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/hack-5.10/998-add-ndo-do-ioctl.patch	2024-03-18 15:16:24.570604187 +0800
@@ -0,0 +1,12 @@
+--- a/net/wireless/wext-core.c
++++ b/net/wireless/wext-core.c
+@@ -956,6 +956,9 @@ static int wireless_process_ioctl(struct
+ 		else if (private)
+ 			return private(dev, iwr, cmd, info, handler);
+ 	}
++	/* Old driver API : call driver ioctl handler */
++	if (dev->netdev_ops->ndo_do_ioctl)
++		return dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *) iwr, cmd);
+ 	return -EOPNOTSUPP;
+ }
+ 
diff -uprN a/target/linux/generic/pending-5.10/050-dtc-checks-Drop-interrupt-provider-address-cells-check.patch b/target/linux/generic/pending-5.10/050-dtc-checks-Drop-interrupt-provider-address-cells-check.patch
--- a/target/linux/generic/pending-5.10/050-dtc-checks-Drop-interrupt-provider-address-cells-check.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/050-dtc-checks-Drop-interrupt-provider-address-cells-check.patch	2024-03-18 15:16:23.590641574 +0800
@@ -0,0 +1,28 @@
+From d8d1a9a77863a8c7031ae82a1d461aa78eb72a7b Mon Sep 17 00:00:00 2001
+From: Rob Herring <robh@kernel.org>
+Date: Mon, 11 Oct 2021 14:12:43 -0500
+Subject: [PATCH] checks: Drop interrupt provider '#address-cells' check
+
+'#address-cells' is only needed when parsing 'interrupt-map' properties, so
+remove it from the common interrupt-provider test.
+
+Cc: Andre Przywara <andre.przywara@arm.com>
+Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
+Signed-off-by: Rob Herring <robh@kernel.org>
+Message-Id: <20211011191245.1009682-3-robh@kernel.org>
+Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
+---
+--- a/scripts/dtc/checks.c
++++ b/scripts/dtc/checks.c
+@@ -1569,11 +1569,6 @@ static void check_interrupt_provider(str
+ 	if (!prop)
+ 		FAIL(c, dti, node,
+ 		     "Missing #interrupt-cells in interrupt provider");
+-
+-	prop = get_property(node, "#address-cells");
+-	if (!prop)
+-		FAIL(c, dti, node,
+-		     "Missing #address-cells in interrupt provider");
+ }
+ WARNING(interrupt_provider, check_interrupt_provider, NULL);
+ 
diff -uprN a/target/linux/generic/pending-5.10/101-Use-stddefs.h-instead-of-compiler.h.patch b/target/linux/generic/pending-5.10/101-Use-stddefs.h-instead-of-compiler.h.patch
--- a/target/linux/generic/pending-5.10/101-Use-stddefs.h-instead-of-compiler.h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/101-Use-stddefs.h-instead-of-compiler.h.patch	2024-03-18 15:16:23.630640048 +0800
@@ -0,0 +1,11 @@
+--- a/include/uapi/linux/swab.h
++++ b/include/uapi/linux/swab.h
+@@ -3,7 +3,7 @@
+ #define _UAPI_LINUX_SWAB_H
+ 
+ #include <linux/types.h>
+-#include <linux/compiler.h>
++#include <linux/stddef.h>
+ #include <asm/bitsperlong.h>
+ #include <asm/swab.h>
+ 
diff -uprN a/target/linux/generic/pending-5.10/110-v6.3-0001-spidev-Add-Silicon-Labs-EM3581-device-compatible.patch b/target/linux/generic/pending-5.10/110-v6.3-0001-spidev-Add-Silicon-Labs-EM3581-device-compatible.patch
--- a/target/linux/generic/pending-5.10/110-v6.3-0001-spidev-Add-Silicon-Labs-EM3581-device-compatible.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/110-v6.3-0001-spidev-Add-Silicon-Labs-EM3581-device-compatible.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,21 +0,0 @@
-From f7982c726e02001afc19052fe48f642dfcbc00b2 Mon Sep 17 00:00:00 2001
-From: Vincent Tremblay <vincent@vtremblay.dev>
-Date: Mon, 26 Dec 2022 21:10:37 -0500
-Subject: [PATCH 1/2] spidev: Add Silicon Labs EM3581 device compatible
-
-Add compatible string for Silicon Labs EM3581 device.
-
-Note: This patch is adapted from a patch submitted to the for-next branch (v6.3).
-
-Signed-off-by: Vincent Tremblay <vincent@vtremblay.dev>
-
---- a/drivers/spi/spidev.c
-+++ b/drivers/spi/spidev.c
-@@ -691,6 +691,7 @@ static const struct of_device_id spidev_
- 	{ .compatible = "lwn,bk4" },
- 	{ .compatible = "dh,dhcom-board" },
- 	{ .compatible = "menlo,m53cpld" },
-+	{ .compatible = "silabs,em3581" },
- 	{},
- };
- MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff -uprN a/target/linux/generic/pending-5.10/110-v6.3-0002-spidev-Add-Silicon-Labs-SI3210-device-compatible.patch b/target/linux/generic/pending-5.10/110-v6.3-0002-spidev-Add-Silicon-Labs-SI3210-device-compatible.patch
--- a/target/linux/generic/pending-5.10/110-v6.3-0002-spidev-Add-Silicon-Labs-SI3210-device-compatible.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/110-v6.3-0002-spidev-Add-Silicon-Labs-SI3210-device-compatible.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From 536581825219e97fa2ae0c4de35605d2f6311416 Mon Sep 17 00:00:00 2001
-From: Vincent Tremblay <vincent@vtremblay.dev>
-Date: Tue, 27 Dec 2022 09:00:58 -0500
-Subject: [PATCH 2/2] spidev: Add Silicon Labs SI3210 device compatible
-
-Add compatible string for Silicon Labs SI3210 device.
-
-Note: This patch is adapted from a patch submitted to the for-next branch (v6.3).
-
-Signed-off-by: Vincent Tremblay <vincent@vtremblay.dev>
----
-
---- a/drivers/spi/spidev.c
-+++ b/drivers/spi/spidev.c
-@@ -692,6 +692,7 @@ static const struct of_device_id spidev_
- 	{ .compatible = "dh,dhcom-board" },
- 	{ .compatible = "menlo,m53cpld" },
- 	{ .compatible = "silabs,em3581" },
-+	{ .compatible = "silabs,si3210" },
- 	{},
- };
- MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff -uprN a/target/linux/generic/pending-5.10/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch b/target/linux/generic/pending-5.10/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch
--- a/target/linux/generic/pending-5.10/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/120-Fix-alloc_node_mem_map-with-ARCH_PFN_OFFSET-calcu.patch	2024-03-18 15:16:23.606640964 +0800
@@ -71,7 +71,7 @@ Signed-off-by: Tobias Wolf <dev-NTEO@vpl
 
 --- a/mm/page_alloc.c
 +++ b/mm/page_alloc.c
-@@ -7107,7 +7107,7 @@ static void __ref alloc_node_mem_map(str
+@@ -7055,7 +7055,7 @@ static void __ref alloc_node_mem_map(str
  	if (pgdat == NODE_DATA(0)) {
  		mem_map = NODE_DATA(0)->node_mem_map;
  		if (page_to_pfn(mem_map) != pgdat->node_start_pfn)
diff -uprN a/target/linux/generic/pending-5.10/130-add-linux-spidev-compatible-si3210.patch b/target/linux/generic/pending-5.10/130-add-linux-spidev-compatible-si3210.patch
--- a/target/linux/generic/pending-5.10/130-add-linux-spidev-compatible-si3210.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/130-add-linux-spidev-compatible-si3210.patch	2024-03-18 15:16:23.610640811 +0800
@@ -0,0 +1,18 @@
+From: Giuseppe Lippolis <giu.lippolis@gmail.com>
+Subject: Add the linux,spidev compatible in spidev Several device in ramips have this binding in the dts
+
+Signed-off-by: Giuseppe Lippolis <giu.lippolis@gmail.com>
+---
+ drivers/spi/spidev.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/spi/spidev.c
++++ b/drivers/spi/spidev.c
+@@ -682,6 +682,7 @@ static const struct of_device_id spidev_
+ 	{ .compatible = "lwn,bk4" },
+ 	{ .compatible = "dh,dhcom-board" },
+ 	{ .compatible = "menlo,m53cpld" },
++	{ .compatible = "siliconlabs,si3210" },
+ 	{},
+ };
+ MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff -uprN a/target/linux/generic/pending-5.10/150-bridge_allow_receiption_on_disabled_port.patch b/target/linux/generic/pending-5.10/150-bridge_allow_receiption_on_disabled_port.patch
--- a/target/linux/generic/pending-5.10/150-bridge_allow_receiption_on_disabled_port.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/150-bridge_allow_receiption_on_disabled_port.patch	2024-03-18 15:16:23.634639895 +0800
@@ -15,7 +15,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/net/bridge/br_input.c
 +++ b/net/bridge/br_input.c
-@@ -202,6 +202,9 @@ static void __br_handle_local_finish(str
+@@ -195,6 +195,9 @@ static void __br_handle_local_finish(str
  /* note: already called with rcu_read_lock */
  static int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
  {
@@ -25,7 +25,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	__br_handle_local_finish(skb);
  
  	/* return 1 to signal the okfn() was called so it's ok to use the skb */
-@@ -355,6 +358,17 @@ static rx_handler_result_t br_handle_fra
+@@ -348,6 +351,17 @@ static rx_handler_result_t br_handle_fra
  
  forward:
  	switch (p->state) {
diff -uprN a/target/linux/generic/pending-5.10/201-extra_optimization.patch b/target/linux/generic/pending-5.10/201-extra_optimization.patch
--- a/target/linux/generic/pending-5.10/201-extra_optimization.patch	2024-03-18 15:15:10.605426119 +0800
+++ b/target/linux/generic/pending-5.10/201-extra_optimization.patch	2024-03-18 15:16:23.618640505 +0800
@@ -14,7 +14,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/Makefile
 +++ b/Makefile
-@@ -754,11 +754,11 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
+@@ -735,11 +735,11 @@ KBUILD_CFLAGS	+= $(call cc-disable-warni
  KBUILD_CFLAGS	+= $(call cc-disable-warning, address-of-packed-member)
  
  ifdef CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE
diff -uprN a/target/linux/generic/pending-5.10/203-kallsyms_uncompressed.patch b/target/linux/generic/pending-5.10/203-kallsyms_uncompressed.patch
--- a/target/linux/generic/pending-5.10/203-kallsyms_uncompressed.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/203-kallsyms_uncompressed.patch	2024-03-18 15:16:23.614640659 +0800
@@ -13,7 +13,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/init/Kconfig
 +++ b/init/Kconfig
-@@ -1389,6 +1389,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
+@@ -1384,6 +1384,17 @@ config SYSCTL_ARCH_UNALIGN_ALLOW
  	  the unaligned access emulation.
  	  see arch/parisc/kernel/unaligned.c for reference
  
@@ -106,7 +106,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		}
 --- a/scripts/link-vmlinux.sh
 +++ b/scripts/link-vmlinux.sh
-@@ -192,6 +192,10 @@ kallsyms()
+@@ -186,6 +186,10 @@ kallsyms()
  		kallsymopt="${kallsymopt} --base-relative"
  	fi
  
diff -uprN a/target/linux/generic/pending-5.10/205-backtrace_module_info.patch b/target/linux/generic/pending-5.10/205-backtrace_module_info.patch
--- a/target/linux/generic/pending-5.10/205-backtrace_module_info.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/205-backtrace_module_info.patch	2024-03-18 15:16:23.610640811 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/lib/vsprintf.c
 +++ b/lib/vsprintf.c
-@@ -985,8 +985,10 @@ char *symbol_string(char *buf, char *end
+@@ -983,8 +983,10 @@ char *symbol_string(char *buf, char *end
  		    struct printf_spec spec, const char *fmt)
  {
  	unsigned long value;
@@ -23,7 +23,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  #endif
  
  	if (fmt[1] == 'R')
-@@ -1003,8 +1005,14 @@ char *symbol_string(char *buf, char *end
+@@ -1001,8 +1003,14 @@ char *symbol_string(char *buf, char *end
  
  	return string_nocheck(buf, end, sym, spec);
  #else
diff -uprN a/target/linux/generic/pending-5.10/400-mtd-mtdsplit-support.patch b/target/linux/generic/pending-5.10/400-mtd-mtdsplit-support.patch
--- a/target/linux/generic/pending-5.10/400-mtd-mtdsplit-support.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/400-mtd-mtdsplit-support.patch	2024-03-18 15:16:23.610640811 +0800
@@ -272,7 +272,7 @@
  obj-$(CONFIG_MTD_BLOCK)		+= mtdblock.o
 --- a/include/linux/mtd/mtd.h
 +++ b/include/linux/mtd/mtd.h
-@@ -606,6 +606,24 @@ static inline void mtd_align_erase_req(s
+@@ -608,6 +608,24 @@ static inline void mtd_align_erase_req(s
  		req->len += mtd->erasesize - mod;
  }
  
@@ -297,7 +297,7 @@
  static inline uint32_t mtd_div_by_ws(uint64_t sz, struct mtd_info *mtd)
  {
  	if (mtd->writesize_shift)
-@@ -679,6 +697,13 @@ extern struct mtd_info *of_get_mtd_devic
+@@ -680,6 +698,13 @@ extern void __put_mtd_device(struct mtd_
  extern struct mtd_info *get_mtd_device_nm(const char *name);
  extern void put_mtd_device(struct mtd_info *mtd);
  
diff -uprN a/target/linux/generic/pending-5.10/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch b/target/linux/generic/pending-5.10/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch
--- a/target/linux/generic/pending-5.10/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/402-mtd-spi-nor-write-support-for-minor-aligned-partitions.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,389 @@
+From patchwork Tue Jun  8 04:07:19 2021
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: John Thomson <git@johnthomson.fastmail.com.au>
+X-Patchwork-Id: 1489105
+X-Patchwork-Delegate: tudor.ambarus@gmail.com
+Return-Path: 
+ <linux-mtd-bounces+incoming=patchwork.ozlabs.org@lists.infradead.org>
+X-Original-To: incoming@patchwork.ozlabs.org
+Delivered-To: patchwork-incoming@bilbo.ozlabs.org
+Authentication-Results: ozlabs.org;
+ spf=none (no SPF record) smtp.mailfrom=lists.infradead.org
+ (client-ip=2607:7c80:54:e::133; helo=bombadil.infradead.org;
+ envelope-from=linux-mtd-bounces+incoming=patchwork.ozlabs.org@lists.infradead.org;
+ receiver=<UNKNOWN>)
+Authentication-Results: ozlabs.org;
+	dkim=pass (2048-bit key;
+ secure) header.d=lists.infradead.org header.i=@lists.infradead.org
+ header.a=rsa-sha256 header.s=bombadil.20210309 header.b=EMabhVoR;
+	dkim=fail reason="signature verification failed" (2048-bit key;
+ unprotected) header.d=fastmail.com.au header.i=@fastmail.com.au
+ header.a=rsa-sha256 header.s=fm3 header.b=dLzuZ6dB;
+	dkim=fail reason="signature verification failed" (2048-bit key;
+ unprotected) header.d=messagingengine.com header.i=@messagingengine.com
+ header.a=rsa-sha256 header.s=fm3 header.b=nSRGsW+C;
+	dkim-atps=neutral
+Received: from bombadil.infradead.org (bombadil.infradead.org
+ [IPv6:2607:7c80:54:e::133])
+	(using TLSv1.3 with cipher TLS_AES_256_GCM_SHA384 (256/256 bits)
+	 key-exchange X25519 server-signature RSA-PSS (4096 bits) server-digest
+ SHA256)
+	(No client certificate requested)
+	by ozlabs.org (Postfix) with ESMTPS id 4FzcFN1j1nz9sW8
+	for <incoming@patchwork.ozlabs.org>; Tue,  8 Jun 2021 14:09:28 +1000 (AEST)
+DKIM-Signature: v=1; a=rsa-sha256; q=dns/txt; c=relaxed/relaxed;
+	d=lists.infradead.org; s=bombadil.20210309; h=Sender:
+	Content-Transfer-Encoding:Content-Type:List-Subscribe:List-Help:List-Post:
+	List-Archive:List-Unsubscribe:List-Id:MIME-Version:Message-Id:Date:Subject:Cc
+	:To:From:Reply-To:Content-ID:Content-Description:Resent-Date:Resent-From:
+	Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:
+	List-Owner; bh=6mUWQd71FwsINycGYY1qOhKz+ecWJVNtwDkTebG3XkA=; b=EMabhVoRE3ad89
+	o3L2AgyKrs+blSofUC3hoSsQe7gi3m4si8S9HW8Z+8SsS5TufUsvGwDl80qSYGlQOytQF+1yRUWvE
+	6FJ/+bqv+TwjqZFibgJ6+9OVsQN9dZ/no1R0bBXIpmrf8ORUmv58QK4ZQquaFKbyXKpFeWOC2MSv4
+	H2MAhyhTU8a3gtooH6G8+KvsJEfVgh6C+aDbwxyh2UY3chHKuw1kvL6AktbfUE2xl4zxi3x3kc70B
+	Wi3LiJBFokxVdgnROXxTU5tI0XboWYkQV64gLuQNV4XKClcuhVpzloDK8Iok6NTd7b32a7TdEFlCS
+	lGKsEKmxtUlW2FpfoduA==;
+Received: from localhost ([::1] helo=bombadil.infradead.org)
+	by bombadil.infradead.org with esmtp (Exim 4.94.2 #2 (Red Hat Linux))
+	id 1lqT1r-006OAW-DX; Tue, 08 Jun 2021 04:07:51 +0000
+Received: from new1-smtp.messagingengine.com ([66.111.4.221])
+ by bombadil.infradead.org with esmtps (Exim 4.94.2 #2 (Red Hat Linux))
+ id 1lqT1l-006O9b-Fq
+ for linux-mtd@lists.infradead.org; Tue, 08 Jun 2021 04:07:50 +0000
+Received: from compute2.internal (compute2.nyi.internal [10.202.2.42])
+ by mailnew.nyi.internal (Postfix) with ESMTP id 4456B580622;
+ Tue,  8 Jun 2021 00:07:42 -0400 (EDT)
+Received: from mailfrontend2 ([10.202.2.163])
+ by compute2.internal (MEProxy); Tue, 08 Jun 2021 00:07:42 -0400
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=fastmail.com.au;
+ h=from:to:cc:subject:date:message-id:mime-version
+ :content-transfer-encoding; s=fm3; bh=ZXRH+YluM1mHCS1EWUiCY/Sg8O
+ LccfHe1oW5iAay6y8=; b=dLzuZ6dBYf7ZA8tWLOBFZYLi7ERsGe/4vnMXG+ovvb
+ dNBO0+SaFGwoqYSFrfq/TeyHfKyvxrA7+LCdopIuT4abpLHxtRwtRiafQcDYCPat
+ qJIqOZO+wCZC5S9Jc1OP7+t1FviGpgevqIMotci37P+RWc5u3AweMzFljZk90E8C
+ uorV6rXagD+OssJQzllRnAIK88+rOAC9ZyXv2gWxy4d1HSCwSWgzx2vnV9CNp918
+ YC/3tiHas9krbrPIaAsdBROr7Bvoe/ShRRzruKRuvZVgg5NN90vX+/5ZjI8u04GM
+ p2bWCbC62CP6wlcgDaz+c/Sgr5ITd2GPENJsHfqmLRBA==
+DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=
+ messagingengine.com; h=cc:content-transfer-encoding:date:from
+ :message-id:mime-version:subject:to:x-me-proxy:x-me-proxy
+ :x-me-sender:x-me-sender:x-sasl-enc; s=fm3; bh=ZXRH+YluM1mHCS1EW
+ UiCY/Sg8OLccfHe1oW5iAay6y8=; b=nSRGsW+CQ2Zx1RVpIUu8W/VD/k5P+32BW
+ 5k2ltd+UhI3dfldBPzHrYiOP/IJqGkNW+V+rHASacW/vFygnaZoxNjRYKnOsu+26
+ wb2yK3jpl6lsNTg3N1Z4XJrYY2lf9H29DMFbhC67l0PTc050rcZk4XsKTLAlv14Q
+ VA4WREYSaX/4IN4O+ES4TMq0a/3gKZh6nvbbJXbsXfK0WlSHTGZtZmW3fyrqvbXa
+ t+R7L8vvqWvwls0pV+Sn8LeQqb7+A69w0UOnuznjkcA3sCc2YehcHbxcUEnMH+9N
+ bxOjmIDeg9/4X/829tUWUJiLhE5SFmQZ1P6oFtmbWoLrDz0ZJIVBw==
+X-ME-Sender: <xms:C-2-YD2uka4HsA6gcdsV2Ia7vebY4Yjp9E8q7KBMb54jnAzGL7-67Q>
+ <xme:C-2-YCEaxASy5VlcrvNO_jLFpMDGkFCRsuVNuZGEQsiRZygk8jPHWq7unPjeT6uYS
+ 2pUP6PrTQ2rggjEIg>
+X-ME-Received: 
+ <xmr:C-2-YD4exeK49N_YZWWf2BWDhVyCbCY3wwvjTyDOFxeugx7Jg08pzMUToo9oJjrBpcVTaA3kbfk>
+X-ME-Proxy-Cause: 
+ gggruggvucftvghtrhhoucdtuddrgeduledrfedtkedgjeduucetufdoteggodetrfdotf
+ fvucfrrhhofhhilhgvmecuhfgrshhtofgrihhlpdfqfgfvpdfurfetoffkrfgpnffqhgen
+ uceurghilhhouhhtmecufedttdenucesvcftvggtihhpihgvnhhtshculddquddttddmne
+ cujfgurhephffvufffkffoggfgsedtkeertdertddtnecuhfhrohhmpeflohhhnhcuvfhh
+ ohhmshhonhcuoehgihhtsehjohhhnhhthhhomhhsohhnrdhfrghsthhmrghilhdrtghomh
+ drrghuqeenucggtffrrghtthgvrhhnpefffeeihfdukedtuedufeetieeuudfhhefhkefh
+ tefgtdeuffekffelleetveduieenucevlhhushhtvghrufhiiigvpedtnecurfgrrhgrmh
+ epmhgrihhlfhhrohhmpehgihhtsehjohhhnhhthhhomhhsohhnrdhfrghsthhmrghilhdr
+ tghomhdrrghu
+X-ME-Proxy: <xmx:C-2-YI0AJZGjcB3wIbI9BoC9X8VNl4i9A7cQnBkvwZ25czWJlkKCLw>
+ <xmx:C-2-YGGufw99T-O81-FeiSyEruv6_Pr0IHFhspQdxjv5k1VFTZ0lzQ>
+ <xmx:C-2-YJ8BW7DhSDSCEAPSJWrwh_hHP79qreTZtWh_kOUwSh1c0MMlAg>
+ <xmx:Du2-YJBeX2Fg9oFZVXGwEJ1ZrZnXHiAqNON8tbpzquYgcm2o_LM48g>
+Received: by mail.messagingengine.com (Postfix) with ESMTPA; Tue,
+ 8 Jun 2021 00:07:35 -0400 (EDT)
+From: John Thomson <git@johnthomson.fastmail.com.au>
+To: Miquel Raynal <miquel.raynal@bootlin.com>,
+ Richard Weinberger <richard@nod.at>, Vignesh Raghavendra <vigneshr@ti.com>,
+ Tudor Ambarus <tudor.ambarus@microchip.com>,
+ Michael Walle <michael@walle.cc>, Pratyush Yadav <p.yadav@ti.com>,
+ linux-mtd@lists.infradead.org
+Cc: linux-kernel@vger.kernel.org,
+ John Thomson <git@johnthomson.fastmail.com.au>,
+ kernel test robot <lkp@intel.com>, Dan Carpenter <dan.carpenter@oracle.com>
+Subject: [PATCH] mtd: spi-nor: write support for minor aligned partitions
+Date: Tue,  8 Jun 2021 14:07:19 +1000
+Message-Id: <20210608040719.14431-1-git@johnthomson.fastmail.com.au>
+X-Mailer: git-send-email 2.31.1
+MIME-Version: 1.0
+X-CRM114-Version: 20100106-BlameMichelson ( TRE 0.8.0 (BSD) ) MR-646709E3 
+X-CRM114-CacheID: sfid-20210607_210745_712053_67A7D864 
+X-CRM114-Status: GOOD (  26.99  )
+X-Spam-Score: -0.8 (/)
+X-Spam-Report: Spam detection software,
+ running on the system "bombadil.infradead.org",
+ has NOT identified this incoming email as spam.  The original
+ message has been attached to this so you can view it or label
+ similar future email.  If you have any questions, see
+ the administrator of that system for details.
+ Content preview:  Do not prevent writing to mtd partitions where a partition
+ boundary sits on a minor erasesize boundary. This addresses a FIXME that
+ has been present since the start of the linux git history: /* Doesn' [...]
+ Content analysis details:   (-0.8 points, 5.0 required)
+ pts rule name              description
+ ---- ----------------------
+ --------------------------------------------------
+ -0.7 RCVD_IN_DNSWL_LOW      RBL: Sender listed at https://www.dnswl.org/,
+ low trust [66.111.4.221 listed in list.dnswl.org]
+ -0.0 SPF_PASS               SPF: sender matches SPF record
+ -0.0 SPF_HELO_PASS          SPF: HELO matches SPF record
+ 0.0 RCVD_IN_MSPIKE_H3      RBL: Good reputation (+3)
+ [66.111.4.221 listed in wl.mailspike.net]
+ -0.1 DKIM_VALID Message has at least one valid DKIM or DK signature
+ 0.1 DKIM_SIGNED            Message has a DKIM or DK signature,
+ not necessarily
+ valid
+ -0.1 DKIM_VALID_EF          Message has a valid DKIM or DK signature from
+ envelope-from domain
+ 0.0 RCVD_IN_MSPIKE_WL      Mailspike good senders
+X-BeenThere: linux-mtd@lists.infradead.org
+X-Mailman-Version: 2.1.34
+Precedence: list
+List-Id: Linux MTD discussion mailing list <linux-mtd.lists.infradead.org>
+List-Unsubscribe: <http://lists.infradead.org/mailman/options/linux-mtd>,
+ <mailto:linux-mtd-request@lists.infradead.org?subject=unsubscribe>
+List-Archive: <http://lists.infradead.org/pipermail/linux-mtd/>
+List-Post: <mailto:linux-mtd@lists.infradead.org>
+List-Help: <mailto:linux-mtd-request@lists.infradead.org?subject=help>
+List-Subscribe: <http://lists.infradead.org/mailman/listinfo/linux-mtd>,
+ <mailto:linux-mtd-request@lists.infradead.org?subject=subscribe>
+Sender: "linux-mtd" <linux-mtd-bounces@lists.infradead.org>
+Errors-To: linux-mtd-bounces+incoming=patchwork.ozlabs.org@lists.infradead.org
+
+Do not prevent writing to mtd partitions where a partition boundary sits
+on a minor erasesize boundary.
+This addresses a FIXME that has been present since the start of the
+linux git history:
+/* Doesn't start on a boundary of major erase size */
+/* FIXME: Let it be writable if it is on a boundary of
+ * _minor_ erase size though */
+
+Allow a uniform erase region spi-nor device to be configured
+to use the non-uniform erase regions code path for an erase with:
+CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE=y
+
+On supporting hardware (SECT_4K: majority of current SPI-NOR device)
+provide the facility for an erase to use the least number
+of SPI-NOR operations, as well as access to 4K erase without
+requiring CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
+
+Introduce erasesize_minor to the mtd struct,
+the smallest erasesize supported by the device
+
+On existing devices, this is useful where write support is wanted
+for data on a 4K partition, such as some u-boot-env partitions,
+or RouterBoot soft_config, while still netting the performance
+benefits of using 64K sectors
+
+Performance:
+time mtd erase firmware
+OpenWrt 5.10 ramips MT7621 w25q128jv 0xfc0000 partition length
+
+Without this patch
+MTD_SPI_NOR_USE_4K_SECTORS=y	|n
+real    2m 11.66s		|0m 50.86s
+user    0m 0.00s		|0m 0.00s
+sys     1m 56.20s		|0m 50.80s
+
+With this patch
+MTD_SPI_NOR_USE_VARIABLE_ERASE=n|y		|4K_SECTORS=y
+real    0m 51.68s		|0m 50.85s	|2m 12.89s
+user    0m 0.00s		|0m 0.00s	|0m 0.01s
+sys     0m 46.94s		|0m 50.38s	|2m 12.46s
+
+Signed-off-by: John Thomson <git@johnthomson.fastmail.com.au>
+---
+Have not tested on variable erase regions device.
+
+checkpatch does not like the printk(KERN_WARNING
+these should be changed separately beforehand?
+
+Changes RFC -> v1:
+Fix uninitialized variable smatch warning
+Reported-by: kernel test robot <lkp@intel.com>
+Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
+---
+ drivers/mtd/mtdpart.c       | 52 ++++++++++++++++++++++++++++---------
+ drivers/mtd/spi-nor/Kconfig | 10 +++++++
+ drivers/mtd/spi-nor/core.c  | 10 +++++--
+ include/linux/mtd/mtd.h     |  2 ++
+ 4 files changed, 60 insertions(+), 14 deletions(-)
+
+--- a/drivers/mtd/mtdpart.c
++++ b/drivers/mtd/mtdpart.c
+@@ -40,10 +40,11 @@ static struct mtd_info *allocate_partiti
+ 	struct mtd_info *master = mtd_get_master(parent);
+ 	int wr_alignment = (parent->flags & MTD_NO_ERASE) ?
+ 			   master->writesize : master->erasesize;
++	int wr_alignment_minor = 0;
+ 	u64 parent_size = mtd_is_partition(parent) ?
+ 			  parent->part.size : parent->size;
+ 	struct mtd_info *child;
+-	u32 remainder;
++	u32 remainder, remainder_minor;
+ 	char *name;
+ 	u64 tmp;
+ 
+@@ -145,6 +146,7 @@ static struct mtd_info *allocate_partiti
+ 		int i, max = parent->numeraseregions;
+ 		u64 end = child->part.offset + child->part.size;
+ 		struct mtd_erase_region_info *regions = parent->eraseregions;
++		uint32_t erasesize_minor = child->erasesize;
+ 
+ 		/* Find the first erase regions which is part of this
+ 		 * partition. */
+@@ -155,15 +157,24 @@ static struct mtd_info *allocate_partiti
+ 		if (i > 0)
+ 			i--;
+ 
+-		/* Pick biggest erasesize */
+ 		for (; i < max && regions[i].offset < end; i++) {
++			/* Pick biggest erasesize */
+ 			if (child->erasesize < regions[i].erasesize)
+ 				child->erasesize = regions[i].erasesize;
++			/* Pick smallest non-zero erasesize */
++			if ((erasesize_minor > regions[i].erasesize) && (regions[i].erasesize > 0))
++				erasesize_minor = regions[i].erasesize;
+ 		}
++
++		if (erasesize_minor < child->erasesize)
++			child->erasesize_minor = erasesize_minor;
++
+ 		BUG_ON(child->erasesize == 0);
+ 	} else {
+ 		/* Single erase size */
+ 		child->erasesize = master->erasesize;
++		if (master->erasesize_minor)
++			child->erasesize_minor = master->erasesize_minor;
+ 	}
+ 
+ 	/*
+@@ -171,26 +182,43 @@ static struct mtd_info *allocate_partiti
+ 	 * exposes several regions with different erasesize. Adjust
+ 	 * wr_alignment accordingly.
+ 	 */
+-	if (!(child->flags & MTD_NO_ERASE))
++	if (!(child->flags & MTD_NO_ERASE)) {
+ 		wr_alignment = child->erasesize;
++		if (IS_ENABLED(CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE) && child->erasesize_minor)
++			wr_alignment_minor = child->erasesize_minor;
++	}
+ 
+ 	tmp = mtd_get_master_ofs(child, 0);
+ 	remainder = do_div(tmp, wr_alignment);
+ 	if ((child->flags & MTD_WRITEABLE) && remainder) {
+-		/* Doesn't start on a boundary of major erase size */
+-		/* FIXME: Let it be writable if it is on a boundary of
+-		 * _minor_ erase size though */
+-		child->flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
+-			part->name);
++		if (wr_alignment_minor) {
++			tmp = mtd_get_master_ofs(child, 0);
++			remainder_minor = do_div(tmp, wr_alignment_minor);
++			if (remainder_minor == 0)
++				child->erasesize = child->erasesize_minor;
++		}
++
++		if ((!wr_alignment_minor) || (wr_alignment_minor && remainder_minor != 0)) {
++			child->flags &= ~MTD_WRITEABLE;
++			printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase/write block boundary -- force read-only\n",
++				part->name);
++		}
+ 	}
+ 
+ 	tmp = mtd_get_master_ofs(child, 0) + child->part.size;
+ 	remainder = do_div(tmp, wr_alignment);
+ 	if ((child->flags & MTD_WRITEABLE) && remainder) {
+-		child->flags &= ~MTD_WRITEABLE;
+-		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
+-			part->name);
++		if (wr_alignment_minor) {
++			tmp = mtd_get_master_ofs(child, 0) + child->part.size;
++			remainder_minor = do_div(tmp, wr_alignment_minor);
++			if (remainder_minor == 0)
++				child->erasesize = child->erasesize_minor;
++		}
++		if ((!wr_alignment_minor) || (wr_alignment_minor && remainder_minor != 0)) {
++			child->flags &= ~MTD_WRITEABLE;
++			printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase/write block -- force read-only\n",
++				part->name);
++		}
+ 	}
+ 
+ 	child->size = child->part.size;
+--- a/drivers/mtd/spi-nor/Kconfig
++++ b/drivers/mtd/spi-nor/Kconfig
+@@ -10,6 +10,16 @@ menuconfig MTD_SPI_NOR
+ 
+ if MTD_SPI_NOR
+ 
++config MTD_SPI_NOR_USE_VARIABLE_ERASE
++	bool "Disable uniform_erase to allow use of all hardware supported erasesizes"
++	depends on !MTD_SPI_NOR_USE_4K_SECTORS
++	default n
++	help
++	  Allow mixed use of all hardware supported erasesizes,
++	  by forcing spi_nor to use the multiple eraseregions code path.
++	  For example: A 68K erase will use one 64K erase, and one 4K erase
++	  on supporting hardware.
++
+ config MTD_SPI_NOR_USE_4K_SECTORS
+ 	bool "Use small 4096 B erase sectors"
+ 	default y
+--- a/drivers/mtd/spi-nor/core.c
++++ b/drivers/mtd/spi-nor/core.c
+@@ -1075,6 +1075,8 @@ static u8 spi_nor_convert_3to4_erase(u8
+ 
+ static bool spi_nor_has_uniform_erase(const struct spi_nor *nor)
+ {
++	if (IS_ENABLED(CONFIG_MTD_SPI_NOR_USE_VARIABLE_ERASE))
++		return false;
+ 	return !!nor->params->erase_map.uniform_erase_type;
+ }
+ 
+@@ -2560,6 +2562,7 @@ static int spi_nor_select_erase(struct s
+ {
+ 	struct spi_nor_erase_map *map = &nor->params->erase_map;
+ 	const struct spi_nor_erase_type *erase = NULL;
++	const struct spi_nor_erase_type *erase_minor = NULL;
+ 	struct mtd_info *mtd = &nor->mtd;
+ 	u32 wanted_size = nor->info->sector_size;
+ 	int i;
+@@ -2592,8 +2595,9 @@ static int spi_nor_select_erase(struct s
+ 	 */
+ 	for (i = SNOR_ERASE_TYPE_MAX - 1; i >= 0; i--) {
+ 		if (map->erase_type[i].size) {
+-			erase = &map->erase_type[i];
+-			break;
++			if (!erase)
++				erase = &map->erase_type[i];
++			erase_minor = &map->erase_type[i];
+ 		}
+ 	}
+ 
+@@ -2601,6 +2605,8 @@ static int spi_nor_select_erase(struct s
+ 		return -EINVAL;
+ 
+ 	mtd->erasesize = erase->size;
++	if (erase_minor && erase_minor->size < erase->size)
++		mtd->erasesize_minor = erase_minor->size;
+ 	return 0;
+ }
+ 
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -242,6 +242,8 @@ struct mtd_info {
+ 	 * information below if they desire
+ 	 */
+ 	uint32_t erasesize;
++	/* "Minor" (smallest) erase size supported by the whole device */
++	uint32_t erasesize_minor;
+ 	/* Minimal writable flash unit size. In case of NOR flash it is 1 (even
+ 	 * though individual bits can be cleared), in case of NAND flash it is
+ 	 * one NAND page (or half, or one-fourths of it), in case of ECC-ed NOR
diff -uprN a/target/linux/generic/pending-5.10/419-mtd-redboot-add-of_match_table-with-DT-binding.patch b/target/linux/generic/pending-5.10/419-mtd-redboot-add-of_match_table-with-DT-binding.patch
--- a/target/linux/generic/pending-5.10/419-mtd-redboot-add-of_match_table-with-DT-binding.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/419-mtd-redboot-add-of_match_table-with-DT-binding.patch	2024-03-18 15:16:23.610640811 +0800
@@ -12,7 +12,7 @@ Signed-off-by: Rafał Miłecki <rafal@mi
 
 --- a/drivers/mtd/parsers/redboot.c
 +++ b/drivers/mtd/parsers/redboot.c
-@@ -306,6 +306,7 @@ static int parse_redboot_partitions(stru
+@@ -305,6 +305,7 @@ static int parse_redboot_partitions(stru
  
  static const struct of_device_id mtd_parser_redboot_of_match_table[] = {
  	{ .compatible = "redboot-fis" },
diff -uprN a/target/linux/generic/pending-5.10/420-mtd-redboot_space.patch b/target/linux/generic/pending-5.10/420-mtd-redboot_space.patch
--- a/target/linux/generic/pending-5.10/420-mtd-redboot_space.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/420-mtd-redboot_space.patch	2024-03-18 15:16:23.614640659 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/drivers/mtd/parsers/redboot.c
 +++ b/drivers/mtd/parsers/redboot.c
-@@ -280,14 +280,21 @@ static int parse_redboot_partitions(stru
+@@ -279,14 +279,21 @@ static int parse_redboot_partitions(stru
  #endif
  		names += strlen(names)+1;
  
diff -uprN a/target/linux/generic/pending-5.10/435-mtd-add-routerbootpart-parser-config.patch b/target/linux/generic/pending-5.10/435-mtd-add-routerbootpart-parser-config.patch
--- a/target/linux/generic/pending-5.10/435-mtd-add-routerbootpart-parser-config.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/435-mtd-add-routerbootpart-parser-config.patch	2024-03-18 15:16:23.614640659 +0800
@@ -16,10 +16,10 @@ Signed-off-by: Thibaut VARÈNE <hacks@sl
 
 --- a/drivers/mtd/parsers/Kconfig
 +++ b/drivers/mtd/parsers/Kconfig
-@@ -204,3 +204,12 @@ config MTD_SERCOMM_PARTS
- 	  partition map. This partition table contains real partition
- 	  offsets, which may differ from device to device depending on the
- 	  number and location of bad blocks on NAND.
+@@ -195,3 +195,12 @@ config MTD_REDBOOT_PARTS_READONLY
+ 	  'FIS directory' images, enable this option.
+ 
+ endif # MTD_REDBOOT_PARTS
 +
 +config MTD_ROUTERBOOT_PARTS
 +	tristate "RouterBoot flash partition parser"
@@ -31,8 +31,8 @@ Signed-off-by: Thibaut VARÈNE <hacks@sl
 +	 formatted DTS.
 --- a/drivers/mtd/parsers/Makefile
 +++ b/drivers/mtd/parsers/Makefile
-@@ -14,3 +14,4 @@ obj-$(CONFIG_MTD_PARSER_TRX)		+= parser_
- obj-$(CONFIG_MTD_SERCOMM_PARTS)		+= scpart.o
+@@ -13,3 +13,4 @@ obj-$(CONFIG_MTD_AFS_PARTS)		+= afs.o
+ obj-$(CONFIG_MTD_PARSER_TRX)		+= parser_trx.o
  obj-$(CONFIG_MTD_SHARPSL_PARTS)		+= sharpslpart.o
  obj-$(CONFIG_MTD_REDBOOT_PARTS)		+= redboot.o
 +obj-$(CONFIG_MTD_ROUTERBOOT_PARTS)		+= routerbootpart.o
diff -uprN a/target/linux/generic/pending-5.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch b/target/linux/generic/pending-5.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch
--- a/target/linux/generic/pending-5.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/460-mtd-cfi_cmdset_0002-no-erase_suspend.patch	2024-03-18 15:16:23.610640811 +0800
@@ -14,7 +14,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/drivers/mtd/chips/cfi_cmdset_0002.c
 +++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -906,7 +906,7 @@ static int get_chip(struct map_info *map
+@@ -913,7 +913,7 @@ static int get_chip(struct map_info *map
  		return 0;
  
  	case FL_ERASING:
diff -uprN a/target/linux/generic/pending-5.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch b/target/linux/generic/pending-5.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch
--- a/target/linux/generic/pending-5.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/461-mtd-cfi_cmdset_0002-add-buffer-write-cmd-timeout.patch	2024-03-18 15:16:23.614640659 +0800
@@ -7,7 +7,7 @@ Signed-off-by: George Kashperko <george@
  1 file changed, 1 insertion(+)
 --- a/drivers/mtd/chips/cfi_cmdset_0002.c
 +++ b/drivers/mtd/chips/cfi_cmdset_0002.c
-@@ -2050,6 +2050,7 @@ static int __xipram do_write_buffer(stru
+@@ -2057,6 +2057,7 @@ static int __xipram do_write_buffer(stru
  
  	/* Write Buffer Load */
  	map_write(map, CMD(0x25), cmd_adr);
diff -uprN a/target/linux/generic/pending-5.10/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch b/target/linux/generic/pending-5.10/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch
--- a/target/linux/generic/pending-5.10/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/470-mtd-spi-nor-support-limiting-4K-sectors-support-base.patch	2024-03-18 15:16:23.614640659 +0800
@@ -19,7 +19,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/drivers/mtd/spi-nor/Kconfig
 +++ b/drivers/mtd/spi-nor/Kconfig
-@@ -24,6 +24,17 @@ config MTD_SPI_NOR_USE_4K_SECTORS
+@@ -34,6 +34,17 @@ config MTD_SPI_NOR_USE_4K_SECTORS
  	  Please note that some tools/drivers/filesystems may not work with
  	  4096 B erase size (e.g. UBIFS requires 15 KiB as a minimum).
  
@@ -39,7 +39,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  endif # MTD_SPI_NOR
 --- a/drivers/mtd/spi-nor/core.c
 +++ b/drivers/mtd/spi-nor/core.c
-@@ -2806,6 +2806,21 @@ static void spi_nor_info_init_params(str
+@@ -2792,6 +2792,21 @@ static void spi_nor_info_init_params(str
  	 */
  	erase_mask = 0;
  	i = 0;
@@ -61,7 +61,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	if (info->flags & SECT_4K_PMC) {
  		erase_mask |= BIT(i);
  		spi_nor_set_erase_type(&map->erase_type[i], 4096u,
-@@ -2817,6 +2832,7 @@ static void spi_nor_info_init_params(str
+@@ -2803,6 +2818,7 @@ static void spi_nor_info_init_params(str
  				       SPINOR_OP_BE_4K);
  		i++;
  	}
diff -uprN a/target/linux/generic/pending-5.10/476-mtd-spi-nor-add-eon-en25q128.patch b/target/linux/generic/pending-5.10/476-mtd-spi-nor-add-eon-en25q128.patch
--- a/target/linux/generic/pending-5.10/476-mtd-spi-nor-add-eon-en25q128.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/476-mtd-spi-nor-add-eon-en25q128.patch	2024-03-18 15:16:23.610640811 +0800
@@ -1,24 +1,18 @@
 From: Piotr Dymacz <pepe2k@gmail.com>
 Subject: kernel/mtd: add support for EON EN25Q128
 
-Add support for EON EN25Q128 with flags SECT_4K and
-from documentation supports QUAD_READ
-
 Signed-off-by: Piotr Dymacz <pepe2k@gmail.com>
-Signed-off-by: Christian Marangi <ansuelsmth@gmail.com>
 ---
  drivers/mtd/spi-nor/spi-nor.c | 1 +
  1 file changed, 1 insertion(+)
 
 --- a/drivers/mtd/spi-nor/eon.c
 +++ b/drivers/mtd/spi-nor/eon.c
-@@ -15,6 +15,9 @@ static const struct flash_info eon_parts
+@@ -15,6 +15,7 @@ static const struct flash_info eon_parts
  	{ "en25q32b",   INFO(0x1c3016, 0, 64 * 1024,   64, 0) },
  	{ "en25p64",    INFO(0x1c2017, 0, 64 * 1024,  128, 0) },
  	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
-+	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256,
-+			     SECT_4K | SPI_NOR_DUAL_READ) },
-+	{ "en25qx128a",	INFO(0x1c7118, 0, 64 * 1024,  256, SECT_4K) },
++	{ "en25q128",   INFO(0x1c3018, 0, 64 * 1024,  256, SECT_4K) },
  	{ "en25q80a",   INFO(0x1c3014, 0, 64 * 1024,   16,
  			     SECT_4K | SPI_NOR_DUAL_READ) },
  	{ "en25qh16",   INFO(0x1c7015, 0, 64 * 1024,   32,
diff -uprN a/target/linux/generic/pending-5.10/479-mtd-spi-nor-add-xtx-xt25f128b.patch b/target/linux/generic/pending-5.10/479-mtd-spi-nor-add-xtx-xt25f128b.patch
--- a/target/linux/generic/pending-5.10/479-mtd-spi-nor-add-xtx-xt25f128b.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/479-mtd-spi-nor-add-xtx-xt25f128b.patch	2024-03-18 15:16:23.618640505 +0800
@@ -59,7 +59,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 +};
 --- a/drivers/mtd/spi-nor/core.c
 +++ b/drivers/mtd/spi-nor/core.c
-@@ -2037,6 +2037,7 @@ static const struct spi_nor_manufacturer
+@@ -2028,6 +2028,7 @@ static const struct spi_nor_manufacturer
  	&spi_nor_winbond,
  	&spi_nor_xilinx,
  	&spi_nor_xmc,
diff -uprN a/target/linux/generic/pending-5.10/483-mtd-spinand-add-support-for-xtx-xt26g0xa.patch b/target/linux/generic/pending-5.10/483-mtd-spinand-add-support-for-xtx-xt26g0xa.patch
--- a/target/linux/generic/pending-5.10/483-mtd-spinand-add-support-for-xtx-xt26g0xa.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/483-mtd-spinand-add-support-for-xtx-xt26g0xa.patch	2024-03-18 15:16:23.638639742 +0800
@@ -0,0 +1,178 @@
+From a07e31adf2753cad2fd9790db5bfc047c81e8152 Mon Sep 17 00:00:00 2001
+From: Felix Matouschek <felix@matouschek.org>
+Date: Fri, 2 Jul 2021 20:31:23 +0200
+Subject: [PATCH] mtd: spinand: Add support for XTX XT26G0xA
+
+Add support for XTX Technology XT26G01AXXXXX, XTX26G02AXXXXX and
+XTX26G04AXXXXX SPI NAND.
+
+These are 3V, 1G/2G/4Gbit serial SLC NAND flash devices with on-die ECC
+(8bit strength per 512bytes).
+
+Tested on Teltonika RUTX10 flashed with OpenWrt.
+
+Datasheets available at
+http://www.xtxtech.com/download/?AId=225
+https://datasheet.lcsc.com/szlcsc/2005251034_XTX-XT26G01AWSEGA_C558841.pdf
+
+Signed-off-by: Felix Matouschek <felix@matouschek.org>
+---
+ drivers/mtd/nand/spi/Makefile |   2 +-
+ drivers/mtd/nand/spi/core.c   |   1 +
+ drivers/mtd/nand/spi/xtx.c    | 122 ++++++++++++++++++++++++++++++++++
+ include/linux/mtd/spinand.h   |   1 +
+ 4 files changed, 125 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/mtd/nand/spi/xtx.c
+
+--- a/drivers/mtd/nand/spi/Makefile
++++ b/drivers/mtd/nand/spi/Makefile
+@@ -1,3 +1,3 @@
+ # SPDX-License-Identifier: GPL-2.0
+-spinand-objs := core.o gigadevice.o macronix.o micron.o paragon.o toshiba.o winbond.o
++spinand-objs := core.o gigadevice.o macronix.o micron.o paragon.o toshiba.o winbond.o xtx.o
+ obj-$(CONFIG_MTD_SPI_NAND) += spinand.o
+--- a/drivers/mtd/nand/spi/core.c
++++ b/drivers/mtd/nand/spi/core.c
+@@ -760,6 +760,7 @@ static const struct spinand_manufacturer
+ 	&paragon_spinand_manufacturer,
+ 	&toshiba_spinand_manufacturer,
+ 	&winbond_spinand_manufacturer,
++	&xtx_spinand_manufacturer,
+ };
+ 
+ static int spinand_manufacturer_match(struct spinand_device *spinand,
+--- /dev/null
++++ b/drivers/mtd/nand/spi/xtx.c
+@@ -0,0 +1,122 @@
++// SPDX-License-Identifier: GPL-2.0
++/*
++ * Author:
++ * Felix Matouschek <felix@matouschek.org>
++ */
++
++#include <linux/device.h>
++#include <linux/kernel.h>
++#include <linux/mtd/spinand.h>
++
++#define SPINAND_MFR_XTX	0x0B
++
++#define XT26G0XA_STATUS_ECC_MASK	GENMASK(5, 2)
++#define XT26G0XA_STATUS_ECC_NO_DETECTED	(0 << 2)
++#define XT26G0XA_STATUS_ECC_8_CORRECTED	(3 << 4)
++#define XT26G0XA_STATUS_ECC_UNCOR_ERROR	(2 << 4)
++
++static SPINAND_OP_VARIANTS(read_cache_variants,
++		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_DUALIO_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
++		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
++
++static SPINAND_OP_VARIANTS(write_cache_variants,
++		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
++		SPINAND_PROG_LOAD(true, 0, NULL, 0));
++
++static SPINAND_OP_VARIANTS(update_cache_variants,
++		SPINAND_PROG_LOAD_X4(false, 0, NULL, 0),
++		SPINAND_PROG_LOAD(false, 0, NULL, 0));
++
++static int xt26g0xa_ooblayout_ecc(struct mtd_info *mtd, int section,
++				   struct mtd_oob_region *region)
++{
++	if (section)
++		return -ERANGE;
++
++	region->offset = 8;
++	region->length = 40;
++
++	return 0;
++}
++
++static int xt26g0xa_ooblayout_free(struct mtd_info *mtd, int section,
++				   struct mtd_oob_region *region)
++{
++	if (section)
++		return -ERANGE;
++
++	region->offset = 1;
++	region->length = 7;
++
++	return 0;
++}
++
++static const struct mtd_ooblayout_ops xt26g0xa_ooblayout = {
++	.ecc = xt26g0xa_ooblayout_ecc,
++	.free = xt26g0xa_ooblayout_free,
++};
++
++static int xt26g0xa_ecc_get_status(struct spinand_device *spinand,
++					 u8 status)
++{
++	switch (status & XT26G0XA_STATUS_ECC_MASK) {
++	case XT26G0XA_STATUS_ECC_NO_DETECTED:
++		return 0;
++	case XT26G0XA_STATUS_ECC_8_CORRECTED:
++		return 8;
++	case XT26G0XA_STATUS_ECC_UNCOR_ERROR:
++		return -EBADMSG;
++	default: /* (1 << 2) through (7 << 2) are 1-7 corrected errors */
++		return (status & XT26G0XA_STATUS_ECC_MASK) >> 2;
++	}
++
++	return -EINVAL;
++}
++
++static const struct spinand_info xtx_spinand_table[] = {
++	SPINAND_INFO("XT26G01A",
++		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xE1),
++		     NAND_MEMORG(1, 2048, 64, 64, 1024, 20, 1, 1, 1),
++		     NAND_ECCREQ(8, 512),
++		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
++					      &write_cache_variants,
++					      &update_cache_variants),
++		     SPINAND_HAS_QE_BIT,
++		     SPINAND_ECCINFO(&xt26g0xa_ooblayout,
++				     xt26g0xa_ecc_get_status)),
++	SPINAND_INFO("XT26G02A",
++		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xE2),
++		     NAND_MEMORG(1, 2048, 64, 64, 2048, 40, 1, 1, 1),
++		     NAND_ECCREQ(8, 512),
++		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
++					      &write_cache_variants,
++					      &update_cache_variants),
++		     SPINAND_HAS_QE_BIT,
++		     SPINAND_ECCINFO(&xt26g0xa_ooblayout,
++				     xt26g0xa_ecc_get_status)),
++	SPINAND_INFO("XT26G04A",
++		     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xE3),
++		     NAND_MEMORG(1, 2048, 64, 128, 2048, 40, 1, 1, 1),
++		     NAND_ECCREQ(8, 512),
++		     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
++					      &write_cache_variants,
++					      &update_cache_variants),
++		     SPINAND_HAS_QE_BIT,
++		     SPINAND_ECCINFO(&xt26g0xa_ooblayout,
++				     xt26g0xa_ecc_get_status)),
++};
++
++static const struct spinand_manufacturer_ops xtx_spinand_manuf_ops = {
++};
++
++const struct spinand_manufacturer xtx_spinand_manufacturer = {
++	.id = SPINAND_MFR_XTX,
++	.name = "XTX",
++	.chips = xtx_spinand_table,
++	.nchips = ARRAY_SIZE(xtx_spinand_table),
++	.ops = &xtx_spinand_manuf_ops,
++};
+--- a/include/linux/mtd/spinand.h
++++ b/include/linux/mtd/spinand.h
+@@ -244,6 +244,7 @@ extern const struct spinand_manufacturer
+ extern const struct spinand_manufacturer paragon_spinand_manufacturer;
+ extern const struct spinand_manufacturer toshiba_spinand_manufacturer;
+ extern const struct spinand_manufacturer winbond_spinand_manufacturer;
++extern const struct spinand_manufacturer xtx_spinand_manufacturer;
+ 
+ /**
+  * struct spinand_op_variants - SPI NAND operation variants
diff -uprN a/target/linux/generic/pending-5.10/484-mtd-spi-nor-add-esmt-f25l16pa.patch b/target/linux/generic/pending-5.10/484-mtd-spi-nor-add-esmt-f25l16pa.patch
--- a/target/linux/generic/pending-5.10/484-mtd-spi-nor-add-esmt-f25l16pa.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/484-mtd-spi-nor-add-esmt-f25l16pa.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,11 @@
+--- a/drivers/mtd/spi-nor/esmt.c
++++ b/drivers/mtd/spi-nor/esmt.c
+@@ -10,6 +10,8 @@
+ 
+ static const struct flash_info esmt_parts[] = {
+ 	/* ESMT */
++	{ "f25l16pa-2s", INFO(0x8c2115, 0, 64 * 1024, 32,
++			   SECT_4K | SPI_NOR_HAS_LOCK) },
+ 	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64,
+ 			   SECT_4K | SPI_NOR_HAS_LOCK) },
+ 	{ "f25l32qa", INFO(0x8c4116, 0, 64 * 1024, 64,
diff -uprN a/target/linux/generic/pending-5.10/485-mtd-spi-nor-add-xmc-xm25qh128c.patch b/target/linux/generic/pending-5.10/485-mtd-spi-nor-add-xmc-xm25qh128c.patch
--- a/target/linux/generic/pending-5.10/485-mtd-spi-nor-add-xmc-xm25qh128c.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/485-mtd-spi-nor-add-xmc-xm25qh128c.patch	2024-03-18 15:16:23.598641269 +0800
@@ -1,14 +1,3 @@
-From: Langhua Ye <y1248289414@outlook.com>
-Subject: mtd/spi-nor/xmc: add support for XMC XM25QH128C
-
-The XMC XM25QH128C is a 16MB SPI NOR chip. The patch is verified on Ruijie RG-EW3200GX PRO.
-Datasheet available at https://www.xmcwh.com/uploads/435/XM25QH128C.pdf
-
-Submitted-by: Langhua Ye <y1248289414@outlook.com>
----
- drivers/mtd/spi-nor/xmc.c                             | 2 ++
- 1 file changed, 2 insertions(+)
-
 --- a/drivers/mtd/spi-nor/xmc.c
 +++ b/drivers/mtd/spi-nor/xmc.c
 @@ -14,6 +14,8 @@ static const struct flash_info xmc_parts
diff -uprN a/target/linux/generic/pending-5.10/488-mtd-spi-nor-add-xmc-xm25qh64c.patch b/target/linux/generic/pending-5.10/488-mtd-spi-nor-add-xmc-xm25qh64c.patch
--- a/target/linux/generic/pending-5.10/488-mtd-spi-nor-add-xmc-xm25qh64c.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/488-mtd-spi-nor-add-xmc-xm25qh64c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,22 +0,0 @@
-From: Joe Mullally <jwmullally@gmail.com>
-Subject: mtd/spi-nor/xmc: add support for XMC XM25QH64C
-
-The XMC XM25QH64C is a 8MB SPI NOR chip. The patch is verified on TL-WPA8631P v3.
-Datasheet available at https://www.xmcwh.com/uploads/442/XM25QH64C.pdf
-
-Signed-off-by: Joe Mullally <jwmullally@gmail.com>
----
- drivers/mtd/spi-nor/xmc.c                             | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/mtd/spi-nor/xmc.c
-+++ b/drivers/mtd/spi-nor/xmc.c
-@@ -12,6 +12,8 @@ static const struct flash_info xmc_parts
- 	/* XMC (Wuhan Xinxin Semiconductor Manufacturing Corp.) */
- 	{ "XM25QH64A", INFO(0x207017, 0, 64 * 1024, 128,
- 			    SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
-+	{ "XM25QH64C", INFO(0x204017, 0, 64 * 1024, 128,
-+			    SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "XM25QH128A", INFO(0x207018, 0, 64 * 1024, 256,
- 			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
- 	{ "XM25QH128C", INFO(0x204018, 0, 64 * 1024, 256,
diff -uprN a/target/linux/generic/pending-5.10/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch b/target/linux/generic/pending-5.10/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch
--- a/target/linux/generic/pending-5.10/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/490-ubi-auto-attach-mtd-device-named-ubi-or-data-on-boot.patch	2024-03-18 15:16:23.610640811 +0800
@@ -8,7 +8,7 @@ Signed-off-by: Daniel Golle <daniel@makr
 
 --- a/drivers/mtd/ubi/build.c
 +++ b/drivers/mtd/ubi/build.c
-@@ -1201,6 +1201,73 @@ static struct mtd_info * __init open_mtd
+@@ -1192,6 +1192,73 @@ static struct mtd_info * __init open_mtd
  	return mtd;
  }
  
@@ -82,7 +82,7 @@ Signed-off-by: Daniel Golle <daniel@makr
  static int __init ubi_init(void)
  {
  	int err, i, k;
-@@ -1284,6 +1351,12 @@ static int __init ubi_init(void)
+@@ -1275,6 +1342,12 @@ static int __init ubi_init(void)
  		}
  	}
  
diff -uprN a/target/linux/generic/pending-5.10/494-mtd-ubi-add-EOF-marker-support.patch b/target/linux/generic/pending-5.10/494-mtd-ubi-add-EOF-marker-support.patch
--- a/target/linux/generic/pending-5.10/494-mtd-ubi-add-EOF-marker-support.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/494-mtd-ubi-add-EOF-marker-support.patch	2024-03-18 15:16:23.614640659 +0800
@@ -50,7 +50,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
  		break;
 --- a/drivers/mtd/ubi/ubi.h
 +++ b/drivers/mtd/ubi/ubi.h
-@@ -780,6 +780,7 @@ struct ubi_attach_info {
+@@ -782,6 +782,7 @@ struct ubi_attach_info {
  	int mean_ec;
  	uint64_t ec_sum;
  	int ec_count;
diff -uprN a/target/linux/generic/pending-5.10/495-mtd-core-add-get_mtd_device_by_node.patch b/target/linux/generic/pending-5.10/495-mtd-core-add-get_mtd_device_by_node.patch
--- a/target/linux/generic/pending-5.10/495-mtd-core-add-get_mtd_device_by_node.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/495-mtd-core-add-get_mtd_device_by_node.patch	2024-03-18 15:16:23.618640505 +0800
@@ -0,0 +1,75 @@
+From 1bd1b740f208d1cf4071932cc51860d37266c402 Mon Sep 17 00:00:00 2001
+From: Bernhard Frauendienst <kernel@nospam.obeliks.de>
+Date: Sat, 1 Sep 2018 00:30:11 +0200
+Subject: [PATCH 495/497] mtd: core: add get_mtd_device_by_node
+
+Add function to retrieve a mtd device by its OF node. Since drivers can
+assign arbitrary names to mtd devices in the absence of a label
+property, there is no other reliable way to retrieve a mtd device for a
+given OF node.
+
+Signed-off-by: Bernhard Frauendienst <kernel@nospam.obeliks.de>
+Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/mtd/mtdcore.c   | 38 ++++++++++++++++++++++++++++++++++++++
+ include/linux/mtd/mtd.h |  2 ++
+ 2 files changed, 40 insertions(+)
+
+--- a/drivers/mtd/mtdcore.c
++++ b/drivers/mtd/mtdcore.c
+@@ -1046,6 +1046,44 @@ out_unlock:
+ }
+ EXPORT_SYMBOL_GPL(get_mtd_device_nm);
+ 
++/**
++ *	get_mtd_device_by_node - obtain a validated handle for an MTD device
++ *	by of_node
++ *	@of_node: OF node of MTD device to open
++ *
++ *	This function returns MTD device description structure in case of
++ *	success and an error code in case of failure.
++ */
++struct mtd_info *get_mtd_device_by_node(const struct device_node *of_node)
++{
++	int err = -ENODEV;
++	struct mtd_info *mtd = NULL, *other;
++
++	mutex_lock(&mtd_table_mutex);
++
++	mtd_for_each_device(other) {
++		if (of_node == other->dev.of_node) {
++			mtd = other;
++			break;
++		}
++	}
++
++	if (!mtd)
++		goto out_unlock;
++
++	err = __get_mtd_device(mtd);
++	if (err)
++		goto out_unlock;
++
++	mutex_unlock(&mtd_table_mutex);
++	return mtd;
++
++out_unlock:
++	mutex_unlock(&mtd_table_mutex);
++	return ERR_PTR(err);
++}
++EXPORT_SYMBOL_GPL(get_mtd_device_by_node);
++
+ void put_mtd_device(struct mtd_info *mtd)
+ {
+ 	mutex_lock(&mtd_table_mutex);
+--- a/include/linux/mtd/mtd.h
++++ b/include/linux/mtd/mtd.h
+@@ -698,6 +698,8 @@ extern struct mtd_info *get_mtd_device(s
+ extern int __get_mtd_device(struct mtd_info *mtd);
+ extern void __put_mtd_device(struct mtd_info *mtd);
+ extern struct mtd_info *get_mtd_device_nm(const char *name);
++extern struct mtd_info *get_mtd_device_by_node(
++		const struct device_node *of_node);
+ extern void put_mtd_device(struct mtd_info *mtd);
+ 
+ static inline uint64_t mtdpart_get_offset(const struct mtd_info *mtd)
diff -uprN a/target/linux/generic/pending-5.10/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch b/target/linux/generic/pending-5.10/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch
--- a/target/linux/generic/pending-5.10/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/497-mtd-mtdconcat-add-dt-driver-for-concat-devices.patch	2024-03-18 15:16:23.614640659 +0800
@@ -165,7 +165,7 @@ Signed-off-by: Bernhard Frauendienst <ke
 +	platform_set_drvdata(pdev, info);
 +
 +	of_for_each_phandle(&it, err, node, "devices", NULL, 0) {
-+		mtd = of_get_mtd_device_by_node(it.node);
++		mtd = get_mtd_device_by_node(it.node);
 +		if (IS_ERR(mtd)) {
 +			of_node_put(it.node);
 +			err = -EPROBE_DEFER;
diff -uprN a/target/linux/generic/pending-5.10/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch b/target/linux/generic/pending-5.10/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch
--- a/target/linux/generic/pending-5.10/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/498-mtd-spi-nor-locking-support-for-MX25L6405D.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,34 @@
+From 8bf2ce6ea4ee840b70f55a27f80e1cd308051b13 Mon Sep 17 00:00:00 2001
+From: Nick Hainke <vincent@systemli.org>
+Date: Mon, 27 Dec 2021 00:38:13 +0100
+Subject: [PATCH 1/2] mtd: spi-nor: locking support for MX25L6405D
+
+Macronix MX25L6405D supports locking with four block-protection bits.
+Currently, the driver only sets three bits.  If the bootloader does not
+sustain the flash chip in an unlocked state, the flash might be
+non-writeable. Add the corresponding flag to enable locking support with
+four bits in the status register.
+
+Tested on Nanostation M2 XM.
+
+Similar to commit 7ea40b54e83b ("mtd: spi-nor: enable locking support for
+MX25L12805D")
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+Signed-off-by: Nick Hainke <vincent@systemli.org>
+---
+ drivers/mtd/spi-nor/macronix.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/mtd/spi-nor/macronix.c
++++ b/drivers/mtd/spi-nor/macronix.c
+@@ -42,7 +42,8 @@ static const struct flash_info macronix_
+ 	{ "mx25l1606e",  INFO(0xc22015, 0, 64 * 1024,  32, SECT_4K) },
+ 	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
+-	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K) },
++	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, SECT_4K |
++			      SPI_NOR_HAS_LOCK | SPI_NOR_4BIT_BP) },
+ 	{ "mx25u2033e",  INFO(0xc22532, 0, 64 * 1024,   4, SECT_4K) },
+ 	{ "mx25u3235f",	 INFO(0xc22536, 0, 64 * 1024,  64,
+ 			      SECT_4K | SPI_NOR_DUAL_READ |
diff -uprN a/target/linux/generic/pending-5.10/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch b/target/linux/generic/pending-5.10/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch
--- a/target/linux/generic/pending-5.10/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/499-mtd-spi-nor-disable-16-bit-sr-for-macronix.patch	2024-03-18 15:16:23.614640659 +0800
@@ -0,0 +1,30 @@
+From 245224608b5368c10407da07557e546743d3c489 Mon Sep 17 00:00:00 2001
+From: Nick Hainke <vincent@systemli.org>
+Date: Mon, 27 Dec 2021 09:33:13 +0100
+Subject: [PATCH 2/2] mtd: spi-nor: disable 16-bit-sr for macronix
+
+Macronix flash chips seem to consist of only one status register.
+These chips will not work with the "16-bit Write Status (01h) Command".
+Disable SNOR_F_HAS_16BIT_SR for all Macronix chips.
+
+Tested with MX25L6405D.
+
+Fixes: 39d1e3340c73 ("mtd: spi-nor: Fix clearing of QE bit on
+lock()/unlock()")
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+Signed-off-by: Nick Hainke <vincent@systemli.org>
+---
+ drivers/mtd/spi-nor/macronix.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/mtd/spi-nor/macronix.c
++++ b/drivers/mtd/spi-nor/macronix.c
+@@ -94,6 +94,7 @@ static void macronix_default_init(struct
+ {
+ 	nor->params->quad_enable = spi_nor_sr1_bit6_quad_enable;
+ 	nor->params->set_4byte_addr_mode = spi_nor_set_4byte_addr_mode;
++	nor->flags &= ~SNOR_F_HAS_16BIT_SR;
+ 	nor->flags |= SNOR_F_HAS_LOCK;
+ }
+ 
diff -uprN a/target/linux/generic/pending-5.10/530-jffs2_make_lzma_available.patch b/target/linux/generic/pending-5.10/530-jffs2_make_lzma_available.patch
--- a/target/linux/generic/pending-5.10/530-jffs2_make_lzma_available.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/530-jffs2_make_lzma_available.patch	2024-03-18 15:16:23.630640048 +0800
@@ -356,7 +356,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +#endif
 --- /dev/null
 +++ b/include/linux/lzma/LzFind.h
-@@ -0,0 +1,98 @@
+@@ -0,0 +1,115 @@
 +/* LzFind.h -- Match finder for LZ algorithms
 +2009-04-22 : Igor Pavlov : Public domain */
 +
@@ -414,6 +414,11 @@ Signed-off-by: Alexandros C. Couloumbis
 +
 +#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)
 +
++int MatchFinder_NeedMove(CMatchFinder *p);
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
++void MatchFinder_MoveBlock(CMatchFinder *p);
++void MatchFinder_ReadIfRequired(CMatchFinder *p);
++
 +void MatchFinder_Construct(CMatchFinder *p);
 +
 +/* Conditions:
@@ -424,6 +429,12 @@ Signed-off-by: Alexandros C. Couloumbis
 +    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
 +    ISzAlloc *alloc);
 +void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
++    UInt32 *distances, UInt32 maxLen);
 +
 +/*
 +Conditions:
@@ -450,6 +461,12 @@ Signed-off-by: Alexandros C. Couloumbis
 +
 +void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);
 +
++void MatchFinder_Init(CMatchFinder *p);
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
++
 +#ifdef __cplusplus
 +}
 +#endif
@@ -514,7 +531,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +#endif
 --- /dev/null
 +++ b/include/linux/lzma/LzmaDec.h
-@@ -0,0 +1,130 @@
+@@ -0,0 +1,231 @@
 +/* LzmaDec.h -- LZMA Decoder
 +2009-02-07 : Igor Pavlov : Public domain */
 +
@@ -548,6 +565,14 @@ Signed-off-by: Alexandros C. Couloumbis
 +  UInt32 dicSize;
 +} CLzmaProps;
 +
++/* LzmaProps_Decode - decodes properties
++Returns:
++  SZ_OK
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);
++
 +
 +/* ---------- LZMA Decoder state ---------- */
 +
@@ -579,6 +604,8 @@ Signed-off-by: Alexandros C. Couloumbis
 +
 +#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }
 +
++void LzmaDec_Init(CLzmaDec *p);
++
 +/* There are two types of LZMA streams:
 +     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
 +     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */
@@ -615,6 +642,97 @@ Signed-off-by: Alexandros C. Couloumbis
 +
 +/* ELzmaStatus is used only as output value for function call */
 +
++
++/* ---------- Interfaces ---------- */
++
++/* There are 3 levels of interfaces:
++     1) Dictionary Interface
++     2) Buffer Interface
++     3) One Call Interface
++   You can select any of these interfaces, but don't mix functions from different
++   groups for same object. */
++
++
++/* There are two variants to allocate state for Dictionary Interface:
++     1) LzmaDec_Allocate / LzmaDec_Free
++     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
++   You can use variant 2, if you set dictionary buffer manually.
++   For Buffer Interface you must always use variant 1.
++
++LzmaDec_Allocate* can return:
++  SZ_OK
++  SZ_ERROR_MEM         - Memory allocation error
++  SZ_ERROR_UNSUPPORTED - Unsupported properties
++*/
++
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);
++
++SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
++void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);
++
++/* ---------- Dictionary Interface ---------- */
++
++/* You can use it, if you want to eliminate the overhead for data copying from
++   dictionary to some other external buffer.
++   You must work with CLzmaDec variables directly in this interface.
++
++   STEPS:
++     LzmaDec_Constr()
++     LzmaDec_Allocate()
++     for (each new stream)
++     {
++       LzmaDec_Init()
++       while (it needs more decompression)
++       {
++         LzmaDec_DecodeToDic()
++         use data from CLzmaDec::dic and update CLzmaDec::dicPos
++       }
++     }
++     LzmaDec_Free()
++*/
++
++/* LzmaDec_DecodeToDic
++
++   The decoding to internal dictionary buffer (CLzmaDec::dic).
++   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (dicLimit).
++  LZMA_FINISH_ANY - Decode just dicLimit bytes.
++  LZMA_FINISH_END - Stream must be finished after dicLimit.
++
++Returns:
++  SZ_OK
++    status:
++      LZMA_STATUS_FINISHED_WITH_MARK
++      LZMA_STATUS_NOT_FINISHED
++      LZMA_STATUS_NEEDS_MORE_INPUT
++      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
++  SZ_ERROR_DATA - Data error
++*/
++
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
++/* ---------- Buffer Interface ---------- */
++
++/* It's zlib-like interface.
++   See LzmaDec_DecodeToDic description for information about STEPS and return results,
++   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
++   to work with CLzmaDec variables manually.
++
++finishMode:
++  It has meaning only if the decoding reaches output limit (*destLen).
++  LZMA_FINISH_ANY - Decode just destLen bytes.
++  LZMA_FINISH_END - Stream must be finished after (*destLen).
++*/
++
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
++    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);
++
++
 +/* ---------- One Call Interface ---------- */
 +
 +/* LzmaDecode
@@ -647,7 +765,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +#endif
 --- /dev/null
 +++ b/include/linux/lzma/LzmaEnc.h
-@@ -0,0 +1,60 @@
+@@ -0,0 +1,80 @@
 +/*  LzmaEnc.h -- LZMA Encoder
 +2009-02-07 : Igor Pavlov : Public domain */
 +
@@ -681,6 +799,9 @@ Signed-off-by: Alexandros C. Couloumbis
 +} CLzmaEncProps;
 +
 +void LzmaEncProps_Init(CLzmaEncProps *p);
++void LzmaEncProps_Normalize(CLzmaEncProps *p);
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);
++
 +
 +/* ---------- CLzmaEncHandle Interface ---------- */
 +
@@ -700,9 +821,26 @@ Signed-off-by: Alexandros C. Couloumbis
 +void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
 +SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
 +SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
++SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
 +SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
 +    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
 +
++/* ---------- One Call Interface ---------- */
++
++/* LzmaEncode
++Return code:
++  SZ_OK               - OK
++  SZ_ERROR_MEM        - Memory allocation error
++  SZ_ERROR_PARAM      - Incorrect paramater
++  SZ_ERROR_OUTPUT_EOF - output buffer overflow
++  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
++*/
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
++
 +#ifdef __cplusplus
 +}
 +#endif
@@ -949,7 +1087,7 @@ Signed-off-by: Alexandros C. Couloumbis
  #define JFFS2_NODE_ACCURATE 0x2000
 --- a/lib/Kconfig
 +++ b/lib/Kconfig
-@@ -320,6 +320,12 @@ config ZSTD_DECOMPRESS
+@@ -315,6 +315,12 @@ config ZSTD_DECOMPRESS
  
  source "lib/xz/Kconfig"
  
@@ -992,7 +1130,7 @@ Signed-off-by: Alexandros C. Couloumbis
  lib-$(CONFIG_DECOMPRESS_BZIP2) += decompress_bunzip2.o
 --- /dev/null
 +++ b/lib/lzma/LzFind.c
-@@ -0,0 +1,522 @@
+@@ -0,0 +1,761 @@
 +/* LzFind.c -- Match finder for LZ algorithms
 +2009-04-22 : Igor Pavlov : Public domain */
 +
@@ -1009,15 +1147,9 @@ Signed-off-by: Alexandros C. Couloumbis
 +
 +#define kStartMaxLen 3
 +
-+#if 0
-+#define DIRECT_INPUT	p->directInput
-+#else
-+#define DIRECT_INPUT	1
-+#endif
-+
 +static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
 +{
-+  if (!DIRECT_INPUT)
++  if (!p->directInput)
 +  {
 +    alloc->Free(alloc, p->bufferBase);
 +    p->bufferBase = 0;
@@ -1029,7 +1161,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
 +{
 +  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
-+  if (DIRECT_INPUT)
++  if (p->directInput)
 +  {
 +    p->blockSize = blockSize;
 +    return 1;
@@ -1043,12 +1175,12 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return (p->bufferBase != 0);
 +}
 +
-+static Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
-+static Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
++Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
++Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }
 +
-+static UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
++UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }
 +
-+static void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
++void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
 +{
 +  p->posLimit -= subValue;
 +  p->pos -= subValue;
@@ -1059,7 +1191,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +{
 +  if (p->streamEndWasReached || p->result != SZ_OK)
 +    return;
-+  if (DIRECT_INPUT)
++  if (p->directInput)
 +  {
 +    UInt32 curSize = 0xFFFFFFFF - p->streamPos;
 +    if (curSize > p->directInputRem)
@@ -1090,7 +1222,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  }
 +}
 +
-+static void MatchFinder_MoveBlock(CMatchFinder *p)
++void MatchFinder_MoveBlock(CMatchFinder *p)
 +{
 +  memmove(p->bufferBase,
 +    p->buffer - p->keepSizeBefore,
@@ -1098,14 +1230,22 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->buffer = p->bufferBase + p->keepSizeBefore;
 +}
 +
-+static int MatchFinder_NeedMove(CMatchFinder *p)
++int MatchFinder_NeedMove(CMatchFinder *p)
 +{
-+  if (DIRECT_INPUT)
++  if (p->directInput)
 +    return 0;
 +  /* if (p->streamEndWasReached) return 0; */
 +  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
 +}
 +
++void MatchFinder_ReadIfRequired(CMatchFinder *p)
++{
++  if (p->streamEndWasReached)
++    return;
++  if (p->keepSizeAfter >= p->streamPos - p->pos)
++    MatchFinder_ReadBlock(p);
++}
++
 +static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
 +{
 +  if (MatchFinder_NeedMove(p))
@@ -1261,7 +1401,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->posLimit = p->pos + limit;
 +}
 +
-+static void MatchFinder_Init(CMatchFinder *p)
++void MatchFinder_Init(CMatchFinder *p)
 +{
 +  UInt32 i;
 +  for (i = 0; i < p->hashSizeSum; i++)
@@ -1280,7 +1420,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return (p->pos - p->historySize - 1) & kNormalizeMask;
 +}
 +
-+static void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
++void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
 +{
 +  UInt32 i;
 +  for (i = 0; i < numItems; i++)
@@ -1312,7 +1452,38 @@ Signed-off-by: Alexandros C. Couloumbis
 +  MatchFinder_SetLimits(p);
 +}
 +
-+static UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
++    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
++    UInt32 *distances, UInt32 maxLen)
++{
++  son[_cyclicBufferPos] = curMatch;
++  for (;;)
++  {
++    UInt32 delta = pos - curMatch;
++    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
++      return distances;
++    {
++      const Byte *pb = cur - delta;
++      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
++      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
++      {
++        UInt32 len = 0;
++        while (++len != lenLimit)
++          if (pb[len] != cur[len])
++            break;
++        if (maxLen < len)
++        {
++          *distances++ = maxLen = len;
++          *distances++ = delta - 1;
++          if (len == lenLimit)
++            return distances;
++        }
++      }
++    }
++  }
++}
++
++UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
 +    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
 +    UInt32 *distances, UInt32 maxLen)
 +{
@@ -1422,9 +1593,9 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->buffer++; \
 +  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);
 +
-+static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
++#define MOVE_POS_RET MOVE_POS return offset;
 +
-+#define MOVE_POS_RET MatchFinder_MovePos(p); return offset;
++static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }
 +
 +#define GET_MATCHES_HEADER2(minLen, ret_op) \
 +  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
@@ -1441,7 +1612,62 @@ Signed-off-by: Alexandros C. Couloumbis
 +  distances + offset, maxLen) - distances); MOVE_POS_RET;
 +
 +#define SKIP_FOOTER \
-+  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MatchFinder_MovePos(p);
++  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;
++
++static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(2)
++  HASH2_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 1)
++}
++
++UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = 0;
++  GET_MATCHES_FOOTER(offset, 2)
++}
++
++static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, delta2, maxLen, offset;
++  GET_MATCHES_HEADER(3)
++
++  HASH3_CALC;
++
++  delta2 = p->pos - p->hash[hash2Value];
++  curMatch = p->hash[kFix3HashSize + hashValue];
++
++  p->hash[hash2Value] =
++  p->hash[kFix3HashSize + hashValue] = p->pos;
++
++
++  maxLen = 2;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[0] = maxLen;
++    distances[1] = delta2 - 1;
++    offset = 2;
++    if (maxLen == lenLimit)
++    {
++      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
++      MOVE_POS_RET;
++    }
++  }
++  GET_MATCHES_FOOTER(offset, maxLen)
++}
 +
 +static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
 +{
@@ -1490,6 +1716,108 @@ Signed-off-by: Alexandros C. Couloumbis
 +  GET_MATCHES_FOOTER(offset, maxLen)
 +}
 +
++static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
++  GET_MATCHES_HEADER(4)
++
++  HASH4_CALC;
++
++  delta2 = p->pos - p->hash[                hash2Value];
++  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
++  curMatch = p->hash[kFix4HashSize + hashValue];
++
++  p->hash[                hash2Value] =
++  p->hash[kFix3HashSize + hash3Value] =
++  p->hash[kFix4HashSize + hashValue] = p->pos;
++
++  maxLen = 1;
++  offset = 0;
++  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
++  {
++    distances[0] = maxLen = 2;
++    distances[1] = delta2 - 1;
++    offset = 2;
++  }
++  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
++  {
++    maxLen = 3;
++    distances[offset + 1] = delta3 - 1;
++    offset += 2;
++    delta2 = delta3;
++  }
++  if (offset != 0)
++  {
++    for (; maxLen != lenLimit; maxLen++)
++      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
++        break;
++    distances[offset - 2] = maxLen;
++    if (maxLen == lenLimit)
++    {
++      p->son[p->cyclicBufferPos] = curMatch;
++      MOVE_POS_RET;
++    }
++  }
++  if (maxLen < 3)
++    maxLen = 3;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances + offset, maxLen) - (distances));
++  MOVE_POS_RET
++}
++
++UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
++{
++  UInt32 offset;
++  GET_MATCHES_HEADER(3)
++  HASH_ZIP_CALC;
++  curMatch = p->hash[hashValue];
++  p->hash[hashValue] = p->pos;
++  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
++    distances, 2) - (distances));
++  MOVE_POS_RET
++}
++
++static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(2)
++    HASH2_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
++static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value;
++    SKIP_HEADER(3)
++    HASH3_CALC;
++    curMatch = p->hash[kFix3HashSize + hashValue];
++    p->hash[hash2Value] =
++    p->hash[kFix3HashSize + hashValue] = p->pos;
++    SKIP_FOOTER
++  }
++  while (--num != 0);
++}
++
 +static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
 +{
 +  do
@@ -1506,18 +1834,67 @@ Signed-off-by: Alexandros C. Couloumbis
 +  while (--num != 0);
 +}
 +
++static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    UInt32 hash2Value, hash3Value;
++    SKIP_HEADER(4)
++    HASH4_CALC;
++    curMatch = p->hash[kFix4HashSize + hashValue];
++    p->hash[                hash2Value] =
++    p->hash[kFix3HashSize + hash3Value] =
++    p->hash[kFix4HashSize + hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
++void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
++{
++  do
++  {
++    SKIP_HEADER(3)
++    HASH_ZIP_CALC;
++    curMatch = p->hash[hashValue];
++    p->hash[hashValue] = p->pos;
++    p->son[p->cyclicBufferPos] = curMatch;
++    MOVE_POS
++  }
++  while (--num != 0);
++}
++
 +void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
 +{
 +  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
 +  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
 +  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
 +  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
-+  vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
-+  vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
++  if (!p->btMode)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 2)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
++  }
++  else if (p->numHashBytes == 3)
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
++  }
++  else
++  {
++    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
++    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
++  }
 +}
 --- /dev/null
 +++ b/lib/lzma/LzmaDec.c
-@@ -0,0 +1,925 @@
+@@ -0,0 +1,999 @@
 +/* LzmaDec.c -- LZMA Decoder
 +2009-09-20 : Igor Pavlov : Public domain */
 +
@@ -2202,7 +2579,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->needFlush = 0;
 +}
 +
-+static void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
++void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
 +{
 +  p->needFlush = 1;
 +  p->remainLen = 0;
@@ -2218,7 +2595,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +    p->needInitState = 1;
 +}
 +
-+static void LzmaDec_Init(CLzmaDec *p)
++void LzmaDec_Init(CLzmaDec *p)
 +{
 +  p->dicPos = 0;
 +  LzmaDec_InitDicAndState(p, True, True);
@@ -2236,7 +2613,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->needInitState = 0;
 +}
 +
-+static SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
++SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
 +    ELzmaFinishMode finishMode, ELzmaStatus *status)
 +{
 +  SizeT inSize = *srcLen;
@@ -2357,13 +2734,65 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
 +}
 +
-+static void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
++SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
++{
++  SizeT outSize = *destLen;
++  SizeT inSize = *srcLen;
++  *srcLen = *destLen = 0;
++  for (;;)
++  {
++    SizeT inSizeCur = inSize, outSizeCur, dicPos;
++    ELzmaFinishMode curFinishMode;
++    SRes res;
++    if (p->dicPos == p->dicBufSize)
++      p->dicPos = 0;
++    dicPos = p->dicPos;
++    if (outSize > p->dicBufSize - dicPos)
++    {
++      outSizeCur = p->dicBufSize;
++      curFinishMode = LZMA_FINISH_ANY;
++    }
++    else
++    {
++      outSizeCur = dicPos + outSize;
++      curFinishMode = finishMode;
++    }
++
++    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
++    src += inSizeCur;
++    inSize -= inSizeCur;
++    *srcLen += inSizeCur;
++    outSizeCur = p->dicPos - dicPos;
++    memcpy(dest, p->dic + dicPos, outSizeCur);
++    dest += outSizeCur;
++    outSize -= outSizeCur;
++    *destLen += outSizeCur;
++    if (res != 0)
++      return res;
++    if (outSizeCur == 0 || outSize == 0)
++      return SZ_OK;
++  }
++}
++
++void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
 +{
 +  alloc->Free(alloc, p->probs);
 +  p->probs = 0;
 +}
 +
-+static SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
++static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
++{
++  alloc->Free(alloc, p->dic);
++  p->dic = 0;
++}
++
++void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
++{
++  LzmaDec_FreeProbs(p, alloc);
++  LzmaDec_FreeDict(p, alloc);
++}
++
++SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
 +{
 +  UInt32 dicSize;
 +  Byte d;
@@ -2403,11 +2832,33 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return SZ_OK;
 +}
 +
-+static SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
++{
++  CLzmaProps propNew;
++  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
++  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  p->prop = propNew;
++  return SZ_OK;
++}
++
++SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
 +{
 +  CLzmaProps propNew;
++  SizeT dicBufSize;
 +  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
 +  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
++  dicBufSize = propNew.dicSize;
++  if (p->dic == 0 || dicBufSize != p->dicBufSize)
++  {
++    LzmaDec_FreeDict(p, alloc);
++    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
++    if (p->dic == 0)
++    {
++      LzmaDec_FreeProbs(p, alloc);
++      return SZ_ERROR_MEM;
++    }
++  }
++  p->dicBufSize = dicBufSize;
 +  p->prop = propNew;
 +  return SZ_OK;
 +}
@@ -2445,7 +2896,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +}
 --- /dev/null
 +++ b/lib/lzma/LzmaEnc.c
-@@ -0,0 +1,2123 @@
+@@ -0,0 +1,2271 @@
 +/* LzmaEnc.c -- LZMA Encoder
 +2009-11-24 : Igor Pavlov : Public domain */
 +
@@ -2501,7 +2952,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->writeEndMark = 0;
 +}
 +
-+static void LzmaEncProps_Normalize(CLzmaEncProps *p)
++void LzmaEncProps_Normalize(CLzmaEncProps *p)
 +{
 +  int level = p->level;
 +  if (level < 0) level = 5;
@@ -2524,7 +2975,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +      #endif
 +}
 +
-+static UInt32 __maybe_unused LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
++UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
 +{
 +  CLzmaEncProps props = *props2;
 +  LzmaEncProps_Normalize(&props);
@@ -2541,7 +2992,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +
 +#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }
 +
-+static UInt32 GetPosSlot1(UInt32 pos)
++UInt32 GetPosSlot1(UInt32 pos)
 +{
 +  UInt32 res;
 +  BSR2_RET(pos, res);
@@ -2555,7 +3006,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
 +#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)
 +
-+static void LzmaEnc_FastPosInit(Byte *g_FastPos)
++void LzmaEnc_FastPosInit(Byte *g_FastPos)
 +{
 +  int c = 2, slotFast;
 +  g_FastPos[0] = 0;
@@ -2787,6 +3238,58 @@ Signed-off-by: Alexandros C. Couloumbis
 +  CSaveState saveState;
 +} CLzmaEnc;
 +
++void LzmaEnc_SaveState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  CSaveState *dest = &p->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
++}
++
++void LzmaEnc_RestoreState(CLzmaEncHandle pp)
++{
++  CLzmaEnc *dest = (CLzmaEnc *)pp;
++  const CSaveState *p = &dest->saveState;
++  int i;
++  dest->lenEnc = p->lenEnc;
++  dest->repLenEnc = p->repLenEnc;
++  dest->state = p->state;
++
++  for (i = 0; i < kNumStates; i++)
++  {
++    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
++    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
++  }
++  for (i = 0; i < kNumLenToPosStates; i++)
++    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
++  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
++  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
++  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
++  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
++  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
++  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
++  memcpy(dest->reps, p->reps, sizeof(p->reps));
++  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
++}
++
 +SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
 +{
 +  CLzmaEnc *p = (CLzmaEnc *)pp;
@@ -2996,7 +3499,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  while (symbol < 0x10000);
 +}
 +
-+static void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
++void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
 +{
 +  UInt32 i;
 +  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
@@ -4072,7 +4575,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->matchPriceCount = 0;
 +}
 +
-+static void LzmaEnc_Construct(CLzmaEnc *p)
++void LzmaEnc_Construct(CLzmaEnc *p)
 +{
 +  RangeEnc_Construct(&p->rc);
 +  MatchFinder_Construct(&p->matchFinderBase);
@@ -4105,7 +4608,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return p;
 +}
 +
-+static void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
++void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
 +{
 +  alloc->Free(alloc, p->litProbs);
 +  alloc->Free(alloc, p->saveState.litProbs);
@@ -4113,7 +4616,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->saveState.litProbs = 0;
 +}
 +
-+static void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
++void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
 +{
 +  #ifndef _7ZIP_ST
 +  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
@@ -4343,7 +4846,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return SZ_OK;
 +}
 +
-+static void LzmaEnc_Init(CLzmaEnc *p)
++void LzmaEnc_Init(CLzmaEnc *p)
 +{
 +  UInt32 i;
 +  p->state = 0;
@@ -4401,7 +4904,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->lpMask = (1 << p->lp) - 1;
 +}
 +
-+static void LzmaEnc_InitPrices(CLzmaEnc *p)
++void LzmaEnc_InitPrices(CLzmaEnc *p)
 +{
 +  if (!p->fastMode)
 +  {
@@ -4433,6 +4936,26 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return SZ_OK;
 +}
 +
++static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  p->rc.outStream = outStream;
++  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
++}
++
++SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
++    ISeqInStream *inStream, UInt32 keepWindowSize,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  p->matchFinderBase.stream = inStream;
++  p->needInit = 1;
++  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
++}
++
 +static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
 +{
 +  p->matchFinderBase.directInput = 1;
@@ -4440,7 +4963,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  p->matchFinderBase.directInputRem = srcLen;
 +}
 +
-+static SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
++SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
 +    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
 +{
 +  CLzmaEnc *p = (CLzmaEnc *)pp;
@@ -4450,7 +4973,7 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
 +}
 +
-+static void LzmaEnc_Finish(CLzmaEncHandle pp)
++void LzmaEnc_Finish(CLzmaEncHandle pp)
 +{
 +  #ifndef _7ZIP_ST
 +  CLzmaEnc *p = (CLzmaEnc *)pp;
@@ -4483,6 +5006,53 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return size;
 +}
 +
++
++UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
++}
++
++const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
++{
++  const CLzmaEnc *p = (CLzmaEnc *)pp;
++  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
++}
++
++SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
++    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
++{
++  CLzmaEnc *p = (CLzmaEnc *)pp;
++  UInt64 nowPos64;
++  SRes res;
++  CSeqOutStreamBuf outStream;
++
++  outStream.funcTable.Write = MyWrite;
++  outStream.data = dest;
++  outStream.rem = *destLen;
++  outStream.overflow = False;
++
++  p->writeEndMark = False;
++  p->finished = False;
++  p->result = SZ_OK;
++
++  if (reInit)
++    LzmaEnc_Init(p);
++  LzmaEnc_InitPrices(p);
++  nowPos64 = p->nowPos64;
++  RangeEnc_Init(&p->rc);
++  p->rc.outStream = &outStream.funcTable;
++
++  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
++
++  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
++  *destLen -= outStream.rem;
++  if (outStream.overflow)
++    return SZ_ERROR_OUTPUT_EOF;
++
++  return res;
++}
++
 +static SRes LzmaEnc_Encode2(CLzmaEnc *p, ICompressProgress *progress)
 +{
 +  SRes res = SZ_OK;
@@ -4513,6 +5083,13 @@ Signed-off-by: Alexandros C. Couloumbis
 +  return res;
 +}
 +
++SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
++    ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  RINOK(LzmaEnc_Prepare(pp, outStream, inStream, alloc, allocBig));
++  return LzmaEnc_Encode2((CLzmaEnc *)pp, progress);
++}
++
 +SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
 +{
 +  CLzmaEnc *p = (CLzmaEnc *)pp;
@@ -4569,6 +5146,28 @@ Signed-off-by: Alexandros C. Couloumbis
 +    return SZ_ERROR_OUTPUT_EOF;
 +  return res;
 +}
++
++SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
++    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
++    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
++{
++  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
++  SRes res;
++  if (p == 0)
++    return SZ_ERROR_MEM;
++
++  res = LzmaEnc_SetProps(p, props);
++  if (res == SZ_OK)
++  {
++    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
++    if (res == SZ_OK)
++      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
++          writeEndMark, progress, alloc, allocBig);
++  }
++
++  LzmaEnc_Destroy(p, alloc, allocBig);
++  return res;
++}
 --- /dev/null
 +++ b/lib/lzma/Makefile
 @@ -0,0 +1,7 @@
diff -uprN a/target/linux/generic/pending-5.10/532-jffs2_eofdetect.patch b/target/linux/generic/pending-5.10/532-jffs2_eofdetect.patch
--- a/target/linux/generic/pending-5.10/532-jffs2_eofdetect.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/532-jffs2_eofdetect.patch	2024-03-18 15:16:23.606640964 +0800
@@ -45,7 +45,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
  		if (ret < 0)
  			goto out;
-@@ -567,6 +573,17 @@ full_scan:
+@@ -565,6 +571,17 @@ full_scan:
  			return err;
  	}
  
diff -uprN a/target/linux/generic/pending-5.10/610-netfilter_match_bypass_default_checks.patch b/target/linux/generic/pending-5.10/610-netfilter_match_bypass_default_checks.patch
--- a/target/linux/generic/pending-5.10/610-netfilter_match_bypass_default_checks.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/610-netfilter_match_bypass_default_checks.patch	2024-03-18 15:16:23.610640811 +0800
@@ -91,7 +91,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		for (i = sizeof(struct ipt_entry);
  		     i < e->target_offset;
  		     i += m->u.match_size) {
-@@ -1222,12 +1259,15 @@ compat_copy_entry_to_user(struct ipt_ent
+@@ -1223,12 +1260,15 @@ compat_copy_entry_to_user(struct ipt_ent
  	compat_uint_t origsize;
  	const struct xt_entry_match *ematch;
  	int ret = 0;
diff -uprN a/target/linux/generic/pending-5.10/613-netfilter_optional_tcp_window_check.patch b/target/linux/generic/pending-5.10/613-netfilter_optional_tcp_window_check.patch
--- a/target/linux/generic/pending-5.10/613-netfilter_optional_tcp_window_check.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/613-netfilter_optional_tcp_window_check.patch	2024-03-18 15:16:23.634639895 +0800
@@ -28,7 +28,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	/*
  	 * Get the required data from the packet.
  	 */
-@@ -1139,7 +1145,7 @@ int nf_conntrack_tcp_packet(struct nf_co
+@@ -1130,7 +1136,7 @@ int nf_conntrack_tcp_packet(struct nf_co
  		 IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED &&
  		 timeouts[new_state] > timeouts[TCP_CONNTRACK_UNACK])
  		timeout = timeouts[TCP_CONNTRACK_UNACK];
@@ -49,7 +49,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  static bool enable_hooks __read_mostly;
  MODULE_PARM_DESC(enable_hooks, "Always enable conntrack hooks");
  module_param(enable_hooks, bool, 0000);
-@@ -659,6 +662,7 @@ enum nf_ct_sysctl_index {
+@@ -660,6 +663,7 @@ enum nf_ct_sysctl_index {
  	NF_SYSCTL_CT_PROTO_TIMEOUT_GRE_STREAM,
  #endif
  
@@ -57,7 +57,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	__NF_SYSCTL_CT_LAST_SYSCTL,
  };
  
-@@ -1007,6 +1011,13 @@ static struct ctl_table nf_ct_sysctl_tab
+@@ -1014,6 +1018,13 @@ static struct ctl_table nf_ct_sysctl_tab
  		.proc_handler   = proc_dointvec_jiffies,
  	},
  #endif
diff -uprN a/target/linux/generic/pending-5.10/630-packet_socket_type.patch b/target/linux/generic/pending-5.10/630-packet_socket_type.patch
--- a/target/linux/generic/pending-5.10/630-packet_socket_type.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/630-packet_socket_type.patch	2024-03-18 15:16:23.606640964 +0800
@@ -55,7 +55,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		goto out;
  
  	if (!net_eq(dev_net(dev), sock_net(sk)))
-@@ -2089,12 +2091,12 @@ static int packet_rcv(struct sk_buff *sk
+@@ -2079,12 +2081,12 @@ static int packet_rcv(struct sk_buff *sk
  	unsigned int snaplen, res;
  	bool is_drop_n_account = false;
  
@@ -71,7 +71,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	if (!net_eq(dev_net(dev), sock_net(sk)))
  		goto drop;
  
-@@ -2220,12 +2222,12 @@ static int tpacket_rcv(struct sk_buff *s
+@@ -2210,12 +2212,12 @@ static int tpacket_rcv(struct sk_buff *s
  	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);
  	BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);
  
@@ -87,7 +87,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	if (!net_eq(dev_net(dev), sock_net(sk)))
  		goto drop;
  
-@@ -3339,6 +3341,7 @@ static int packet_create(struct net *net
+@@ -3325,6 +3327,7 @@ static int packet_create(struct net *net
  	mutex_init(&po->pg_vec_lock);
  	po->rollover = NULL;
  	po->prot_hook.func = packet_rcv;
@@ -95,7 +95,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
  	if (sock->type == SOCK_PACKET)
  		po->prot_hook.func = packet_rcv_spkt;
-@@ -3982,6 +3985,16 @@ packet_setsockopt(struct socket *sock, i
+@@ -3969,6 +3972,16 @@ packet_setsockopt(struct socket *sock, i
  		po->xmit = val ? packet_direct_xmit : dev_queue_xmit;
  		return 0;
  	}
@@ -112,7 +112,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	default:
  		return -ENOPROTOOPT;
  	}
-@@ -4038,6 +4051,13 @@ static int packet_getsockopt(struct sock
+@@ -4025,6 +4038,13 @@ static int packet_getsockopt(struct sock
  	case PACKET_VNET_HDR:
  		val = po->has_vnet_hdr;
  		break;
diff -uprN a/target/linux/generic/pending-5.10/655-increase_skb_pad.patch b/target/linux/generic/pending-5.10/655-increase_skb_pad.patch
--- a/target/linux/generic/pending-5.10/655-increase_skb_pad.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/655-increase_skb_pad.patch	2024-03-18 15:16:23.610640811 +0800
@@ -9,7 +9,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/include/linux/skbuff.h
 +++ b/include/linux/skbuff.h
-@@ -2693,7 +2693,7 @@ static inline int pskb_network_may_pull(
+@@ -2676,7 +2676,7 @@ static inline int pskb_network_may_pull(
   * NET_IP_ALIGN(2) + ethernet_header(14) + IP_header(20/40) + ports(8)
   */
  #ifndef NET_SKB_PAD
diff -uprN a/target/linux/generic/pending-5.10/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch b/target/linux/generic/pending-5.10/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch
--- a/target/linux/generic/pending-5.10/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/666-Add-support-for-MAP-E-FMRs-mesh-mode.patch	2024-03-18 15:16:23.606640964 +0800
@@ -338,7 +338,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
  		return -1;
  
-@@ -1556,6 +1717,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
+@@ -1555,6 +1716,14 @@ ip6_tnl_change(struct ip6_tnl *t, const
  	t->parms.link = p->link;
  	t->parms.proto = p->proto;
  	t->parms.fwmark = p->fwmark;
@@ -353,7 +353,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  	dst_cache_reset(&t->dst_cache);
  	ip6_tnl_link_config(t);
  	return 0;
-@@ -1594,6 +1763,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
+@@ -1593,6 +1762,7 @@ ip6_tnl_parm_from_user(struct __ip6_tnl_
  	p->flowinfo = u->flowinfo;
  	p->link = u->link;
  	p->proto = u->proto;
@@ -361,7 +361,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  	memcpy(p->name, u->name, sizeof(u->name));
  }
  
-@@ -1979,6 +2149,15 @@ static int ip6_tnl_validate(struct nlatt
+@@ -1978,6 +2148,15 @@ static int ip6_tnl_validate(struct nlatt
  	return 0;
  }
  
@@ -377,7 +377,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  static void ip6_tnl_netlink_parms(struct nlattr *data[],
  				  struct __ip6_tnl_parm *parms)
  {
-@@ -2016,6 +2195,46 @@ static void ip6_tnl_netlink_parms(struct
+@@ -2015,6 +2194,46 @@ static void ip6_tnl_netlink_parms(struct
  
  	if (data[IFLA_IPTUN_FWMARK])
  		parms->fwmark = nla_get_u32(data[IFLA_IPTUN_FWMARK]);
@@ -424,7 +424,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  }
  
  static bool ip6_tnl_netlink_encap_parms(struct nlattr *data[],
-@@ -2131,6 +2350,12 @@ static void ip6_tnl_dellink(struct net_d
+@@ -2130,6 +2349,12 @@ static void ip6_tnl_dellink(struct net_d
  
  static size_t ip6_tnl_get_size(const struct net_device *dev)
  {
@@ -437,7 +437,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  	return
  		/* IFLA_IPTUN_LINK */
  		nla_total_size(4) +
-@@ -2160,6 +2385,24 @@ static size_t ip6_tnl_get_size(const str
+@@ -2159,6 +2384,24 @@ static size_t ip6_tnl_get_size(const str
  		nla_total_size(0) +
  		/* IFLA_IPTUN_FWMARK */
  		nla_total_size(4) +
@@ -462,7 +462,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  		0;
  }
  
-@@ -2167,6 +2410,9 @@ static int ip6_tnl_fill_info(struct sk_b
+@@ -2166,6 +2409,9 @@ static int ip6_tnl_fill_info(struct sk_b
  {
  	struct ip6_tnl *tunnel = netdev_priv(dev);
  	struct __ip6_tnl_parm *parm = &tunnel->parms;
@@ -472,7 +472,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  
  	if (nla_put_u32(skb, IFLA_IPTUN_LINK, parm->link) ||
  	    nla_put_in6_addr(skb, IFLA_IPTUN_LOCAL, &parm->laddr) ||
-@@ -2176,9 +2422,27 @@ static int ip6_tnl_fill_info(struct sk_b
+@@ -2175,9 +2421,27 @@ static int ip6_tnl_fill_info(struct sk_b
  	    nla_put_be32(skb, IFLA_IPTUN_FLOWINFO, parm->flowinfo) ||
  	    nla_put_u32(skb, IFLA_IPTUN_FLAGS, parm->flags) ||
  	    nla_put_u8(skb, IFLA_IPTUN_PROTO, parm->proto) ||
@@ -501,7 +501,7 @@ Signed-off-by: Steven Barth <cyrus@openw
  	if (nla_put_u16(skb, IFLA_IPTUN_ENCAP_TYPE, tunnel->encap.type) ||
  	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_SPORT, tunnel->encap.sport) ||
  	    nla_put_be16(skb, IFLA_IPTUN_ENCAP_DPORT, tunnel->encap.dport) ||
-@@ -2218,6 +2482,7 @@ static const struct nla_policy ip6_tnl_p
+@@ -2217,6 +2481,7 @@ static const struct nla_policy ip6_tnl_p
  	[IFLA_IPTUN_ENCAP_DPORT]	= { .type = NLA_U16 },
  	[IFLA_IPTUN_COLLECT_METADATA]	= { .type = NLA_FLAG },
  	[IFLA_IPTUN_FWMARK]		= { .type = NLA_U32 },
diff -uprN a/target/linux/generic/pending-5.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch b/target/linux/generic/pending-5.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch
--- a/target/linux/generic/pending-5.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/670-ipv6-allow-rejecting-with-source-address-failed-policy.patch	2024-03-18 15:16:23.614640659 +0800
@@ -53,7 +53,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  
 --- a/net/ipv4/fib_semantics.c
 +++ b/net/ipv4/fib_semantics.c
-@@ -143,6 +143,10 @@ const struct fib_prop fib_props[RTN_MAX
+@@ -142,6 +142,10 @@ const struct fib_prop fib_props[RTN_MAX
  		.error	= -EINVAL,
  		.scope	= RT_SCOPE_NOWHERE,
  	},
@@ -66,7 +66,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  static void rt_fibinfo_free(struct rtable __rcu **rtp)
 --- a/net/ipv4/fib_trie.c
 +++ b/net/ipv4/fib_trie.c
-@@ -2736,6 +2736,7 @@ static const char *const rtn_type_names[
+@@ -2734,6 +2734,7 @@ static const char *const rtn_type_names[
  	[RTN_THROW] = "THROW",
  	[RTN_NAT] = "NAT",
  	[RTN_XRESOLVE] = "XRESOLVE",
@@ -157,7 +157,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  	case RTN_THROW:
  	case RTN_UNREACHABLE:
  	default:
-@@ -4449,6 +4468,17 @@ static int ip6_pkt_prohibit_out(struct n
+@@ -4448,6 +4467,17 @@ static int ip6_pkt_prohibit_out(struct n
  	return ip6_pkt_drop(skb, ICMPV6_ADM_PROHIBITED, IPSTATS_MIB_OUTNOROUTES);
  }
  
@@ -175,7 +175,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  /*
   *	Allocate a dst for local (unicast / anycast) address.
   */
-@@ -4936,7 +4966,8 @@ static int rtm_to_fib6_config(struct sk_
+@@ -4928,7 +4958,8 @@ static int rtm_to_fib6_config(struct sk_
  	if (rtm->rtm_type == RTN_UNREACHABLE ||
  	    rtm->rtm_type == RTN_BLACKHOLE ||
  	    rtm->rtm_type == RTN_PROHIBIT ||
@@ -185,7 +185,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  		cfg->fc_flags |= RTF_REJECT;
  
  	if (rtm->rtm_type == RTN_LOCAL)
-@@ -6136,6 +6167,8 @@ static int ip6_route_dev_notify(struct n
+@@ -6127,6 +6158,8 @@ static int ip6_route_dev_notify(struct n
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  		net->ipv6.ip6_prohibit_entry->dst.dev = dev;
  		net->ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(dev);
@@ -194,7 +194,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  		net->ipv6.ip6_blk_hole_entry->dst.dev = dev;
  		net->ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(dev);
  #endif
-@@ -6147,6 +6180,7 @@ static int ip6_route_dev_notify(struct n
+@@ -6138,6 +6171,7 @@ static int ip6_route_dev_notify(struct n
  		in6_dev_put_clear(&net->ipv6.ip6_null_entry->rt6i_idev);
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  		in6_dev_put_clear(&net->ipv6.ip6_prohibit_entry->rt6i_idev);
@@ -202,7 +202,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  		in6_dev_put_clear(&net->ipv6.ip6_blk_hole_entry->rt6i_idev);
  #endif
  	}
-@@ -6338,6 +6372,8 @@ static int __net_init ip6_route_net_init
+@@ -6329,6 +6363,8 @@ static int __net_init ip6_route_net_init
  
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  	net->ipv6.fib6_has_custom_rules = false;
@@ -211,7 +211,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  	net->ipv6.ip6_prohibit_entry = kmemdup(&ip6_prohibit_entry_template,
  					       sizeof(*net->ipv6.ip6_prohibit_entry),
  					       GFP_KERNEL);
-@@ -6348,11 +6384,21 @@ static int __net_init ip6_route_net_init
+@@ -6339,11 +6375,21 @@ static int __net_init ip6_route_net_init
  			 ip6_template_metrics, true);
  	INIT_LIST_HEAD(&net->ipv6.ip6_prohibit_entry->rt6i_uncached);
  
@@ -234,7 +234,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  	net->ipv6.ip6_blk_hole_entry->dst.ops = &net->ipv6.ip6_dst_ops;
  	dst_init_metrics(&net->ipv6.ip6_blk_hole_entry->dst,
  			 ip6_template_metrics, true);
-@@ -6379,6 +6425,8 @@ out:
+@@ -6370,6 +6416,8 @@ out:
  	return ret;
  
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
@@ -243,7 +243,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  out_ip6_prohibit_entry:
  	kfree(net->ipv6.ip6_prohibit_entry);
  out_ip6_null_entry:
-@@ -6398,6 +6446,7 @@ static void __net_exit ip6_route_net_exi
+@@ -6389,6 +6437,7 @@ static void __net_exit ip6_route_net_exi
  	kfree(net->ipv6.ip6_null_entry);
  #ifdef CONFIG_IPV6_MULTIPLE_TABLES
  	kfree(net->ipv6.ip6_prohibit_entry);
@@ -251,7 +251,7 @@ Signed-off-by: Jonas Gorski <jogo@openwr
  	kfree(net->ipv6.ip6_blk_hole_entry);
  #endif
  	dst_entries_destroy(&net->ipv6.ip6_dst_ops);
-@@ -6481,6 +6530,9 @@ void __init ip6_route_init_special_entri
+@@ -6466,6 +6515,9 @@ void __init ip6_route_init_special_entri
  	init_net.ipv6.ip6_prohibit_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
  	init_net.ipv6.ip6_blk_hole_entry->dst.dev = init_net.loopback_dev;
  	init_net.ipv6.ip6_blk_hole_entry->rt6i_idev = in6_dev_get(init_net.loopback_dev);
diff -uprN a/target/linux/generic/pending-5.10/680-NET-skip-GRO-for-foreign-MAC-addresses.patch b/target/linux/generic/pending-5.10/680-NET-skip-GRO-for-foreign-MAC-addresses.patch
--- a/target/linux/generic/pending-5.10/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/680-NET-skip-GRO-for-foreign-MAC-addresses.patch	2024-03-18 15:16:23.602641117 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -2059,6 +2059,8 @@ struct net_device {
+@@ -2036,6 +2036,8 @@ struct net_device {
  	struct netdev_hw_addr_list	mc;
  	struct netdev_hw_addr_list	dev_addrs;
  
@@ -22,17 +22,17 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  #endif
 --- a/include/linux/skbuff.h
 +++ b/include/linux/skbuff.h
-@@ -863,6 +863,7 @@ struct sk_buff {
+@@ -858,6 +858,7 @@ struct sk_buff {
+ #ifdef CONFIG_TLS_DEVICE
  	__u8			decrypted:1;
  #endif
- 	__u8			scm_io_uring:1;
 +	__u8			gro_skip:1;
  
  #ifdef CONFIG_NET_SCHED
  	__u16			tc_index;	/* traffic control index */
 --- a/net/core/dev.c
 +++ b/net/core/dev.c
-@@ -6069,6 +6069,9 @@ static enum gro_result dev_gro_receive(s
+@@ -6062,6 +6062,9 @@ static enum gro_result dev_gro_receive(s
  	int same_flow;
  	int grow;
  
@@ -42,7 +42,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	if (netif_elide_gro(skb->dev))
  		goto normal;
  
-@@ -8048,6 +8051,48 @@ static void __netdev_adjacent_dev_unlink
+@@ -8039,6 +8042,48 @@ static void __netdev_adjacent_dev_unlink
  					   &upper_dev->adj_list.lower);
  }
  
@@ -91,7 +91,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  static int __netdev_upper_dev_link(struct net_device *dev,
  				   struct net_device *upper_dev, bool master,
  				   void *upper_priv, void *upper_info,
-@@ -8099,6 +8144,7 @@ static int __netdev_upper_dev_link(struc
+@@ -8090,6 +8135,7 @@ static int __netdev_upper_dev_link(struc
  	if (ret)
  		return ret;
  
@@ -99,7 +99,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	ret = call_netdevice_notifiers_info(NETDEV_CHANGEUPPER,
  					    &changeupper_info.info);
  	ret = notifier_to_errno(ret);
-@@ -8195,6 +8241,7 @@ static void __netdev_upper_dev_unlink(st
+@@ -8186,6 +8232,7 @@ static void __netdev_upper_dev_unlink(st
  
  	__netdev_adjacent_dev_unlink_neighbour(dev, upper_dev);
  
@@ -107,7 +107,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	call_netdevice_notifiers_info(NETDEV_CHANGEUPPER,
  				      &changeupper_info.info);
  
-@@ -8981,6 +9028,7 @@ int dev_set_mac_address(struct net_devic
+@@ -8972,6 +9019,7 @@ int dev_set_mac_address(struct net_devic
  	if (err)
  		return err;
  	dev->addr_assign_type = NET_ADDR_SET;
diff -uprN a/target/linux/generic/pending-5.10/681-NET-add-mtd-mac-address-support-to-of_get_mac_addres.patch b/target/linux/generic/pending-5.10/681-NET-add-mtd-mac-address-support-to-of_get_mac_addres.patch
--- a/target/linux/generic/pending-5.10/681-NET-add-mtd-mac-address-support-to-of_get_mac_addres.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/681-NET-add-mtd-mac-address-support-to-of_get_mac_addres.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,102 +0,0 @@
-From 6f8e5369ae054ec6c9265581d5a7e39738a5cd84 Mon Sep 17 00:00:00 2001
-From: Ansuel Smith <ansuelsmth@gmail.com>
-Date: Tue, 30 Mar 2021 13:16:38 +0200
-Subject: [PATCH 1/2] NET: add mtd-mac-address support to of_get_mac_address()
-
-Many embedded devices have information such as mac addresses stored inside mtd
-devices. This patch allows us to add a property inside a node describing a
-network interface. The new property points at a mtd partition with an offset
-where the mac address can be found.
-
-Signed-off-by: John Crispin <blogic@openwrt.org>
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
----
- drivers/of/of_net.c | 75 ++++++++++++++++++++++++++++++++++++++++++++-
- 1 file changed, 74 insertions(+), 1 deletion(-)
-
---- a/drivers/of/of_net.c
-+++ b/drivers/of/of_net.c
-@@ -12,6 +12,7 @@
- #include <linux/export.h>
- #include <linux/device.h>
- #include <linux/nvmem-consumer.h>
-+#include <linux/mtd/mtd.h>
- 
- /**
-  * of_get_phy_mode - Get phy mode for given device_node
-@@ -95,6 +96,52 @@ static int of_get_mac_addr_nvmem(struct
- 	return 0;
- }
- 
-+static int of_get_mac_address_mtd(struct device_node *np, u8 *addr)
-+{
-+#ifdef CONFIG_MTD
-+	struct platform_device *pdev = of_find_device_by_node(np);
-+	struct device_node *mtd_np = NULL;
-+	size_t retlen;
-+	int size, ret;
-+	struct mtd_info *mtd;
-+	const char *part;
-+	const __be32 *list;
-+	phandle phandle;
-+	u8 mac[ETH_ALEN];
-+
-+	list = of_get_property(np, "mtd-mac-address", &size);
-+	if (!list || (size != (2 * sizeof(*list))))
-+		return -ENODEV;
-+
-+	phandle = be32_to_cpup(list++);
-+	if (phandle)
-+		mtd_np = of_find_node_by_phandle(phandle);
-+
-+	if (!mtd_np)
-+		return -ENODEV;
-+
-+	part = of_get_property(mtd_np, "label", NULL);
-+	if (!part)
-+		part = mtd_np->name;
-+
-+	mtd = get_mtd_device_nm(part);
-+	if (IS_ERR(mtd))
-+		return -ENODEV;
-+
-+	ret = mtd_read(mtd, be32_to_cpup(list), 6, &retlen, mac);
-+	put_mtd_device(mtd);
-+
-+	if (!is_valid_ether_addr(mac))
-+		return -EINVAL;
-+
-+	memcpy(addr, mac, ETH_ALEN);
-+
-+	return 0;
-+#endif
-+	return -EINVAL;
-+}
-+
-+
- /**
-  * Search the device tree for the best MAC address to use.  'mac-address' is
-  * checked first, because that is supposed to contain to "most recent" MAC
-@@ -115,6 +162,10 @@ static int of_get_mac_addr_nvmem(struct
-  * this case, the real MAC is in 'local-mac-address', and 'mac-address' exists
-  * but is all zeros.
-  *
-+ *
-+ * If a mtd-mac-address property exists, try to fetch the MAC address from the
-+ * specified mtd device.
-+ *
-  * Return: 0 on success and errno in case of error.
- */
- int of_get_mac_address(struct device_node *np, u8 *addr)
-@@ -136,6 +187,10 @@ int of_get_mac_address(struct device_nod
- 	if (!ret)
- 		return 0;
- 
-+	ret = of_get_mac_address_mtd(np, addr);
-+	if (!ret)
-+		return 0;
-+
- 	return of_get_mac_addr_nvmem(np, addr);
- }
- EXPORT_SYMBOL(of_get_mac_address);
diff -uprN a/target/linux/generic/pending-5.10/682-of_net-add-mac-address-increment-support.patch b/target/linux/generic/pending-5.10/682-of_net-add-mac-address-increment-support.patch
--- a/target/linux/generic/pending-5.10/682-of_net-add-mac-address-increment-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/682-of_net-add-mac-address-increment-support.patch	2024-03-18 15:16:23.634639895 +0800
@@ -0,0 +1,89 @@
+From 844c273286f328acf0dab5fbd5d864366b4904dc Mon Sep 17 00:00:00 2001
+From: Ansuel Smith <ansuelsmth@gmail.com>
+Date: Tue, 30 Mar 2021 18:21:14 +0200
+Subject: [PATCH] of_net: add mac-address-increment support
+
+Lots of embedded devices use the mac-address of other interface
+extracted from nvmem cells and increments it by one or two. Add two
+bindings to integrate this and directly use the right mac-address for
+the interface. Some example are some routers that use the gmac
+mac-address stored in the art partition and increments it by one for the
+wifi. mac-address-increment-byte bindings is used to tell what byte of
+the mac-address has to be increased (if not defined the last byte is
+increased) and mac-address-increment tells how much the byte decided
+early has to be increased.
+
+Signed-off-by: Ansuel Smith <ansuelsmth@gmail.com>
+---
+ drivers/of/of_net.c | 43 +++++++++++++++++++++++++++++++++++++++----
+ 1 file changed, 39 insertions(+), 4 deletions(-)
+
+--- a/drivers/of/of_net.c
++++ b/drivers/of/of_net.c
+@@ -115,27 +115,62 @@ static int of_get_mac_addr_nvmem(struct
+  * this case, the real MAC is in 'local-mac-address', and 'mac-address' exists
+  * but is all zeros.
+  *
++ * DT can tell the system to increment the mac-address after is extracted by
++ * using:
++ * - mac-address-increment-byte to decide what byte to increase
++ *   (if not defined is increased the last byte)
++ * - mac-address-increment to decide how much to increase. The value WILL
++ *   overflow to other bytes if the increment is over 255 or the total
++ *   increment will exceed 255 of the current byte.
++ *   (example 00:01:02:03:04:ff + 1 == 00:01:02:03:05:00)
++ *   (example 00:01:02:03:04:fe + 5 == 00:01:02:03:05:03)
++ *
+  * Return: 0 on success and errno in case of error.
+ */
+ int of_get_mac_address(struct device_node *np, u8 *addr)
+ {
++	u32 inc_idx, mac_inc, mac_val;
+ 	int ret;
+ 
++	/* Check first if the increment byte is present and valid.
++	 * If not set assume to increment the last byte if found.
++	 */
++	if (of_property_read_u32(np, "mac-address-increment-byte", &inc_idx))
++		inc_idx = 5;
++	if (inc_idx < 3 || inc_idx > 5)
++		return -EINVAL;
++
+ 	if (!np)
+ 		return -ENODEV;
+ 
+ 	ret = of_get_mac_addr(np, "mac-address", addr);
+ 	if (!ret)
+-		return 0;
++		goto found;
+ 
+ 	ret = of_get_mac_addr(np, "local-mac-address", addr);
+ 	if (!ret)
+-		return 0;
++		goto found;
+ 
+ 	ret = of_get_mac_addr(np, "address", addr);
+ 	if (!ret)
+-		return 0;
++		goto found;
++
++	ret = of_get_mac_addr_nvmem(np, addr);
++	if (ret)
++		return ret;
++
++found:
++	if (!of_property_read_u32(np, "mac-address-increment", &mac_inc)) {
++		/* Convert to a contiguous value */
++		mac_val = (addr[3] << 16) + (addr[4] << 8) + addr[5];
++		mac_val += mac_inc << 8 * (5-inc_idx);
++
++		/* Apply the incremented value handling overflow case */
++		addr[3] = (mac_val >> 16) & 0xff;
++		addr[4] = (mac_val >> 8) & 0xff;
++		addr[5] = (mac_val >> 0) & 0xff;
++	}
+ 
+-	return of_get_mac_addr_nvmem(np, addr);
++	return ret;
+ }
+ EXPORT_SYMBOL(of_get_mac_address);
diff -uprN a/target/linux/generic/pending-5.10/683-of_net-add-mac-address-to-of-tree.patch b/target/linux/generic/pending-5.10/683-of_net-add-mac-address-to-of-tree.patch
--- a/target/linux/generic/pending-5.10/683-of_net-add-mac-address-to-of-tree.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/683-of_net-add-mac-address-to-of-tree.patch	2024-03-18 15:16:23.606640964 +0800
@@ -0,0 +1,38 @@
+--- a/drivers/of/of_net.c
++++ b/drivers/of/of_net.c
+@@ -95,6 +95,27 @@ static int of_get_mac_addr_nvmem(struct
+ 	return 0;
+ }
+ 
++static int of_add_mac_address(struct device_node *np, u8* addr)
++{
++	struct property *prop;
++
++	prop = kzalloc(sizeof(*prop), GFP_KERNEL);
++	if (!prop)
++		return -ENOMEM;
++
++	prop->name = "mac-address";
++	prop->length = ETH_ALEN;
++	prop->value = kmemdup(addr, ETH_ALEN, GFP_KERNEL);
++	if (!prop->value || of_update_property(np, prop))
++		goto free;
++
++	return 0;
++free:
++	kfree(prop->value);
++	kfree(prop);
++	return -ENOMEM;
++}
++
+ /**
+  * Search the device tree for the best MAC address to use.  'mac-address' is
+  * checked first, because that is supposed to contain to "most recent" MAC
+@@ -171,6 +192,7 @@ found:
+ 		addr[5] = (mac_val >> 0) & 0xff;
+ 	}
+ 
++	of_add_mac_address(np, addr);
+ 	return ret;
+ }
+ EXPORT_SYMBOL(of_get_mac_address);
diff -uprN a/target/linux/generic/pending-5.10/701-00-net-ethernet-mtk_eth_soc-add-support-for-coherent-DM.patch b/target/linux/generic/pending-5.10/701-00-net-ethernet-mtk_eth_soc-add-support-for-coherent-DM.patch
--- a/target/linux/generic/pending-5.10/701-00-net-ethernet-mtk_eth_soc-add-support-for-coherent-DM.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/701-00-net-ethernet-mtk_eth_soc-add-support-for-coherent-DM.patch	2024-03-18 15:16:23.602641117 +0800
@@ -20,7 +20,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  #include <linux/mfd/syscon.h>
  #include <linux/regmap.h>
  #include <linux/clk.h>
-@@ -833,7 +834,7 @@ static int mtk_init_fq_dma(struct mtk_et
+@@ -821,7 +822,7 @@ static int mtk_init_fq_dma(struct mtk_et
  	dma_addr_t dma_addr;
  	int i;
  
@@ -29,7 +29,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  					       cnt * sizeof(struct mtk_tx_dma),
  					       &eth->phy_scratch_ring,
  					       GFP_ATOMIC);
-@@ -845,10 +846,10 @@ static int mtk_init_fq_dma(struct mtk_et
+@@ -833,10 +834,10 @@ static int mtk_init_fq_dma(struct mtk_et
  	if (unlikely(!eth->scratch_head))
  		return -ENOMEM;
  
@@ -42,7 +42,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		return -ENOMEM;
  
  	phy_ring_tail = eth->phy_scratch_ring +
-@@ -902,26 +903,26 @@ static void mtk_tx_unmap(struct mtk_eth
+@@ -890,26 +891,26 @@ static void mtk_tx_unmap(struct mtk_eth
  {
  	if (MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {
  		if (tx_buf->flags & MTK_TX_FLAGS_SINGLE0) {
@@ -73,7 +73,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				       dma_unmap_addr(tx_buf, dma_addr1),
  				       dma_unmap_len(tx_buf, dma_len1),
  				       DMA_TO_DEVICE);
-@@ -999,9 +1000,9 @@ static int mtk_tx_map(struct sk_buff *sk
+@@ -987,9 +988,9 @@ static int mtk_tx_map(struct sk_buff *sk
  	if (skb_vlan_tag_present(skb))
  		txd4 |= TX_DMA_INS_VLAN | skb_vlan_tag_get(skb);
  
@@ -85,7 +85,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		return -ENOMEM;
  
  	WRITE_ONCE(itxd->txd1, mapped_addr);
-@@ -1040,10 +1041,10 @@ static int mtk_tx_map(struct sk_buff *sk
+@@ -1028,10 +1029,10 @@ static int mtk_tx_map(struct sk_buff *sk
  
  
  			frag_map_size = min(frag_size, MTK_TX_DMA_BUF_LEN);
@@ -98,7 +98,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				goto err_dma;
  
  			if (i == nr_frags - 1 &&
-@@ -1324,18 +1325,18 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1309,18 +1310,18 @@ static int mtk_poll_rx(struct napi_struc
  			netdev->stats.rx_dropped++;
  			goto release_desc;
  		}
@@ -120,7 +120,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				 ring->buf_size, DMA_FROM_DEVICE);
  
  		/* receive data */
-@@ -1608,7 +1609,7 @@ static int mtk_tx_alloc(struct mtk_eth *
+@@ -1593,7 +1594,7 @@ static int mtk_tx_alloc(struct mtk_eth *
  	if (!ring->buf)
  		goto no_tx_mem;
  
@@ -129,7 +129,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				       &ring->phys, GFP_ATOMIC);
  	if (!ring->dma)
  		goto no_tx_mem;
-@@ -1626,7 +1627,7 @@ static int mtk_tx_alloc(struct mtk_eth *
+@@ -1611,7 +1612,7 @@ static int mtk_tx_alloc(struct mtk_eth *
  	 * descriptors in ring->dma_pdma.
  	 */
  	if (!MTK_HAS_CAPS(eth->soc->caps, MTK_QDMA)) {
@@ -138,7 +138,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  						    &ring->phys_pdma,
  						    GFP_ATOMIC);
  		if (!ring->dma_pdma)
-@@ -1685,7 +1686,7 @@ static void mtk_tx_clean(struct mtk_eth
+@@ -1670,7 +1671,7 @@ static void mtk_tx_clean(struct mtk_eth
  	}
  
  	if (ring->dma) {
@@ -147,7 +147,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				  MTK_DMA_SIZE * sizeof(*ring->dma),
  				  ring->dma,
  				  ring->phys);
-@@ -1693,7 +1694,7 @@ static void mtk_tx_clean(struct mtk_eth
+@@ -1678,7 +1679,7 @@ static void mtk_tx_clean(struct mtk_eth
  	}
  
  	if (ring->dma_pdma) {
@@ -156,7 +156,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				  MTK_DMA_SIZE * sizeof(*ring->dma_pdma),
  				  ring->dma_pdma,
  				  ring->phys_pdma);
-@@ -1741,18 +1742,18 @@ static int mtk_rx_alloc(struct mtk_eth *
+@@ -1723,18 +1724,18 @@ static int mtk_rx_alloc(struct mtk_eth *
  			return -ENOMEM;
  	}
  
@@ -178,7 +178,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  			return -ENOMEM;
  		ring->dma[i].rxd1 = (unsigned int)dma_addr;
  
-@@ -1788,7 +1789,7 @@ static void mtk_rx_clean(struct mtk_eth
+@@ -1770,7 +1771,7 @@ static void mtk_rx_clean(struct mtk_eth
  				continue;
  			if (!ring->dma[i].rxd1)
  				continue;
@@ -187,7 +187,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  					 ring->dma[i].rxd1,
  					 ring->buf_size,
  					 DMA_FROM_DEVICE);
-@@ -1799,7 +1800,7 @@ static void mtk_rx_clean(struct mtk_eth
+@@ -1781,7 +1782,7 @@ static void mtk_rx_clean(struct mtk_eth
  	}
  
  	if (ring->dma) {
@@ -196,7 +196,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				  ring->dma_size * sizeof(*ring->dma),
  				  ring->dma,
  				  ring->phys);
-@@ -2155,7 +2156,7 @@ static void mtk_dma_free(struct mtk_eth
+@@ -2134,7 +2135,7 @@ static void mtk_dma_free(struct mtk_eth
  		if (eth->netdev[i])
  			netdev_reset_queue(eth->netdev[i]);
  	if (eth->scratch_ring) {
@@ -205,7 +205,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  				  MTK_DMA_SIZE * sizeof(struct mtk_tx_dma),
  				  eth->scratch_ring,
  				  eth->phy_scratch_ring);
-@@ -2506,6 +2507,8 @@ static void mtk_dim_tx(struct work_struc
+@@ -2482,6 +2483,8 @@ static void mtk_dim_tx(struct work_struc
  
  static int mtk_hw_init(struct mtk_eth *eth)
  {
@@ -214,7 +214,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	int i, val, ret;
  
  	if (test_and_set_bit(MTK_HW_INIT, &eth->state))
-@@ -2518,6 +2521,10 @@ static int mtk_hw_init(struct mtk_eth *e
+@@ -2494,6 +2497,10 @@ static int mtk_hw_init(struct mtk_eth *e
  	if (ret)
  		goto err_disable_pm;
  
@@ -225,7 +225,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	if (MTK_HAS_CAPS(eth->soc->caps, MTK_SOC_MT7628)) {
  		ret = device_reset(eth->dev);
  		if (ret) {
-@@ -3067,6 +3074,35 @@ free_netdev:
+@@ -3043,6 +3050,35 @@ free_netdev:
  	return err;
  }
  
@@ -261,7 +261,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  static int mtk_probe(struct platform_device *pdev)
  {
  	struct device_node *mac_np;
-@@ -3080,6 +3116,7 @@ static int mtk_probe(struct platform_dev
+@@ -3056,6 +3092,7 @@ static int mtk_probe(struct platform_dev
  	eth->soc = of_device_get_match_data(&pdev->dev);
  
  	eth->dev = &pdev->dev;
@@ -269,7 +269,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	eth->base = devm_platform_ioremap_resource(pdev, 0);
  	if (IS_ERR(eth->base))
  		return PTR_ERR(eth->base);
-@@ -3128,6 +3165,16 @@ static int mtk_probe(struct platform_dev
+@@ -3104,6 +3141,16 @@ static int mtk_probe(struct platform_dev
  		}
  	}
  
@@ -288,7 +288,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  					  GFP_KERNEL);
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-@@ -457,6 +457,12 @@
+@@ -456,6 +456,12 @@
  #define RSTCTRL_FE		BIT(6)
  #define RSTCTRL_PPE		BIT(31)
  
@@ -301,7 +301,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  /* SGMII subsystem config registers */
  /* Register to auto-negotiation restart */
  #define SGMSYS_PCS_CONTROL_1	0x0
-@@ -874,6 +880,7 @@ struct mtk_sgmii {
+@@ -873,6 +879,7 @@ struct mtk_sgmii {
  /* struct mtk_eth -	This is the main datasructure for holding the state
   *			of the driver
   * @dev:		The device pointer
@@ -309,7 +309,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
   * @base:		The mapped register i/o base
   * @page_lock:		Make sure that register operations are atomic
   * @tx_irq__lock:	Make sure that IRQ register operations are atomic
-@@ -917,6 +924,7 @@ struct mtk_sgmii {
+@@ -916,6 +923,7 @@ struct mtk_sgmii {
  
  struct mtk_eth {
  	struct device			*dev;
@@ -317,7 +317,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	void __iomem			*base;
  	spinlock_t			page_lock;
  	spinlock_t			tx_irq_lock;
-@@ -1015,6 +1023,7 @@ int mtk_gmac_rgmii_path_setup(struct mtk
+@@ -1014,6 +1022,7 @@ int mtk_gmac_rgmii_path_setup(struct mtk
  int mtk_eth_offload_init(struct mtk_eth *eth);
  int mtk_eth_setup_tc(struct net_device *dev, enum tc_setup_type type,
  		     void *type_data);
diff -uprN a/target/linux/generic/pending-5.10/701-01-arm64-dts-mediatek-mt7622-add-support-for-coherent-D.patch b/target/linux/generic/pending-5.10/701-01-arm64-dts-mediatek-mt7622-add-support-for-coherent-D.patch
--- a/target/linux/generic/pending-5.10/701-01-arm64-dts-mediatek-mt7622-add-support-for-coherent-D.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/701-01-arm64-dts-mediatek-mt7622-add-support-for-coherent-D.patch	2024-03-18 15:16:23.634639895 +0800
@@ -19,7 +19,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  			interface-type = "ace";
  			reg = <0x5000 0x1000>;
  		};
-@@ -937,6 +937,8 @@
+@@ -936,6 +936,8 @@
  		power-domains = <&scpsys MT7622_POWER_DOMAIN_ETHSYS>;
  		mediatek,ethsys = <&ethsys>;
  		mediatek,sgmiisys = <&sgmiisys>;
diff -uprN a/target/linux/generic/pending-5.10/701-02-net-ethernet-mtk_eth_soc-add-support-for-Wireless-Et.patch b/target/linux/generic/pending-5.10/701-02-net-ethernet-mtk_eth_soc-add-support-for-Wireless-Et.patch
--- a/target/linux/generic/pending-5.10/701-02-net-ethernet-mtk_eth_soc-add-support-for-Wireless-Et.patch	2024-03-18 15:15:10.621425508 +0800
+++ b/target/linux/generic/pending-5.10/701-02-net-ethernet-mtk_eth_soc-add-support-for-Wireless-Et.patch	2024-03-18 15:16:23.634639895 +0800
@@ -56,7 +56,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
  static int mtk_msg_level = -1;
  module_param_named(msg_level, mtk_msg_level, int, 0);
-@@ -3197,6 +3198,22 @@ static int mtk_probe(struct platform_dev
+@@ -3173,6 +3174,22 @@ static int mtk_probe(struct platform_dev
  		}
  	}
  
diff -uprN a/target/linux/generic/pending-5.10/701-03-net-ethernet-mtk_eth_soc-implement-flow-offloading-t.patch b/target/linux/generic/pending-5.10/701-03-net-ethernet-mtk_eth_soc-implement-flow-offloading-t.patch
--- a/target/linux/generic/pending-5.10/701-03-net-ethernet-mtk_eth_soc-implement-flow-offloading-t.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/701-03-net-ethernet-mtk_eth_soc-implement-flow-offloading-t.patch	2024-03-18 15:16:23.606640964 +0800
@@ -233,7 +233,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  static inline void
 --- a/include/linux/netdevice.h
 +++ b/include/linux/netdevice.h
-@@ -856,6 +856,7 @@ enum net_device_path_type {
+@@ -833,6 +833,7 @@ enum net_device_path_type {
  	DEV_PATH_BRIDGE,
  	DEV_PATH_PPPOE,
  	DEV_PATH_DSA,
@@ -241,7 +241,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  };
  
  struct net_device_path {
-@@ -881,6 +882,12 @@ struct net_device_path {
+@@ -858,6 +859,12 @@ struct net_device_path {
  			int port;
  			u16 proto;
  		} dsa;
diff -uprN a/target/linux/generic/pending-5.10/701-04-arm64-dts-mediatek-mt7622-introduce-nodes-for-Wirele.patch b/target/linux/generic/pending-5.10/701-04-arm64-dts-mediatek-mt7622-introduce-nodes-for-Wirele.patch
--- a/target/linux/generic/pending-5.10/701-04-arm64-dts-mediatek-mt7622-introduce-nodes-for-Wirele.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/701-04-arm64-dts-mediatek-mt7622-introduce-nodes-for-Wirele.patch	2024-03-18 15:16:23.610640811 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/arch/arm64/boot/dts/mediatek/mt7622.dtsi
 +++ b/arch/arm64/boot/dts/mediatek/mt7622.dtsi
-@@ -893,6 +893,11 @@
+@@ -892,6 +892,11 @@
  		};
  	};
  
@@ -23,7 +23,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	ethsys: syscon@1b000000 {
  		compatible = "mediatek,mt7622-ethsys",
  			     "syscon";
-@@ -911,6 +916,26 @@
+@@ -910,6 +915,26 @@
  		#dma-cells = <1>;
  	};
  
@@ -50,7 +50,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	eth: ethernet@1b100000 {
  		compatible = "mediatek,mt7622-eth",
  			     "mediatek,mt2701-eth",
-@@ -938,6 +963,9 @@
+@@ -937,6 +962,9 @@
  		mediatek,ethsys = <&ethsys>;
  		mediatek,sgmiisys = <&sgmiisys>;
  		mediatek,cci-control = <&cci_control2>;
diff -uprN a/target/linux/generic/pending-5.10/701-07-net-ethernet-mtk_eth_soc-allocate-struct-mtk_ppe-sep.patch b/target/linux/generic/pending-5.10/701-07-net-ethernet-mtk_eth_soc-allocate-struct-mtk_ppe-sep.patch
--- a/target/linux/generic/pending-5.10/701-07-net-ethernet-mtk_eth_soc-allocate-struct-mtk_ppe-sep.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/701-07-net-ethernet-mtk_eth_soc-allocate-struct-mtk_ppe-sep.patch	2024-03-18 15:16:23.606640964 +0800
@@ -10,16 +10,16 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2329,7 +2329,7 @@ static int mtk_open(struct net_device *d
+@@ -2305,7 +2305,7 @@ static int mtk_open(struct net_device *d
+ 		if (err)
  			return err;
- 		}
  
 -		if (eth->soc->offload_version && mtk_ppe_start(&eth->ppe) == 0)
 +		if (eth->soc->offload_version && mtk_ppe_start(eth->ppe) == 0)
  			gdm_config = MTK_GDMA_TO_PPE;
  
  		mtk_gdm_config(eth, gdm_config);
-@@ -2403,7 +2403,7 @@ static int mtk_stop(struct net_device *d
+@@ -2379,7 +2379,7 @@ static int mtk_stop(struct net_device *d
  	mtk_dma_free(eth);
  
  	if (eth->soc->offload_version)
@@ -28,7 +28,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
  	return 0;
  }
-@@ -3289,10 +3289,11 @@ static int mtk_probe(struct platform_dev
+@@ -3265,10 +3265,11 @@ static int mtk_probe(struct platform_dev
  	}
  
  	if (eth->soc->offload_version) {
@@ -45,7 +45,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		if (err)
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
-@@ -977,7 +977,7 @@ struct mtk_eth {
+@@ -976,7 +976,7 @@ struct mtk_eth {
  	u32				rx_dma_l4_valid;
  	int				ip_align;
  
diff -uprN a/target/linux/generic/pending-5.10/701-08-net-ethernet-mtk_eth_soc-rework-hardware-flow-table-.patch b/target/linux/generic/pending-5.10/701-08-net-ethernet-mtk_eth_soc-rework-hardware-flow-table-.patch
--- a/target/linux/generic/pending-5.10/701-08-net-ethernet-mtk_eth_soc-rework-hardware-flow-table-.patch	2024-03-18 15:15:10.589426729 +0800
+++ b/target/linux/generic/pending-5.10/701-08-net-ethernet-mtk_eth_soc-rework-hardware-flow-table-.patch	2024-03-18 15:16:23.590641574 +0800
@@ -33,7 +33,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  #include <net/dsa.h>
  
  #include "mtk_eth_soc.h"
-@@ -1286,7 +1287,7 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1274,7 +1275,7 @@ static int mtk_poll_rx(struct napi_struc
  		struct net_device *netdev;
  		unsigned int pktlen;
  		dma_addr_t dma_addr;
@@ -42,7 +42,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		int mac;
  
  		ring = mtk_get_rx_ring(eth);
-@@ -1365,6 +1366,11 @@ static int mtk_poll_rx(struct napi_struc
+@@ -1350,6 +1351,11 @@ static int mtk_poll_rx(struct napi_struc
  			skb_set_hash(skb, hash, PKT_HASH_TYPE_L4);
  		}
  
@@ -54,7 +54,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  		if (netdev->features & NETIF_F_HW_VLAN_CTAG_RX &&
  		    (trxd.rxd2 & RX_DMA_VTAG))
  			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
-@@ -3289,7 +3295,7 @@ static int mtk_probe(struct platform_dev
+@@ -3265,7 +3271,7 @@ static int mtk_probe(struct platform_dev
  	}
  
  	if (eth->soc->offload_version) {
diff -uprN a/target/linux/generic/pending-5.10/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch b/target/linux/generic/pending-5.10/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch
--- a/target/linux/generic/pending-5.10/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/702-net-ethernet-mtk_eth_soc-enable-threaded-NAPI.patch	2024-03-18 15:16:23.634639895 +0800
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
 +++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
-@@ -2200,8 +2200,8 @@ static irqreturn_t mtk_handle_irq_rx(int
+@@ -2179,8 +2179,8 @@ static irqreturn_t mtk_handle_irq_rx(int
  
  	eth->rx_events++;
  	if (likely(napi_schedule_prep(&eth->rx_napi))) {
@@ -20,7 +20,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	}
  
  	return IRQ_HANDLED;
-@@ -2213,8 +2213,8 @@ static irqreturn_t mtk_handle_irq_tx(int
+@@ -2192,8 +2192,8 @@ static irqreturn_t mtk_handle_irq_tx(int
  
  	eth->tx_events++;
  	if (likely(napi_schedule_prep(&eth->tx_napi))) {
@@ -30,7 +30,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  	}
  
  	return IRQ_HANDLED;
-@@ -3324,6 +3324,8 @@ static int mtk_probe(struct platform_dev
+@@ -3300,6 +3300,8 @@ static int mtk_probe(struct platform_dev
  	 * for NAPI to work
  	 */
  	init_dummy_netdev(&eth->dummy_dev);
diff -uprN a/target/linux/generic/pending-5.10/703-phy-add-detach-callback-to-struct-phy_driver.patch b/target/linux/generic/pending-5.10/703-phy-add-detach-callback-to-struct-phy_driver.patch
--- a/target/linux/generic/pending-5.10/703-phy-add-detach-callback-to-struct-phy_driver.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/703-phy-add-detach-callback-to-struct-phy_driver.patch	2024-03-18 15:16:23.610640811 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
 
 --- a/drivers/net/phy/phy_device.c
 +++ b/drivers/net/phy/phy_device.c
-@@ -1652,6 +1652,9 @@ void phy_detach(struct phy_device *phyde
+@@ -1651,6 +1651,9 @@ void phy_detach(struct phy_device *phyde
  	struct module *ndev_owner = NULL;
  	struct mii_bus *bus;
  
diff -uprN a/target/linux/generic/pending-5.10/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch b/target/linux/generic/pending-5.10/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch
--- a/target/linux/generic/pending-5.10/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/705-net-dsa-tag_mtk-add-padding-for-tx-packets.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Fri, 6 May 2022 21:38:42 +0200
-Subject: [PATCH] net: dsa: tag_mtk: add padding for tx packets
-
-Padding for transmitted packets needs to account for the special tag.
-With not enough padding, garbage bytes are inserted by the switch at the
-end of small packets.
-
-Fixes: 5cd8985a1909 ("net-next: dsa: add Mediatek tag RX/TX handler")
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/dsa/tag_mtk.c
-+++ b/net/dsa/tag_mtk.c
-@@ -25,6 +25,13 @@ static struct sk_buff *mtk_tag_xmit(stru
- 	u8 xmit_tpid;
- 	u8 *mtk_tag;
- 
-+	/* The Ethernet switch we are interfaced with needs packets to be at
-+	 * least 64 bytes (including FCS) otherwise their padding might be
-+	 * corrupted. With tags enabled, we need to make sure that packets are
-+	 * at least 68 bytes (including FCS and tag).
-+	 */
-+	eth_skb_pad(skb);
-+
- 	/* Build the special tag after the MAC Source Address. If VLAN header
- 	 * is present, it's required that VLAN header and special tag is
- 	 * being combined. Only in this way we can allow the switch can parse
diff -uprN a/target/linux/generic/pending-5.10/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch b/target/linux/generic/pending-5.10/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch
--- a/target/linux/generic/pending-5.10/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/710-bridge-add-knob-for-filtering-rx-tx-BPDU-pack.patch	2024-03-18 15:16:23.610640811 +0800
@@ -0,0 +1,177 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 27 Aug 2021 12:22:32 +0200
+Subject: [PATCH] bridge: add knob for filtering rx/tx BPDU packets on a port
+
+Some devices (e.g. wireless APs) can't have devices behind them be part of
+a bridge topology with redundant links, due to address limitations.
+Additionally, broadcast traffic on these devices is somewhat expensive, due to
+the low data rate and wakeups of clients in powersave mode.
+This knob can be used to ensure that BPDU packets are never sent or forwarded
+to/from these devices
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/linux/if_bridge.h
++++ b/include/linux/if_bridge.h
+@@ -56,6 +56,7 @@ struct br_ip_list {
+ #define BR_MRP_AWARE		BIT(17)
+ #define BR_MRP_LOST_CONT	BIT(18)
+ #define BR_MRP_LOST_IN_CONT	BIT(19)
++#define BR_BPDU_FILTER		BIT(20)
+ 
+ #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
+ 
+--- a/net/bridge/br_forward.c
++++ b/net/bridge/br_forward.c
+@@ -191,6 +191,7 @@ out:
+ void br_flood(struct net_bridge *br, struct sk_buff *skb,
+ 	      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig)
+ {
++	const unsigned char *dest = eth_hdr(skb)->h_dest;
+ 	struct net_bridge_port *prev = NULL;
+ 	struct net_bridge_port *p;
+ 
+@@ -206,6 +207,10 @@ void br_flood(struct net_bridge *br, str
+ 		case BR_PKT_MULTICAST:
+ 			if (!(p->flags & BR_MCAST_FLOOD) && skb->dev != br->dev)
+ 				continue;
++			if ((p->flags & BR_BPDU_FILTER) &&
++			    unlikely(is_link_local_ether_addr(dest) &&
++				     dest[5] == 0))
++				continue;
+ 			break;
+ 		case BR_PKT_BROADCAST:
+ 			if (!(p->flags & BR_BCAST_FLOOD) && skb->dev != br->dev)
+--- a/net/bridge/br_input.c
++++ b/net/bridge/br_input.c
+@@ -305,6 +305,8 @@ static rx_handler_result_t br_handle_fra
+ 		fwd_mask |= p->group_fwd_mask;
+ 		switch (dest[5]) {
+ 		case 0x00:	/* Bridge Group Address */
++			if (p->flags & BR_BPDU_FILTER)
++				goto drop;
+ 			/* If STP is turned off,
+ 			   then must forward to keep loop detection */
+ 			if (p->br->stp_enabled == BR_NO_STP ||
+--- a/net/bridge/br_sysfs_if.c
++++ b/net/bridge/br_sysfs_if.c
+@@ -233,6 +233,7 @@ BRPORT_ATTR_FLAG(multicast_flood, BR_MCA
+ BRPORT_ATTR_FLAG(broadcast_flood, BR_BCAST_FLOOD);
+ BRPORT_ATTR_FLAG(neigh_suppress, BR_NEIGH_SUPPRESS);
+ BRPORT_ATTR_FLAG(isolated, BR_ISOLATED);
++BRPORT_ATTR_FLAG(bpdu_filter, BR_BPDU_FILTER);
+ 
+ #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+ static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
+@@ -285,6 +286,7 @@ static const struct brport_attribute *br
+ 	&brport_attr_group_fwd_mask,
+ 	&brport_attr_neigh_suppress,
+ 	&brport_attr_isolated,
++	&brport_attr_bpdu_filter,
+ 	&brport_attr_backup_port,
+ 	NULL
+ };
+--- a/net/bridge/br_stp_bpdu.c
++++ b/net/bridge/br_stp_bpdu.c
+@@ -80,7 +80,8 @@ void br_send_config_bpdu(struct net_brid
+ {
+ 	unsigned char buf[35];
+ 
+-	if (p->br->stp_enabled != BR_KERNEL_STP)
++	if (p->br->stp_enabled != BR_KERNEL_STP ||
++	    (p->flags & BR_BPDU_FILTER))
+ 		return;
+ 
+ 	buf[0] = 0;
+@@ -127,7 +128,8 @@ void br_send_tcn_bpdu(struct net_bridge_
+ {
+ 	unsigned char buf[4];
+ 
+-	if (p->br->stp_enabled != BR_KERNEL_STP)
++	if (p->br->stp_enabled != BR_KERNEL_STP ||
++	    (p->flags & BR_BPDU_FILTER))
+ 		return;
+ 
+ 	buf[0] = 0;
+@@ -172,6 +174,9 @@ void br_stp_rcv(const struct stp_proto *
+ 	if (!(br->dev->flags & IFF_UP))
+ 		goto out;
+ 
++	if (p->flags & BR_BPDU_FILTER)
++		goto out;
++
+ 	if (p->state == BR_STATE_DISABLED)
+ 		goto out;
+ 
+--- a/include/uapi/linux/if_link.h
++++ b/include/uapi/linux/if_link.h
+@@ -524,6 +524,7 @@ enum {
+ 	IFLA_BRPORT_BACKUP_PORT,
+ 	IFLA_BRPORT_MRP_RING_OPEN,
+ 	IFLA_BRPORT_MRP_IN_OPEN,
++	IFLA_BRPORT_BPDU_FILTER,
+ 	__IFLA_BRPORT_MAX
+ };
+ #define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
+--- a/net/bridge/br_netlink.c
++++ b/net/bridge/br_netlink.c
+@@ -137,6 +137,7 @@ static inline size_t br_port_info_size(v
+ 		+ nla_total_size(1)	/* IFLA_BRPORT_VLAN_TUNNEL */
+ 		+ nla_total_size(1)	/* IFLA_BRPORT_NEIGH_SUPPRESS */
+ 		+ nla_total_size(1)	/* IFLA_BRPORT_ISOLATED */
++		+ nla_total_size(1)	/* IFLA_BRPORT_BPDU_FILTER */
+ 		+ nla_total_size(sizeof(struct ifla_bridge_id))	/* IFLA_BRPORT_ROOT_ID */
+ 		+ nla_total_size(sizeof(struct ifla_bridge_id))	/* IFLA_BRPORT_BRIDGE_ID */
+ 		+ nla_total_size(sizeof(u16))	/* IFLA_BRPORT_DESIGNATED_PORT */
+@@ -220,7 +221,8 @@ static int br_port_fill_attrs(struct sk_
+ 							  BR_MRP_LOST_CONT)) ||
+ 	    nla_put_u8(skb, IFLA_BRPORT_MRP_IN_OPEN,
+ 		       !!(p->flags & BR_MRP_LOST_IN_CONT)) ||
+-	    nla_put_u8(skb, IFLA_BRPORT_ISOLATED, !!(p->flags & BR_ISOLATED)))
++	    nla_put_u8(skb, IFLA_BRPORT_ISOLATED, !!(p->flags & BR_ISOLATED)) ||
++	    nla_put_u8(skb, IFLA_BRPORT_BPDU_FILTER, !!(p->flags & BR_BPDU_FILTER)))
+ 		return -EMSGSIZE;
+ 
+ 	timerval = br_timer_value(&p->message_age_timer);
+@@ -728,6 +730,7 @@ static const struct nla_policy br_port_p
+ 	[IFLA_BRPORT_NEIGH_SUPPRESS] = { .type = NLA_U8 },
+ 	[IFLA_BRPORT_ISOLATED]	= { .type = NLA_U8 },
+ 	[IFLA_BRPORT_BACKUP_PORT] = { .type = NLA_U32 },
++	[IFLA_BRPORT_BPDU_FILTER] = { .type = NLA_U8 },
+ };
+ 
+ /* Change the state of the port and notify spanning tree */
+@@ -826,6 +829,10 @@ static int br_setport(struct net_bridge_
+ 	if (err)
+ 		return err;
+ 
++	err = br_set_port_flag(p, tb, IFLA_BRPORT_BPDU_FILTER, BR_BPDU_FILTER);
++	if (err)
++		return err;
++
+ 	br_vlan_tunnel_old = (p->flags & BR_VLAN_TUNNEL) ? true : false;
+ 	err = br_set_port_flag(p, tb, IFLA_BRPORT_VLAN_TUNNEL, BR_VLAN_TUNNEL);
+ 	if (err)
+--- a/net/core/rtnetlink.c
++++ b/net/core/rtnetlink.c
+@@ -55,7 +55,7 @@
+ #include <net/net_namespace.h>
+ 
+ #define RTNL_MAX_TYPE		50
+-#define RTNL_SLAVE_MAX_TYPE	36
++#define RTNL_SLAVE_MAX_TYPE	37
+ 
+ struct rtnl_link {
+ 	rtnl_doit_func		doit;
+@@ -4684,7 +4684,9 @@ int ndo_dflt_bridge_getlink(struct sk_bu
+ 	    brport_nla_put_flag(skb, flags, mask,
+ 				IFLA_BRPORT_MCAST_FLOOD, BR_MCAST_FLOOD) ||
+ 	    brport_nla_put_flag(skb, flags, mask,
+-				IFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD)) {
++				IFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD) ||
++	    brport_nla_put_flag(skb, flags, mask,
++				IFLA_BRPORT_BPDU_FILTER, BR_BPDU_FILTER)) {
+ 		nla_nest_cancel(skb, protinfo);
+ 		goto nla_put_failure;
+ 	}
diff -uprN a/target/linux/generic/pending-5.10/730-net-phy-at803x-fix-feature-detection.patch b/target/linux/generic/pending-5.10/730-net-phy-at803x-fix-feature-detection.patch
--- a/target/linux/generic/pending-5.10/730-net-phy-at803x-fix-feature-detection.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/730-net-phy-at803x-fix-feature-detection.patch	2024-03-18 15:16:23.606640964 +0800
@@ -0,0 +1,66 @@
+From 97ca310aa18a93329ef5cd68c20de89761962f45 Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Sun, 13 Jun 2021 12:19:36 +0200
+Subject: [PATCH] net: phy: at803x: fix feature detection
+
+AR8031/AR8033 have different status registers for copper
+and fiber operation. However, the extended status register
+is the same for both operation modes.
+
+As a result of that, ESTATUS_1000_XFULL is set to 1 even when
+operating in copper TP mode.
+
+Remove this mode from the supported link modes, as this driver
+currently only supports copper operation.
+
+Signed-off-by: David Bauer <mail@david-bauer.net>
+---
+ drivers/net/phy/at803x.c | 30 +++++++++++++++++++++++++++++-
+ 1 file changed, 29 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/phy/at803x.c
++++ b/drivers/net/phy/at803x.c
+@@ -1032,6 +1032,34 @@ static int at803x_set_tunable(struct phy
+ 	}
+ }
+ 
++static int at803x_get_features(struct phy_device *phydev)
++{
++	int err;
++
++	err = genphy_read_abilities(phydev);
++	if (err)
++		return err;
++
++	if (!at803x_match_phy_id(phydev, ATH8031_PHY_ID))
++		return 0;
++
++	/* AR8031/AR8033 have different status registers
++	 * for copper and fiber operation. However, the
++	 * extended status register is the same for both
++	 * operation modes.
++	 *
++	 * As a result of that, ESTATUS_1000_XFULL is set
++	 * to 1 even when operating in copper TP mode.
++	 *
++	 * Remove this mode from the supported link modes,
++	 * as this driver currently only supports copper
++	 * operation.
++	 */
++	linkmode_clear_bit(ETHTOOL_LINK_MODE_1000baseX_Full_BIT,
++			   phydev->supported);
++	return 0;
++}
++
+ static int at803x_cable_test_result_trans(u16 status)
+ {
+ 	switch (FIELD_GET(AT803X_CDT_STATUS_STAT_MASK, status)) {
+@@ -1364,7 +1392,7 @@ static struct phy_driver at803x_driver[]
+ 	.resume			= at803x_resume,
+ 	.read_page		= at803x_read_page,
+ 	.write_page		= at803x_write_page,
+-	/* PHY_GBIT_FEATURES */
++	.get_features		= at803x_get_features,
+ 	.read_status		= at803x_read_status,
+ 	.aneg_done		= at803x_aneg_done,
+ 	.ack_interrupt		= &at803x_ack_interrupt,
diff -uprN a/target/linux/generic/pending-5.10/750-skb-Do-mix-page-pool-and-page-referenced-frags-in-GR.patch b/target/linux/generic/pending-5.10/750-skb-Do-mix-page-pool-and-page-referenced-frags-in-GR.patch
--- a/target/linux/generic/pending-5.10/750-skb-Do-mix-page-pool-and-page-referenced-frags-in-GR.patch	2024-03-18 15:15:10.617425660 +0800
+++ b/target/linux/generic/pending-5.10/750-skb-Do-mix-page-pool-and-page-referenced-frags-in-GR.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,35 +0,0 @@
-From: Alexander Duyck <alexanderduyck@fb.com>
-Date: Thu, 26 Jan 2023 11:06:59 -0800
-Subject: [PATCH] skb: Do mix page pool and page referenced frags in GRO
-
-GSO should not merge page pool recycled frames with standard reference
-counted frames. Traditionally this didn't occur, at least not often.
-However as we start looking at adding support for wireless adapters there
-becomes the potential to mix the two due to A-MSDU repartitioning frames in
-the receive path. There are possibly other places where this may have
-occurred however I suspect they must be few and far between as we have not
-seen this issue until now.
-
-Fixes: 53e0961da1c7 ("page_pool: add frag page recycling support in page pool")
-Reported-by: Felix Fietkau <nbd@nbd.name>
-Signed-off-by: Alexander Duyck <alexanderduyck@fb.com>
----
-
---- a/net/core/skbuff.c
-+++ b/net/core/skbuff.c
-@@ -4164,6 +4164,15 @@ int skb_gro_receive(struct sk_buff *p, s
- 	if (unlikely(p->len + len >= 65536 || NAPI_GRO_CB(skb)->flush))
- 		return -E2BIG;
- 
-+	/* Do not splice page pool based packets w/ non-page pool
-+	 * packets. This can result in reference count issues as page
-+	 * pool pages will not decrement the reference count and will
-+	 * instead be immediately returned to the pool or have frag
-+	 * count decremented.
-+	 */
-+	if (p->pp_recycle != skb->pp_recycle)
-+		return -ETOOMANYREFS;
-+
- 	lp = NAPI_GRO_CB(p)->last;
- 	pinfo = skb_shinfo(lp);
- 
diff -uprN a/target/linux/generic/pending-5.10/760-net-dsa-mv88e6xxx-fix-vlan-setup.patch b/target/linux/generic/pending-5.10/760-net-dsa-mv88e6xxx-fix-vlan-setup.patch
--- a/target/linux/generic/pending-5.10/760-net-dsa-mv88e6xxx-fix-vlan-setup.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/760-net-dsa-mv88e6xxx-fix-vlan-setup.patch	2024-03-18 15:16:23.606640964 +0800
@@ -17,7 +17,7 @@ Signed-off-by: DENG Qingfang <dqfext@gma
 
 --- a/drivers/net/dsa/mv88e6xxx/chip.c
 +++ b/drivers/net/dsa/mv88e6xxx/chip.c
-@@ -2929,6 +2929,7 @@ static int mv88e6xxx_setup(struct dsa_sw
+@@ -2917,6 +2917,7 @@ static int mv88e6xxx_setup(struct dsa_sw
  
  	chip->ds = ds;
  	ds->slave_mii_bus = mv88e6xxx_default_mdio_bus(chip);
diff -uprN a/target/linux/generic/pending-5.10/763-net-bridge-switchdev-Include-local-flag-in-FDB-notif.patch b/target/linux/generic/pending-5.10/763-net-bridge-switchdev-Include-local-flag-in-FDB-notif.patch
--- a/target/linux/generic/pending-5.10/763-net-bridge-switchdev-Include-local-flag-in-FDB-notif.patch	2024-03-18 15:15:10.597426423 +0800
+++ b/target/linux/generic/pending-5.10/763-net-bridge-switchdev-Include-local-flag-in-FDB-notif.patch	2024-03-18 15:16:23.610640811 +0800
@@ -22,7 +22,7 @@ Signed-off-by: Tobias Waldekranz <tobias
 
 --- a/include/net/switchdev.h
 +++ b/include/net/switchdev.h
-@@ -226,6 +226,7 @@ struct switchdev_notifier_fdb_info {
+@@ -224,6 +224,7 @@ struct switchdev_notifier_fdb_info {
  	const unsigned char *addr;
  	u16 vid;
  	u8 added_by_user:1,
diff -uprN a/target/linux/generic/pending-5.10/768-net-dsa-mv88e6xxx-Request-assisted-learning-on-CPU-port.patch b/target/linux/generic/pending-5.10/768-net-dsa-mv88e6xxx-Request-assisted-learning-on-CPU-port.patch
--- a/target/linux/generic/pending-5.10/768-net-dsa-mv88e6xxx-Request-assisted-learning-on-CPU-port.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/768-net-dsa-mv88e6xxx-Request-assisted-learning-on-CPU-port.patch	2024-03-18 15:16:23.594641422 +0800
@@ -17,7 +17,7 @@ Signed-off-by: Tobias Waldekranz <tobias
 
 --- a/drivers/net/dsa/mv88e6xxx/chip.c
 +++ b/drivers/net/dsa/mv88e6xxx/chip.c
-@@ -5498,6 +5498,7 @@ static int mv88e6xxx_register_switch(str
+@@ -5484,6 +5484,7 @@ static int mv88e6xxx_register_switch(str
  	ds->ops = &mv88e6xxx_switch_ops;
  	ds->ageing_time_min = chip->info->age_time_coeff;
  	ds->ageing_time_max = chip->info->age_time_coeff * U8_MAX;
diff -uprN a/target/linux/generic/pending-5.10/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch b/target/linux/generic/pending-5.10/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch
--- a/target/linux/generic/pending-5.10/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/801-gpio-gpio-cascade-add-generic-GPIO-cascade.patch	2024-03-18 15:16:23.638639742 +0800
@@ -0,0 +1,222 @@
+From fc23ea48ba52c24f201fe5ca0132ee1a3de5a70a Mon Sep 17 00:00:00 2001
+From: Mauri Sandberg <maukka@ext.kapsi.fi>
+Date: Thu, 25 Mar 2021 11:48:05 +0200
+Subject: [PATCH 2/2] gpio: gpio-cascade: add generic GPIO cascade
+
+Adds support for building cascades of GPIO lines. That is, it allows
+setups when there is one upstream line and multiple cascaded lines, out
+of which one can be chosen at a time. The status of the upstream line
+can be conveyed to the selected cascaded line or, vice versa, the status
+of the cascaded line can be conveyed to the upstream line.
+
+A multiplexer is being used to select, which cascaded GPIO line is being
+used at any given time.
+
+At the moment only input direction is supported. In future it should be
+possible to add support for output direction, too.
+
+Signed-off-by: Mauri Sandberg <maukka@ext.kapsi.fi>
+Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
+Reviewed-by: Andy Shevchenko <andy.shevchenko@gmail.com>
+---
+v7 -> v8:
+ - rearrange members in struct gpio_cascade
+ - cosmetic changes in file header and in one function declaration
+ - added Reviewed-by tags by Linus and Andy
+v6 -> v7:
+ - In Kconfig add info about module name
+ - adhere to new convention that allows lines longer than 80 chars
+ - use dev_probe_err with upstream gpio line too
+ - refactor for cleaner exit of probe function.
+v5 -> v6:
+ - In Kconfig, remove dependency to OF_GPIO and select only MULTIPLEXER
+ - refactor code preferring one-liners
+ - clean up prints, removing them from success-path.
+ - don't explicitly set gpio_chip.of_node as it's done in the GPIO library
+ - use devm_gpiochip_add_data instead of gpiochip_add
+v4 -> v5:
+ - renamed gpio-mux-input -> gpio-cascade. refactored code accordingly
+   here and there and changed to use new bindings and compatible string
+   - ambigious and vague 'pin' was rename to 'upstream_line'
+ - dropped Tested-by and Reviewed-by due to changes in bindings
+ - dropped Reported-by suggested by an automatic bot as it was not really
+   appropriate to begin with
+ - functionally it's the same as v4
+v3 -> v4:
+ - Changed author email
+ - Included Tested-by and Reviewed-by from Drew
+v2 -> v3:
+ - use managed device resources
+ - update Kconfig description
+v1 -> v2:
+ - removed .owner from platform_driver as per test bot's instruction
+ - added MODULE_AUTHOR, MODULE_DESCRIPTION, MODULE_LICENSE
+ - added gpio_mux_input_get_direction as it's recommended for all chips
+ - removed because this is input only chip: gpio_mux_input_set_value
+ - removed because they are not needed for input/output only chips:
+     gpio_mux_input_direction_input
+     gpio_mux_input_direction_output
+ - fixed typo in an error message
+ - added info message about successful registration
+ - removed can_sleep flag as this does not sleep while getting GPIO value
+   like I2C or SPI do
+ - Updated description in Kconfig
+---
+ drivers/gpio/Kconfig        |  15 +++++
+ drivers/gpio/Makefile       |   1 +
+ drivers/gpio/gpio-cascade.c | 117 ++++++++++++++++++++++++++++++++++++
+ 3 files changed, 133 insertions(+)
+ create mode 100644 drivers/gpio/gpio-cascade.c
+
+--- a/drivers/gpio/Kconfig
++++ b/drivers/gpio/Kconfig
+@@ -1617,4 +1617,19 @@ config GPIO_MOCKUP
+ 	  tools/testing/selftests/gpio/gpio-mockup.sh. Reference the usage in
+ 	  it.
+ 
++comment "Other GPIO expanders"
++
++config GPIO_CASCADE
++	tristate "General GPIO cascade"
++	select MULTIPLEXER
++	help
++	  Say yes here to enable support for generic GPIO cascade.
++
++	  This allows building one-to-many cascades of GPIO lines using
++	  different types of multiplexers readily available. At the
++	  moment only input lines are supported.
++
++	  To build the driver as a module choose 'm' and the resulting module
++	  will be called 'gpio-cascade'.
++
+ endif
+--- a/drivers/gpio/Makefile
++++ b/drivers/gpio/Makefile
+@@ -44,6 +44,7 @@ obj-$(CONFIG_GPIO_BD9571MWV)		+= gpio-bd
+ obj-$(CONFIG_GPIO_BRCMSTB)		+= gpio-brcmstb.o
+ obj-$(CONFIG_GPIO_BT8XX)		+= gpio-bt8xx.o
+ obj-$(CONFIG_GPIO_CADENCE)		+= gpio-cadence.o
++obj-$(CONFIG_GPIO_CASCADE)		+= gpio-cascade.o
+ obj-$(CONFIG_GPIO_CLPS711X)		+= gpio-clps711x.o
+ obj-$(CONFIG_GPIO_SNPS_CREG)		+= gpio-creg-snps.o
+ obj-$(CONFIG_GPIO_CRYSTAL_COVE)		+= gpio-crystalcove.o
+--- /dev/null
++++ b/drivers/gpio/gpio-cascade.c
+@@ -0,0 +1,117 @@
++// SPDX-License-Identifier: GPL-2.0-only
++/*
++ *  A generic GPIO cascade driver
++ *
++ *  Copyright (C) 2021 Mauri Sandberg <maukka@ext.kapsi.fi>
++ *
++ * This allows building cascades of GPIO lines in a manner illustrated
++ * below:
++ *
++ *                 /|---- Cascaded GPIO line 0
++ *  Upstream      | |---- Cascaded GPIO line 1
++ *  GPIO line ----+ | .
++ *                | | .
++ *                 \|---- Cascaded GPIO line n
++ *
++ * A multiplexer is being used to select, which cascaded line is being
++ * addressed at any given time.
++ *
++ * At the moment only input mode is supported due to lack of means for
++ * testing output functionality. At least theoretically output should be
++ * possible with open drain constructions.
++ */
++
++#include <linux/module.h>
++#include <linux/slab.h>
++#include <linux/platform_device.h>
++#include <linux/mux/consumer.h>
++
++#include <linux/gpio/consumer.h>
++#include <linux/gpio/driver.h>
++
++struct gpio_cascade {
++	struct gpio_chip	gpio_chip;
++	struct device		*parent;
++	struct mux_control	*mux_control;
++	struct gpio_desc	*upstream_line;
++};
++
++static struct gpio_cascade *chip_to_cascade(struct gpio_chip *gc)
++{
++	return container_of(gc, struct gpio_cascade, gpio_chip);
++}
++
++static int gpio_cascade_get_direction(struct gpio_chip *gc, unsigned int offset)
++{
++	return GPIO_LINE_DIRECTION_IN;
++}
++
++static int gpio_cascade_get_value(struct gpio_chip *gc, unsigned int offset)
++{
++	struct gpio_cascade *cas = chip_to_cascade(gc);
++	int ret;
++
++	ret = mux_control_select(cas->mux_control, offset);
++	if (ret)
++		return ret;
++
++	ret = gpiod_get_value(cas->upstream_line);
++	mux_control_deselect(cas->mux_control);
++	return ret;
++}
++
++static int gpio_cascade_probe(struct platform_device *pdev)
++{
++	struct device *dev = &pdev->dev;
++	struct gpio_cascade *cas;
++	struct mux_control *mc;
++	struct gpio_desc *upstream;
++	struct gpio_chip *gc;
++
++	cas = devm_kzalloc(dev, sizeof(*cas), GFP_KERNEL);
++	if (!cas)
++		return -ENOMEM;
++
++	mc = devm_mux_control_get(dev, NULL);
++	if (IS_ERR(mc))
++		return dev_err_probe(dev, PTR_ERR(mc), "unable to get mux-control\n");
++
++	cas->mux_control = mc;
++	upstream = devm_gpiod_get(dev, "upstream",  GPIOD_IN);
++	if (IS_ERR(upstream))
++		return dev_err_probe(dev, PTR_ERR(upstream), "unable to claim upstream GPIO line\n");
++
++	cas->upstream_line = upstream;
++	cas->parent = dev;
++
++	gc = &cas->gpio_chip;
++	gc->get = gpio_cascade_get_value;
++	gc->get_direction = gpio_cascade_get_direction;
++	gc->base = -1;
++	gc->ngpio = mux_control_states(mc);
++	gc->label = dev_name(cas->parent);
++	gc->parent = cas->parent;
++	gc->owner = THIS_MODULE;
++
++	platform_set_drvdata(pdev, cas);
++	return devm_gpiochip_add_data(dev, &cas->gpio_chip, NULL);
++}
++
++static const struct of_device_id gpio_cascade_id[] = {
++	{ .compatible = "gpio-cascade" },
++	{ /* sentinel */ }
++};
++MODULE_DEVICE_TABLE(of, gpio_cascade_id);
++
++static struct platform_driver gpio_cascade_driver = {
++	.driver	= {
++		.name		= "gpio-cascade",
++		.of_match_table = gpio_cascade_id,
++	},
++	.probe	= gpio_cascade_probe,
++};
++module_platform_driver(gpio_cascade_driver);
++
++MODULE_AUTHOR("Mauri Sandberg <maukka@ext.kapsi.fi>");
++MODULE_DESCRIPTION("Generic GPIO cascade");
++MODULE_LICENSE("GPL");
diff -uprN a/target/linux/generic/pending-5.10/810-pci_disable_common_quirks.patch b/target/linux/generic/pending-5.10/810-pci_disable_common_quirks.patch
--- a/target/linux/generic/pending-5.10/810-pci_disable_common_quirks.patch	2024-03-18 15:15:10.593426577 +0800
+++ b/target/linux/generic/pending-5.10/810-pci_disable_common_quirks.patch	2024-03-18 15:16:23.606640964 +0800
@@ -33,7 +33,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
  /*
   * The Mellanox Tavor device gives false positive parity errors.  Mark this
   * device with a broken_parity_status to allow PCI scanning code to "skip"
-@@ -3335,6 +3336,8 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
+@@ -3323,6 +3324,8 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65f9, quirk_intel_mc_errata);
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x65fa, quirk_intel_mc_errata);
  
@@ -42,7 +42,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
  /*
   * Ivytown NTB BAR sizes are misreported by the hardware due to an erratum.
   * To work around this, query the size it should be configured to by the
-@@ -3360,6 +3363,8 @@ static void quirk_intel_ntb(struct pci_d
+@@ -3348,6 +3351,8 @@ static void quirk_intel_ntb(struct pci_d
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e08, quirk_intel_ntb);
  DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x0e0d, quirk_intel_ntb);
  
@@ -51,7 +51,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
  /*
   * Some BIOS implementations leave the Intel GPU interrupts enabled, even
   * though no one is handling them (e.g., if the i915 driver is never
-@@ -3398,6 +3403,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
+@@ -3386,6 +3391,8 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_IN
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x010a, disable_igfx_irq);
  DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0152, disable_igfx_irq);
  
diff -uprN a/target/linux/generic/pending-5.10/811-pci_disable_usb_common_quirks.patch b/target/linux/generic/pending-5.10/811-pci_disable_usb_common_quirks.patch
--- a/target/linux/generic/pending-5.10/811-pci_disable_usb_common_quirks.patch	2024-03-18 15:15:10.605426119 +0800
+++ b/target/linux/generic/pending-5.10/811-pci_disable_usb_common_quirks.patch	2024-03-18 15:16:23.618640505 +0800
@@ -98,7 +98,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  #endif  /*  __LINUX_USB_PCI_QUIRKS_H  */
 --- a/include/linux/usb/hcd.h
 +++ b/include/linux/usb/hcd.h
-@@ -487,7 +487,14 @@ extern int usb_hcd_pci_probe(struct pci_
+@@ -484,7 +484,14 @@ extern int usb_hcd_pci_probe(struct pci_
  extern void usb_hcd_pci_remove(struct pci_dev *dev);
  extern void usb_hcd_pci_shutdown(struct pci_dev *dev);
  
diff -uprN a/target/linux/generic/pending-5.10/834-ledtrig-libata.patch b/target/linux/generic/pending-5.10/834-ledtrig-libata.patch
--- a/target/linux/generic/pending-5.10/834-ledtrig-libata.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/834-ledtrig-libata.patch	2024-03-18 15:16:23.618640505 +0800
@@ -65,7 +65,7 @@ Signed-off-by: Daniel Golle <daniel@makr
  /**
   *	ata_build_rw_tf - Build ATA taskfile for given read/write request
   *	@tf: Target ATA taskfile
-@@ -4555,6 +4568,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
+@@ -4548,6 +4561,9 @@ struct ata_queued_cmd *ata_qc_new_init(s
  		if (tag < 0)
  			return NULL;
  	}
@@ -75,7 +75,7 @@ Signed-off-by: Daniel Golle <daniel@makr
  
  	qc = __ata_qc_from_tag(ap, tag);
  	qc->tag = qc->hw_tag = tag;
-@@ -5333,6 +5349,9 @@ struct ata_port *ata_port_alloc(struct a
+@@ -5326,6 +5342,9 @@ struct ata_port *ata_port_alloc(struct a
  	ap->stats.unhandled_irq = 1;
  	ap->stats.idle_irq = 1;
  #endif
@@ -85,7 +85,7 @@ Signed-off-by: Daniel Golle <daniel@makr
  	ata_sff_port_init(ap);
  
  	return ap;
-@@ -5368,6 +5387,12 @@ static void ata_host_release(struct kref
+@@ -5361,6 +5380,12 @@ static void ata_host_release(struct kref
  
  		kfree(ap->pmp_link);
  		kfree(ap->slave_link);
@@ -98,7 +98,7 @@ Signed-off-by: Daniel Golle <daniel@makr
  		kfree(ap);
  		host->ports[i] = NULL;
  	}
-@@ -5774,7 +5799,23 @@ int ata_host_register(struct ata_host *h
+@@ -5767,7 +5792,23 @@ int ata_host_register(struct ata_host *h
  		host->ports[i]->print_id = atomic_inc_return(&ata_print_id);
  		host->ports[i]->local_port_no = i + 1;
  	}
diff -uprN a/target/linux/generic/pending-5.10/842-net-qmi_wwan-add-ZTE-MF286D-modem-19d2-1485.patch b/target/linux/generic/pending-5.10/842-net-qmi_wwan-add-ZTE-MF286D-modem-19d2-1485.patch
--- a/target/linux/generic/pending-5.10/842-net-qmi_wwan-add-ZTE-MF286D-modem-19d2-1485.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/842-net-qmi_wwan-add-ZTE-MF286D-modem-19d2-1485.patch	2024-03-18 15:16:23.610640811 +0800
@@ -0,0 +1,59 @@
+From 078c6a1cbd4cd7496048786beec2e312577bebbf Mon Sep 17 00:00:00 2001
+From: Pawel Dembicki <paweldembicki@gmail.com>
+Date: Tue, 11 Jan 2022 23:11:32 +0100
+Subject: [PATCH] net: qmi_wwan: add ZTE MF286D modem 19d2:1485
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Modem from ZTE MF286D is an Qualcomm MDM9250 based 3G/4G modem.
+
+T:  Bus=02 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  3 Spd=5000 MxCh= 0
+D:  Ver= 3.00 Cls=00(>ifc ) Sub=00 Prot=00 MxPS= 9 #Cfgs=  1
+P:  Vendor=19d2 ProdID=1485 Rev=52.87
+S:  Manufacturer=ZTE,Incorporated
+S:  Product=ZTE Technologies MSM
+S:  SerialNumber=MF286DZTED000000
+C:* #Ifs= 7 Cfg#= 1 Atr=80 MxPwr=896mA
+A:  FirstIf#= 0 IfCount= 2 Cls=02(comm.) Sub=06 Prot=00
+I:* If#= 0 Alt= 0 #EPs= 1 Cls=02(comm.) Sub=02 Prot=ff Driver=rndis_host
+E:  Ad=82(I) Atr=03(Int.) MxPS=   8 Ivl=32ms
+I:* If#= 1 Alt= 0 #EPs= 2 Cls=0a(data ) Sub=00 Prot=00 Driver=rndis_host
+E:  Ad=81(I) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+E:  Ad=01(O) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+I:* If#= 2 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=ff Prot=ff Driver=option
+E:  Ad=83(I) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+E:  Ad=02(O) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+I:* If#= 3 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=option
+E:  Ad=85(I) Atr=03(Int.) MxPS=  10 Ivl=32ms
+E:  Ad=84(I) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+E:  Ad=03(O) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+I:* If#= 4 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=option
+E:  Ad=87(I) Atr=03(Int.) MxPS=  10 Ivl=32ms
+E:  Ad=86(I) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+E:  Ad=04(O) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+I:* If#= 5 Alt= 0 #EPs= 3 Cls=ff(vend.) Sub=ff Prot=ff Driver=qmi_wwan
+E:  Ad=88(I) Atr=03(Int.) MxPS=   8 Ivl=32ms
+E:  Ad=8e(I) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+E:  Ad=0f(O) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+I:* If#= 6 Alt= 0 #EPs= 2 Cls=ff(vend.) Sub=42 Prot=01 Driver=usbfs
+E:  Ad=05(O) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+E:  Ad=89(I) Atr=02(Bulk) MxPS=1024 Ivl=0ms
+
+Signed-off-by: Pawel Dembicki <paweldembicki@gmail.com>
+Acked-by: Bjørn Mork <bjorn@mork.no>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ drivers/net/usb/qmi_wwan.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -1252,6 +1252,7 @@ static const struct usb_device_id produc
+ 	{QMI_FIXED_INTF(0x19d2, 0x1426, 2)},	/* ZTE MF91 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1428, 2)},	/* Telewell TW-LTE 4G v2 */
+ 	{QMI_FIXED_INTF(0x19d2, 0x1432, 3)},	/* ZTE ME3620 */
++	{QMI_FIXED_INTF(0x19d2, 0x1485, 5)},	/* ZTE MF286D */
+ 	{QMI_FIXED_INTF(0x19d2, 0x2002, 4)},	/* ZTE (Vodafone) K3765-Z */
+ 	{QMI_FIXED_INTF(0x2001, 0x7e16, 3)},	/* D-Link DWM-221 */
+ 	{QMI_FIXED_INTF(0x2001, 0x7e19, 4)},	/* D-Link DWM-221 B1 */
diff -uprN a/target/linux/generic/pending-5.10/850-0001-PCI-aardvark-Replace-custom-PCIE_CORE_INT_-macros-wi.patch b/target/linux/generic/pending-5.10/850-0001-PCI-aardvark-Replace-custom-PCIE_CORE_INT_-macros-wi.patch
--- a/target/linux/generic/pending-5.10/850-0001-PCI-aardvark-Replace-custom-PCIE_CORE_INT_-macros-wi.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0001-PCI-aardvark-Replace-custom-PCIE_CORE_INT_-macros-wi.patch	2024-03-18 15:16:23.602641117 +0800
@@ -0,0 +1,40 @@
+From 43f3f187e6f62ca40802afe39495c8a3e20b4bfa Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Mon, 10 Jan 2022 01:50:50 +0100
+Subject: [PATCH] PCI: aardvark: Replace custom PCIE_CORE_INT_* macros with
+ PCI_INTERRUPT_*
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Header file linux/pci.h defines enum pci_interrupt_pin with corresponding
+PCI_INTERRUPT_* values.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 6 +-----
+ 1 file changed, 1 insertion(+), 5 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -37,10 +37,6 @@
+ #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHK_TX_EN			BIT(6)
+ #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHCK			BIT(7)
+ #define     PCIE_CORE_ERR_CAPCTL_ECRC_CHCK_RCV			BIT(8)
+-#define     PCIE_CORE_INT_A_ASSERT_ENABLE			1
+-#define     PCIE_CORE_INT_B_ASSERT_ENABLE			2
+-#define     PCIE_CORE_INT_C_ASSERT_ENABLE			3
+-#define     PCIE_CORE_INT_D_ASSERT_ENABLE			4
+ /* PIO registers base address and register offsets */
+ #define PIO_BASE_ADDR				0x4000
+ #define PIO_CTRL				(PIO_BASE_ADDR + 0x0)
+@@ -966,7 +962,7 @@ static int advk_sw_pci_bridge_init(struc
+ 	bridge->conf.pref_mem_limit = cpu_to_le16(PCI_PREF_RANGE_TYPE_64);
+ 
+ 	/* Support interrupt A for MSI feature */
+-	bridge->conf.intpin = PCIE_CORE_INT_A_ASSERT_ENABLE;
++	bridge->conf.intpin = PCI_INTERRUPT_INTA;
+ 
+ 	/* Aardvark HW provides PCIe Capability structure in version 2 */
+ 	bridge->pcie_conf.cap = cpu_to_le16(2);
diff -uprN a/target/linux/generic/pending-5.10/850-0002-PCI-aardvark-Fix-reading-MSI-interrupt-number.patch b/target/linux/generic/pending-5.10/850-0002-PCI-aardvark-Fix-reading-MSI-interrupt-number.patch
--- a/target/linux/generic/pending-5.10/850-0002-PCI-aardvark-Fix-reading-MSI-interrupt-number.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0002-PCI-aardvark-Fix-reading-MSI-interrupt-number.patch	2024-03-18 15:16:23.634639895 +0800
@@ -0,0 +1,57 @@
+From a29a7d01cd778854e08108461cba321a63d98871 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 2 Jul 2021 16:39:47 +0200
+Subject: [PATCH] PCI: aardvark: Fix reading MSI interrupt number
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+In advk_pcie_handle_msi() the authors expect that when bit i in the W1C
+register PCIE_MSI_STATUS_REG is cleared, the PCIE_MSI_PAYLOAD_REG is
+updated to contain the MSI number corresponding to index i.
+
+Experiments show that this is not so, and instead PCIE_MSI_PAYLOAD_REG
+always contains the number of the last received MSI, overall.
+
+Do not read PCIE_MSI_PAYLOAD_REG register for determining MSI interrupt
+number. Since Aardvark already forbids more than 32 interrupts and uses
+own allocated hwirq numbers, the msi_idx already corresponds to the
+received MSI number.
+
+Fixes: 8c39d710363c ("PCI: aardvark: Add Aardvark PCI host controller driver")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 13 ++++++-------
+ 1 file changed, 6 insertions(+), 7 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1393,7 +1393,7 @@ static void advk_pcie_remove_irq_domain(
+ static void advk_pcie_handle_msi(struct advk_pcie *pcie)
+ {
+ 	u32 msi_val, msi_mask, msi_status, msi_idx;
+-	u16 msi_data;
++	int virq;
+ 
+ 	msi_mask = advk_readl(pcie, PCIE_MSI_MASK_REG);
+ 	msi_val = advk_readl(pcie, PCIE_MSI_STATUS_REG);
+@@ -1403,13 +1403,12 @@ static void advk_pcie_handle_msi(struct
+ 		if (!(BIT(msi_idx) & msi_status))
+ 			continue;
+ 
+-		/*
+-		 * msi_idx contains bits [4:0] of the msi_data and msi_data
+-		 * contains 16bit MSI interrupt number
+-		 */
+ 		advk_writel(pcie, BIT(msi_idx), PCIE_MSI_STATUS_REG);
+-		msi_data = advk_readl(pcie, PCIE_MSI_PAYLOAD_REG) & PCIE_MSI_DATA_MASK;
+-		generic_handle_irq(msi_data);
++		virq = irq_find_mapping(pcie->msi_inner_domain, msi_idx);
++		if (virq)
++			generic_handle_irq(virq);
++		else
++			dev_err_ratelimited(&pcie->pdev->dev, "unexpected MSI 0x%02x\n", msi_idx);
+ 	}
+ 
+ 	advk_writel(pcie, PCIE_ISR0_MSI_INT_PENDING,
diff -uprN a/target/linux/generic/pending-5.10/850-0003-PCI-aardvark-Fix-support-for-MSI-interrupts.patch b/target/linux/generic/pending-5.10/850-0003-PCI-aardvark-Fix-support-for-MSI-interrupts.patch
--- a/target/linux/generic/pending-5.10/850-0003-PCI-aardvark-Fix-support-for-MSI-interrupts.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0003-PCI-aardvark-Fix-support-for-MSI-interrupts.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,72 @@
+From bb03b126ea6c9e57177b537dd022246fa5dbef16 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 12 Feb 2021 16:24:07 +0100
+Subject: [PATCH] PCI: aardvark: Fix support for MSI interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Aardvark hardware supports Multi-MSI and MSI_FLAG_MULTI_PCI_MSI is already
+set for the MSI chip. But when allocating MSI interrupt numbers for
+Multi-MSI, the numbers need to be properly aligned, otherwise endpoint
+devices send MSI interrupt with incorrect numbers.
+
+Fix this issue by using function bitmap_find_free_region() instead of
+bitmap_find_next_zero_area().
+
+To ensure that aligned MSI interrupt numbers are used by endpoint devices,
+we cannot use Linux virtual irq numbers (as they are random and not
+properly aligned). Instead we need to use the aligned hwirq numbers.
+
+This change fixes receiving MSI interrupts on Armada 3720 boards and
+allows using NVMe disks which use Multi-MSI feature with 3 interrupts.
+
+Without this NVMe disks freeze booting as linux nvme-core.c is waiting
+60s for an interrupt.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 16 ++++++----------
+ 1 file changed, 6 insertions(+), 10 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1189,7 +1189,7 @@ static void advk_msi_irq_compose_msi_msg
+ 
+ 	msg->address_lo = lower_32_bits(msi_msg);
+ 	msg->address_hi = upper_32_bits(msi_msg);
+-	msg->data = data->irq;
++	msg->data = data->hwirq;
+ }
+ 
+ static int advk_msi_set_affinity(struct irq_data *irq_data,
+@@ -1206,15 +1206,11 @@ static int advk_msi_irq_domain_alloc(str
+ 	int hwirq, i;
+ 
+ 	mutex_lock(&pcie->msi_used_lock);
+-	hwirq = bitmap_find_next_zero_area(pcie->msi_used, MSI_IRQ_NUM,
+-					   0, nr_irqs, 0);
+-	if (hwirq >= MSI_IRQ_NUM) {
+-		mutex_unlock(&pcie->msi_used_lock);
+-		return -ENOSPC;
+-	}
+-
+-	bitmap_set(pcie->msi_used, hwirq, nr_irqs);
++	hwirq = bitmap_find_free_region(pcie->msi_used, MSI_IRQ_NUM,
++					order_base_2(nr_irqs));
+ 	mutex_unlock(&pcie->msi_used_lock);
++	if (hwirq < 0)
++		return -ENOSPC;
+ 
+ 	for (i = 0; i < nr_irqs; i++)
+ 		irq_domain_set_info(domain, virq + i, hwirq + i,
+@@ -1232,7 +1228,7 @@ static void advk_msi_irq_domain_free(str
+ 	struct advk_pcie *pcie = domain->host_data;
+ 
+ 	mutex_lock(&pcie->msi_used_lock);
+-	bitmap_clear(pcie->msi_used, d->hwirq, nr_irqs);
++	bitmap_release_region(pcie->msi_used, d->hwirq, order_base_2(nr_irqs));
+ 	mutex_unlock(&pcie->msi_used_lock);
+ }
+ 
diff -uprN a/target/linux/generic/pending-5.10/850-0004-PCI-aardvark-Rewrite-IRQ-code-to-chained-IRQ-handler.patch b/target/linux/generic/pending-5.10/850-0004-PCI-aardvark-Rewrite-IRQ-code-to-chained-IRQ-handler.patch
--- a/target/linux/generic/pending-5.10/850-0004-PCI-aardvark-Rewrite-IRQ-code-to-chained-IRQ-handler.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0004-PCI-aardvark-Rewrite-IRQ-code-to-chained-IRQ-handler.patch	2024-03-18 15:16:23.638639742 +0800
@@ -0,0 +1,125 @@
+From 0cd5141d1866afb23286fe90cd846441fe7aeb39 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sat, 27 Mar 2021 14:44:11 +0100
+Subject: [PATCH] PCI: aardvark: Rewrite IRQ code to chained IRQ handler
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Rewrite the code to use irq_set_chained_handler_and_data() handler with
+chained_irq_enter() and chained_irq_exit() processing instead of using
+devm_request_irq().
+
+advk_pcie_irq_handler() reads IRQ status bits and calls other functions
+based on which bits are set. These functions then read its own IRQ status
+bits and calls other aardvark functions based on these bits. Finally
+generic_handle_domain_irq() with translated linux IRQ numbers are called.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 48 +++++++++++++++------------
+ 1 file changed, 26 insertions(+), 22 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -275,6 +275,7 @@ struct advk_pcie {
+ 		u32 actions;
+ 	} wins[OB_WIN_COUNT];
+ 	u8 wins_count;
++	int irq;
+ 	struct irq_domain *irq_domain;
+ 	struct irq_chip irq_chip;
+ 	raw_spinlock_t irq_lock;
+@@ -1442,21 +1443,26 @@ static void advk_pcie_handle_int(struct
+ 	}
+ }
+ 
+-static irqreturn_t advk_pcie_irq_handler(int irq, void *arg)
++static void advk_pcie_irq_handler(struct irq_desc *desc)
+ {
+-	struct advk_pcie *pcie = arg;
+-	u32 status;
++	struct advk_pcie *pcie = irq_desc_get_handler_data(desc);
++	struct irq_chip *chip = irq_desc_get_chip(desc);
++	u32 val, mask, status;
+ 
+-	status = advk_readl(pcie, HOST_CTRL_INT_STATUS_REG);
+-	if (!(status & PCIE_IRQ_CORE_INT))
+-		return IRQ_NONE;
++	chained_irq_enter(chip, desc);
+ 
+-	advk_pcie_handle_int(pcie);
++	val = advk_readl(pcie, HOST_CTRL_INT_STATUS_REG);
++	mask = advk_readl(pcie, HOST_CTRL_INT_MASK_REG);
++	status = val & ((~mask) & PCIE_IRQ_ALL_MASK);
+ 
+-	/* Clear interrupt */
+-	advk_writel(pcie, PCIE_IRQ_CORE_INT, HOST_CTRL_INT_STATUS_REG);
++	if (status & PCIE_IRQ_CORE_INT) {
++		advk_pcie_handle_int(pcie);
+ 
+-	return IRQ_HANDLED;
++		/* Clear interrupt */
++		advk_writel(pcie, PCIE_IRQ_CORE_INT, HOST_CTRL_INT_STATUS_REG);
++	}
++
++	chained_irq_exit(chip, desc);
+ }
+ 
+ static void __maybe_unused advk_pcie_disable_phy(struct advk_pcie *pcie)
+@@ -1523,7 +1529,7 @@ static int advk_pcie_probe(struct platfo
+ 	struct advk_pcie *pcie;
+ 	struct pci_host_bridge *bridge;
+ 	struct resource_entry *entry;
+-	int ret, irq;
++	int ret;
+ 
+ 	bridge = devm_pci_alloc_host_bridge(dev, sizeof(struct advk_pcie));
+ 	if (!bridge)
+@@ -1611,17 +1617,9 @@ static int advk_pcie_probe(struct platfo
+ 	if (IS_ERR(pcie->base))
+ 		return PTR_ERR(pcie->base);
+ 
+-	irq = platform_get_irq(pdev, 0);
+-	if (irq < 0)
+-		return irq;
+-
+-	ret = devm_request_irq(dev, irq, advk_pcie_irq_handler,
+-			       IRQF_SHARED | IRQF_NO_THREAD, "advk-pcie",
+-			       pcie);
+-	if (ret) {
+-		dev_err(dev, "Failed to register interrupt\n");
+-		return ret;
+-	}
++	pcie->irq = platform_get_irq(pdev, 0);
++	if (pcie->irq < 0)
++		return pcie->irq;
+ 
+ 	pcie->reset_gpio = devm_gpiod_get_from_of_node(dev, dev->of_node,
+ 						       "reset-gpios", 0,
+@@ -1670,11 +1668,14 @@ static int advk_pcie_probe(struct platfo
+ 		return ret;
+ 	}
+ 
++	irq_set_chained_handler_and_data(pcie->irq, advk_pcie_irq_handler, pcie);
++
+ 	bridge->sysdata = pcie;
+ 	bridge->ops = &advk_pcie_ops;
+ 
+ 	ret = pci_host_probe(bridge);
+ 	if (ret < 0) {
++		irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
+ 		advk_pcie_remove_msi_irq_domain(pcie);
+ 		advk_pcie_remove_irq_domain(pcie);
+ 		return ret;
+@@ -1722,6 +1723,9 @@ static int advk_pcie_remove(struct platf
+ 	advk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_REG);
+ 	advk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);
+ 
++	/* Remove IRQ handler */
++	irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
++
+ 	/* Remove IRQ domains */
+ 	advk_pcie_remove_msi_irq_domain(pcie);
+ 	advk_pcie_remove_irq_domain(pcie);
diff -uprN a/target/linux/generic/pending-5.10/850-0005-PCI-aardvark-Check-return-value-of-generic_handle_do.patch b/target/linux/generic/pending-5.10/850-0005-PCI-aardvark-Check-return-value-of-generic_handle_do.patch
--- a/target/linux/generic/pending-5.10/850-0005-PCI-aardvark-Check-return-value-of-generic_handle_do.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0005-PCI-aardvark-Check-return-value-of-generic_handle_do.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,31 @@
+From 69c1f2c6f45a556361fd8e8d2d4eb20e2c8d3d95 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 18 Mar 2021 17:04:32 +0100
+Subject: [PATCH] PCI: aardvark: Check return value of
+ generic_handle_domain_irq() when processing INTx IRQ
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It is possible that we receive spurious INTx interrupt. Check for the
+return value of generic_handle_domain_irq() when processing INTx IRQ.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1439,7 +1439,9 @@ static void advk_pcie_handle_int(struct
+ 			    PCIE_ISR1_REG);
+ 
+ 		virq = irq_find_mapping(pcie->irq_domain, i);
+-		generic_handle_irq(virq);
++		if (generic_handle_irq(virq) == -EINVAL)
++			dev_err_ratelimited(&pcie->pdev->dev, "unexpected INT%c IRQ\n",
++					    (char)i + 'A');
+ 	}
+ }
+ 
diff -uprN a/target/linux/generic/pending-5.10/850-0006-PCI-aardvark-Make-MSI-irq_chip-structures-static-dri.patch b/target/linux/generic/pending-5.10/850-0006-PCI-aardvark-Make-MSI-irq_chip-structures-static-dri.patch
--- a/target/linux/generic/pending-5.10/850-0006-PCI-aardvark-Make-MSI-irq_chip-structures-static-dri.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0006-PCI-aardvark-Make-MSI-irq_chip-structures-static-dri.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,93 @@
+From 5eb36a6b9508da442aac80f4df23e3951bbfa7aa Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 10 Jan 2022 00:03:41 +0100
+Subject: [PATCH] PCI: aardvark: Make MSI irq_chip structures static driver
+ structures
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Marc Zyngier says [1] that we should use struct irq_chip as a global
+static struct in the driver. Even though the structure currently
+contains a dynamic member (parent_device), Marc says [2] that he plans
+to kill it and make the structure completely static.
+
+Convert Aardvark's priv->msi_bottom_irq_chip and priv->msi_irq_chip to
+static driver structure.
+
+[1] https://lore.kernel.org/linux-pci/877dbcvngf.wl-maz@kernel.org/
+[2] https://lore.kernel.org/linux-pci/874k6gvkhz.wl-maz@kernel.org/
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 26 ++++++++++++--------------
+ 1 file changed, 12 insertions(+), 14 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -281,8 +281,6 @@ struct advk_pcie {
+ 	raw_spinlock_t irq_lock;
+ 	struct irq_domain *msi_domain;
+ 	struct irq_domain *msi_inner_domain;
+-	struct irq_chip msi_bottom_irq_chip;
+-	struct irq_chip msi_irq_chip;
+ 	struct msi_domain_info msi_domain_info;
+ 	DECLARE_BITMAP(msi_used, MSI_IRQ_NUM);
+ 	struct mutex msi_used_lock;
+@@ -1199,6 +1197,12 @@ static int advk_msi_set_affinity(struct
+ 	return -EINVAL;
+ }
+ 
++static struct irq_chip advk_msi_bottom_irq_chip = {
++	.name			= "MSI",
++	.irq_compose_msi_msg	= advk_msi_irq_compose_msi_msg,
++	.irq_set_affinity	= advk_msi_set_affinity,
++};
++
+ static int advk_msi_irq_domain_alloc(struct irq_domain *domain,
+ 				     unsigned int virq,
+ 				     unsigned int nr_irqs, void *args)
+@@ -1215,7 +1219,7 @@ static int advk_msi_irq_domain_alloc(str
+ 
+ 	for (i = 0; i < nr_irqs; i++)
+ 		irq_domain_set_info(domain, virq + i, hwirq + i,
+-				    &pcie->msi_bottom_irq_chip,
++				    &advk_msi_bottom_irq_chip,
+ 				    domain->host_data, handle_simple_irq,
+ 				    NULL, NULL);
+ 
+@@ -1285,29 +1289,23 @@ static const struct irq_domain_ops advk_
+ 	.xlate = irq_domain_xlate_onecell,
+ };
+ 
++static struct irq_chip advk_msi_irq_chip = {
++	.name = "advk-MSI",
++};
++
+ static int advk_pcie_init_msi_irq_domain(struct advk_pcie *pcie)
+ {
+ 	struct device *dev = &pcie->pdev->dev;
+ 	struct device_node *node = dev->of_node;
+-	struct irq_chip *bottom_ic, *msi_ic;
+ 	struct msi_domain_info *msi_di;
+ 	phys_addr_t msi_msg_phys;
+ 
+ 	mutex_init(&pcie->msi_used_lock);
+ 
+-	bottom_ic = &pcie->msi_bottom_irq_chip;
+-
+-	bottom_ic->name = "MSI";
+-	bottom_ic->irq_compose_msi_msg = advk_msi_irq_compose_msi_msg;
+-	bottom_ic->irq_set_affinity = advk_msi_set_affinity;
+-
+-	msi_ic = &pcie->msi_irq_chip;
+-	msi_ic->name = "advk-MSI";
+-
+ 	msi_di = &pcie->msi_domain_info;
+ 	msi_di->flags = MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+ 		MSI_FLAG_MULTI_PCI_MSI;
+-	msi_di->chip = msi_ic;
++	msi_di->chip = &advk_msi_irq_chip;
+ 
+ 	msi_msg_phys = virt_to_phys(&pcie->msi_msg);
+ 
diff -uprN a/target/linux/generic/pending-5.10/850-0007-PCI-aardvark-Make-msi_domain_info-structure-a-static.patch b/target/linux/generic/pending-5.10/850-0007-PCI-aardvark-Make-msi_domain_info-structure-a-static.patch
--- a/target/linux/generic/pending-5.10/850-0007-PCI-aardvark-Make-msi_domain_info-structure-a-static.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0007-PCI-aardvark-Make-msi_domain_info-structure-a-static.patch	2024-03-18 15:16:23.634639895 +0800
@@ -0,0 +1,64 @@
+From c092ab8994f1f777054c0179a9deb40b87ee606f Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 10 Jan 2022 00:10:46 +0100
+Subject: [PATCH] PCI: aardvark: Make msi_domain_info structure a static driver
+ structure
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Make Aardvark's msi_domain_info structure into a private driver structure.
+Domain info is same for every potential instatination of a controller.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 16 ++++++++--------
+ 1 file changed, 8 insertions(+), 8 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -281,7 +281,6 @@ struct advk_pcie {
+ 	raw_spinlock_t irq_lock;
+ 	struct irq_domain *msi_domain;
+ 	struct irq_domain *msi_inner_domain;
+-	struct msi_domain_info msi_domain_info;
+ 	DECLARE_BITMAP(msi_used, MSI_IRQ_NUM);
+ 	struct mutex msi_used_lock;
+ 	u16 msi_msg;
+@@ -1293,20 +1292,20 @@ static struct irq_chip advk_msi_irq_chip
+ 	.name = "advk-MSI",
+ };
+ 
++static struct msi_domain_info advk_msi_domain_info = {
++	.flags	= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
++		  MSI_FLAG_MULTI_PCI_MSI,
++	.chip	= &advk_msi_irq_chip,
++};
++
+ static int advk_pcie_init_msi_irq_domain(struct advk_pcie *pcie)
+ {
+ 	struct device *dev = &pcie->pdev->dev;
+ 	struct device_node *node = dev->of_node;
+-	struct msi_domain_info *msi_di;
+ 	phys_addr_t msi_msg_phys;
+ 
+ 	mutex_init(&pcie->msi_used_lock);
+ 
+-	msi_di = &pcie->msi_domain_info;
+-	msi_di->flags = MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+-		MSI_FLAG_MULTI_PCI_MSI;
+-	msi_di->chip = &advk_msi_irq_chip;
+-
+ 	msi_msg_phys = virt_to_phys(&pcie->msi_msg);
+ 
+ 	advk_writel(pcie, lower_32_bits(msi_msg_phys),
+@@ -1322,7 +1321,8 @@ static int advk_pcie_init_msi_irq_domain
+ 
+ 	pcie->msi_domain =
+ 		pci_msi_create_irq_domain(of_node_to_fwnode(node),
+-					  msi_di, pcie->msi_inner_domain);
++					  &advk_msi_domain_info,
++					  pcie->msi_inner_domain);
+ 	if (!pcie->msi_domain) {
+ 		irq_domain_remove(pcie->msi_inner_domain);
+ 		return -ENOMEM;
diff -uprN a/target/linux/generic/pending-5.10/850-0008-PCI-aardvark-Use-dev_fwnode-instead-of-of_node_to_fw.patch b/target/linux/generic/pending-5.10/850-0008-PCI-aardvark-Use-dev_fwnode-instead-of-of_node_to_fw.patch
--- a/target/linux/generic/pending-5.10/850-0008-PCI-aardvark-Use-dev_fwnode-instead-of-of_node_to_fw.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0008-PCI-aardvark-Use-dev_fwnode-instead-of-of_node_to_fw.patch	2024-03-18 15:16:23.610640811 +0800
@@ -0,0 +1,40 @@
+From 59029739d42b439628e2f64f3d8f2db9be97deff Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 10 Jan 2022 00:15:17 +0100
+Subject: [PATCH] PCI: aardvark: Use dev_fwnode() instead of
+ of_node_to_fwnode(dev->of_node)
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Use simple
+  dev_fwnode(dev)
+instead of
+  struct device_node *node = dev->of_node;
+  of_node_to_fwnode(node)
+especially since the node variable is not used elsewhere in the function.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 3 +--
+ 1 file changed, 1 insertion(+), 2 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1301,7 +1301,6 @@ static struct msi_domain_info advk_msi_d
+ static int advk_pcie_init_msi_irq_domain(struct advk_pcie *pcie)
+ {
+ 	struct device *dev = &pcie->pdev->dev;
+-	struct device_node *node = dev->of_node;
+ 	phys_addr_t msi_msg_phys;
+ 
+ 	mutex_init(&pcie->msi_used_lock);
+@@ -1320,7 +1319,7 @@ static int advk_pcie_init_msi_irq_domain
+ 		return -ENOMEM;
+ 
+ 	pcie->msi_domain =
+-		pci_msi_create_irq_domain(of_node_to_fwnode(node),
++		pci_msi_create_irq_domain(dev_fwnode(dev),
+ 					  &advk_msi_domain_info,
+ 					  pcie->msi_inner_domain);
+ 	if (!pcie->msi_domain) {
diff -uprN a/target/linux/generic/pending-5.10/850-0009-PCI-aardvark-Refactor-unmasking-summary-MSI-interrup.patch b/target/linux/generic/pending-5.10/850-0009-PCI-aardvark-Refactor-unmasking-summary-MSI-interrup.patch
--- a/target/linux/generic/pending-5.10/850-0009-PCI-aardvark-Refactor-unmasking-summary-MSI-interrup.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0009-PCI-aardvark-Refactor-unmasking-summary-MSI-interrup.patch	2024-03-18 15:16:23.614640659 +0800
@@ -0,0 +1,44 @@
+From 98feaf97bc64fc640a6c5b1394cd18fc7cd7dac8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Sun, 28 Mar 2021 14:34:49 +0200
+Subject: [PATCH] PCI: aardvark: Refactor unmasking summary MSI interrupt
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Refactor the masking of ISR0/1 Sources and unmasking of summary MSI interrupt
+so that it corresponds to the comments:
+- first mask all ISR0/1
+- then unmask all MSIs
+- then unmask summary MSI interrupt
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 10 ++++++----
+ 1 file changed, 6 insertions(+), 4 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -578,15 +578,17 @@ static void advk_pcie_setup_hw(struct ad
+ 	advk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);
+ 
+ 	/* Disable All ISR0/1 Sources */
+-	reg = PCIE_ISR0_ALL_MASK;
+-	reg &= ~PCIE_ISR0_MSI_INT_PENDING;
+-	advk_writel(pcie, reg, PCIE_ISR0_MASK_REG);
+-
++	advk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_MASK_REG);
+ 	advk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_MASK_REG);
+ 
+ 	/* Unmask all MSIs */
+ 	advk_writel(pcie, ~(u32)PCIE_MSI_ALL_MASK, PCIE_MSI_MASK_REG);
+ 
++	/* Unmask summary MSI interrupt */
++	reg = advk_readl(pcie, PCIE_ISR0_MASK_REG);
++	reg &= ~PCIE_ISR0_MSI_INT_PENDING;
++	advk_writel(pcie, reg, PCIE_ISR0_MASK_REG);
++
+ 	/* Enable summary interrupt for GIC SPI source */
+ 	reg = PCIE_IRQ_ALL_MASK & (~PCIE_IRQ_ENABLE_INTS_MASK);
+ 	advk_writel(pcie, reg, HOST_CTRL_INT_MASK_REG);
diff -uprN a/target/linux/generic/pending-5.10/850-0010-PCI-aardvark-Add-support-for-masking-MSI-interrupts.patch b/target/linux/generic/pending-5.10/850-0010-PCI-aardvark-Add-support-for-masking-MSI-interrupts.patch
--- a/target/linux/generic/pending-5.10/850-0010-PCI-aardvark-Add-support-for-masking-MSI-interrupts.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0010-PCI-aardvark-Add-support-for-masking-MSI-interrupts.patch	2024-03-18 15:16:23.606640964 +0800
@@ -0,0 +1,117 @@
+From 7f353accca6e4a3222991c65b1a6801503973bd3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 2 Jul 2021 16:44:10 +0200
+Subject: [PATCH] PCI: aardvark: Add support for masking MSI interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+We should not unmask MSIs at setup, but only when kernel asks for them
+to be unmasked.
+
+At setup, mask all MSIs, and implement IRQ chip callbacks for masking
+and unmasking particular MSIs.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 54 ++++++++++++++++++++++++---
+ 1 file changed, 49 insertions(+), 5 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -281,6 +281,7 @@ struct advk_pcie {
+ 	raw_spinlock_t irq_lock;
+ 	struct irq_domain *msi_domain;
+ 	struct irq_domain *msi_inner_domain;
++	raw_spinlock_t msi_irq_lock;
+ 	DECLARE_BITMAP(msi_used, MSI_IRQ_NUM);
+ 	struct mutex msi_used_lock;
+ 	u16 msi_msg;
+@@ -577,12 +578,10 @@ static void advk_pcie_setup_hw(struct ad
+ 	advk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_REG);
+ 	advk_writel(pcie, PCIE_IRQ_ALL_MASK, HOST_CTRL_INT_STATUS_REG);
+ 
+-	/* Disable All ISR0/1 Sources */
++	/* Disable All ISR0/1 and MSI Sources */
+ 	advk_writel(pcie, PCIE_ISR0_ALL_MASK, PCIE_ISR0_MASK_REG);
+ 	advk_writel(pcie, PCIE_ISR1_ALL_MASK, PCIE_ISR1_MASK_REG);
+-
+-	/* Unmask all MSIs */
+-	advk_writel(pcie, ~(u32)PCIE_MSI_ALL_MASK, PCIE_MSI_MASK_REG);
++	advk_writel(pcie, PCIE_MSI_ALL_MASK, PCIE_MSI_MASK_REG);
+ 
+ 	/* Unmask summary MSI interrupt */
+ 	reg = advk_readl(pcie, PCIE_ISR0_MASK_REG);
+@@ -1198,10 +1197,52 @@ static int advk_msi_set_affinity(struct
+ 	return -EINVAL;
+ }
+ 
++static void advk_msi_irq_mask(struct irq_data *d)
++{
++	struct advk_pcie *pcie = d->domain->host_data;
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	unsigned long flags;
++	u32 mask;
++
++	raw_spin_lock_irqsave(&pcie->msi_irq_lock, flags);
++	mask = advk_readl(pcie, PCIE_MSI_MASK_REG);
++	mask |= BIT(hwirq);
++	advk_writel(pcie, mask, PCIE_MSI_MASK_REG);
++	raw_spin_unlock_irqrestore(&pcie->msi_irq_lock, flags);
++}
++
++static void advk_msi_irq_unmask(struct irq_data *d)
++{
++	struct advk_pcie *pcie = d->domain->host_data;
++	irq_hw_number_t hwirq = irqd_to_hwirq(d);
++	unsigned long flags;
++	u32 mask;
++
++	raw_spin_lock_irqsave(&pcie->msi_irq_lock, flags);
++	mask = advk_readl(pcie, PCIE_MSI_MASK_REG);
++	mask &= ~BIT(hwirq);
++	advk_writel(pcie, mask, PCIE_MSI_MASK_REG);
++	raw_spin_unlock_irqrestore(&pcie->msi_irq_lock, flags);
++}
++
++static void advk_msi_top_irq_mask(struct irq_data *d)
++{
++	pci_msi_mask_irq(d);
++	irq_chip_mask_parent(d);
++}
++
++static void advk_msi_top_irq_unmask(struct irq_data *d)
++{
++	pci_msi_unmask_irq(d);
++	irq_chip_unmask_parent(d);
++}
++
+ static struct irq_chip advk_msi_bottom_irq_chip = {
+ 	.name			= "MSI",
+ 	.irq_compose_msi_msg	= advk_msi_irq_compose_msi_msg,
+ 	.irq_set_affinity	= advk_msi_set_affinity,
++	.irq_mask		= advk_msi_irq_mask,
++	.irq_unmask		= advk_msi_irq_unmask,
+ };
+ 
+ static int advk_msi_irq_domain_alloc(struct irq_domain *domain,
+@@ -1291,7 +1332,9 @@ static const struct irq_domain_ops advk_
+ };
+ 
+ static struct irq_chip advk_msi_irq_chip = {
+-	.name = "advk-MSI",
++	.name		= "advk-MSI",
++	.irq_mask	= advk_msi_top_irq_mask,
++	.irq_unmask	= advk_msi_top_irq_unmask,
+ };
+ 
+ static struct msi_domain_info advk_msi_domain_info = {
+@@ -1305,6 +1348,7 @@ static int advk_pcie_init_msi_irq_domain
+ 	struct device *dev = &pcie->pdev->dev;
+ 	phys_addr_t msi_msg_phys;
+ 
++	raw_spin_lock_init(&pcie->msi_irq_lock);
+ 	mutex_init(&pcie->msi_used_lock);
+ 
+ 	msi_msg_phys = virt_to_phys(&pcie->msi_msg);
diff -uprN a/target/linux/generic/pending-5.10/850-0011-PCI-aardvark-Fix-setting-MSI-address.patch b/target/linux/generic/pending-5.10/850-0011-PCI-aardvark-Fix-setting-MSI-address.patch
--- a/target/linux/generic/pending-5.10/850-0011-PCI-aardvark-Fix-setting-MSI-address.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0011-PCI-aardvark-Fix-setting-MSI-address.patch	2024-03-18 15:16:23.594641422 +0800
@@ -0,0 +1,91 @@
+From fa73c200f181436eab859374657c53a73778d8ad Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 26 Mar 2021 17:35:44 +0100
+Subject: [PATCH] PCI: aardvark: Fix setting MSI address
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+MSI address for receiving MSI interrupts needs to be correctly set before
+enabling processing of MSI interrupts.
+
+Move code for setting PCIE_MSI_ADDR_LOW_REG and PCIE_MSI_ADDR_HIGH_REG
+from advk_pcie_init_msi_irq_domain() to advk_pcie_setup_hw(), before
+enabling PCIE_CORE_CTRL2_MSI_ENABLE.
+
+After this we can remove the now unused member msi_msg, which was used
+only for MSI doorbell address. MSI address can be any address which cannot
+be used to DMA to. So change it to the address of the main struct advk_pcie.
+
+Fixes: 8c39d710363c ("PCI: aardvark: Add Aardvark PCI host controller driver")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Marc Zyngier <maz@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Cc: stable@vger.kernel.org # f21a8b1b6837 ("PCI: aardvark: Move to MSI handling using generic MSI support")
+---
+ drivers/pci/controller/pci-aardvark.c | 21 +++++++++------------
+ 1 file changed, 9 insertions(+), 12 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -284,7 +284,6 @@ struct advk_pcie {
+ 	raw_spinlock_t msi_irq_lock;
+ 	DECLARE_BITMAP(msi_used, MSI_IRQ_NUM);
+ 	struct mutex msi_used_lock;
+-	u16 msi_msg;
+ 	int link_gen;
+ 	struct pci_bridge_emul bridge;
+ 	struct gpio_desc *reset_gpio;
+@@ -479,6 +478,7 @@ static void advk_pcie_disable_ob_win(str
+ 
+ static void advk_pcie_setup_hw(struct advk_pcie *pcie)
+ {
++	phys_addr_t msi_addr;
+ 	u32 reg;
+ 	int i;
+ 
+@@ -567,6 +567,11 @@ static void advk_pcie_setup_hw(struct ad
+ 	reg |= LANE_COUNT_1;
+ 	advk_writel(pcie, reg, PCIE_CORE_CTRL0_REG);
+ 
++	/* Set MSI address */
++	msi_addr = virt_to_phys(pcie);
++	advk_writel(pcie, lower_32_bits(msi_addr), PCIE_MSI_ADDR_LOW_REG);
++	advk_writel(pcie, upper_32_bits(msi_addr), PCIE_MSI_ADDR_HIGH_REG);
++
+ 	/* Enable MSI */
+ 	reg = advk_readl(pcie, PCIE_CORE_CTRL2_REG);
+ 	reg |= PCIE_CORE_CTRL2_MSI_ENABLE;
+@@ -1184,10 +1189,10 @@ static void advk_msi_irq_compose_msi_msg
+ 					 struct msi_msg *msg)
+ {
+ 	struct advk_pcie *pcie = irq_data_get_irq_chip_data(data);
+-	phys_addr_t msi_msg = virt_to_phys(&pcie->msi_msg);
++	phys_addr_t msi_addr = virt_to_phys(pcie);
+ 
+-	msg->address_lo = lower_32_bits(msi_msg);
+-	msg->address_hi = upper_32_bits(msi_msg);
++	msg->address_lo = lower_32_bits(msi_addr);
++	msg->address_hi = upper_32_bits(msi_addr);
+ 	msg->data = data->hwirq;
+ }
+ 
+@@ -1346,18 +1351,10 @@ static struct msi_domain_info advk_msi_d
+ static int advk_pcie_init_msi_irq_domain(struct advk_pcie *pcie)
+ {
+ 	struct device *dev = &pcie->pdev->dev;
+-	phys_addr_t msi_msg_phys;
+ 
+ 	raw_spin_lock_init(&pcie->msi_irq_lock);
+ 	mutex_init(&pcie->msi_used_lock);
+ 
+-	msi_msg_phys = virt_to_phys(&pcie->msi_msg);
+-
+-	advk_writel(pcie, lower_32_bits(msi_msg_phys),
+-		    PCIE_MSI_ADDR_LOW_REG);
+-	advk_writel(pcie, upper_32_bits(msi_msg_phys),
+-		    PCIE_MSI_ADDR_HIGH_REG);
+-
+ 	pcie->msi_inner_domain =
+ 		irq_domain_add_linear(NULL, MSI_IRQ_NUM,
+ 				      &advk_msi_domain_ops, pcie);
diff -uprN a/target/linux/generic/pending-5.10/850-0012-PCI-aardvark-Enable-MSI-X-support.patch b/target/linux/generic/pending-5.10/850-0012-PCI-aardvark-Enable-MSI-X-support.patch
--- a/target/linux/generic/pending-5.10/850-0012-PCI-aardvark-Enable-MSI-X-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0012-PCI-aardvark-Enable-MSI-X-support.patch	2024-03-18 15:16:23.614640659 +0800
@@ -0,0 +1,38 @@
+From 735a4ac9782b96fbe1543c578aa8334364f21abd Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 2 Apr 2021 14:05:24 +0200
+Subject: [PATCH] PCI: aardvark: Enable MSI-X support
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+According to PCI 3.0 specification, sending both MSI and MSI-X interrupts
+is done by DWORD memory write operation to doorbell message address. The
+write operation for MSI has zero upper 16 bits and the MSI interrupt number
+in the lower 16 bits, while the write operation for MSI-X contains a 32-bit
+value from MSI-X table.
+
+Since the driver only uses interrupt numbers from range 0..31, the upper
+16 bits of the DWORD memory write operation to doorbell message address
+are zero even for MSI-X interrupts. Thus we can enable MSI-X interrupts.
+
+Testing proves that kernel can correctly receive MSI-X interrupts from PCIe
+cards which supports both MSI and MSI-X interrupts.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1344,7 +1344,7 @@ static struct irq_chip advk_msi_irq_chip
+ 
+ static struct msi_domain_info advk_msi_domain_info = {
+ 	.flags	= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+-		  MSI_FLAG_MULTI_PCI_MSI,
++		  MSI_FLAG_MULTI_PCI_MSI | MSI_FLAG_PCI_MSIX,
+ 	.chip	= &advk_msi_irq_chip,
+ };
+ 
diff -uprN a/target/linux/generic/pending-5.10/850-0013-PCI-aardvark-Add-support-for-ERR-interrupt-on-emulat.patch b/target/linux/generic/pending-5.10/850-0013-PCI-aardvark-Add-support-for-ERR-interrupt-on-emulat.patch
--- a/target/linux/generic/pending-5.10/850-0013-PCI-aardvark-Add-support-for-ERR-interrupt-on-emulat.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0013-PCI-aardvark-Add-support-for-ERR-interrupt-on-emulat.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,100 @@
+From 7f3e55a3890fa26d15e2e4e90213962d1a7f6df9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 12 Feb 2021 20:32:55 +0100
+Subject: [PATCH] PCI: aardvark: Add support for ERR interrupt on emulated
+ bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+ERR interrupt is triggered when corresponding bit is unmasked in both ISR0
+and PCI_EXP_DEVCTL registers. Unmasking ERR bits in PCI_EXP_DEVCTL register
+is not enough. This means that currently the ERR interrupt is never
+triggered.
+
+Unmask ERR bits in ISR0 register at driver probe time. ERR interrupt is not
+triggered until ERR bits are unmasked also in PCI_EXP_DEVCTL register,
+which is done by AER driver. So it is safe to unconditionally unmask all
+ERR bits in aardvark probe.
+
+Aardvark HW sets PCI_ERR_ROOT_AER_IRQ to zero and when corresponding bits
+in ISR0 and PCI_EXP_DEVCTL are enabled, the HW triggers a generic interrupt
+on GIC. Chain this interrupt to PCIe interrupt 0 with
+generic_handle_domain_irq() to allow processing of ERR interrupts.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 36 ++++++++++++++++++++++++++-
+ 1 file changed, 35 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -97,6 +97,10 @@
+ #define PCIE_MSG_PM_PME_MASK			BIT(7)
+ #define PCIE_ISR0_MASK_REG			(CONTROL_BASE_ADDR + 0x44)
+ #define     PCIE_ISR0_MSI_INT_PENDING		BIT(24)
++#define     PCIE_ISR0_CORR_ERR			BIT(11)
++#define     PCIE_ISR0_NFAT_ERR			BIT(12)
++#define     PCIE_ISR0_FAT_ERR			BIT(13)
++#define     PCIE_ISR0_ERR_MASK			GENMASK(13, 11)
+ #define     PCIE_ISR0_INTX_ASSERT(val)		BIT(16 + (val))
+ #define     PCIE_ISR0_INTX_DEASSERT(val)	BIT(20 + (val))
+ #define     PCIE_ISR0_ALL_MASK			GENMASK(31, 0)
+@@ -785,11 +789,15 @@ advk_pci_bridge_emul_base_conf_read(stru
+ 	case PCI_INTERRUPT_LINE: {
+ 		/*
+ 		 * From the whole 32bit register we support reading from HW only
+-		 * one bit: PCI_BRIDGE_CTL_BUS_RESET.
++		 * two bits: PCI_BRIDGE_CTL_BUS_RESET and PCI_BRIDGE_CTL_SERR.
+ 		 * Other bits are retrieved only from emulated config buffer.
+ 		 */
+ 		__le32 *cfgspace = (__le32 *)&bridge->conf;
+ 		u32 val = le32_to_cpu(cfgspace[PCI_INTERRUPT_LINE / 4]);
++		if (advk_readl(pcie, PCIE_ISR0_MASK_REG) & PCIE_ISR0_ERR_MASK)
++			val &= ~(PCI_BRIDGE_CTL_SERR << 16);
++		else
++			val |= PCI_BRIDGE_CTL_SERR << 16;
+ 		if (advk_readl(pcie, PCIE_CORE_CTRL1_REG) & HOT_RESET_GEN)
+ 			val |= PCI_BRIDGE_CTL_BUS_RESET << 16;
+ 		else
+@@ -815,6 +823,19 @@ advk_pci_bridge_emul_base_conf_write(str
+ 		break;
+ 
+ 	case PCI_INTERRUPT_LINE:
++		/*
++		 * According to Figure 6-3: Pseudo Logic Diagram for Error
++		 * Message Controls in PCIe base specification, SERR# Enable bit
++		 * in Bridge Control register enable receiving of ERR_* messages
++		 */
++		if (mask & (PCI_BRIDGE_CTL_SERR << 16)) {
++			u32 val = advk_readl(pcie, PCIE_ISR0_MASK_REG);
++			if (new & (PCI_BRIDGE_CTL_SERR << 16))
++				val &= ~PCIE_ISR0_ERR_MASK;
++			else
++				val |= PCIE_ISR0_ERR_MASK;
++			advk_writel(pcie, val, PCIE_ISR0_MASK_REG);
++		}
+ 		if (mask & (PCI_BRIDGE_CTL_BUS_RESET << 16)) {
+ 			u32 val = advk_readl(pcie, PCIE_CORE_CTRL1_REG);
+ 			if (new & (PCI_BRIDGE_CTL_BUS_RESET << 16))
+@@ -1466,6 +1487,19 @@ static void advk_pcie_handle_int(struct
+ 	isr1_mask = advk_readl(pcie, PCIE_ISR1_MASK_REG);
+ 	isr1_status = isr1_val & ((~isr1_mask) & PCIE_ISR1_ALL_MASK);
+ 
++	/* Process ERR interrupt */
++	if (isr0_status & PCIE_ISR0_ERR_MASK) {
++		advk_writel(pcie, PCIE_ISR0_ERR_MASK, PCIE_ISR0_REG);
++
++		/*
++		 * Aardvark HW returns zero for PCI_ERR_ROOT_AER_IRQ, so use
++		 * PCIe interrupt 0
++		 */
++		virq = irq_find_mapping(pcie->irq_domain, 0);
++		if (generic_handle_irq(virq) == -EINVAL)
++			dev_err_ratelimited(&pcie->pdev->dev, "unhandled ERR IRQ\n");
++	}
++
+ 	/* Process MSI interrupts */
+ 	if (isr0_status & PCIE_ISR0_MSI_INT_PENDING)
+ 		advk_pcie_handle_msi(pcie);
diff -uprN a/target/linux/generic/pending-5.10/850-0014-PCI-aardvark-Fix-reading-PCI_EXP_RTSTA_PME-bit-on-em.patch b/target/linux/generic/pending-5.10/850-0014-PCI-aardvark-Fix-reading-PCI_EXP_RTSTA_PME-bit-on-em.patch
--- a/target/linux/generic/pending-5.10/850-0014-PCI-aardvark-Fix-reading-PCI_EXP_RTSTA_PME-bit-on-em.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0014-PCI-aardvark-Fix-reading-PCI_EXP_RTSTA_PME-bit-on-em.patch	2024-03-18 15:16:23.602641117 +0800
@@ -0,0 +1,44 @@
+From 5f354992eeef9a51c67796dc9f7f578d3584baa2 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 8 Dec 2021 05:57:54 +0100
+Subject: [PATCH] PCI: aardvark: Fix reading PCI_EXP_RTSTA_PME bit on emulated
+ bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The emulated bridge returns incorrect value for PCI_EXP_RTSTA register
+during readout in advk_pci_bridge_emul_pcie_conf_read() function: the
+correct bit is BIT(16), but we are setting BIT(23), because the code
+does
+  *value = (isr0 & PCIE_MSG_PM_PME_MASK) << 16
+where
+  PCIE_MSG_PM_PME_MASK
+is
+  BIT(7).
+
+The code should probably have been something like
+  *value = (!!(isr0 & PCIE_MSG_PM_PME_MASK)) << 16,
+but we are better of using an if() and using the proper macro for this
+bit.
+
+Fixes: 8a3ebd8de328 ("PCI: aardvark: Implement emulated root PCI bridge config space")
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -874,7 +874,9 @@ advk_pci_bridge_emul_pcie_conf_read(stru
+ 	case PCI_EXP_RTSTA: {
+ 		u32 isr0 = advk_readl(pcie, PCIE_ISR0_REG);
+ 		u32 msglog = advk_readl(pcie, PCIE_MSG_LOG_REG);
+-		*value = (isr0 & PCIE_MSG_PM_PME_MASK) << 16 | (msglog >> 16);
++		*value = msglog >> 16;
++		if (isr0 & PCIE_MSG_PM_PME_MASK)
++			*value |= PCI_EXP_RTSTA_PME;
+ 		return PCI_BRIDGE_EMUL_HANDLED;
+ 	}
+ 
diff -uprN a/target/linux/generic/pending-5.10/850-0015-PCI-aardvark-Optimize-writing-PCI_EXP_RTCTL_PMEIE-an.patch b/target/linux/generic/pending-5.10/850-0015-PCI-aardvark-Optimize-writing-PCI_EXP_RTCTL_PMEIE-an.patch
--- a/target/linux/generic/pending-5.10/850-0015-PCI-aardvark-Optimize-writing-PCI_EXP_RTCTL_PMEIE-an.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0015-PCI-aardvark-Optimize-writing-PCI_EXP_RTCTL_PMEIE-an.patch	2024-03-18 15:16:23.606640964 +0800
@@ -0,0 +1,52 @@
+From 3fe0073d116d9902df08761c1cf0d733dd4c38fc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 8 Dec 2021 06:03:50 +0100
+Subject: [PATCH] PCI: aardvark: Optimize writing PCI_EXP_RTCTL_PMEIE and
+ PCI_EXP_RTSTA_PME on emulated bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+To optimize advk_pci_bridge_emul_pcie_conf_write() code, touch
+PCIE_ISR0_REG and PCIE_ISR0_MASK_REG registers only when it is really
+needed, when processing PCI_EXP_RTCTL_PMEIE and PCI_EXP_RTSTA_PME bits.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 20 +++++++++++---------
+ 1 file changed, 11 insertions(+), 9 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -932,19 +932,21 @@ advk_pci_bridge_emul_pcie_conf_write(str
+ 			advk_pcie_wait_for_retrain(pcie);
+ 		break;
+ 
+-	case PCI_EXP_RTCTL: {
++	case PCI_EXP_RTCTL:
+ 		/* Only mask/unmask PME interrupt */
+-		u32 val = advk_readl(pcie, PCIE_ISR0_MASK_REG) &
+-			~PCIE_MSG_PM_PME_MASK;
+-		if ((new & PCI_EXP_RTCTL_PMEIE) == 0)
+-			val |= PCIE_MSG_PM_PME_MASK;
+-		advk_writel(pcie, val, PCIE_ISR0_MASK_REG);
++		if (mask & PCI_EXP_RTCTL_PMEIE) {
++			u32 val = advk_readl(pcie, PCIE_ISR0_MASK_REG);
++			if (new & PCI_EXP_RTCTL_PMEIE)
++				val &= ~PCIE_MSG_PM_PME_MASK;
++			else
++				val |= PCIE_MSG_PM_PME_MASK;
++			advk_writel(pcie, val, PCIE_ISR0_MASK_REG);
++		}
+ 		break;
+-	}
+ 
+ 	case PCI_EXP_RTSTA:
+-		new = (new & PCI_EXP_RTSTA_PME) >> 9;
+-		advk_writel(pcie, new, PCIE_ISR0_REG);
++		if (new & PCI_EXP_RTSTA_PME)
++			advk_writel(pcie, PCIE_MSG_PM_PME_MASK, PCIE_ISR0_REG);
+ 		break;
+ 
+ 	case PCI_EXP_DEVCTL:
diff -uprN a/target/linux/generic/pending-5.10/850-0016-PCI-aardvark-Add-support-for-PME-interrupts.patch b/target/linux/generic/pending-5.10/850-0016-PCI-aardvark-Add-support-for-PME-interrupts.patch
--- a/target/linux/generic/pending-5.10/850-0016-PCI-aardvark-Add-support-for-PME-interrupts.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0016-PCI-aardvark-Add-support-for-PME-interrupts.patch	2024-03-18 15:16:23.594641422 +0800
@@ -0,0 +1,47 @@
+From 7acd8ef92e8789e10b5d736d73cea3b625087f26 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Wed, 8 Dec 2021 06:07:44 +0100
+Subject: [PATCH] PCI: aardvark: Add support for PME interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Currently enabling PCI_EXP_RTSTA_PME bit in PCI_EXP_RTCTL register does
+nothing. This is because PCIe PME driver expects to receive PCIe interrupt
+defined in PCI_EXP_FLAGS_IRQ register, but aardvark hardware does not
+trigger PCIe INTx/MSI interrupt for PME event, rather it triggers custom
+aardvark interrupt which this driver is not processing yet.
+
+Fix this issue by handling PME interrupt in advk_pcie_handle_int() and
+chaining it to PCIe interrupt 0 with generic_handle_domain_irq() (since
+aardvark sets PCI_EXP_FLAGS_IRQ to zero). With this change PCIe PME driver
+finally starts receiving PME interrupt.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 13 +++++++++++++
+ 1 file changed, 13 insertions(+)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1491,6 +1491,19 @@ static void advk_pcie_handle_int(struct
+ 	isr1_mask = advk_readl(pcie, PCIE_ISR1_MASK_REG);
+ 	isr1_status = isr1_val & ((~isr1_mask) & PCIE_ISR1_ALL_MASK);
+ 
++	/* Process PME interrupt */
++	if (isr0_status & PCIE_MSG_PM_PME_MASK) {
++		/*
++		 * Do not clear PME interrupt bit in ISR0, it is cleared by IRQ
++		 * receiver by writing to the PCI_EXP_RTSTA register of emulated
++		 * root bridge. Aardvark HW returns zero for PCI_EXP_FLAGS_IRQ,
++		 * so use PCIe interrupt 0.
++		 */
++		virq = irq_find_mapping(pcie->irq_domain, 0);
++		if (generic_handle_irq(virq) == -EINVAL)
++			dev_err_ratelimited(&pcie->pdev->dev, "unhandled PME IRQ\n");
++	}
++
+ 	/* Process ERR interrupt */
+ 	if (isr0_status & PCIE_ISR0_ERR_MASK) {
+ 		advk_writel(pcie, PCIE_ISR0_ERR_MASK, PCIE_ISR0_REG);
diff -uprN a/target/linux/generic/pending-5.10/850-0017-PCI-aardvark-Fix-support-for-PME-requester-on-emulat.patch b/target/linux/generic/pending-5.10/850-0017-PCI-aardvark-Fix-support-for-PME-requester-on-emulat.patch
--- a/target/linux/generic/pending-5.10/850-0017-PCI-aardvark-Fix-support-for-PME-requester-on-emulat.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0017-PCI-aardvark-Fix-support-for-PME-requester-on-emulat.patch	2024-03-18 15:16:23.614640659 +0800
@@ -0,0 +1,173 @@
+From 68727b545332327b4c2f9c0f8d006be8970e7832 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 19 Feb 2021 14:22:22 +0100
+Subject: [PATCH] PCI: aardvark: Fix support for PME requester on emulated
+ bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Enable aardvark PME interrupt unconditionally by unmasking it and read PME
+requester ID to emulated bridge config space immediately after receiving
+interrupt.
+
+PME requester ID is stored in the PCIE_MSG_LOG_REG register, which contains
+the last inbound message. So when new inbound message is received by HW
+(including non-PM), the content in PCIE_MSG_LOG_REG register is replaced by
+a new value.
+
+PCIe specification mandates that subsequent PMEs are kept pending until the
+PME Status Register bit is cleared by software by writing a 1b.
+
+Support for masking/unmasking PME interrupt on emulated bridge via
+PCI_EXP_RTCTL_PMEIE bit is now implemented only in emulated bridge config
+space, to ensure that we do not miss any aardvark PME interrupt.
+
+Reading of PCI_EXP_RTCAP and PCI_EXP_RTSTA registers is simplified as final
+value is now always stored into emulated bridge config space by the
+interrupt handler, so there is no need to implement support for these
+registers in read_pcie callback.
+
+Clearing of W1C bit PCI_EXP_RTSTA_PME is now also simplified as it is done
+by pci-bridge-emul.c code for emulated bridge config space. So there is no
+need to implement support for clearing this bit in write_pcie callback.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 94 +++++++++++++++------------
+ 1 file changed, 52 insertions(+), 42 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -597,6 +597,11 @@ static void advk_pcie_setup_hw(struct ad
+ 	reg &= ~PCIE_ISR0_MSI_INT_PENDING;
+ 	advk_writel(pcie, reg, PCIE_ISR0_MASK_REG);
+ 
++	/* Unmask PME interrupt for processing of PME requester */
++	reg = advk_readl(pcie, PCIE_ISR0_MASK_REG);
++	reg &= ~PCIE_MSG_PM_PME_MASK;
++	advk_writel(pcie, reg, PCIE_ISR0_MASK_REG);
++
+ 	/* Enable summary interrupt for GIC SPI source */
+ 	reg = PCIE_IRQ_ALL_MASK & (~PCIE_IRQ_ENABLE_INTS_MASK);
+ 	advk_writel(pcie, reg, HOST_CTRL_INT_MASK_REG);
+@@ -863,22 +868,11 @@ advk_pci_bridge_emul_pcie_conf_read(stru
+ 		*value = PCI_EXP_SLTSTA_PDS << 16;
+ 		return PCI_BRIDGE_EMUL_HANDLED;
+ 
+-	case PCI_EXP_RTCTL: {
+-		u32 val = advk_readl(pcie, PCIE_ISR0_MASK_REG);
+-		*value = (val & PCIE_MSG_PM_PME_MASK) ? 0 : PCI_EXP_RTCTL_PMEIE;
+-		*value |= le16_to_cpu(bridge->pcie_conf.rootctl) & PCI_EXP_RTCTL_CRSSVE;
+-		*value |= PCI_EXP_RTCAP_CRSVIS << 16;
+-		return PCI_BRIDGE_EMUL_HANDLED;
+-	}
+-
+-	case PCI_EXP_RTSTA: {
+-		u32 isr0 = advk_readl(pcie, PCIE_ISR0_REG);
+-		u32 msglog = advk_readl(pcie, PCIE_MSG_LOG_REG);
+-		*value = msglog >> 16;
+-		if (isr0 & PCIE_MSG_PM_PME_MASK)
+-			*value |= PCI_EXP_RTSTA_PME;
+-		return PCI_BRIDGE_EMUL_HANDLED;
+-	}
++	/*
++	 * PCI_EXP_RTCTL and PCI_EXP_RTSTA are also supported, but do not need
++	 * to be handled here, because their values are stored in emulated
++	 * config space buffer, and we read them from there when needed.
++	 */
+ 
+ 	case PCI_EXP_LNKCAP: {
+ 		u32 val = advk_readl(pcie, PCIE_CORE_PCIEXP_CAP + reg);
+@@ -932,22 +926,19 @@ advk_pci_bridge_emul_pcie_conf_write(str
+ 			advk_pcie_wait_for_retrain(pcie);
+ 		break;
+ 
+-	case PCI_EXP_RTCTL:
+-		/* Only mask/unmask PME interrupt */
+-		if (mask & PCI_EXP_RTCTL_PMEIE) {
+-			u32 val = advk_readl(pcie, PCIE_ISR0_MASK_REG);
+-			if (new & PCI_EXP_RTCTL_PMEIE)
+-				val &= ~PCIE_MSG_PM_PME_MASK;
+-			else
+-				val |= PCIE_MSG_PM_PME_MASK;
+-			advk_writel(pcie, val, PCIE_ISR0_MASK_REG);
+-		}
++	case PCI_EXP_RTCTL: {
++		u16 rootctl = le16_to_cpu(bridge->pcie_conf.rootctl);
++		/* Only emulation of PMEIE and CRSSVE bits is provided */
++		rootctl &= PCI_EXP_RTCTL_PMEIE | PCI_EXP_RTCTL_CRSSVE;
++		bridge->pcie_conf.rootctl = cpu_to_le16(rootctl);
+ 		break;
++	}
+ 
+-	case PCI_EXP_RTSTA:
+-		if (new & PCI_EXP_RTSTA_PME)
+-			advk_writel(pcie, PCIE_MSG_PM_PME_MASK, PCIE_ISR0_REG);
+-		break;
++	/*
++	 * PCI_EXP_RTSTA is also supported, but does not need to be handled
++	 * here, because its value is stored in emulated config space buffer,
++	 * and we write it there when needed.
++	 */
+ 
+ 	case PCI_EXP_DEVCTL:
+ 	case PCI_EXP_DEVCTL2:
+@@ -1452,6 +1443,34 @@ static void advk_pcie_remove_irq_domain(
+ 	irq_domain_remove(pcie->irq_domain);
+ }
+ 
++static void advk_pcie_handle_pme(struct advk_pcie *pcie)
++{
++	u32 requester = advk_readl(pcie, PCIE_MSG_LOG_REG) >> 16;
++	int virq;
++
++	advk_writel(pcie, PCIE_MSG_PM_PME_MASK, PCIE_ISR0_REG);
++
++	/*
++	 * PCIE_MSG_LOG_REG contains the last inbound message, so store
++	 * the requester ID only when PME was not asserted yet.
++	 * Also do not trigger PME interrupt when PME is still asserted.
++	 */
++	if (!(le32_to_cpu(pcie->bridge.pcie_conf.rootsta) & PCI_EXP_RTSTA_PME)) {
++		pcie->bridge.pcie_conf.rootsta = cpu_to_le32(requester | PCI_EXP_RTSTA_PME);
++
++		/*
++		 * Trigger PME interrupt only if PMEIE bit in Root Control is set.
++		 * Aardvark HW returns zero for PCI_EXP_FLAGS_IRQ, so use PCIe interrupt 0.
++		 */
++		if (!(le16_to_cpu(pcie->bridge.pcie_conf.rootctl) & PCI_EXP_RTCTL_PMEIE))
++			return;
++
++		virq = irq_find_mapping(pcie->irq_domain, 0);
++		if (generic_handle_irq(virq) == -EINVAL)
++			dev_err_ratelimited(&pcie->pdev->dev, "unhandled PME IRQ\n");
++	}
++}
++
+ static void advk_pcie_handle_msi(struct advk_pcie *pcie)
+ {
+ 	u32 msi_val, msi_mask, msi_status, msi_idx;
+@@ -1491,18 +1510,9 @@ static void advk_pcie_handle_int(struct
+ 	isr1_mask = advk_readl(pcie, PCIE_ISR1_MASK_REG);
+ 	isr1_status = isr1_val & ((~isr1_mask) & PCIE_ISR1_ALL_MASK);
+ 
+-	/* Process PME interrupt */
+-	if (isr0_status & PCIE_MSG_PM_PME_MASK) {
+-		/*
+-		 * Do not clear PME interrupt bit in ISR0, it is cleared by IRQ
+-		 * receiver by writing to the PCI_EXP_RTSTA register of emulated
+-		 * root bridge. Aardvark HW returns zero for PCI_EXP_FLAGS_IRQ,
+-		 * so use PCIe interrupt 0.
+-		 */
+-		virq = irq_find_mapping(pcie->irq_domain, 0);
+-		if (generic_handle_irq(virq) == -EINVAL)
+-			dev_err_ratelimited(&pcie->pdev->dev, "unhandled PME IRQ\n");
+-	}
++	/* Process PME interrupt as the first one to do not miss PME requester id */
++	if (isr0_status & PCIE_MSG_PM_PME_MASK)
++		advk_pcie_handle_pme(pcie);
+ 
+ 	/* Process ERR interrupt */
+ 	if (isr0_status & PCIE_ISR0_ERR_MASK) {
diff -uprN a/target/linux/generic/pending-5.10/850-0018-PCI-aardvark-Use-separate-INTA-interrupt-for-emulate.patch b/target/linux/generic/pending-5.10/850-0018-PCI-aardvark-Use-separate-INTA-interrupt-for-emulate.patch
--- a/target/linux/generic/pending-5.10/850-0018-PCI-aardvark-Use-separate-INTA-interrupt-for-emulate.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0018-PCI-aardvark-Use-separate-INTA-interrupt-for-emulate.patch	2024-03-18 15:16:23.610640811 +0800
@@ -0,0 +1,161 @@
+From db305233136f5aa2444a8287a279384e8458c458 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 1 Apr 2021 20:12:48 +0200
+Subject: [PATCH] PCI: aardvark: Use separate INTA interrupt for emulated root
+ bridge
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Emulated root bridge currently provides only one Legacy INTA interrupt
+which is used for reporting PCIe PME and ERR events and handled by kernel
+PCIe PME and AER drivers.
+
+Aardvark HW reports these PME and ERR events separately, so there is no
+need to mix real INTA interrupt and emulated INTA interrupt for PCIe PME
+and AER drivers.
+
+Register a new advk-RP (as in Root Port) irq chip and a new irq domain
+for emulated root bridge and use this new separate irq domain for
+providing INTA interrupt from emulated root bridge for PME and ERR events.
+
+The real INTA interrupt from real devices is now separate.
+
+A custom map_irq callback function on PCI host bridge structure is used to
+allocate IRQ mapping for emulated root bridge from new irq domain. Original
+callback of_irq_parse_and_map_pci() is used for all other devices as before.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 69 ++++++++++++++++++++++++++-
+ 1 file changed, 67 insertions(+), 2 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -280,6 +280,7 @@ struct advk_pcie {
+ 	} wins[OB_WIN_COUNT];
+ 	u8 wins_count;
+ 	int irq;
++	struct irq_domain *rp_irq_domain;
+ 	struct irq_domain *irq_domain;
+ 	struct irq_chip irq_chip;
+ 	raw_spinlock_t irq_lock;
+@@ -1443,6 +1444,44 @@ static void advk_pcie_remove_irq_domain(
+ 	irq_domain_remove(pcie->irq_domain);
+ }
+ 
++static struct irq_chip advk_rp_irq_chip = {
++	.name = "advk-RP",
++};
++
++static int advk_pcie_rp_irq_map(struct irq_domain *h,
++				unsigned int virq, irq_hw_number_t hwirq)
++{
++	struct advk_pcie *pcie = h->host_data;
++
++	irq_set_chip_and_handler(virq, &advk_rp_irq_chip, handle_simple_irq);
++	irq_set_chip_data(virq, pcie);
++
++	return 0;
++}
++
++static const struct irq_domain_ops advk_pcie_rp_irq_domain_ops = {
++	.map = advk_pcie_rp_irq_map,
++	.xlate = irq_domain_xlate_onecell,
++};
++
++static int advk_pcie_init_rp_irq_domain(struct advk_pcie *pcie)
++{
++	pcie->rp_irq_domain = irq_domain_add_linear(NULL, 1,
++						    &advk_pcie_rp_irq_domain_ops,
++						    pcie);
++	if (!pcie->rp_irq_domain) {
++		dev_err(&pcie->pdev->dev, "Failed to add Root Port IRQ domain\n");
++		return -ENOMEM;
++	}
++
++	return 0;
++}
++
++static void advk_pcie_remove_rp_irq_domain(struct advk_pcie *pcie)
++{
++	irq_domain_remove(pcie->rp_irq_domain);
++}
++
+ static void advk_pcie_handle_pme(struct advk_pcie *pcie)
+ {
+ 	u32 requester = advk_readl(pcie, PCIE_MSG_LOG_REG) >> 16;
+@@ -1465,7 +1504,7 @@ static void advk_pcie_handle_pme(struct
+ 		if (!(le16_to_cpu(pcie->bridge.pcie_conf.rootctl) & PCI_EXP_RTCTL_PMEIE))
+ 			return;
+ 
+-		virq = irq_find_mapping(pcie->irq_domain, 0);
++		virq = irq_find_mapping(pcie->rp_irq_domain, 0);
+ 		if (generic_handle_irq(virq) == -EINVAL)
+ 			dev_err_ratelimited(&pcie->pdev->dev, "unhandled PME IRQ\n");
+ 	}
+@@ -1522,7 +1561,7 @@ static void advk_pcie_handle_int(struct
+ 		 * Aardvark HW returns zero for PCI_ERR_ROOT_AER_IRQ, so use
+ 		 * PCIe interrupt 0
+ 		 */
+-		virq = irq_find_mapping(pcie->irq_domain, 0);
++		virq = irq_find_mapping(pcie->rp_irq_domain, 0);
+ 		if (generic_handle_irq(virq) == -EINVAL)
+ 			dev_err_ratelimited(&pcie->pdev->dev, "unhandled ERR IRQ\n");
+ 	}
+@@ -1568,6 +1607,21 @@ static void advk_pcie_irq_handler(struct
+ 	chained_irq_exit(chip, desc);
+ }
+ 
++static int advk_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
++{
++	struct advk_pcie *pcie = dev->bus->sysdata;
++
++	/*
++	 * Emulated root bridge has its own emulated irq chip and irq domain.
++	 * Argument pin is the INTx pin (1=INTA, 2=INTB, 3=INTC, 4=INTD) and
++	 * hwirq for irq_create_mapping() is indexed from zero.
++	 */
++	if (pci_is_root_bus(dev->bus))
++		return irq_create_mapping(pcie->rp_irq_domain, pin - 1);
++	else
++		return of_irq_parse_and_map_pci(dev, slot, pin);
++}
++
+ static void __maybe_unused advk_pcie_disable_phy(struct advk_pcie *pcie)
+ {
+ 	phy_power_off(pcie->phy);
+@@ -1771,14 +1825,24 @@ static int advk_pcie_probe(struct platfo
+ 		return ret;
+ 	}
+ 
++	ret = advk_pcie_init_rp_irq_domain(pcie);
++	if (ret) {
++		dev_err(dev, "Failed to initialize irq\n");
++		advk_pcie_remove_msi_irq_domain(pcie);
++		advk_pcie_remove_irq_domain(pcie);
++		return ret;
++	}
++
+ 	irq_set_chained_handler_and_data(pcie->irq, advk_pcie_irq_handler, pcie);
+ 
+ 	bridge->sysdata = pcie;
+ 	bridge->ops = &advk_pcie_ops;
++	bridge->map_irq = advk_pcie_map_irq;
+ 
+ 	ret = pci_host_probe(bridge);
+ 	if (ret < 0) {
+ 		irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
++		advk_pcie_remove_rp_irq_domain(pcie);
+ 		advk_pcie_remove_msi_irq_domain(pcie);
+ 		advk_pcie_remove_irq_domain(pcie);
+ 		return ret;
+@@ -1830,6 +1894,7 @@ static int advk_pcie_remove(struct platf
+ 	irq_set_chained_handler_and_data(pcie->irq, NULL, NULL);
+ 
+ 	/* Remove IRQ domains */
++	advk_pcie_remove_rp_irq_domain(pcie);
+ 	advk_pcie_remove_msi_irq_domain(pcie);
+ 	advk_pcie_remove_irq_domain(pcie);
+ 
diff -uprN a/target/linux/generic/pending-5.10/850-0019-PCI-aardvark-Remove-irq_mask_ack-callback-for-INTx-i.patch b/target/linux/generic/pending-5.10/850-0019-PCI-aardvark-Remove-irq_mask_ack-callback-for-INTx-i.patch
--- a/target/linux/generic/pending-5.10/850-0019-PCI-aardvark-Remove-irq_mask_ack-callback-for-INTx-i.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0019-PCI-aardvark-Remove-irq_mask_ack-callback-for-INTx-i.patch	2024-03-18 15:16:23.598641269 +0800
@@ -0,0 +1,29 @@
+From 8c9eef96e24f34ff8b62b230700416b822691a37 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 1 Apr 2021 14:24:12 +0200
+Subject: [PATCH] PCI: aardvark: Remove irq_mask_ack callback for INTx
+ interrupts
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Callback for irq_mask_ack is the same as for irq_mask. As there is no
+special handling for irq_ack, there is no need to define irq_mask_ack too.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Marc Zyngier <maz@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1422,7 +1422,6 @@ static int advk_pcie_init_irq_domain(str
+ 	}
+ 
+ 	irq_chip->irq_mask = advk_pcie_irq_mask;
+-	irq_chip->irq_mask_ack = advk_pcie_irq_mask;
+ 	irq_chip->irq_unmask = advk_pcie_irq_unmask;
+ 
+ 	pcie->irq_domain =
diff -uprN a/target/linux/generic/pending-5.10/850-0020-PCI-aardvark-Don-t-mask-irq-when-mapping.patch b/target/linux/generic/pending-5.10/850-0020-PCI-aardvark-Don-t-mask-irq-when-mapping.patch
--- a/target/linux/generic/pending-5.10/850-0020-PCI-aardvark-Don-t-mask-irq-when-mapping.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0020-PCI-aardvark-Don-t-mask-irq-when-mapping.patch	2024-03-18 15:16:23.634639895 +0800
@@ -0,0 +1,27 @@
+From dc01fca5a9d9c09ce9a3fb2bc2e7715c37ff3bd9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 1 Apr 2021 14:30:06 +0200
+Subject: [PATCH] PCI: aardvark: Don't mask irq when mapping
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+By default, all Legacy INTx interrupts are masked, so there is no need to
+mask this interrupt during irq_map callback.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1339,7 +1339,6 @@ static int advk_pcie_irq_map(struct irq_
+ {
+ 	struct advk_pcie *pcie = h->host_data;
+ 
+-	advk_pcie_irq_mask(irq_get_irq_data(virq));
+ 	irq_set_status_flags(virq, IRQ_LEVEL);
+ 	irq_set_chip_and_handler(virq, &pcie->irq_chip,
+ 				 handle_level_irq);
diff -uprN a/target/linux/generic/pending-5.10/850-0021-PCI-aardvark-Drop-__maybe_unused-from-advk_pcie_disa.patch b/target/linux/generic/pending-5.10/850-0021-PCI-aardvark-Drop-__maybe_unused-from-advk_pcie_disa.patch
--- a/target/linux/generic/pending-5.10/850-0021-PCI-aardvark-Drop-__maybe_unused-from-advk_pcie_disa.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0021-PCI-aardvark-Drop-__maybe_unused-from-advk_pcie_disa.patch	2024-03-18 15:16:23.618640505 +0800
@@ -0,0 +1,28 @@
+From a511c99262ce19ee06908d27212b39ec4c5aeb17 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Wed, 8 Dec 2021 04:40:29 +0100
+Subject: [PATCH] PCI: aardvark: Drop __maybe_unused from
+ advk_pcie_disable_phy()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This function is now always used in driver remove method, drop the
+__maybe_unused attribute.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1620,7 +1620,7 @@ static int advk_pcie_map_irq(const struc
+ 		return of_irq_parse_and_map_pci(dev, slot, pin);
+ }
+ 
+-static void __maybe_unused advk_pcie_disable_phy(struct advk_pcie *pcie)
++static void advk_pcie_disable_phy(struct advk_pcie *pcie)
+ {
+ 	phy_power_off(pcie->phy);
+ 	phy_exit(pcie->phy);
diff -uprN a/target/linux/generic/pending-5.10/850-0022-PCI-aardvark-Update-comment-about-link-going-down-af.patch b/target/linux/generic/pending-5.10/850-0022-PCI-aardvark-Update-comment-about-link-going-down-af.patch
--- a/target/linux/generic/pending-5.10/850-0022-PCI-aardvark-Update-comment-about-link-going-down-af.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0022-PCI-aardvark-Update-comment-about-link-going-down-af.patch	2024-03-18 15:16:23.614640659 +0800
@@ -0,0 +1,35 @@
+From bafda858364003a70b9cda84282f9761587f8033 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 10 Jan 2022 00:47:38 +0100
+Subject: [PATCH] PCI: aardvark: Update comment about link going down after
+ link-up
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Update the comment about what happens when link goes down after we have
+checked for link-up. If a PIO request is done while link-down, we have
+a serious problem.
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 8 ++++++--
+ 1 file changed, 6 insertions(+), 2 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1005,8 +1005,12 @@ static bool advk_pcie_valid_device(struc
+ 		return false;
+ 
+ 	/*
+-	 * If the link goes down after we check for link-up, nothing bad
+-	 * happens but the config access times out.
++	 * If the link goes down after we check for link-up, we have a problem:
++	 * if a PIO request is executed while link-down, the whole controller
++	 * gets stuck in a non-functional state, and even after link comes up
++	 * again, PIO requests won't work anymore, and a reset of the whole PCIe
++	 * controller is needed. Therefore we need to prevent sending PIO
++	 * requests while the link is down.
+ 	 */
+ 	if (!pci_is_root_bus(bus) && !advk_pcie_link_up(pcie))
+ 		return false;
diff -uprN a/target/linux/generic/pending-5.10/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch b/target/linux/generic/pending-5.10/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch
--- a/target/linux/generic/pending-5.10/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/850-0023-PCI-aardvark-Make-main-irq_chip-structure-a-static-d.patch	2024-03-18 15:16:23.594641422 +0800
@@ -0,0 +1,102 @@
+From 663b9f99bb35dbc0c7b685f71ee3668a60d31320 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <kabel@kernel.org>
+Date: Mon, 10 Jan 2022 02:02:00 +0100
+Subject: [PATCH] PCI: aardvark: Make main irq_chip structure a static driver
+ structure
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Marc Zyngier says [1] that we should use struct irq_chip as a global
+static struct in the driver. Even though the structure currently
+contains a dynamic member (parent_device), Marc says [2] that he plans
+to kill it and make the structure completely static.
+
+We have already converted others irq_chip structures in this driver in
+this way, but we omitted this one because the .name member is
+dynamically created from device's name, and the name is displayed in
+sysfs, so changing it would break sysfs ABI.
+
+The rationale for changing the name (to "advk-INT") in spite of sysfs
+ABI, and thus allowing to convert to a static structure, is that after
+the other changes we made in this series, the IRQ chip is basically
+something different: it no logner generates ERR and PME interrupts (they
+are generated by emulated bridge's rp_irq_chip).
+
+[1] https://lore.kernel.org/linux-pci/877dbcvngf.wl-maz@kernel.org/
+[2] https://lore.kernel.org/linux-pci/874k6gvkhz.wl-maz@kernel.org/
+
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/pci/controller/pci-aardvark.c | 25 +++++++------------------
+ 1 file changed, 7 insertions(+), 18 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -282,7 +282,6 @@ struct advk_pcie {
+ 	int irq;
+ 	struct irq_domain *rp_irq_domain;
+ 	struct irq_domain *irq_domain;
+-	struct irq_chip irq_chip;
+ 	raw_spinlock_t irq_lock;
+ 	struct irq_domain *msi_domain;
+ 	struct irq_domain *msi_inner_domain;
+@@ -1338,14 +1337,19 @@ static void advk_pcie_irq_unmask(struct
+ 	raw_spin_unlock_irqrestore(&pcie->irq_lock, flags);
+ }
+ 
++static struct irq_chip advk_irq_chip = {
++	.name		= "advk-INT",
++	.irq_mask	= advk_pcie_irq_mask,
++	.irq_unmask	= advk_pcie_irq_unmask,
++};
++
+ static int advk_pcie_irq_map(struct irq_domain *h,
+ 			     unsigned int virq, irq_hw_number_t hwirq)
+ {
+ 	struct advk_pcie *pcie = h->host_data;
+ 
+ 	irq_set_status_flags(virq, IRQ_LEVEL);
+-	irq_set_chip_and_handler(virq, &pcie->irq_chip,
+-				 handle_level_irq);
++	irq_set_chip_and_handler(virq, &advk_irq_chip, handle_level_irq);
+ 	irq_set_chip_data(virq, pcie);
+ 
+ 	return 0;
+@@ -1404,7 +1408,6 @@ static int advk_pcie_init_irq_domain(str
+ 	struct device *dev = &pcie->pdev->dev;
+ 	struct device_node *node = dev->of_node;
+ 	struct device_node *pcie_intc_node;
+-	struct irq_chip *irq_chip;
+ 	int ret = 0;
+ 
+ 	raw_spin_lock_init(&pcie->irq_lock);
+@@ -1415,28 +1418,14 @@ static int advk_pcie_init_irq_domain(str
+ 		return -ENODEV;
+ 	}
+ 
+-	irq_chip = &pcie->irq_chip;
+-
+-	irq_chip->name = devm_kasprintf(dev, GFP_KERNEL, "%s-irq",
+-					dev_name(dev));
+-	if (!irq_chip->name) {
+-		ret = -ENOMEM;
+-		goto out_put_node;
+-	}
+-
+-	irq_chip->irq_mask = advk_pcie_irq_mask;
+-	irq_chip->irq_unmask = advk_pcie_irq_unmask;
+-
+ 	pcie->irq_domain =
+ 		irq_domain_add_linear(pcie_intc_node, PCI_NUM_INTX,
+ 				      &advk_pcie_irq_domain_ops, pcie);
+ 	if (!pcie->irq_domain) {
+ 		dev_err(dev, "Failed to get a INTx IRQ domain\n");
+ 		ret = -ENOMEM;
+-		goto out_put_node;
+ 	}
+ 
+-out_put_node:
+ 	of_node_put(pcie_intc_node);
+ 	return ret;
+ }
diff -uprN a/target/linux/generic/pending-5.10/851-0001-phy-marvell-phy-mvebu-a3700-comphy-Remove-port-from-.patch b/target/linux/generic/pending-5.10/851-0001-phy-marvell-phy-mvebu-a3700-comphy-Remove-port-from-.patch
--- a/target/linux/generic/pending-5.10/851-0001-phy-marvell-phy-mvebu-a3700-comphy-Remove-port-from-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/851-0001-phy-marvell-phy-mvebu-a3700-comphy-Remove-port-from-.patch	2024-03-18 15:16:23.634639895 +0800
@@ -0,0 +1,217 @@
+From a719f7ba7fcba05d85801c6f0267f389a21627c1 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Fri, 24 Sep 2021 13:03:02 +0200
+Subject: [PATCH] phy: marvell: phy-mvebu-a3700-comphy: Remove port from driver
+ configuration
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Port number is encoded into argument for SMC call. It is zero for SATA,
+PCIe and also both USB 3.0 PHYs. It is non-zero only for Ethernet PHY
+(incorrectly called SGMII) on lane 0. Ethernet PHY on lane 1 also uses zero
+port number.
+
+So construct "port" bits for SMC call argument can be constructed directly
+from PHY type and lane number.
+
+Change driver code to always pass zero port number for non-ethernet PHYs
+and for ethernet PHYs determinate port number from lane number. This
+simplifies the driver.
+
+As port number from DT PHY configuration is not used anymore, remove whole
+driver code which parses it. This also simplifies the driver.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Reviewed-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/phy/marvell/phy-mvebu-a3700-comphy.c | 62 +++++++++-----------
+ 1 file changed, 29 insertions(+), 33 deletions(-)
+
+--- a/drivers/phy/marvell/phy-mvebu-a3700-comphy.c
++++ b/drivers/phy/marvell/phy-mvebu-a3700-comphy.c
+@@ -20,7 +20,6 @@
+ #include <linux/platform_device.h>
+ 
+ #define MVEBU_A3700_COMPHY_LANES		3
+-#define MVEBU_A3700_COMPHY_PORTS		2
+ 
+ /* COMPHY Fast SMC function identifiers */
+ #define COMPHY_SIP_POWER_ON			0x82000001
+@@ -45,51 +44,47 @@
+ #define COMPHY_FW_NET(mode, idx, speed)		(COMPHY_FW_MODE(mode) | \
+ 						 ((idx) << 8) |	\
+ 						 ((speed) << 2))
+-#define COMPHY_FW_PCIE(mode, idx, speed, width)	(COMPHY_FW_NET(mode, idx, speed) | \
++#define COMPHY_FW_PCIE(mode, speed, width)	(COMPHY_FW_NET(mode, 0, speed) | \
+ 						 ((width) << 18))
+ 
+ struct mvebu_a3700_comphy_conf {
+ 	unsigned int lane;
+ 	enum phy_mode mode;
+ 	int submode;
+-	unsigned int port;
+ 	u32 fw_mode;
+ };
+ 
+-#define MVEBU_A3700_COMPHY_CONF(_lane, _mode, _smode, _port, _fw)	\
++#define MVEBU_A3700_COMPHY_CONF(_lane, _mode, _smode, _fw)		\
+ 	{								\
+ 		.lane = _lane,						\
+ 		.mode = _mode,						\
+ 		.submode = _smode,					\
+-		.port = _port,						\
+ 		.fw_mode = _fw,						\
+ 	}
+ 
+-#define MVEBU_A3700_COMPHY_CONF_GEN(_lane, _mode, _port, _fw) \
+-	MVEBU_A3700_COMPHY_CONF(_lane, _mode, PHY_INTERFACE_MODE_NA, _port, _fw)
++#define MVEBU_A3700_COMPHY_CONF_GEN(_lane, _mode, _fw) \
++	MVEBU_A3700_COMPHY_CONF(_lane, _mode, PHY_INTERFACE_MODE_NA, _fw)
+ 
+-#define MVEBU_A3700_COMPHY_CONF_ETH(_lane, _smode, _port, _fw) \
+-	MVEBU_A3700_COMPHY_CONF(_lane, PHY_MODE_ETHERNET, _smode, _port, _fw)
++#define MVEBU_A3700_COMPHY_CONF_ETH(_lane, _smode, _fw) \
++	MVEBU_A3700_COMPHY_CONF(_lane, PHY_MODE_ETHERNET, _smode, _fw)
+ 
+ static const struct mvebu_a3700_comphy_conf mvebu_a3700_comphy_modes[] = {
+ 	/* lane 0 */
+-	MVEBU_A3700_COMPHY_CONF_GEN(0, PHY_MODE_USB_HOST_SS, 0,
++	MVEBU_A3700_COMPHY_CONF_GEN(0, PHY_MODE_USB_HOST_SS,
+ 				    COMPHY_FW_MODE_USB3H),
+-	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_SGMII, 1,
++	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_SGMII,
+ 				    COMPHY_FW_MODE_SGMII),
+-	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_2500BASEX, 1,
++	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_2500BASEX,
+ 				    COMPHY_FW_MODE_2500BASEX),
+ 	/* lane 1 */
+-	MVEBU_A3700_COMPHY_CONF_GEN(1, PHY_MODE_PCIE, 0,
+-				    COMPHY_FW_MODE_PCIE),
+-	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_SGMII, 0,
++	MVEBU_A3700_COMPHY_CONF_GEN(1, PHY_MODE_PCIE, COMPHY_FW_MODE_PCIE),
++	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_SGMII,
+ 				    COMPHY_FW_MODE_SGMII),
+-	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_2500BASEX, 0,
++	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_2500BASEX,
+ 				    COMPHY_FW_MODE_2500BASEX),
+ 	/* lane 2 */
+-	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_SATA, 0,
+-				    COMPHY_FW_MODE_SATA),
+-	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_USB_HOST_SS, 0,
++	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_SATA, COMPHY_FW_MODE_SATA),
++	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_USB_HOST_SS,
+ 				    COMPHY_FW_MODE_USB3H),
+ };
+ 
+@@ -98,7 +93,6 @@ struct mvebu_a3700_comphy_lane {
+ 	unsigned int id;
+ 	enum phy_mode mode;
+ 	int submode;
+-	int port;
+ };
+ 
+ static int mvebu_a3700_comphy_smc(unsigned long function, unsigned long lane,
+@@ -120,7 +114,7 @@ static int mvebu_a3700_comphy_smc(unsign
+ 	}
+ }
+ 
+-static int mvebu_a3700_comphy_get_fw_mode(int lane, int port,
++static int mvebu_a3700_comphy_get_fw_mode(int lane,
+ 					  enum phy_mode mode,
+ 					  int submode)
+ {
+@@ -132,7 +126,6 @@ static int mvebu_a3700_comphy_get_fw_mod
+ 
+ 	for (i = 0; i < n; i++) {
+ 		if (mvebu_a3700_comphy_modes[i].lane == lane &&
+-		    mvebu_a3700_comphy_modes[i].port == port &&
+ 		    mvebu_a3700_comphy_modes[i].mode == mode &&
+ 		    mvebu_a3700_comphy_modes[i].submode == submode)
+ 			break;
+@@ -153,7 +146,7 @@ static int mvebu_a3700_comphy_set_mode(s
+ 	if (submode == PHY_INTERFACE_MODE_1000BASEX)
+ 		submode = PHY_INTERFACE_MODE_SGMII;
+ 
+-	fw_mode = mvebu_a3700_comphy_get_fw_mode(lane->id, lane->port, mode,
++	fw_mode = mvebu_a3700_comphy_get_fw_mode(lane->id, mode,
+ 						 submode);
+ 	if (fw_mode < 0) {
+ 		dev_err(lane->dev, "invalid COMPHY mode\n");
+@@ -172,9 +165,10 @@ static int mvebu_a3700_comphy_power_on(s
+ 	struct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);
+ 	u32 fw_param;
+ 	int fw_mode;
++	int fw_port;
+ 	int ret;
+ 
+-	fw_mode = mvebu_a3700_comphy_get_fw_mode(lane->id, lane->port,
++	fw_mode = mvebu_a3700_comphy_get_fw_mode(lane->id,
+ 						 lane->mode, lane->submode);
+ 	if (fw_mode < 0) {
+ 		dev_err(lane->dev, "invalid COMPHY mode\n");
+@@ -191,17 +185,18 @@ static int mvebu_a3700_comphy_power_on(s
+ 		fw_param = COMPHY_FW_MODE(fw_mode);
+ 		break;
+ 	case PHY_MODE_ETHERNET:
++		fw_port = (lane->id == 0) ? 1 : 0;
+ 		switch (lane->submode) {
+ 		case PHY_INTERFACE_MODE_SGMII:
+ 			dev_dbg(lane->dev, "set lane %d to SGMII mode\n",
+ 				lane->id);
+-			fw_param = COMPHY_FW_NET(fw_mode, lane->port,
++			fw_param = COMPHY_FW_NET(fw_mode, fw_port,
+ 						 COMPHY_FW_SPEED_1_25G);
+ 			break;
+ 		case PHY_INTERFACE_MODE_2500BASEX:
+ 			dev_dbg(lane->dev, "set lane %d to 2500BASEX mode\n",
+ 				lane->id);
+-			fw_param = COMPHY_FW_NET(fw_mode, lane->port,
++			fw_param = COMPHY_FW_NET(fw_mode, fw_port,
+ 						 COMPHY_FW_SPEED_3_125G);
+ 			break;
+ 		default:
+@@ -212,8 +207,7 @@ static int mvebu_a3700_comphy_power_on(s
+ 		break;
+ 	case PHY_MODE_PCIE:
+ 		dev_dbg(lane->dev, "set lane %d to PCIe mode\n", lane->id);
+-		fw_param = COMPHY_FW_PCIE(fw_mode, lane->port,
+-					  COMPHY_FW_SPEED_5G,
++		fw_param = COMPHY_FW_PCIE(fw_mode, COMPHY_FW_SPEED_5G,
+ 					  phy->attrs.bus_width);
+ 		break;
+ 	default:
+@@ -247,17 +241,20 @@ static struct phy *mvebu_a3700_comphy_xl
+ 					    struct of_phandle_args *args)
+ {
+ 	struct mvebu_a3700_comphy_lane *lane;
++	unsigned int port;
+ 	struct phy *phy;
+ 
+-	if (WARN_ON(args->args[0] >= MVEBU_A3700_COMPHY_PORTS))
+-		return ERR_PTR(-EINVAL);
+-
+ 	phy = of_phy_simple_xlate(dev, args);
+ 	if (IS_ERR(phy))
+ 		return phy;
+ 
+ 	lane = phy_get_drvdata(phy);
+-	lane->port = args->args[0];
++
++	port = args->args[0];
++	if (port != 0 && (port != 1 || lane->id != 0)) {
++		dev_err(lane->dev, "invalid port number %u\n", port);
++		return ERR_PTR(-EINVAL);
++	}
+ 
+ 	return phy;
+ }
+@@ -302,7 +299,6 @@ static int mvebu_a3700_comphy_probe(stru
+ 		lane->mode = PHY_MODE_INVALID;
+ 		lane->submode = PHY_INTERFACE_MODE_NA;
+ 		lane->id = lane_id;
+-		lane->port = -1;
+ 		phy_set_drvdata(phy, lane);
+ 	}
+ 
diff -uprN a/target/linux/generic/pending-5.10/851-0002-phy-marvell-phy-mvebu-a3700-comphy-Add-native-kernel.patch b/target/linux/generic/pending-5.10/851-0002-phy-marvell-phy-mvebu-a3700-comphy-Add-native-kernel.patch
--- a/target/linux/generic/pending-5.10/851-0002-phy-marvell-phy-mvebu-a3700-comphy-Add-native-kernel.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/851-0002-phy-marvell-phy-mvebu-a3700-comphy-Add-native-kernel.patch	2024-03-18 15:16:23.634639895 +0800
@@ -0,0 +1,1564 @@
+From 9d276da259cce20b2ed7a868b6e6a6a205f7bb04 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 23 Sep 2021 19:20:13 +0200
+Subject: [PATCH] phy: marvell: phy-mvebu-a3700-comphy: Add native kernel
+ implementation
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Remove old RPC implementation and add a new native kernel implementation.
+
+The old implementation uses ARM SMC API to issue RPC calls to ARM Trusted
+Firmware which provides real implementation of PHY configuration.
+
+But older versions of ARM Trusted Firmware do not provide this PHY
+configuration functionality, simply returning: operation not supported; or
+worse, some versions provide the configuration functionality incorrectly.
+
+For example the firmware shipped in ESPRESSObin board has this older
+version of ARM Trusted Firmware and therefore SATA, USB 3.0 and PCIe
+functionality do not work with newer versions of Linux kernel.
+
+Due to the above reasons, the following commits were introduced into Linux,
+to workaround these issues by ignoring -EOPNOTSUPP error code from
+phy-mvebu-a3700-comphy driver function phy_power_on():
+
+commit 45aefe3d2251 ("ata: ahci: mvebu: Make SATA PHY optional for Armada
+3720")
+commit 3241929b67d2 ("usb: host: xhci: mvebu: make USB 3.0 PHY optional for
+Armada 3720")
+commit b0c6ae0f8948 ("PCI: aardvark: Fix initialization with old Marvell's
+Arm Trusted Firmware")
+
+Replace this RPC implementation with proper native kernel implementation,
+which is independent on the firmware. Never return -EOPNOTSUPP for proper
+arguments.
+
+This should solve multiple issues with real-world boards, where it is not
+possible or really inconvenient to change the firmware. Let's eliminate
+these issues.
+
+This implementation is ported directly from Armada 3720 comphy driver found
+in newest version of ARM Trusted Firmware source code, but with various
+fixes of register names, some added comments, some refactoring due to the
+original code not conforming to kernel standards. Also PCIe mode poweroff
+support was added here, and PHY reset support. These changes are also going
+to be sent to ARM Trusted Firmware.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Acked-by: Miquel Raynal <miquel.raynal@bootlin.com>
+[ Pali did the porting from ATF.
+  I (Marek) then fixed some register names, some various other things,
+  added some comments and refactored the code to kernel standards. Also
+  fixed PHY poweroff and added PHY reset. ]
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ drivers/phy/marvell/phy-mvebu-a3700-comphy.c | 1351 ++++++++++++++++--
+ 1 file changed, 1234 insertions(+), 117 deletions(-)
+
+--- a/drivers/phy/marvell/phy-mvebu-a3700-comphy.c
++++ b/drivers/phy/marvell/phy-mvebu-a3700-comphy.c
+@@ -5,12 +5,16 @@
+  * Authors:
+  *   Evan Wang <xswang@marvell.com>
+  *   Miquèl Raynal <miquel.raynal@bootlin.com>
++ *   Pali Rohár <pali@kernel.org>
++ *   Marek Behún <kabel@kernel.org>
+  *
+  * Structure inspired from phy-mvebu-cp110-comphy.c written by Antoine Tenart.
+- * SMC call initial support done by Grzegorz Jaszczyk.
++ * Comphy code from ARM Trusted Firmware ported by Pali Rohár <pali@kernel.org>
++ * and Marek Behún <kabel@kernel.org>.
+  */
+ 
+-#include <linux/arm-smccc.h>
++#include <linux/bitfield.h>
++#include <linux/clk.h>
+ #include <linux/io.h>
+ #include <linux/iopoll.h>
+ #include <linux/mfd/syscon.h>
+@@ -18,103 +22,1147 @@
+ #include <linux/phy.h>
+ #include <linux/phy/phy.h>
+ #include <linux/platform_device.h>
++#include <linux/spinlock.h>
+ 
+-#define MVEBU_A3700_COMPHY_LANES		3
++#define PLL_SET_DELAY_US		600
++#define COMPHY_PLL_SLEEP		1000
++#define COMPHY_PLL_TIMEOUT		150000
++
++/* Comphy lane2 indirect access register offset */
++#define COMPHY_LANE2_INDIR_ADDR		0x0
++#define COMPHY_LANE2_INDIR_DATA		0x4
++
++/* SATA and USB3 PHY offset compared to SATA PHY */
++#define COMPHY_LANE2_REGS_BASE		0x200
++
++/*
++ * When accessing common PHY lane registers directly, we need to shift by 1,
++ * since the registers are 16-bit.
++ */
++#define COMPHY_LANE_REG_DIRECT(reg)	(((reg) & 0x7FF) << 1)
++
++/* COMPHY registers */
++#define COMPHY_POWER_PLL_CTRL		0x01
++#define PU_IVREF_BIT			BIT(15)
++#define PU_PLL_BIT			BIT(14)
++#define PU_RX_BIT			BIT(13)
++#define PU_TX_BIT			BIT(12)
++#define PU_TX_INTP_BIT			BIT(11)
++#define PU_DFE_BIT			BIT(10)
++#define RESET_DTL_RX_BIT		BIT(9)
++#define PLL_LOCK_BIT			BIT(8)
++#define REF_FREF_SEL_MASK		GENMASK(4, 0)
++#define REF_FREF_SEL_SERDES_25MHZ	FIELD_PREP(REF_FREF_SEL_MASK, 0x1)
++#define REF_FREF_SEL_SERDES_40MHZ	FIELD_PREP(REF_FREF_SEL_MASK, 0x3)
++#define REF_FREF_SEL_SERDES_50MHZ	FIELD_PREP(REF_FREF_SEL_MASK, 0x4)
++#define REF_FREF_SEL_PCIE_USB3_25MHZ	FIELD_PREP(REF_FREF_SEL_MASK, 0x2)
++#define REF_FREF_SEL_PCIE_USB3_40MHZ	FIELD_PREP(REF_FREF_SEL_MASK, 0x3)
++#define COMPHY_MODE_MASK		GENMASK(7, 5)
++#define COMPHY_MODE_SATA		FIELD_PREP(COMPHY_MODE_MASK, 0x0)
++#define COMPHY_MODE_PCIE		FIELD_PREP(COMPHY_MODE_MASK, 0x3)
++#define COMPHY_MODE_SERDES		FIELD_PREP(COMPHY_MODE_MASK, 0x4)
++#define COMPHY_MODE_USB3		FIELD_PREP(COMPHY_MODE_MASK, 0x5)
++
++#define COMPHY_KVCO_CAL_CTRL		0x02
++#define USE_MAX_PLL_RATE_BIT		BIT(12)
++#define SPEED_PLL_MASK			GENMASK(7, 2)
++#define SPEED_PLL_VALUE_16		FIELD_PREP(SPEED_PLL_MASK, 0x10)
++
++#define COMPHY_DIG_LOOPBACK_EN		0x23
++#define SEL_DATA_WIDTH_MASK		GENMASK(11, 10)
++#define DATA_WIDTH_10BIT		FIELD_PREP(SEL_DATA_WIDTH_MASK, 0x0)
++#define DATA_WIDTH_20BIT		FIELD_PREP(SEL_DATA_WIDTH_MASK, 0x1)
++#define DATA_WIDTH_40BIT		FIELD_PREP(SEL_DATA_WIDTH_MASK, 0x2)
++#define PLL_READY_TX_BIT		BIT(4)
++
++#define COMPHY_SYNC_PATTERN		0x24
++#define TXD_INVERT_BIT			BIT(10)
++#define RXD_INVERT_BIT			BIT(11)
++
++#define COMPHY_SYNC_MASK_GEN		0x25
++#define PHY_GEN_MAX_MASK		GENMASK(11, 10)
++#define PHY_GEN_MAX_USB3_5G		FIELD_PREP(PHY_GEN_MAX_MASK, 0x1)
++
++#define COMPHY_ISOLATION_CTRL		0x26
++#define PHY_ISOLATE_MODE		BIT(15)
++
++#define COMPHY_GEN2_SET2		0x3e
++#define GS2_TX_SSC_AMP_MASK		GENMASK(15, 9)
++#define GS2_TX_SSC_AMP_4128		FIELD_PREP(GS2_TX_SSC_AMP_MASK, 0x20)
++#define GS2_VREG_RXTX_MAS_ISET_MASK	GENMASK(8, 7)
++#define GS2_VREG_RXTX_MAS_ISET_60U	FIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\
++						   0x0)
++#define GS2_VREG_RXTX_MAS_ISET_80U	FIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\
++						   0x1)
++#define GS2_VREG_RXTX_MAS_ISET_100U	FIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\
++						   0x2)
++#define GS2_VREG_RXTX_MAS_ISET_120U	FIELD_PREP(GS2_VREG_RXTX_MAS_ISET_MASK,\
++						   0x3)
++#define GS2_RSVD_6_0_MASK		GENMASK(6, 0)
++
++#define COMPHY_GEN3_SET2		0x3f
++
++#define COMPHY_IDLE_SYNC_EN		0x48
++#define IDLE_SYNC_EN			BIT(12)
++
++#define COMPHY_MISC_CTRL0		0x4F
++#define CLK100M_125M_EN			BIT(4)
++#define TXDCLK_2X_SEL			BIT(6)
++#define CLK500M_EN			BIT(7)
++#define PHY_REF_CLK_SEL			BIT(10)
++
++#define COMPHY_SFT_RESET		0x52
++#define SFT_RST				BIT(9)
++#define SFT_RST_NO_REG			BIT(10)
++
++#define COMPHY_MISC_CTRL1		0x73
++#define SEL_BITS_PCIE_FORCE		BIT(15)
++
++#define COMPHY_GEN2_SET3		0x112
++#define GS3_FFE_CAP_SEL_MASK		GENMASK(3, 0)
++#define GS3_FFE_CAP_SEL_VALUE		FIELD_PREP(GS3_FFE_CAP_SEL_MASK, 0xF)
++
++/* PIPE registers */
++#define COMPHY_PIPE_LANE_CFG0		0x180
++#define PRD_TXDEEMPH0_MASK		BIT(0)
++#define PRD_TXMARGIN_MASK		GENMASK(3, 1)
++#define PRD_TXSWING_MASK		BIT(4)
++#define CFG_TX_ALIGN_POS_MASK		GENMASK(8, 5)
++
++#define COMPHY_PIPE_LANE_CFG1		0x181
++#define PRD_TXDEEMPH1_MASK		BIT(15)
++#define USE_MAX_PLL_RATE_EN		BIT(9)
++#define TX_DET_RX_MODE			BIT(6)
++#define GEN2_TX_DATA_DLY_MASK		GENMASK(4, 3)
++#define GEN2_TX_DATA_DLY_DEFT		FIELD_PREP(GEN2_TX_DATA_DLY_MASK, 2)
++#define TX_ELEC_IDLE_MODE_EN		BIT(0)
++
++#define COMPHY_PIPE_LANE_STAT1		0x183
++#define TXDCLK_PCLK_EN			BIT(0)
++
++#define COMPHY_PIPE_LANE_CFG4		0x188
++#define SPREAD_SPECTRUM_CLK_EN		BIT(7)
++
++#define COMPHY_PIPE_RST_CLK_CTRL	0x1C1
++#define PIPE_SOFT_RESET			BIT(0)
++#define PIPE_REG_RESET			BIT(1)
++#define MODE_CORE_CLK_FREQ_SEL		BIT(9)
++#define MODE_PIPE_WIDTH_32		BIT(3)
++#define MODE_REFDIV_MASK		GENMASK(5, 4)
++#define MODE_REFDIV_BY_4		FIELD_PREP(MODE_REFDIV_MASK, 0x2)
++
++#define COMPHY_PIPE_TEST_MODE_CTRL	0x1C2
++#define MODE_MARGIN_OVERRIDE		BIT(2)
++
++#define COMPHY_PIPE_CLK_SRC_LO		0x1C3
++#define MODE_CLK_SRC			BIT(0)
++#define BUNDLE_PERIOD_SEL		BIT(1)
++#define BUNDLE_PERIOD_SCALE_MASK	GENMASK(3, 2)
++#define BUNDLE_SAMPLE_CTRL		BIT(4)
++#define PLL_READY_DLY_MASK		GENMASK(7, 5)
++#define CFG_SEL_20B			BIT(15)
++
++#define COMPHY_PIPE_PWR_MGM_TIM1	0x1D0
++#define CFG_PM_OSCCLK_WAIT_MASK		GENMASK(15, 12)
++#define CFG_PM_RXDEN_WAIT_MASK		GENMASK(11, 8)
++#define CFG_PM_RXDEN_WAIT_1_UNIT	FIELD_PREP(CFG_PM_RXDEN_WAIT_MASK, 0x1)
++#define CFG_PM_RXDLOZ_WAIT_MASK		GENMASK(7, 0)
++#define CFG_PM_RXDLOZ_WAIT_7_UNIT	FIELD_PREP(CFG_PM_RXDLOZ_WAIT_MASK, 0x7)
++#define CFG_PM_RXDLOZ_WAIT_12_UNIT	FIELD_PREP(CFG_PM_RXDLOZ_WAIT_MASK, 0xC)
++
++/*
++ * This register is not from PHY lane register space. It only exists in the
++ * indirect register space, before the actual PHY lane 2 registers. So the
++ * offset is absolute, not relative to COMPHY_LANE2_REGS_BASE.
++ * It is used only for SATA PHY initialization.
++ */
++#define COMPHY_RESERVED_REG		0x0E
++#define PHYCTRL_FRM_PIN_BIT		BIT(13)
+ 
+-/* COMPHY Fast SMC function identifiers */
+-#define COMPHY_SIP_POWER_ON			0x82000001
+-#define COMPHY_SIP_POWER_OFF			0x82000002
+-#define COMPHY_SIP_PLL_LOCK			0x82000003
+-
+-#define COMPHY_FW_MODE_SATA			0x1
+-#define COMPHY_FW_MODE_SGMII			0x2
+-#define COMPHY_FW_MODE_2500BASEX		0x3
+-#define COMPHY_FW_MODE_USB3H			0x4
+-#define COMPHY_FW_MODE_USB3D			0x5
+-#define COMPHY_FW_MODE_PCIE			0x6
+-#define COMPHY_FW_MODE_USB3			0xa
+-
+-#define COMPHY_FW_SPEED_1_25G			0 /* SGMII 1G */
+-#define COMPHY_FW_SPEED_2_5G			1
+-#define COMPHY_FW_SPEED_3_125G			2 /* 2500BASE-X */
+-#define COMPHY_FW_SPEED_5G			3
+-#define COMPHY_FW_SPEED_MAX			0x3F
+-
+-#define COMPHY_FW_MODE(mode)			((mode) << 12)
+-#define COMPHY_FW_NET(mode, idx, speed)		(COMPHY_FW_MODE(mode) | \
+-						 ((idx) << 8) |	\
+-						 ((speed) << 2))
+-#define COMPHY_FW_PCIE(mode, speed, width)	(COMPHY_FW_NET(mode, 0, speed) | \
+-						 ((width) << 18))
++/* South Bridge PHY Configuration Registers */
++#define COMPHY_PHY_REG(lane, reg)	(((1 - (lane)) * 0x28) + ((reg) & 0x3f))
++
++/*
++ * lane0: USB3/GbE1 PHY Configuration 1
++ * lane1: PCIe/GbE0 PHY Configuration 1
++ * (used only by SGMII code)
++ */
++#define COMPHY_PHY_CFG1			0x0
++#define PIN_PU_IVREF_BIT		BIT(1)
++#define PIN_RESET_CORE_BIT		BIT(11)
++#define PIN_RESET_COMPHY_BIT		BIT(12)
++#define PIN_PU_PLL_BIT			BIT(16)
++#define PIN_PU_RX_BIT			BIT(17)
++#define PIN_PU_TX_BIT			BIT(18)
++#define PIN_TX_IDLE_BIT			BIT(19)
++#define GEN_RX_SEL_MASK			GENMASK(25, 22)
++#define GEN_RX_SEL_VALUE(val)		FIELD_PREP(GEN_RX_SEL_MASK, (val))
++#define GEN_TX_SEL_MASK			GENMASK(29, 26)
++#define GEN_TX_SEL_VALUE(val)		FIELD_PREP(GEN_TX_SEL_MASK, (val))
++#define SERDES_SPEED_1_25_G		0x6
++#define SERDES_SPEED_3_125_G		0x8
++#define PHY_RX_INIT_BIT			BIT(30)
++
++/*
++ * lane0: USB3/GbE1 PHY Status 1
++ * lane1: PCIe/GbE0 PHY Status 1
++ * (used only by SGMII code)
++ */
++#define COMPHY_PHY_STAT1		0x18
++#define PHY_RX_INIT_DONE_BIT		BIT(0)
++#define PHY_PLL_READY_RX_BIT		BIT(2)
++#define PHY_PLL_READY_TX_BIT		BIT(3)
++
++/* PHY Selector */
++#define COMPHY_SELECTOR_PHY_REG			0xFC
++/* bit0: 0: Lane1 is GbE0; 1: Lane1 is PCIe */
++#define COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT	BIT(0)
++/* bit4: 0: Lane0 is GbE1; 1: Lane0 is USB3 */
++#define COMPHY_SELECTOR_USB3_GBE1_SEL_BIT	BIT(4)
++/* bit8: 0: Lane0 is USB3 instead of GbE1, Lane2 is SATA; 1: Lane2 is USB3 */
++#define COMPHY_SELECTOR_USB3_PHY_SEL_BIT	BIT(8)
+ 
+ struct mvebu_a3700_comphy_conf {
+ 	unsigned int lane;
+ 	enum phy_mode mode;
+ 	int submode;
+-	u32 fw_mode;
+ };
+ 
+-#define MVEBU_A3700_COMPHY_CONF(_lane, _mode, _smode, _fw)		\
++#define MVEBU_A3700_COMPHY_CONF(_lane, _mode, _smode)			\
+ 	{								\
+ 		.lane = _lane,						\
+ 		.mode = _mode,						\
+ 		.submode = _smode,					\
+-		.fw_mode = _fw,						\
+ 	}
+ 
+-#define MVEBU_A3700_COMPHY_CONF_GEN(_lane, _mode, _fw) \
+-	MVEBU_A3700_COMPHY_CONF(_lane, _mode, PHY_INTERFACE_MODE_NA, _fw)
++#define MVEBU_A3700_COMPHY_CONF_GEN(_lane, _mode) \
++	MVEBU_A3700_COMPHY_CONF(_lane, _mode, PHY_INTERFACE_MODE_NA)
+ 
+-#define MVEBU_A3700_COMPHY_CONF_ETH(_lane, _smode, _fw) \
+-	MVEBU_A3700_COMPHY_CONF(_lane, PHY_MODE_ETHERNET, _smode, _fw)
++#define MVEBU_A3700_COMPHY_CONF_ETH(_lane, _smode) \
++	MVEBU_A3700_COMPHY_CONF(_lane, PHY_MODE_ETHERNET, _smode)
+ 
+ static const struct mvebu_a3700_comphy_conf mvebu_a3700_comphy_modes[] = {
+ 	/* lane 0 */
+-	MVEBU_A3700_COMPHY_CONF_GEN(0, PHY_MODE_USB_HOST_SS,
+-				    COMPHY_FW_MODE_USB3H),
+-	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_SGMII,
+-				    COMPHY_FW_MODE_SGMII),
+-	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_2500BASEX,
+-				    COMPHY_FW_MODE_2500BASEX),
++	MVEBU_A3700_COMPHY_CONF_GEN(0, PHY_MODE_USB_HOST_SS),
++	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_SGMII),
++	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_1000BASEX),
++	MVEBU_A3700_COMPHY_CONF_ETH(0, PHY_INTERFACE_MODE_2500BASEX),
+ 	/* lane 1 */
+-	MVEBU_A3700_COMPHY_CONF_GEN(1, PHY_MODE_PCIE, COMPHY_FW_MODE_PCIE),
+-	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_SGMII,
+-				    COMPHY_FW_MODE_SGMII),
+-	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_2500BASEX,
+-				    COMPHY_FW_MODE_2500BASEX),
++	MVEBU_A3700_COMPHY_CONF_GEN(1, PHY_MODE_PCIE),
++	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_SGMII),
++	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_1000BASEX),
++	MVEBU_A3700_COMPHY_CONF_ETH(1, PHY_INTERFACE_MODE_2500BASEX),
+ 	/* lane 2 */
+-	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_SATA, COMPHY_FW_MODE_SATA),
+-	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_USB_HOST_SS,
+-				    COMPHY_FW_MODE_USB3H),
++	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_SATA),
++	MVEBU_A3700_COMPHY_CONF_GEN(2, PHY_MODE_USB_HOST_SS),
++};
++
++struct mvebu_a3700_comphy_priv {
++	void __iomem *comphy_regs;
++	void __iomem *lane0_phy_regs; /* USB3 and GbE1 */
++	void __iomem *lane1_phy_regs; /* PCIe and GbE0 */
++	void __iomem *lane2_phy_indirect; /* SATA and USB3 */
++	spinlock_t lock; /* for PHY selector access */
++	bool xtal_is_40m;
+ };
+ 
+ struct mvebu_a3700_comphy_lane {
++	struct mvebu_a3700_comphy_priv *priv;
+ 	struct device *dev;
+ 	unsigned int id;
+ 	enum phy_mode mode;
+ 	int submode;
++	bool invert_tx;
++	bool invert_rx;
++	bool needs_reset;
++};
++
++struct gbe_phy_init_data_fix {
++	u16 addr;
++	u16 value;
++};
++
++/* Changes to 40M1G25 mode data required for running 40M3G125 init mode */
++static struct gbe_phy_init_data_fix gbe_phy_init_fix[] = {
++	{ 0x005, 0x07CC }, { 0x015, 0x0000 }, { 0x01B, 0x0000 },
++	{ 0x01D, 0x0000 }, { 0x01E, 0x0000 }, { 0x01F, 0x0000 },
++	{ 0x020, 0x0000 }, { 0x021, 0x0030 }, { 0x026, 0x0888 },
++	{ 0x04D, 0x0152 }, { 0x04F, 0xA020 }, { 0x050, 0x07CC },
++	{ 0x053, 0xE9CA }, { 0x055, 0xBD97 }, { 0x071, 0x3015 },
++	{ 0x076, 0x03AA }, { 0x07C, 0x0FDF }, { 0x0C2, 0x3030 },
++	{ 0x0C3, 0x8000 }, { 0x0E2, 0x5550 }, { 0x0E3, 0x12A4 },
++	{ 0x0E4, 0x7D00 }, { 0x0E6, 0x0C83 }, { 0x101, 0xFCC0 },
++	{ 0x104, 0x0C10 }
+ };
+ 
+-static int mvebu_a3700_comphy_smc(unsigned long function, unsigned long lane,
+-				  unsigned long mode)
++/* 40M1G25 mode init data */
++static u16 gbe_phy_init[512] = {
++	/* 0       1       2       3       4       5       6       7 */
++	/*-----------------------------------------------------------*/
++	/* 8       9       A       B       C       D       E       F */
++	0x3110, 0xFD83, 0x6430, 0x412F, 0x82C0, 0x06FA, 0x4500, 0x6D26,	/* 00 */
++	0xAFC0, 0x8000, 0xC000, 0x0000, 0x2000, 0x49CC, 0x0BC9, 0x2A52,	/* 08 */
++	0x0BD2, 0x0CDE, 0x13D2, 0x0CE8, 0x1149, 0x10E0, 0x0000, 0x0000,	/* 10 */
++	0x0000, 0x0000, 0x0000, 0x0001, 0x0000, 0x4134, 0x0D2D, 0xFFFF,	/* 18 */
++	0xFFE0, 0x4030, 0x1016, 0x0030, 0x0000, 0x0800, 0x0866, 0x0000,	/* 20 */
++	0x0000, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,	/* 28 */
++	0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* 30 */
++	0x0000, 0x0000, 0x000F, 0x6A62, 0x1988, 0x3100, 0x3100, 0x3100,	/* 38 */
++	0x3100, 0xA708, 0x2430, 0x0830, 0x1030, 0x4610, 0xFF00, 0xFF00,	/* 40 */
++	0x0060, 0x1000, 0x0400, 0x0040, 0x00F0, 0x0155, 0x1100, 0xA02A,	/* 48 */
++	0x06FA, 0x0080, 0xB008, 0xE3ED, 0x5002, 0xB592, 0x7A80, 0x0001,	/* 50 */
++	0x020A, 0x8820, 0x6014, 0x8054, 0xACAA, 0xFC88, 0x2A02, 0x45CF,	/* 58 */
++	0x000F, 0x1817, 0x2860, 0x064F, 0x0000, 0x0204, 0x1800, 0x6000,	/* 60 */
++	0x810F, 0x4F23, 0x4000, 0x4498, 0x0850, 0x0000, 0x000E, 0x1002,	/* 68 */
++	0x9D3A, 0x3009, 0xD066, 0x0491, 0x0001, 0x6AB0, 0x0399, 0x3780,	/* 70 */
++	0x0040, 0x5AC0, 0x4A80, 0x0000, 0x01DF, 0x0000, 0x0007, 0x0000,	/* 78 */
++	0x2D54, 0x00A1, 0x4000, 0x0100, 0xA20A, 0x0000, 0x0000, 0x0000,	/* 80 */
++	0x0000, 0x0000, 0x0000, 0x7400, 0x0E81, 0x1000, 0x1242, 0x0210,	/* 88 */
++	0x80DF, 0x0F1F, 0x2F3F, 0x4F5F, 0x6F7F, 0x0F1F, 0x2F3F, 0x4F5F,	/* 90 */
++	0x6F7F, 0x4BAD, 0x0000, 0x0000, 0x0800, 0x0000, 0x2400, 0xB651,	/* 98 */
++	0xC9E0, 0x4247, 0x0A24, 0x0000, 0xAF19, 0x1004, 0x0000, 0x0000,	/* A0 */
++	0x0000, 0x0013, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* A8 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/* B0 */
++	0x0000, 0x0000, 0x0000, 0x0060, 0x0000, 0x0000, 0x0000, 0x0000,	/* B8 */
++	0x0000, 0x0000, 0x3010, 0xFA00, 0x0000, 0x0000, 0x0000, 0x0003,	/* C0 */
++	0x1618, 0x8200, 0x8000, 0x0400, 0x050F, 0x0000, 0x0000, 0x0000,	/* C8 */
++	0x4C93, 0x0000, 0x1000, 0x1120, 0x0010, 0x1242, 0x1242, 0x1E00,	/* D0 */
++	0x0000, 0x0000, 0x0000, 0x00F8, 0x0000, 0x0041, 0x0800, 0x0000,	/* D8 */
++	0x82A0, 0x572E, 0x2490, 0x14A9, 0x4E00, 0x0000, 0x0803, 0x0541,	/* E0 */
++	0x0C15, 0x0000, 0x0000, 0x0400, 0x2626, 0x0000, 0x0000, 0x4200,	/* E8 */
++	0x0000, 0xAA55, 0x1020, 0x0000, 0x0000, 0x5010, 0x0000, 0x0000,	/* F0 */
++	0x0000, 0x0000, 0x5000, 0x0000, 0x0000, 0x0000, 0x02F2, 0x0000,	/* F8 */
++	0x101F, 0xFDC0, 0x4000, 0x8010, 0x0110, 0x0006, 0x0000, 0x0000,	/*100 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*108 */
++	0x04CF, 0x0000, 0x04CF, 0x0000, 0x04CF, 0x0000, 0x04C6, 0x0000,	/*110 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*118 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*120 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*128 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*130 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*138 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*140 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*148 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*150 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*158 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*160 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*168 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*170 */
++	0x0000, 0x0000, 0x0000, 0x00F0, 0x08A2, 0x3112, 0x0A14, 0x0000,	/*178 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*180 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*188 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*190 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*198 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A0 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1A8 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B0 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1B8 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C0 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1C8 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D0 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1D8 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E0 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1E8 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,	/*1F0 */
++	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000	/*1F8 */
++};
++
++static inline void comphy_reg_set(void __iomem *addr, u32 data, u32 mask)
+ {
+-	struct arm_smccc_res res;
+-	s32 ret;
++	u32 val;
+ 
+-	arm_smccc_smc(function, lane, mode, 0, 0, 0, 0, 0, &res);
+-	ret = res.a0;
++	val = readl(addr);
++	val = (val & ~mask) | (data & mask);
++	writel(val, addr);
++}
+ 
+-	switch (ret) {
+-	case SMCCC_RET_SUCCESS:
+-		return 0;
+-	case SMCCC_RET_NOT_SUPPORTED:
+-		return -EOPNOTSUPP;
++static inline void comphy_reg_set16(void __iomem *addr, u16 data, u16 mask)
++{
++	u16 val;
++
++	val = readw(addr);
++	val = (val & ~mask) | (data & mask);
++	writew(val, addr);
++}
++
++/* Used for accessing lane 2 registers (SATA/USB3 PHY) */
++static void comphy_set_indirect(struct mvebu_a3700_comphy_priv *priv,
++				u32 offset, u16 data, u16 mask)
++{
++	writel(offset,
++	       priv->lane2_phy_indirect + COMPHY_LANE2_INDIR_ADDR);
++	comphy_reg_set(priv->lane2_phy_indirect + COMPHY_LANE2_INDIR_DATA,
++		       data, mask);
++}
++
++static void comphy_lane_reg_set(struct mvebu_a3700_comphy_lane *lane,
++				u16 reg, u16 data, u16 mask)
++{
++	if (lane->id == 2) {
++		/* lane 2 PHY registers are accessed indirectly */
++		comphy_set_indirect(lane->priv,
++				    reg + COMPHY_LANE2_REGS_BASE,
++				    data, mask);
++	} else {
++		void __iomem *base = lane->id == 1 ?
++				     lane->priv->lane1_phy_regs :
++				     lane->priv->lane0_phy_regs;
++
++		comphy_reg_set16(base + COMPHY_LANE_REG_DIRECT(reg),
++				 data, mask);
++	}
++}
++
++static int comphy_lane_reg_poll(struct mvebu_a3700_comphy_lane *lane,
++				u16 reg, u16 bits,
++				ulong sleep_us, ulong timeout_us)
++{
++	int ret;
++
++	if (lane->id == 2) {
++		u32 data;
++
++		/* lane 2 PHY registers are accessed indirectly */
++		writel(reg + COMPHY_LANE2_REGS_BASE,
++		       lane->priv->lane2_phy_indirect +
++		       COMPHY_LANE2_INDIR_ADDR);
++
++		ret = readl_poll_timeout(lane->priv->lane2_phy_indirect +
++					 COMPHY_LANE2_INDIR_DATA,
++					 data, (data & bits) == bits,
++					 sleep_us, timeout_us);
++	} else {
++		void __iomem *base = lane->id == 1 ?
++				     lane->priv->lane1_phy_regs :
++				     lane->priv->lane0_phy_regs;
++		u16 data;
++
++		ret = readw_poll_timeout(base + COMPHY_LANE_REG_DIRECT(reg),
++					 data, (data & bits) == bits,
++					 sleep_us, timeout_us);
++	}
++
++	return ret;
++}
++
++static void comphy_periph_reg_set(struct mvebu_a3700_comphy_lane *lane,
++				  u8 reg, u32 data, u32 mask)
++{
++	comphy_reg_set(lane->priv->comphy_regs + COMPHY_PHY_REG(lane->id, reg),
++		       data, mask);
++}
++
++static int comphy_periph_reg_poll(struct mvebu_a3700_comphy_lane *lane,
++				  u8 reg, u32 bits,
++				  ulong sleep_us, ulong timeout_us)
++{
++	u32 data;
++
++	return readl_poll_timeout(lane->priv->comphy_regs +
++				  COMPHY_PHY_REG(lane->id, reg),
++				  data, (data & bits) == bits,
++				  sleep_us, timeout_us);
++}
++
++/* PHY selector configures with corresponding modes */
++static int
++mvebu_a3700_comphy_set_phy_selector(struct mvebu_a3700_comphy_lane *lane)
++{
++	u32 old, new, clr = 0, set = 0;
++	unsigned long flags;
++
++	switch (lane->mode) {
++	case PHY_MODE_SATA:
++		/* SATA must be in Lane2 */
++		if (lane->id == 2)
++			clr = COMPHY_SELECTOR_USB3_PHY_SEL_BIT;
++		else
++			goto error;
++		break;
++
++	case PHY_MODE_ETHERNET:
++		if (lane->id == 0)
++			clr = COMPHY_SELECTOR_USB3_GBE1_SEL_BIT;
++		else if (lane->id == 1)
++			clr = COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT;
++		else
++			goto error;
++		break;
++
++	case PHY_MODE_USB_HOST_SS:
++		if (lane->id == 2)
++			set = COMPHY_SELECTOR_USB3_PHY_SEL_BIT;
++		else if (lane->id == 0)
++			set = COMPHY_SELECTOR_USB3_GBE1_SEL_BIT;
++		else
++			goto error;
++		break;
++
++	case PHY_MODE_PCIE:
++		/* PCIE must be in Lane1 */
++		if (lane->id == 1)
++			set = COMPHY_SELECTOR_PCIE_GBE0_SEL_BIT;
++		else
++			goto error;
++		break;
++
++	default:
++		goto error;
++	}
++
++	spin_lock_irqsave(&lane->priv->lock, flags);
++
++	old = readl(lane->priv->comphy_regs + COMPHY_SELECTOR_PHY_REG);
++	new = (old & ~clr) | set;
++	writel(new, lane->priv->comphy_regs + COMPHY_SELECTOR_PHY_REG);
++
++	spin_unlock_irqrestore(&lane->priv->lock, flags);
++
++	dev_dbg(lane->dev,
++		"COMPHY[%d] mode[%d] changed PHY selector 0x%08x -> 0x%08x\n",
++		lane->id, lane->mode, old, new);
++
++	return 0;
++error:
++	dev_err(lane->dev, "COMPHY[%d] mode[%d] is invalid\n", lane->id,
++		lane->mode);
++	return -EINVAL;
++}
++
++static int
++mvebu_a3700_comphy_sata_power_on(struct mvebu_a3700_comphy_lane *lane)
++{
++	u32 mask, data, ref_clk;
++	int ret;
++
++	/* Configure phy selector for SATA */
++	ret = mvebu_a3700_comphy_set_phy_selector(lane);
++	if (ret)
++		return ret;
++
++	/* Clear phy isolation mode to make it work in normal mode */
++	comphy_lane_reg_set(lane, COMPHY_ISOLATION_CTRL,
++			    0x0, PHY_ISOLATE_MODE);
++
++	/* 0. Check the Polarity invert bits */
++	data = 0x0;
++	if (lane->invert_tx)
++		data |= TXD_INVERT_BIT;
++	if (lane->invert_rx)
++		data |= RXD_INVERT_BIT;
++	mask = TXD_INVERT_BIT | RXD_INVERT_BIT;
++	comphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);
++
++	/* 1. Select 40-bit data width */
++	comphy_lane_reg_set(lane, COMPHY_DIG_LOOPBACK_EN,
++			    DATA_WIDTH_40BIT, SEL_DATA_WIDTH_MASK);
++
++	/* 2. Select reference clock(25M) and PHY mode (SATA) */
++	if (lane->priv->xtal_is_40m)
++		ref_clk = REF_FREF_SEL_SERDES_40MHZ;
++	else
++		ref_clk = REF_FREF_SEL_SERDES_25MHZ;
++
++	data = ref_clk | COMPHY_MODE_SATA;
++	mask = REF_FREF_SEL_MASK | COMPHY_MODE_MASK;
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);
++
++	/* 3. Use maximum PLL rate (no power save) */
++	comphy_lane_reg_set(lane, COMPHY_KVCO_CAL_CTRL,
++			    USE_MAX_PLL_RATE_BIT, USE_MAX_PLL_RATE_BIT);
++
++	/* 4. Reset reserved bit */
++	comphy_set_indirect(lane->priv, COMPHY_RESERVED_REG,
++			    0x0, PHYCTRL_FRM_PIN_BIT);
++
++	/* 5. Set vendor-specific configuration (It is done in sata driver) */
++	/* XXX: in U-Boot below sequence was executed in this place, in Linux
++	 * not.  Now it is done only in U-Boot before this comphy
++	 * initialization - tests shows that it works ok, but in case of any
++	 * future problem it is left for reference.
++	 *   reg_set(MVEBU_REGS_BASE + 0xe00a0, 0, 0xffffffff);
++	 *   reg_set(MVEBU_REGS_BASE + 0xe00a4, BIT(6), BIT(6));
++	 */
++
++	/* Wait for > 55 us to allow PLL be enabled */
++	udelay(PLL_SET_DELAY_US);
++
++	/* Polling status */
++	ret = comphy_lane_reg_poll(lane, COMPHY_DIG_LOOPBACK_EN,
++				   PLL_READY_TX_BIT, COMPHY_PLL_SLEEP,
++				   COMPHY_PLL_TIMEOUT);
++	if (ret) {
++		dev_err(lane->dev, "Failed to lock SATA PLL\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static void comphy_gbe_phy_init(struct mvebu_a3700_comphy_lane *lane,
++				bool is_1gbps)
++{
++	int addr, fix_idx;
++	u16 val;
++
++	fix_idx = 0;
++	for (addr = 0; addr < 512; addr++) {
++		/*
++		 * All PHY register values are defined in full for 3.125Gbps
++		 * SERDES speed. The values required for 1.25 Gbps are almost
++		 * the same and only few registers should be "fixed" in
++		 * comparison to 3.125 Gbps values. These register values are
++		 * stored in "gbe_phy_init_fix" array.
++		 */
++		if (!is_1gbps && gbe_phy_init_fix[fix_idx].addr == addr) {
++			/* Use new value */
++			val = gbe_phy_init_fix[fix_idx].value;
++			if (fix_idx < ARRAY_SIZE(gbe_phy_init_fix))
++				fix_idx++;
++		} else {
++			val = gbe_phy_init[addr];
++		}
++
++		comphy_lane_reg_set(lane, addr, val, 0xFFFF);
++	}
++}
++
++static int
++mvebu_a3700_comphy_ethernet_power_on(struct mvebu_a3700_comphy_lane *lane)
++{
++	u32 mask, data, speed_sel;
++	int ret;
++
++	/* Set selector */
++	ret = mvebu_a3700_comphy_set_phy_selector(lane);
++	if (ret)
++		return ret;
++
++	/*
++	 * 1. Reset PHY by setting PHY input port PIN_RESET=1.
++	 * 2. Set PHY input port PIN_TX_IDLE=1, PIN_PU_IVREF=1 to keep
++	 *    PHY TXP/TXN output to idle state during PHY initialization
++	 * 3. Set PHY input port PIN_PU_PLL=0, PIN_PU_RX=0, PIN_PU_TX=0.
++	 */
++	data = PIN_PU_IVREF_BIT | PIN_TX_IDLE_BIT | PIN_RESET_COMPHY_BIT;
++	mask = data | PIN_RESET_CORE_BIT | PIN_PU_PLL_BIT | PIN_PU_RX_BIT |
++	       PIN_PU_TX_BIT | PHY_RX_INIT_BIT;
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);
++
++	/* 4. Release reset to the PHY by setting PIN_RESET=0. */
++	data = 0x0;
++	mask = PIN_RESET_COMPHY_BIT;
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);
++
++	/*
++	 * 5. Set PIN_PHY_GEN_TX[3:0] and PIN_PHY_GEN_RX[3:0] to decide COMPHY
++	 * bit rate
++	 */
++	switch (lane->submode) {
++	case PHY_INTERFACE_MODE_SGMII:
++	case PHY_INTERFACE_MODE_1000BASEX:
++		/* SGMII 1G, SerDes speed 1.25G */
++		speed_sel = SERDES_SPEED_1_25_G;
++		break;
++	case PHY_INTERFACE_MODE_2500BASEX:
++		/* 2500Base-X, SerDes speed 3.125G */
++		speed_sel = SERDES_SPEED_3_125_G;
++		break;
+ 	default:
++		/* Other rates are not supported */
++		dev_err(lane->dev,
++			"unsupported phy speed %d on comphy lane%d\n",
++			lane->submode, lane->id);
+ 		return -EINVAL;
+ 	}
++	data = GEN_RX_SEL_VALUE(speed_sel) | GEN_TX_SEL_VALUE(speed_sel);
++	mask = GEN_RX_SEL_MASK | GEN_TX_SEL_MASK;
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);
++
++	/*
++	 * 6. Wait 10mS for bandgap and reference clocks to stabilize; then
++	 * start SW programming.
++	 */
++	mdelay(10);
++
++	/* 7. Program COMPHY register PHY_MODE */
++	data = COMPHY_MODE_SERDES;
++	mask = COMPHY_MODE_MASK;
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);
++
++	/*
++	 * 8. Set COMPHY register REFCLK_SEL to select the correct REFCLK
++	 * source
++	 */
++	data = 0x0;
++	mask = PHY_REF_CLK_SEL;
++	comphy_lane_reg_set(lane, COMPHY_MISC_CTRL0, data, mask);
++
++	/*
++	 * 9. Set correct reference clock frequency in COMPHY register
++	 * REF_FREF_SEL.
++	 */
++	if (lane->priv->xtal_is_40m)
++		data = REF_FREF_SEL_SERDES_50MHZ;
++	else
++		data = REF_FREF_SEL_SERDES_25MHZ;
++
++	mask = REF_FREF_SEL_MASK;
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);
++
++	/* 10. Program COMPHY register PHY_GEN_MAX[1:0]
++	 * This step is mentioned in the flow received from verification team.
++	 * However the PHY_GEN_MAX value is only meaningful for other interfaces
++	 * (not SERDES). For instance, it selects SATA speed 1.5/3/6 Gbps or
++	 * PCIe speed 2.5/5 Gbps
++	 */
++
++	/*
++	 * 11. Program COMPHY register SEL_BITS to set correct parallel data
++	 * bus width
++	 */
++	data = DATA_WIDTH_10BIT;
++	mask = SEL_DATA_WIDTH_MASK;
++	comphy_lane_reg_set(lane, COMPHY_DIG_LOOPBACK_EN, data, mask);
++
++	/*
++	 * 12. As long as DFE function needs to be enabled in any mode,
++	 * COMPHY register DFE_UPDATE_EN[5:0] shall be programmed to 0x3F
++	 * for real chip during COMPHY power on.
++	 * The step 14 exists (and empty) in the original initialization flow
++	 * obtained from the verification team. According to the functional
++	 * specification DFE_UPDATE_EN already has the default value 0x3F
++	 */
++
++	/*
++	 * 13. Program COMPHY GEN registers.
++	 * These registers should be programmed based on the lab testing result
++	 * to achieve optimal performance. Please contact the CEA group to get
++	 * the related GEN table during real chip bring-up. We only required to
++	 * run though the entire registers programming flow defined by
++	 * "comphy_gbe_phy_init" when the REF clock is 40 MHz. For REF clock
++	 * 25 MHz the default values stored in PHY registers are OK.
++	 */
++	dev_dbg(lane->dev, "Running C-DPI phy init %s mode\n",
++		lane->submode == PHY_INTERFACE_MODE_2500BASEX ? "2G5" : "1G");
++	if (lane->priv->xtal_is_40m)
++		comphy_gbe_phy_init(lane,
++				    lane->submode != PHY_INTERFACE_MODE_2500BASEX);
++
++	/*
++	 * 14. [Simulation Only] should not be used for real chip.
++	 * By pass power up calibration by programming EXT_FORCE_CAL_DONE
++	 * (R02h[9]) to 1 to shorten COMPHY simulation time.
++	 */
++
++	/*
++	 * 15. [Simulation Only: should not be used for real chip]
++	 * Program COMPHY register FAST_DFE_TIMER_EN=1 to shorten RX training
++	 * simulation time.
++	 */
++
++	/*
++	 * 16. Check the PHY Polarity invert bit
++	 */
++	data = 0x0;
++	if (lane->invert_tx)
++		data |= TXD_INVERT_BIT;
++	if (lane->invert_rx)
++		data |= RXD_INVERT_BIT;
++	mask = TXD_INVERT_BIT | RXD_INVERT_BIT;
++	comphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);
++
++	/*
++	 * 17. Set PHY input ports PIN_PU_PLL, PIN_PU_TX and PIN_PU_RX to 1 to
++	 * start PHY power up sequence. All the PHY register programming should
++	 * be done before PIN_PU_PLL=1. There should be no register programming
++	 * for normal PHY operation from this point.
++	 */
++	data = PIN_PU_PLL_BIT | PIN_PU_RX_BIT | PIN_PU_TX_BIT;
++	mask = data;
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);
++
++	/*
++	 * 18. Wait for PHY power up sequence to finish by checking output ports
++	 * PIN_PLL_READY_TX=1 and PIN_PLL_READY_RX=1.
++	 */
++	ret = comphy_periph_reg_poll(lane, COMPHY_PHY_STAT1,
++				     PHY_PLL_READY_TX_BIT |
++				     PHY_PLL_READY_RX_BIT,
++				     COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);
++	if (ret) {
++		dev_err(lane->dev, "Failed to lock PLL for SERDES PHY %d\n",
++			lane->id);
++		return ret;
++	}
++
++	/*
++	 * 19. Set COMPHY input port PIN_TX_IDLE=0
++	 */
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, 0x0, PIN_TX_IDLE_BIT);
++
++	/*
++	 * 20. After valid data appear on PIN_RXDATA bus, set PIN_RX_INIT=1. To
++	 * start RX initialization. PIN_RX_INIT_DONE will be cleared to 0 by the
++	 * PHY After RX initialization is done, PIN_RX_INIT_DONE will be set to
++	 * 1 by COMPHY Set PIN_RX_INIT=0 after PIN_RX_INIT_DONE= 1. Please
++	 * refer to RX initialization part for details.
++	 */
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1,
++			      PHY_RX_INIT_BIT, PHY_RX_INIT_BIT);
++
++	ret = comphy_periph_reg_poll(lane, COMPHY_PHY_STAT1,
++				     PHY_PLL_READY_TX_BIT |
++				     PHY_PLL_READY_RX_BIT,
++				     COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);
++	if (ret) {
++		dev_err(lane->dev, "Failed to lock PLL for SERDES PHY %d\n",
++			lane->id);
++		return ret;
++	}
++
++	ret = comphy_periph_reg_poll(lane, COMPHY_PHY_STAT1,
++				     PHY_RX_INIT_DONE_BIT,
++				     COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);
++	if (ret) {
++		dev_err(lane->dev, "Failed to init RX of SERDES PHY %d\n",
++			lane->id);
++		return ret;
++	}
++
++	return 0;
+ }
+ 
+-static int mvebu_a3700_comphy_get_fw_mode(int lane,
++static int
++mvebu_a3700_comphy_usb3_power_on(struct mvebu_a3700_comphy_lane *lane)
++{
++	u32 mask, data, cfg, ref_clk;
++	int ret;
++
++	/* Set phy seclector */
++	ret = mvebu_a3700_comphy_set_phy_selector(lane);
++	if (ret)
++		return ret;
++
++	/*
++	 * 0. Set PHY OTG Control(0x5d034), bit 4, Power up OTG module The
++	 * register belong to UTMI module, so it is set in UTMI phy driver.
++	 */
++
++	/*
++	 * 1. Set PRD_TXDEEMPH (3.5db de-emph)
++	 */
++	data = PRD_TXDEEMPH0_MASK;
++	mask = PRD_TXDEEMPH0_MASK | PRD_TXMARGIN_MASK | PRD_TXSWING_MASK |
++	       CFG_TX_ALIGN_POS_MASK;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG0, data, mask);
++
++	/*
++	 * 2. Set BIT0: enable transmitter in high impedance mode
++	 *    Set BIT[3:4]: delay 2 clock cycles for HiZ off latency
++	 *    Set BIT6: Tx detect Rx at HiZ mode
++	 *    Unset BIT15: set to 0 to set USB3 De-emphasize level to -3.5db
++	 *            together with bit 0 of COMPHY_PIPE_LANE_CFG0 register
++	 */
++	data = TX_DET_RX_MODE | GEN2_TX_DATA_DLY_DEFT | TX_ELEC_IDLE_MODE_EN;
++	mask = PRD_TXDEEMPH1_MASK | TX_DET_RX_MODE | GEN2_TX_DATA_DLY_MASK |
++	       TX_ELEC_IDLE_MODE_EN;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG1, data, mask);
++
++	/*
++	 * 3. Set Spread Spectrum Clock Enabled
++	 */
++	comphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG4,
++			    SPREAD_SPECTRUM_CLK_EN, SPREAD_SPECTRUM_CLK_EN);
++
++	/*
++	 * 4. Set Override Margining Controls From the MAC:
++	 *    Use margining signals from lane configuration
++	 */
++	comphy_lane_reg_set(lane, COMPHY_PIPE_TEST_MODE_CTRL,
++			    MODE_MARGIN_OVERRIDE, 0xFFFF);
++
++	/*
++	 * 5. Set Lane-to-Lane Bundle Clock Sampling Period = per PCLK cycles
++	 *    set Mode Clock Source = PCLK is generated from REFCLK
++	 */
++	data = 0x0;
++	mask = MODE_CLK_SRC | BUNDLE_PERIOD_SEL | BUNDLE_PERIOD_SCALE_MASK |
++	       BUNDLE_SAMPLE_CTRL | PLL_READY_DLY_MASK;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_CLK_SRC_LO, data, mask);
++
++	/*
++	 * 6. Set G2 Spread Spectrum Clock Amplitude at 4K
++	 */
++	comphy_lane_reg_set(lane, COMPHY_GEN2_SET2,
++			    GS2_TX_SSC_AMP_4128, GS2_TX_SSC_AMP_MASK);
++
++	/*
++	 * 7. Unset G3 Spread Spectrum Clock Amplitude
++	 *    set G3 TX and RX Register Master Current Select
++	 */
++	data = GS2_VREG_RXTX_MAS_ISET_60U;
++	mask = GS2_TX_SSC_AMP_MASK | GS2_VREG_RXTX_MAS_ISET_MASK |
++	       GS2_RSVD_6_0_MASK;
++	comphy_lane_reg_set(lane, COMPHY_GEN3_SET2, data, mask);
++
++	/*
++	 * 8. Check crystal jumper setting and program the Power and PLL Control
++	 * accordingly Change RX wait
++	 */
++	if (lane->priv->xtal_is_40m) {
++		ref_clk = REF_FREF_SEL_PCIE_USB3_40MHZ;
++		cfg = CFG_PM_RXDLOZ_WAIT_12_UNIT;
++	} else {
++		ref_clk = REF_FREF_SEL_PCIE_USB3_25MHZ;
++		cfg = CFG_PM_RXDLOZ_WAIT_7_UNIT;
++	}
++
++	data = PU_IVREF_BIT | PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT |
++	       PU_TX_INTP_BIT | PU_DFE_BIT | COMPHY_MODE_USB3 | ref_clk;
++	mask = PU_IVREF_BIT | PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT |
++	       PU_TX_INTP_BIT | PU_DFE_BIT | PLL_LOCK_BIT | COMPHY_MODE_MASK |
++	       REF_FREF_SEL_MASK;
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);
++
++	data = CFG_PM_RXDEN_WAIT_1_UNIT | cfg;
++	mask = CFG_PM_OSCCLK_WAIT_MASK | CFG_PM_RXDEN_WAIT_MASK |
++	       CFG_PM_RXDLOZ_WAIT_MASK;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_PWR_MGM_TIM1, data, mask);
++
++	/*
++	 * 9. Enable idle sync
++	 */
++	comphy_lane_reg_set(lane, COMPHY_IDLE_SYNC_EN,
++			    IDLE_SYNC_EN, IDLE_SYNC_EN);
++
++	/*
++	 * 10. Enable the output of 500M clock
++	 */
++	comphy_lane_reg_set(lane, COMPHY_MISC_CTRL0, CLK500M_EN, CLK500M_EN);
++
++	/*
++	 * 11. Set 20-bit data width
++	 */
++	comphy_lane_reg_set(lane, COMPHY_DIG_LOOPBACK_EN,
++			    DATA_WIDTH_20BIT, 0xFFFF);
++
++	/*
++	 * 12. Override Speed_PLL value and use MAC PLL
++	 */
++	data = SPEED_PLL_VALUE_16 | USE_MAX_PLL_RATE_BIT;
++	mask = 0xFFFF;
++	comphy_lane_reg_set(lane, COMPHY_KVCO_CAL_CTRL, data, mask);
++
++	/*
++	 * 13. Check the Polarity invert bit
++	 */
++	data = 0x0;
++	if (lane->invert_tx)
++		data |= TXD_INVERT_BIT;
++	if (lane->invert_rx)
++		data |= RXD_INVERT_BIT;
++	mask = TXD_INVERT_BIT | RXD_INVERT_BIT;
++	comphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);
++
++	/*
++	 * 14. Set max speed generation to USB3.0 5Gbps
++	 */
++	comphy_lane_reg_set(lane, COMPHY_SYNC_MASK_GEN,
++			    PHY_GEN_MAX_USB3_5G, PHY_GEN_MAX_MASK);
++
++	/*
++	 * 15. Set capacitor value for FFE gain peaking to 0xF
++	 */
++	comphy_lane_reg_set(lane, COMPHY_GEN2_SET3,
++			    GS3_FFE_CAP_SEL_VALUE, GS3_FFE_CAP_SEL_MASK);
++
++	/*
++	 * 16. Release SW reset
++	 */
++	data = MODE_CORE_CLK_FREQ_SEL | MODE_PIPE_WIDTH_32 | MODE_REFDIV_BY_4;
++	mask = 0xFFFF;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_RST_CLK_CTRL, data, mask);
++
++	/* Wait for > 55 us to allow PCLK be enabled */
++	udelay(PLL_SET_DELAY_US);
++
++	ret = comphy_lane_reg_poll(lane, COMPHY_PIPE_LANE_STAT1, TXDCLK_PCLK_EN,
++				   COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);
++	if (ret) {
++		dev_err(lane->dev, "Failed to lock USB3 PLL\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static int
++mvebu_a3700_comphy_pcie_power_on(struct mvebu_a3700_comphy_lane *lane)
++{
++	u32 mask, data, ref_clk;
++	int ret;
++
++	/* Configure phy selector for PCIe */
++	ret = mvebu_a3700_comphy_set_phy_selector(lane);
++	if (ret)
++		return ret;
++
++	/* 1. Enable max PLL. */
++	comphy_lane_reg_set(lane, COMPHY_PIPE_LANE_CFG1,
++			    USE_MAX_PLL_RATE_EN, USE_MAX_PLL_RATE_EN);
++
++	/* 2. Select 20 bit SERDES interface. */
++	comphy_lane_reg_set(lane, COMPHY_PIPE_CLK_SRC_LO,
++			    CFG_SEL_20B, CFG_SEL_20B);
++
++	/* 3. Force to use reg setting for PCIe mode */
++	comphy_lane_reg_set(lane, COMPHY_MISC_CTRL1,
++			    SEL_BITS_PCIE_FORCE, SEL_BITS_PCIE_FORCE);
++
++	/* 4. Change RX wait */
++	data = CFG_PM_RXDEN_WAIT_1_UNIT | CFG_PM_RXDLOZ_WAIT_12_UNIT;
++	mask = CFG_PM_OSCCLK_WAIT_MASK | CFG_PM_RXDEN_WAIT_MASK |
++	       CFG_PM_RXDLOZ_WAIT_MASK;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_PWR_MGM_TIM1, data, mask);
++
++	/* 5. Enable idle sync */
++	comphy_lane_reg_set(lane, COMPHY_IDLE_SYNC_EN,
++			    IDLE_SYNC_EN, IDLE_SYNC_EN);
++
++	/* 6. Enable the output of 100M/125M/500M clock */
++	data = CLK500M_EN | TXDCLK_2X_SEL | CLK100M_125M_EN;
++	mask = data;
++	comphy_lane_reg_set(lane, COMPHY_MISC_CTRL0, data, mask);
++
++	/*
++	 * 7. Enable TX, PCIE global register, 0xd0074814, it is done in
++	 * PCI-E driver
++	 */
++
++	/*
++	 * 8. Check crystal jumper setting and program the Power and PLL
++	 * Control accordingly
++	 */
++
++	if (lane->priv->xtal_is_40m)
++		ref_clk = REF_FREF_SEL_PCIE_USB3_40MHZ;
++	else
++		ref_clk = REF_FREF_SEL_PCIE_USB3_25MHZ;
++
++	data = PU_IVREF_BIT | PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT |
++	       PU_TX_INTP_BIT | PU_DFE_BIT | COMPHY_MODE_PCIE | ref_clk;
++	mask = 0xFFFF;
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL, data, mask);
++
++	/* 9. Override Speed_PLL value and use MAC PLL */
++	comphy_lane_reg_set(lane, COMPHY_KVCO_CAL_CTRL,
++			    SPEED_PLL_VALUE_16 | USE_MAX_PLL_RATE_BIT,
++			    0xFFFF);
++
++	/* 10. Check the Polarity invert bit */
++	data = 0x0;
++	if (lane->invert_tx)
++		data |= TXD_INVERT_BIT;
++	if (lane->invert_rx)
++		data |= RXD_INVERT_BIT;
++	mask = TXD_INVERT_BIT | RXD_INVERT_BIT;
++	comphy_lane_reg_set(lane, COMPHY_SYNC_PATTERN, data, mask);
++
++	/* 11. Release SW reset */
++	data = MODE_CORE_CLK_FREQ_SEL | MODE_PIPE_WIDTH_32;
++	mask = data | PIPE_SOFT_RESET | MODE_REFDIV_MASK;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_RST_CLK_CTRL, data, mask);
++
++	/* Wait for > 55 us to allow PCLK be enabled */
++	udelay(PLL_SET_DELAY_US);
++
++	ret = comphy_lane_reg_poll(lane, COMPHY_PIPE_LANE_STAT1, TXDCLK_PCLK_EN,
++				   COMPHY_PLL_SLEEP, COMPHY_PLL_TIMEOUT);
++	if (ret) {
++		dev_err(lane->dev, "Failed to lock PCIE PLL\n");
++		return ret;
++	}
++
++	return 0;
++}
++
++static void
++mvebu_a3700_comphy_usb3_power_off(struct mvebu_a3700_comphy_lane *lane)
++{
++	/*
++	 * Currently the USB3 MAC sets the USB3 PHY to low state, so we do not
++	 * need to power off USB3 PHY again.
++	 */
++}
++
++static void
++mvebu_a3700_comphy_sata_power_off(struct mvebu_a3700_comphy_lane *lane)
++{
++	/* Set phy isolation mode */
++	comphy_lane_reg_set(lane, COMPHY_ISOLATION_CTRL,
++			    PHY_ISOLATE_MODE, PHY_ISOLATE_MODE);
++
++	/* Power off PLL, Tx, Rx */
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL,
++			    0x0, PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT);
++}
++
++static void
++mvebu_a3700_comphy_ethernet_power_off(struct mvebu_a3700_comphy_lane *lane)
++{
++	u32 mask, data;
++
++	data = PIN_RESET_CORE_BIT | PIN_RESET_COMPHY_BIT | PIN_PU_IVREF_BIT |
++	       PHY_RX_INIT_BIT;
++	mask = data;
++	comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);
++}
++
++static void
++mvebu_a3700_comphy_pcie_power_off(struct mvebu_a3700_comphy_lane *lane)
++{
++	/* Power off PLL, Tx, Rx */
++	comphy_lane_reg_set(lane, COMPHY_POWER_PLL_CTRL,
++			    0x0, PU_PLL_BIT | PU_RX_BIT | PU_TX_BIT);
++}
++
++static int mvebu_a3700_comphy_reset(struct phy *phy)
++{
++	struct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);
++	u16 mask, data;
++
++	dev_dbg(lane->dev, "resetting lane %d\n", lane->id);
++
++	/* COMPHY reset for internal logic */
++	comphy_lane_reg_set(lane, COMPHY_SFT_RESET,
++			    SFT_RST_NO_REG, SFT_RST_NO_REG);
++
++	/* COMPHY register reset (cleared automatically) */
++	comphy_lane_reg_set(lane, COMPHY_SFT_RESET, SFT_RST, SFT_RST);
++
++	/* PIPE soft and register reset */
++	data = PIPE_SOFT_RESET | PIPE_REG_RESET;
++	mask = data;
++	comphy_lane_reg_set(lane, COMPHY_PIPE_RST_CLK_CTRL, data, mask);
++
++	/* Release PIPE register reset */
++	comphy_lane_reg_set(lane, COMPHY_PIPE_RST_CLK_CTRL,
++			    0x0, PIPE_REG_RESET);
++
++	/* Reset SB configuration register (only for lanes 0 and 1) */
++	if (lane->id == 0 || lane->id == 1) {
++		u32 mask, data;
++
++		data = PIN_RESET_CORE_BIT | PIN_RESET_COMPHY_BIT |
++		       PIN_PU_PLL_BIT | PIN_PU_RX_BIT | PIN_PU_TX_BIT;
++		mask = data | PIN_PU_IVREF_BIT | PIN_TX_IDLE_BIT;
++		comphy_periph_reg_set(lane, COMPHY_PHY_CFG1, data, mask);
++	}
++
++	return 0;
++}
++
++static bool mvebu_a3700_comphy_check_mode(int lane,
+ 					  enum phy_mode mode,
+ 					  int submode)
+ {
+@@ -122,7 +1170,7 @@ static int mvebu_a3700_comphy_get_fw_mod
+ 
+ 	/* Unused PHY mux value is 0x0 */
+ 	if (mode == PHY_MODE_INVALID)
+-		return -EINVAL;
++		return false;
+ 
+ 	for (i = 0; i < n; i++) {
+ 		if (mvebu_a3700_comphy_modes[i].lane == lane &&
+@@ -132,27 +1180,30 @@ static int mvebu_a3700_comphy_get_fw_mod
+ 	}
+ 
+ 	if (i == n)
+-		return -EINVAL;
++		return false;
+ 
+-	return mvebu_a3700_comphy_modes[i].fw_mode;
++	return true;
+ }
+ 
+ static int mvebu_a3700_comphy_set_mode(struct phy *phy, enum phy_mode mode,
+ 				       int submode)
+ {
+ 	struct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);
+-	int fw_mode;
+-
+-	if (submode == PHY_INTERFACE_MODE_1000BASEX)
+-		submode = PHY_INTERFACE_MODE_SGMII;
+ 
+-	fw_mode = mvebu_a3700_comphy_get_fw_mode(lane->id, mode,
+-						 submode);
+-	if (fw_mode < 0) {
++	if (!mvebu_a3700_comphy_check_mode(lane->id, mode, submode)) {
+ 		dev_err(lane->dev, "invalid COMPHY mode\n");
+-		return fw_mode;
++		return -EINVAL;
+ 	}
+ 
++	/* Mode cannot be changed while the PHY is powered on */
++	if (phy->power_count &&
++	    (lane->mode != mode || lane->submode != submode))
++		return -EBUSY;
++
++	/* If changing mode, ensure reset is called */
++	if (lane->mode != PHY_MODE_INVALID && lane->mode != mode)
++		lane->needs_reset = true;
++
+ 	/* Just remember the mode, ->power_on() will do the real setup */
+ 	lane->mode = mode;
+ 	lane->submode = submode;
+@@ -163,76 +1214,68 @@ static int mvebu_a3700_comphy_set_mode(s
+ static int mvebu_a3700_comphy_power_on(struct phy *phy)
+ {
+ 	struct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);
+-	u32 fw_param;
+-	int fw_mode;
+-	int fw_port;
+ 	int ret;
+ 
+-	fw_mode = mvebu_a3700_comphy_get_fw_mode(lane->id,
+-						 lane->mode, lane->submode);
+-	if (fw_mode < 0) {
++	if (!mvebu_a3700_comphy_check_mode(lane->id, lane->mode,
++					   lane->submode)) {
+ 		dev_err(lane->dev, "invalid COMPHY mode\n");
+-		return fw_mode;
++		return -EINVAL;
++	}
++
++	if (lane->needs_reset) {
++		ret = mvebu_a3700_comphy_reset(phy);
++		if (ret)
++			return ret;
++
++		lane->needs_reset = false;
+ 	}
+ 
+ 	switch (lane->mode) {
+ 	case PHY_MODE_USB_HOST_SS:
+ 		dev_dbg(lane->dev, "set lane %d to USB3 host mode\n", lane->id);
+-		fw_param = COMPHY_FW_MODE(fw_mode);
+-		break;
++		return mvebu_a3700_comphy_usb3_power_on(lane);
+ 	case PHY_MODE_SATA:
+ 		dev_dbg(lane->dev, "set lane %d to SATA mode\n", lane->id);
+-		fw_param = COMPHY_FW_MODE(fw_mode);
+-		break;
++		return mvebu_a3700_comphy_sata_power_on(lane);
+ 	case PHY_MODE_ETHERNET:
+-		fw_port = (lane->id == 0) ? 1 : 0;
+-		switch (lane->submode) {
+-		case PHY_INTERFACE_MODE_SGMII:
+-			dev_dbg(lane->dev, "set lane %d to SGMII mode\n",
+-				lane->id);
+-			fw_param = COMPHY_FW_NET(fw_mode, fw_port,
+-						 COMPHY_FW_SPEED_1_25G);
+-			break;
+-		case PHY_INTERFACE_MODE_2500BASEX:
+-			dev_dbg(lane->dev, "set lane %d to 2500BASEX mode\n",
+-				lane->id);
+-			fw_param = COMPHY_FW_NET(fw_mode, fw_port,
+-						 COMPHY_FW_SPEED_3_125G);
+-			break;
+-		default:
+-			dev_err(lane->dev, "unsupported PHY submode (%d)\n",
+-				lane->submode);
+-			return -ENOTSUPP;
+-		}
+-		break;
++		dev_dbg(lane->dev, "set lane %d to Ethernet mode\n", lane->id);
++		return mvebu_a3700_comphy_ethernet_power_on(lane);
+ 	case PHY_MODE_PCIE:
+ 		dev_dbg(lane->dev, "set lane %d to PCIe mode\n", lane->id);
+-		fw_param = COMPHY_FW_PCIE(fw_mode, COMPHY_FW_SPEED_5G,
+-					  phy->attrs.bus_width);
+-		break;
++		return mvebu_a3700_comphy_pcie_power_on(lane);
+ 	default:
+ 		dev_err(lane->dev, "unsupported PHY mode (%d)\n", lane->mode);
+-		return -ENOTSUPP;
++		return -EOPNOTSUPP;
+ 	}
+-
+-	ret = mvebu_a3700_comphy_smc(COMPHY_SIP_POWER_ON, lane->id, fw_param);
+-	if (ret == -EOPNOTSUPP)
+-		dev_err(lane->dev,
+-			"unsupported SMC call, try updating your firmware\n");
+-
+-	return ret;
+ }
+ 
+ static int mvebu_a3700_comphy_power_off(struct phy *phy)
+ {
+ 	struct mvebu_a3700_comphy_lane *lane = phy_get_drvdata(phy);
+ 
+-	return mvebu_a3700_comphy_smc(COMPHY_SIP_POWER_OFF, lane->id, 0);
++	switch (lane->mode) {
++	case PHY_MODE_USB_HOST_SS:
++		mvebu_a3700_comphy_usb3_power_off(lane);
++		return 0;
++	case PHY_MODE_SATA:
++		mvebu_a3700_comphy_sata_power_off(lane);
++		return 0;
++	case PHY_MODE_ETHERNET:
++		mvebu_a3700_comphy_ethernet_power_off(lane);
++		return 0;
++	case PHY_MODE_PCIE:
++		mvebu_a3700_comphy_pcie_power_off(lane);
++		return 0;
++	default:
++		dev_err(lane->dev, "invalid COMPHY mode\n");
++		return -EINVAL;
++	}
+ }
+ 
+ static const struct phy_ops mvebu_a3700_comphy_ops = {
+ 	.power_on	= mvebu_a3700_comphy_power_on,
+ 	.power_off	= mvebu_a3700_comphy_power_off,
++	.reset		= mvebu_a3700_comphy_reset,
+ 	.set_mode	= mvebu_a3700_comphy_set_mode,
+ 	.owner		= THIS_MODULE,
+ };
+@@ -256,13 +1299,75 @@ static struct phy *mvebu_a3700_comphy_xl
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
++	lane->invert_tx = args->args[1] & BIT(0);
++	lane->invert_rx = args->args[1] & BIT(1);
++
+ 	return phy;
+ }
+ 
+ static int mvebu_a3700_comphy_probe(struct platform_device *pdev)
+ {
++	struct mvebu_a3700_comphy_priv *priv;
+ 	struct phy_provider *provider;
+ 	struct device_node *child;
++	struct resource *res;
++	struct clk *clk;
++	int ret;
++
++	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++
++	spin_lock_init(&priv->lock);
++
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "comphy");
++	priv->comphy_regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(priv->comphy_regs))
++		return PTR_ERR(priv->comphy_regs);
++
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
++					   "lane1_pcie_gbe");
++	priv->lane1_phy_regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(priv->lane1_phy_regs))
++		return PTR_ERR(priv->lane1_phy_regs);
++
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
++					   "lane0_usb3_gbe");
++	priv->lane0_phy_regs = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(priv->lane0_phy_regs))
++		return PTR_ERR(priv->lane0_phy_regs);
++
++	res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
++					   "lane2_sata_usb3");
++	priv->lane2_phy_indirect = devm_ioremap_resource(&pdev->dev, res);
++	if (IS_ERR(priv->lane2_phy_indirect))
++		return PTR_ERR(priv->lane2_phy_indirect);
++
++	/*
++	 * Driver needs to know if reference xtal clock is 40MHz or 25MHz.
++	 * Old DT bindings do not have xtal clk present. So do not fail here
++	 * and expects that default 25MHz reference clock is used.
++	 */
++	clk = clk_get(&pdev->dev, "xtal");
++	if (IS_ERR(clk)) {
++		if (PTR_ERR(clk) == -EPROBE_DEFER)
++			return -EPROBE_DEFER;
++		dev_warn(&pdev->dev, "missing 'xtal' clk (%ld)\n",
++			 PTR_ERR(clk));
++	} else {
++		ret = clk_prepare_enable(clk);
++		if (ret) {
++			dev_warn(&pdev->dev, "enabling xtal clk failed (%d)\n",
++				 ret);
++		} else {
++			if (clk_get_rate(clk) == 40000000)
++				priv->xtal_is_40m = true;
++			clk_disable_unprepare(clk);
++		}
++		clk_put(clk);
++	}
++
++	dev_set_drvdata(&pdev->dev, priv);
+ 
+ 	for_each_available_child_of_node(pdev->dev.of_node, child) {
+ 		struct mvebu_a3700_comphy_lane *lane;
+@@ -277,7 +1382,7 @@ static int mvebu_a3700_comphy_probe(stru
+ 			continue;
+ 		}
+ 
+-		if (lane_id >= MVEBU_A3700_COMPHY_LANES) {
++		if (lane_id >= 3) {
+ 			dev_err(&pdev->dev, "invalid 'reg' property\n");
+ 			continue;
+ 		}
+@@ -295,11 +1400,21 @@ static int mvebu_a3700_comphy_probe(stru
+ 			return PTR_ERR(phy);
+ 		}
+ 
++		lane->priv = priv;
+ 		lane->dev = &pdev->dev;
+ 		lane->mode = PHY_MODE_INVALID;
+ 		lane->submode = PHY_INTERFACE_MODE_NA;
+ 		lane->id = lane_id;
++		lane->invert_tx = false;
++		lane->invert_rx = false;
+ 		phy_set_drvdata(phy, lane);
++
++		/*
++		 * To avoid relying on the bootloader/firmware configuration,
++		 * power off all comphys.
++		 */
++		mvebu_a3700_comphy_reset(phy);
++		lane->needs_reset = false;
+ 	}
+ 
+ 	provider = devm_of_phy_provider_register(&pdev->dev,
+@@ -323,5 +1438,7 @@ static struct platform_driver mvebu_a370
+ module_platform_driver(mvebu_a3700_comphy_driver);
+ 
+ MODULE_AUTHOR("Miquèl Raynal <miquel.raynal@bootlin.com>");
++MODULE_AUTHOR("Pali Rohár <pali@kernel.org>");
++MODULE_AUTHOR("Marek Behún <kabel@kernel.org>");
+ MODULE_DESCRIPTION("Common PHY driver for A3700");
+ MODULE_LICENSE("GPL v2");
diff -uprN a/target/linux/generic/pending-5.10/851-0003-arm64-dts-marvell-armada-37xx-Add-xtal-clock-to-comp.patch b/target/linux/generic/pending-5.10/851-0003-arm64-dts-marvell-armada-37xx-Add-xtal-clock-to-comp.patch
--- a/target/linux/generic/pending-5.10/851-0003-arm64-dts-marvell-armada-37xx-Add-xtal-clock-to-comp.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/851-0003-arm64-dts-marvell-armada-37xx-Add-xtal-clock-to-comp.patch	2024-03-18 15:16:23.594641422 +0800
@@ -0,0 +1,31 @@
+From 66c51c39fd4bf05e99debf0e71de5704231c57dc Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 23 Sep 2021 19:26:26 +0200
+Subject: [PATCH] arm64: dts: marvell: armada-37xx: Add xtal clock to comphy
+ node
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Kernel driver phy-mvebu-a3700-comphy.c needs to know the rate of the
+reference xtal clock. So add missing xtal clock source into comphy device
+tree node. If the property is not present, the driver defaults to 25 MHz
+xtal rate (which, as far as we know, is used by all the existing boards).
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+---
+ arch/arm64/boot/dts/marvell/armada-37xx.dtsi | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
++++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi
+@@ -265,6 +265,8 @@
+ 					    "lane2_sata_usb3";
+ 				#address-cells = <1>;
+ 				#size-cells = <0>;
++				clocks = <&xtalclk>;
++				clock-names = "xtal";
+ 
+ 				comphy0: phy@0 {
+ 					reg = <0>;
diff -uprN a/target/linux/generic/pending-5.10/851-0004-Revert-ata-ahci-mvebu-Make-SATA-PHY-optional-for-Arm.patch b/target/linux/generic/pending-5.10/851-0004-Revert-ata-ahci-mvebu-Make-SATA-PHY-optional-for-Arm.patch
--- a/target/linux/generic/pending-5.10/851-0004-Revert-ata-ahci-mvebu-Make-SATA-PHY-optional-for-Arm.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/851-0004-Revert-ata-ahci-mvebu-Make-SATA-PHY-optional-for-Arm.patch	2024-03-18 15:16:23.630640048 +0800
@@ -0,0 +1,61 @@
+From 750bb44dbbe9dfb4ba3e1f8a746b831b39ba3cd9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 23 Sep 2021 19:35:57 +0200
+Subject: [PATCH] Revert "ata: ahci: mvebu: Make SATA PHY optional for Armada
+ 3720"
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This reverts commit 45aefe3d2251e4e229d7662052739f96ad1d08d9.
+
+Armada 3720 PHY driver (phy-mvebu-a3700-comphy.c) does not return
+-EOPNOTSUPP from phy_power_on() callback anymore.
+
+So remove AHCI_HFLAG_IGN_NOTSUPP_POWER_ON flag from Armada 3720 plat data.
+
+AHCI_HFLAG_IGN_NOTSUPP_POWER_ON is not used by any other ahci driver, so
+remove this flag completely.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Acked-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/ata/ahci.h             | 2 --
+ drivers/ata/ahci_mvebu.c       | 2 +-
+ drivers/ata/libahci_platform.c | 2 +-
+ 3 files changed, 2 insertions(+), 4 deletions(-)
+
+--- a/drivers/ata/ahci.h
++++ b/drivers/ata/ahci.h
+@@ -240,8 +240,6 @@ enum {
+ 							as default lpm_policy */
+ 	AHCI_HFLAG_SUSPEND_PHYS		= (1 << 26), /* handle PHYs during
+ 							suspend/resume */
+-	AHCI_HFLAG_IGN_NOTSUPP_POWER_ON	= (1 << 27), /* ignore -EOPNOTSUPP
+-							from phy_power_on() */
+ 	AHCI_HFLAG_NO_SXS		= (1 << 28), /* SXS not supported */
+ 
+ 	/* ap->flags bits */
+--- a/drivers/ata/ahci_mvebu.c
++++ b/drivers/ata/ahci_mvebu.c
+@@ -227,7 +227,7 @@ static const struct ahci_mvebu_plat_data
+ 
+ static const struct ahci_mvebu_plat_data ahci_mvebu_armada_3700_plat_data = {
+ 	.plat_config = ahci_mvebu_armada_3700_config,
+-	.flags = AHCI_HFLAG_SUSPEND_PHYS | AHCI_HFLAG_IGN_NOTSUPP_POWER_ON,
++	.flags = AHCI_HFLAG_SUSPEND_PHYS,
+ };
+ 
+ static const struct of_device_id ahci_mvebu_of_match[] = {
+--- a/drivers/ata/libahci_platform.c
++++ b/drivers/ata/libahci_platform.c
+@@ -59,7 +59,7 @@ int ahci_platform_enable_phys(struct ahc
+ 		}
+ 
+ 		rc = phy_power_on(hpriv->phys[i]);
+-		if (rc && !(rc == -EOPNOTSUPP && (hpriv->flags & AHCI_HFLAG_IGN_NOTSUPP_POWER_ON))) {
++		if (rc) {
+ 			phy_exit(hpriv->phys[i]);
+ 			goto disable_phys;
+ 		}
diff -uprN a/target/linux/generic/pending-5.10/851-0005-Revert-usb-host-xhci-mvebu-make-USB-3.0-PHY-optional.patch b/target/linux/generic/pending-5.10/851-0005-Revert-usb-host-xhci-mvebu-make-USB-3.0-PHY-optional.patch
--- a/target/linux/generic/pending-5.10/851-0005-Revert-usb-host-xhci-mvebu-make-USB-3.0-PHY-optional.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/851-0005-Revert-usb-host-xhci-mvebu-make-USB-3.0-PHY-optional.patch	2024-03-18 15:16:23.614640659 +0800
@@ -0,0 +1,163 @@
+From 9f0dfb279b1dd505d5e10b10e4a78a62030978d8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 23 Sep 2021 19:40:06 +0200
+Subject: [PATCH] Revert "usb: host: xhci: mvebu: make USB 3.0 PHY optional for
+ Armada 3720"
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This reverts commit 3241929b67d28c83945d3191c6816a3271fd6b85.
+
+Armada 3720 phy driver (phy-mvebu-a3700-comphy.c) does not return
+-EOPNOTSUPP from phy_power_on() callback anymore.
+
+So remove XHCI_SKIP_PHY_INIT flag from xhci_mvebu_a3700_plat_setup() and
+then also whole xhci_mvebu_a3700_plat_setup() function which is there just
+to handle -EOPNOTSUPP for XHCI_SKIP_PHY_INIT.
+
+xhci plat_setup callback is not used by any other xhci plat driver, so
+remove this callback completely.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Acked-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/usb/host/xhci-mvebu.c | 42 -----------------------------------
+ drivers/usb/host/xhci-mvebu.h |  6 -----
+ drivers/usb/host/xhci-plat.c  | 20 +----------------
+ drivers/usb/host/xhci-plat.h  |  1 -
+ 4 files changed, 1 insertion(+), 68 deletions(-)
+
+--- a/drivers/usb/host/xhci-mvebu.c
++++ b/drivers/usb/host/xhci-mvebu.c
+@@ -8,7 +8,6 @@
+ #include <linux/mbus.h>
+ #include <linux/of.h>
+ #include <linux/platform_device.h>
+-#include <linux/phy/phy.h>
+ 
+ #include <linux/usb.h>
+ #include <linux/usb/hcd.h>
+@@ -74,47 +73,6 @@ int xhci_mvebu_mbus_init_quirk(struct us
+ 
+ 	return 0;
+ }
+-
+-int xhci_mvebu_a3700_plat_setup(struct usb_hcd *hcd)
+-{
+-	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
+-	struct device *dev = hcd->self.controller;
+-	struct phy *phy;
+-	int ret;
+-
+-	/* Old bindings miss the PHY handle */
+-	phy = of_phy_get(dev->of_node, "usb3-phy");
+-	if (IS_ERR(phy) && PTR_ERR(phy) == -EPROBE_DEFER)
+-		return -EPROBE_DEFER;
+-	else if (IS_ERR(phy))
+-		goto phy_out;
+-
+-	ret = phy_init(phy);
+-	if (ret)
+-		goto phy_put;
+-
+-	ret = phy_set_mode(phy, PHY_MODE_USB_HOST_SS);
+-	if (ret)
+-		goto phy_exit;
+-
+-	ret = phy_power_on(phy);
+-	if (ret == -EOPNOTSUPP) {
+-		/* Skip initializatin of XHCI PHY when it is unsupported by firmware */
+-		dev_warn(dev, "PHY unsupported by firmware\n");
+-		xhci->quirks |= XHCI_SKIP_PHY_INIT;
+-	}
+-	if (ret)
+-		goto phy_exit;
+-
+-	phy_power_off(phy);
+-phy_exit:
+-	phy_exit(phy);
+-phy_put:
+-	of_phy_put(phy);
+-phy_out:
+-
+-	return 0;
+-}
+ 
+ int xhci_mvebu_a3700_init_quirk(struct usb_hcd *hcd)
+ {
+--- a/drivers/usb/host/xhci-mvebu.h
++++ b/drivers/usb/host/xhci-mvebu.h
+@@ -12,18 +12,12 @@ struct usb_hcd;
+ 
+ #if IS_ENABLED(CONFIG_USB_XHCI_MVEBU)
+ int xhci_mvebu_mbus_init_quirk(struct usb_hcd *hcd);
+-int xhci_mvebu_a3700_plat_setup(struct usb_hcd *hcd);
+ int xhci_mvebu_a3700_init_quirk(struct usb_hcd *hcd);
+ #else
+ static inline int xhci_mvebu_mbus_init_quirk(struct usb_hcd *hcd)
+ {
+ 	return 0;
+ }
+-
+-static inline int xhci_mvebu_a3700_plat_setup(struct usb_hcd *hcd)
+-{
+-	return 0;
+-}
+ 
+ static inline int xhci_mvebu_a3700_init_quirk(struct usb_hcd *hcd)
+ {
+--- a/drivers/usb/host/xhci-plat.c
++++ b/drivers/usb/host/xhci-plat.c
+@@ -44,16 +44,6 @@ static void xhci_priv_plat_start(struct
+ 		priv->plat_start(hcd);
+ }
+ 
+-static int xhci_priv_plat_setup(struct usb_hcd *hcd)
+-{
+-	struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
+-
+-	if (!priv->plat_setup)
+-		return 0;
+-
+-	return priv->plat_setup(hcd);
+-}
+-
+ static int xhci_priv_init_quirk(struct usb_hcd *hcd)
+ {
+ 	struct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);
+@@ -121,7 +111,6 @@ static const struct xhci_plat_priv xhci_
+ };
+ 
+ static const struct xhci_plat_priv xhci_plat_marvell_armada3700 = {
+-	.plat_setup = xhci_mvebu_a3700_plat_setup,
+ 	.init_quirk = xhci_mvebu_a3700_init_quirk,
+ };
+ 
+@@ -341,14 +330,7 @@ static int xhci_plat_probe(struct platfo
+ 
+ 	hcd->tpl_support = of_usb_host_tpl_support(sysdev->of_node);
+ 	xhci->shared_hcd->tpl_support = hcd->tpl_support;
+-
+-	if (priv) {
+-		ret = xhci_priv_plat_setup(hcd);
+-		if (ret)
+-			goto disable_usb_phy;
+-	}
+-
+-	if ((xhci->quirks & XHCI_SKIP_PHY_INIT) || (priv && (priv->quirks & XHCI_SKIP_PHY_INIT)))
++	if (priv && (priv->quirks & XHCI_SKIP_PHY_INIT))
+ 		hcd->skip_phy_initialization = 1;
+ 
+ 	if (priv && (priv->quirks & XHCI_SG_TRB_CACHE_SIZE_QUIRK))
+--- a/drivers/usb/host/xhci-plat.h
++++ b/drivers/usb/host/xhci-plat.h
+@@ -13,7 +13,6 @@
+ struct xhci_plat_priv {
+ 	const char *firmware_name;
+ 	unsigned long long quirks;
+-	int (*plat_setup)(struct usb_hcd *);
+ 	void (*plat_start)(struct usb_hcd *);
+ 	int (*init_quirk)(struct usb_hcd *);
+ 	int (*suspend_quirk)(struct usb_hcd *);
diff -uprN a/target/linux/generic/pending-5.10/851-0006-Revert-PCI-aardvark-Fix-initialization-with-old-Marv.patch b/target/linux/generic/pending-5.10/851-0006-Revert-PCI-aardvark-Fix-initialization-with-old-Marv.patch
--- a/target/linux/generic/pending-5.10/851-0006-Revert-PCI-aardvark-Fix-initialization-with-old-Marv.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/target/linux/generic/pending-5.10/851-0006-Revert-PCI-aardvark-Fix-initialization-with-old-Marv.patch	2024-03-18 15:16:23.618640505 +0800
@@ -0,0 +1,36 @@
+From 9a352062b7e3857742389dff6f64393481dc755e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Pali=20Roh=C3=A1r?= <pali@kernel.org>
+Date: Thu, 23 Sep 2021 19:37:05 +0200
+Subject: [PATCH] Revert "PCI: aardvark: Fix initialization with old Marvell's
+ Arm Trusted Firmware"
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This reverts commit b0c6ae0f8948a2be6bf4e8b4bbab9ca1343289b6.
+
+Armada 3720 phy driver (phy-mvebu-a3700-comphy.c) does not return
+-EOPNOTSUPP from phy_power_on() callback anymore.
+
+So remove dead code which handles -EOPNOTSUPP return value.
+
+Signed-off-by: Pali Rohár <pali@kernel.org>
+Signed-off-by: Marek Behún <kabel@kernel.org>
+Acked-by: Miquel Raynal <miquel.raynal@bootlin.com>
+---
+ drivers/pci/controller/pci-aardvark.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+--- a/drivers/pci/controller/pci-aardvark.c
++++ b/drivers/pci/controller/pci-aardvark.c
+@@ -1637,9 +1637,7 @@ static int advk_pcie_enable_phy(struct a
+ 	}
+ 
+ 	ret = phy_power_on(pcie->phy);
+-	if (ret == -EOPNOTSUPP) {
+-		dev_warn(&pcie->pdev->dev, "PHY unsupported by firmware\n");
+-	} else if (ret) {
++	if (ret) {
+ 		phy_exit(pcie->phy);
+ 		return ret;
+ 	}
diff -uprN a/target/linux/generic/pending-5.10/920-mangle_bootargs.patch b/target/linux/generic/pending-5.10/920-mangle_bootargs.patch
--- a/target/linux/generic/pending-5.10/920-mangle_bootargs.patch	2024-03-18 15:15:10.601426272 +0800
+++ b/target/linux/generic/pending-5.10/920-mangle_bootargs.patch	2024-03-18 15:16:23.614640659 +0800
@@ -13,7 +13,7 @@ Signed-off-by: Imre Kaloz <kaloz@openwrt
 
 --- a/init/Kconfig
 +++ b/init/Kconfig
-@@ -1805,6 +1805,15 @@ config EMBEDDED
+@@ -1800,6 +1800,15 @@ config EMBEDDED
  	  an embedded system so certain expert options are available
  	  for configuration.
  
