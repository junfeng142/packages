diff -uprN a/package/kernel/mac80211/ath.mk b/package/kernel/mac80211/ath.mk
--- a/package/kernel/mac80211/ath.mk	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/ath.mk	2022-04-04 20:20:32.943829000 +0800
@@ -1,6 +1,6 @@
 PKG_DRIVERS += \
 	ath ath5k ath6kl ath6kl-sdio ath6kl-usb ath9k ath9k-common ath9k-htc ath10k \
-	carl9170 owl-loader
+	carl9170
 
 PKG_CONFIG_DEPENDS += \
 	CONFIG_PACKAGE_ATH_DEBUG \
@@ -38,7 +38,6 @@ config-$(CONFIG_PACKAGE_ATH_SPECTRAL) +=
 config-$(CONFIG_PACKAGE_ATH_DYNACK) += ATH9K_DYNACK
 config-$(call config_package,ath9k) += ATH9K
 config-$(call config_package,ath9k-common) += ATH9K_COMMON
-config-$(call config_package,owl-loader) += ATH9K_PCI_NO_EEPROM
 config-$(CONFIG_TARGET_ar71xx) += ATH9K_AHB
 config-$(CONFIG_TARGET_ath79) += ATH9K_AHB
 config-$(CONFIG_TARGET_ipq40xx) += ATH10K_AHB
@@ -275,20 +274,3 @@ define KernelPackage/carl9170
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/carl9170/carl9170.ko
   AUTOLOAD:=$(call AutoProbe,carl9170)
 endef
-
-define KernelPackage/owl-loader
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Owl loader for initializing Atheros PCI(e) Wifi chips
-  DEPENDS:=@PCI_SUPPORT +kmod-ath9k
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.ko
-  AUTOLOAD:=$(call AutoProbe,ath9k_pci_owl_loader)
-endef
-
-define KernelPackage/owl-loader/description
-  Kernel module that helps to initialize certain Qualcomm
-  Atheros' PCI(e) Wifi chips, which have the init data
-  (which contains the PCI device ID for example) stored
-  together with the calibration data in the file system.
-
-  This is necessary for devices like the Cisco Meraki Z1.
-endef
diff -uprN a/package/kernel/mac80211/broadcom.mk b/package/kernel/mac80211/broadcom.mk
--- a/package/kernel/mac80211/broadcom.mk	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/broadcom.mk	2022-04-04 20:20:32.943829000 +0800
@@ -105,7 +105,7 @@ define KernelPackage/b43
   	CONFIG_HW_RANDOM=y
   # Depend on PCI_SUPPORT to make sure we can select kmod-bcma or kmod-ssb
   DEPENDS += \
-	@PCI_SUPPORT +kmod-mac80211 +kmod-lib-cordic \
+	@PCI_SUPPORT +@DRIVER_11W_SUPPORT +kmod-mac80211 \
 	$(if $(CONFIG_PACKAGE_B43_USE_SSB),+kmod-ssb) \
 	$(if $(CONFIG_PACKAGE_B43_USE_BCMA),+kmod-bcma)
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/b43/b43.ko
@@ -347,7 +347,7 @@ define KernelPackage/b43legacy
   URL:=https://wireless.wiki.kernel.org/en/users/drivers/b43
   KCONFIG:= \
   	CONFIG_HW_RANDOM=y
-  DEPENDS+= +kmod-mac80211 +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb @!TARGET_brcm47xx_mips74k +b43legacy-firmware
+  DEPENDS+= +kmod-mac80211 +!(TARGET_brcm47xx||TARGET_brcm63xx):kmod-ssb @!TARGET_brcm47xx_mips74k +b43legacy-firmware +@DRIVER_11W_SUPPORT
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/broadcom/b43legacy/b43legacy.ko
   AUTOLOAD:=$(call AutoProbe,b43legacy)
   MENU:=1
@@ -449,7 +449,7 @@ define KernelPackage/brcmfmac/config
 
 	config BRCMFMAC_SDIO
 		bool "Enable SDIO bus interface support"
-		default y if TARGET_bcm27xx
+		default y if TARGET_brcm2708
 		default y if TARGET_sunxi
 		default n
 		help
@@ -478,29 +478,6 @@ define KernelPackage/brcmfmac/config
   endif
 endef
 
-
-define KernelPackage/b43/install
-	rm -rf $(1)/lib/firmware/
-ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
-	tar xzf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
-else
-	tar xjf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
-endif
-	$(INSTALL_DIR) $(1)/lib/firmware/
-ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
-	$(MAKE) -C "$(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/"
-	$(INSTALL_DIR) $(1)/lib/firmware/b43-open/
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/ucode5.fw $(1)/lib/firmware/b43-open/ucode5.fw
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0bsinitvals5.fw $(1)/lib/firmware/b43-open/b0g0bsinitvals5.fw
-	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0initvals5.fw $(1)/lib/firmware/b43-open/b0g0initvals5.fw
-else
-	b43-fwcutter -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)
-endif
-ifneq ($(CONFIG_B43_FW_SQUASH),)
-	b43-fwsquash.py "$(CONFIG_B43_FW_SQUASH_PHYTYPES)" "$(CONFIG_B43_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43"
-endif
-endef
-
 define KernelPackage/brcmsmac/install
 	$(INSTALL_DIR) $(1)/lib/firmware/brcm
 ifeq ($(CONFIG_BRCMSMAC_USE_FW_FROM_WL),y)
diff -uprN a/package/kernel/mac80211/files/lib/netifd/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/mac80211.sh
--- a/package/kernel/mac80211/files/lib/netifd/mac80211.sh	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/files/lib/netifd/mac80211.sh	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
-mac80211_phy_to_path() {
-	local phy="$1"
-
-	[ -x /usr/bin/readlink -a -h /sys/class/ieee80211/${phy} ] || return
-
-	local path="$(readlink -f /sys/class/ieee80211/${phy}/device)"
-	[ -n "$path" ] || return
-
-	path="${path##/sys/devices/}"
-	case "$path" in
-		platform*/pci*) path="${path##platform/}";;
-	esac
-
-	local p
-	local seq=""
-	for p in $(ls /sys/class/ieee80211/$phy/device/ieee80211); do
-		[ "$p" = "$phy" ] && {
-			echo "$path${seq:++$seq}"
-			break
-		}
-
-		seq=$((${seq:-0} + 1))
-	done
-}
-
-mac80211_path_to_phy() {
-	local path="$1"
-
-	local p
-	for p in $(ls /sys/class/ieee80211); do
-		local cur="$(mac80211_phy_to_path "$p")"
-		case "$cur" in
-			*$path) echo "$p"; return;;
-		esac
-	done
-}
diff -uprN a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
--- a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh	2022-04-04 20:20:32.943829000 +0800
@@ -1,7 +1,6 @@
 #!/bin/sh
 . /lib/netifd/netifd-wireless.sh
 . /lib/netifd/hostapd.sh
-. /lib/netifd/mac80211.sh
 
 init_wireless_driver "$@"
 
@@ -15,12 +14,9 @@ MP_CONFIG_INT="mesh_retry_timeout mesh_c
 MP_CONFIG_BOOL="mesh_auto_open_plinks mesh_fwding"
 MP_CONFIG_STRING="mesh_power_mode"
 
-NEWAPLIST=
-OLDAPLIST=
-NEWSPLIST=
-OLDSPLIST=
-NEWUMLIST=
-OLDUMLIST=
+iw() {
+	command iw $@ || logger -t mac80211 "Failed command: iw $@"
+}
 
 drv_mac80211_init_device_config() {
 	hostapd_common_add_device_config
@@ -28,9 +24,10 @@ drv_mac80211_init_device_config() {
 	config_add_string path phy 'macaddr:macaddr'
 	config_add_string hwmode
 	config_add_string tx_burst
+	config_add_string distance
 	config_add_int beacon_int chanbw frag rts
-	config_add_int rxantenna txantenna antenna_gain txpower distance
-	config_add_boolean noscan ht_coex acs_exclude_dfs
+	config_add_int rxantenna txantenna antenna_gain txpower
+	config_add_boolean noscan ht_coex
 	config_add_array ht_capab
 	config_add_array channels
 	config_add_boolean \
@@ -61,8 +58,7 @@ drv_mac80211_init_iface_config() {
 
 	config_add_string 'macaddr:macaddr' ifname
 
-	config_add_boolean wds powersave enable
-	config_add_string wds_bridge
+	config_add_boolean wds powersave
 	config_add_int maxassoc
 	config_add_int max_listen_int
 	config_add_int dtim_period
@@ -102,11 +98,7 @@ mac80211_hostapd_setup_base() {
 	[ "$auto_channel" -gt 0 ] && channel=acs_survey
 	[ "$auto_channel" -gt 0 ] && json_get_values channel_list channels
 
-	[ "$auto_channel" -gt 0 ] && json_get_vars acs_exclude_dfs
-	[ -n "$acs_exclude_dfs" ] && [ "$acs_exclude_dfs" -gt 0 ] &&
-		append base_cfg "acs_exclude_dfs=1" "$N"
-
-	json_get_vars noscan ht_coex vendor_vht
+	json_get_vars noscan ht_coex
 	json_get_values ht_capab_list ht_capab tx_burst
 
 	set_default noscan 0
@@ -222,7 +214,7 @@ mac80211_hostapd_setup_base() {
 		;;
 	esac
 
-	if [ "$enable_ac" != "0" -o "$vendor_vht" = "1" ]; then
+	if [ "$enable_ac" != "0" ]; then
 		json_get_vars \
 			rxldpc:1 \
 			short_gi_80:1 \
@@ -329,8 +321,6 @@ $base_cfg
 
 EOF
 	json_select ..
-	radio_md5sum=$(md5sum $hostapd_conf_file | cut -d" " -f1)
-	echo "radio_config_id=${radio_md5sum}" >> $hostapd_conf_file
 }
 
 mac80211_hostapd_setup_bss() {
@@ -343,15 +333,12 @@ mac80211_hostapd_setup_bss() {
 	append hostapd_cfg "$type=$ifname" "$N"
 
 	hostapd_set_bss_options hostapd_cfg "$vif" || return 1
-	json_get_vars wds wds_bridge dtim_period max_listen_int start_disabled
+	json_get_vars wds dtim_period max_listen_int start_disabled
 
 	set_default wds 0
 	set_default start_disabled 0
 
-	[ "$wds" -gt 0 ] && {
-		append hostapd_cfg "wds_sta=1" "$N"
-		[ -n "$wds_bridge" ] && append hostapd_cfg "wds_bridge=$wds_bridge" "$N"
-	}
+	[ "$wds" -gt 0 ] && append hostapd_cfg "wds_sta=1" "$N"
 	[ "$staidx" -gt 0 -o "$start_disabled" -eq 1 ] && append hostapd_cfg "start_disabled=1" "$N"
 
 	cat >> /var/run/hostapd-$phy.conf <<EOF
@@ -366,7 +353,7 @@ mac80211_get_addr() {
 	local phy="$1"
 	local idx="$(($2 + 1))"
 
-	head -n $(($macidx + 1)) /sys/class/ieee80211/${phy}/addresses | tail -n1
+	head -n $idx /sys/class/ieee80211/${phy}/addresses | tail -n1
 }
 
 mac80211_generate_mac() {
@@ -399,7 +386,7 @@ mac80211_generate_mac() {
 	[ "$((0x$mask1))" -gt 0 ] && {
 		b1="0x$1"
 		[ "$id" -gt 0 ] && \
-			b1=$(($b1 ^ ((($id - !($b1 & 2)) << 2) | 0x2)))
+			b1=$(($b1 ^ ((($id - 1) << 2) | 0x2)))
 		printf "%02x:%s:%s:%s:%s:%s" $b1 $2 $3 $4 $5 $6
 		return
 	}
@@ -419,8 +406,11 @@ mac80211_generate_mac() {
 find_phy() {
 	[ -n "$phy" -a -d /sys/class/ieee80211/$phy ] && return 0
 	[ -n "$path" ] && {
-		phy="$(mac80211_path_to_phy "$path")"
-		[ -n "$phy" ] && return 0
+		for phy in $(ls /sys/class/ieee80211 2>/dev/null); do
+			case "$(readlink -f /sys/class/ieee80211/$phy/device)" in
+				*$path) return 0;;
+			esac
+		done
 	}
 	[ -n "$macaddr" ] && {
 		for phy in $(ls /sys/class/ieee80211 2>/dev/null); do
@@ -453,36 +443,6 @@ mac80211_iw_interface_add() {
 	}
 
 	[ "$rc" = 233 ] && {
-		# Keep matching pre-existing interface
-		[ -d "/sys/class/ieee80211/${phy}/device/net/${ifname}" ] && \
-		case "$(iw dev wlan0 info | grep "^\ttype" | cut -d' ' -f2- 2>/dev/null)" in
-			"AP")
-				[ "$type" = "__ap" ] && rc=0
-				;;
-			"IBSS")
-				[ "$type" = "adhoc" ] && rc=0
-				;;
-			"managed")
-				[ "$type" = "managed" ] && rc=0
-				;;
-			"mesh point")
-				[ "$type" = "mp" ] && rc=0
-				;;
-			"monitor")
-				[ "$type" = "monitor" ] && rc=0
-				;;
-		esac
-	}
-
-	[ "$rc" = 233 ] && {
-		iw dev "$ifname" del
-		sleep 1
-
-		iw phy "$phy" interface add "$ifname" type "$type" $wdsflag
-		rc="$?"
-	}
-
-	[ "$rc" = 233 ] && {
 		# Device might not support virtual interfaces, so the interface never got deleted in the first place.
 		# Check if the interface already exists, and avoid failing in this case.
 		ip link show dev "$ifname" >/dev/null 2>/dev/null && rc=0
@@ -495,7 +455,7 @@ mac80211_iw_interface_add() {
 mac80211_prepare_vif() {
 	json_select config
 
-	json_get_vars ifname mode ssid wds powersave macaddr enable
+	json_get_vars ifname mode ssid wds powersave macaddr
 
 	[ -n "$ifname" ] || ifname="wlan${phy#phy}${if_idx:+-$if_idx}"
 	if_idx=$((${if_idx:-0} + 1))
@@ -531,9 +491,8 @@ mac80211_prepare_vif() {
 
 			mac80211_hostapd_setup_bss "$phy" "$ifname" "$macaddr" "$type" || return
 
-			NEWAPLIST="${NEWAPLIST}$ifname "
 			[ -n "$hostapd_ctrl" ] || {
-				ap_ifname="${ifname}"
+				mac80211_iw_interface_add "$phy" "$ifname" __ap || return
 				hostapd_ctrl="${hostapd_ctrl:-/var/run/hostapd/$ifname}"
 			}
 		;;
@@ -545,14 +504,9 @@ mac80211_prepare_vif() {
 		;;
 		sta)
 			local wdsflag=
-			[ "$enable" = 0 ] || staidx="$(($staidx + 1))"
+			staidx="$(($staidx + 1))"
 			[ "$wds" -gt 0 ] && wdsflag="4addr on"
 			mac80211_iw_interface_add "$phy" "$ifname" managed "$wdsflag" || return
-			if [ "$wds" -gt 0 ]; then
-				iw "$ifname" set 4addr on
-			else
-				iw "$ifname" set 4addr off
-			fi
 			[ "$powersave" -gt 0 ] && powersave="on" || powersave="off"
 			iw "$ifname" set power_save "$powersave"
 		;;
@@ -576,62 +530,19 @@ mac80211_prepare_vif() {
 }
 
 mac80211_setup_supplicant() {
-	local enable=$1
-	local add_sp=0
-	local spobj="$(ubus -S list | grep wpa_supplicant.${ifname})"
-
 	wpa_supplicant_prepare_interface "$ifname" nl80211 || return 1
-	wpa_supplicant_prepare_interface "$ifname" nl80211 || {
-		iw dev "$ifname" del
-		return 1
-	}
 	if [ "$mode" = "sta" ]; then
 		wpa_supplicant_add_network "$ifname"
 	else
 		wpa_supplicant_add_network "$ifname" "$freq" "$htmode" "$noscan"
 	fi
-
-	NEWSPLIST="${NEWSPLIST}$ifname "
-
-	if [ "${NEWAPLIST%% *}" != "${OLDAPLIST%% *}" ]; then
-		[ "$spobj" ] && ubus call wpa_supplicant.${phy} config_del "{\"iface\":\"$ifname\"}"
-		add_sp=1
-	fi
-	[ "$enable" = 0 ] && {
-		ubus call wpa_supplicant.${phy} config_del "{\"iface\":\"$ifname\"}"
-		ip link set dev "$ifname" down
-		return 0
-	}
-	[ -z "$spobj" ] && add_sp=1
-
-	if [ "$add_sp" = "1" ]; then
-		wpa_supplicant_run "$ifname" "$hostapd_ctrl"
-	else
-		ubus call $spobj reload
-	fi
+	wpa_supplicant_run "$ifname" ${hostapd_ctrl:+-H $hostapd_ctrl}
 }
 
 mac80211_setup_supplicant_noctl() {
-	local enable=$1
-	local spobj="$(ubus -S list | grep wpa_supplicant.${ifname})"
-	wpa_supplicant_prepare_interface "$ifname" nl80211 || {
-		iw dev "$ifname" del
-		return 1
-	}
-
+	wpa_supplicant_prepare_interface "$ifname" nl80211 || return 1
 	wpa_supplicant_add_network "$ifname" "$freq" "$htmode" "$noscan"
-
-	NEWSPLIST="${NEWSPLIST}$ifname "
-	[ "$enable" = 0 ] && {
-		ubus call wpa_supplicant.${phy} config_del "{\"iface\":\"$ifname\"}"
-		ip link set dev "$ifname" down
-		return 0
-	}
-	if [ -z "$spobj" ]; then
-		wpa_supplicant_run "$ifname"
-	else
-		ubus call $spobj reload
-	fi
+	wpa_supplicant_run "$ifname"
 }
 
 mac80211_prepare_iw_htmode() {
@@ -669,19 +580,12 @@ mac80211_prepare_iw_htmode() {
 		;;
 		*) iw_htmode="" ;;
 	esac
+
 }
 
 mac80211_setup_adhoc() {
-	local enable=$1
 	json_get_vars bssid ssid key mcast_rate
 
-	NEWUMLIST="${NEWUMLIST}$ifname "
-
-	[ "$enable" = 0 ] && {
-		ip link set dev "$ifname" down
-		return 0
-	}
-
 	keyspec=
 	[ "$auth_type" = "wep" ] && {
 		set_default key 1
@@ -720,16 +624,8 @@ mac80211_setup_adhoc() {
 }
 
 mac80211_setup_mesh() {
-	local enable=$1
 	json_get_vars ssid mesh_id mcast_rate
 
-	NEWUMLIST="${NEWUMLIST}$ifname "
-
-	[ "$enable" = 0 ] && {
-		ip link set dev "$ifname" down
-		return 0
-	}
-
 	mcval=
 	[ -n "$mcast_rate" ] && wpa_supplicant_add_rate mcval "$mcast_rate"
 	[ -n "$mesh_id" ] && ssid="$mesh_id"
@@ -742,7 +638,6 @@ mac80211_setup_mesh() {
 mac80211_setup_vif() {
 	local name="$1"
 	local failed
-	local action=up
 
 	json_select data
 	json_get_vars ifname
@@ -750,28 +645,25 @@ mac80211_setup_vif() {
 
 	json_select config
 	json_get_vars mode
-	json_get_var vif_txpower
-	json_get_var vif_enable enable 1
+	json_get_var vif_txpower txpower
 
-	[ "$vif_enable" = 1 ] || action=down
-	if [ "$mode" != "ap" ] || [ "$ifname" = "$ap_ifname" ]; then
-		logger ip link set dev "$ifname" $action
-		ip link set dev "$ifname" "$action" || {
-			wireless_setup_vif_failed IFUP_ERROR
-			json_select ..
-			return
-		}
-		[ -z "$vif_txpower" ] || iw dev "$ifname" set txpower fixed "${vif_txpower%%.*}00"
-	fi
+	ip link set dev "$ifname" up || {
+		wireless_setup_vif_failed IFUP_ERROR
+		json_select ..
+		return
+	}
+
+	set_default vif_txpower "$txpower"
+	[ -z "$vif_txpower" ] || iw dev "$ifname" set txpower fixed "${vif_txpower%%.*}00"
 
 	case "$mode" in
 		mesh)
 			wireless_vif_parse_encryption
 			freq="$(get_freq "$phy" "$channel")"
 			if [ "$wpa" -gt 0 -o "$auto_channel" -gt 0 ] || chan_is_dfs "$phy" "$channel"; then
-				mac80211_setup_supplicant $vif_enable || failed=1
+				mac80211_setup_supplicant || failed=1
 			else
-				mac80211_setup_mesh $vif_enable
+				mac80211_setup_mesh
 			fi
 			for var in $MP_CONFIG_INT $MP_CONFIG_BOOL $MP_CONFIG_STRING; do
 				json_get_var mp_val "$var"
@@ -782,13 +674,13 @@ mac80211_setup_vif() {
 			wireless_vif_parse_encryption
 			if [ "$wpa" -gt 0 -o "$auto_channel" -gt 0 ]; then
 				freq="$(get_freq "$phy" "$channel")"
-				mac80211_setup_supplicant_noctl $vif_enable || failed=1
+				mac80211_setup_supplicant_noctl || failed=1
 			else
-				mac80211_setup_adhoc $vif_enable
+				mac80211_setup_adhoc
 			fi
 		;;
 		sta)
-			mac80211_setup_supplicant $vif_enable || failed=1
+			mac80211_setup_supplicant || failed=1
 		;;
 	esac
 
@@ -809,27 +701,15 @@ chan_is_dfs() {
 	return $!
 }
 
-mac80211_vap_cleanup() {
-	local service="$1"
-	local vaps="$2"
+mac80211_interface_cleanup() {
+	local phy="$1"
 
-	for wdev in $vaps; do
-		[ "$service" != "none" ] && ubus call ${service}.${phy} config_remove "{\"iface\":\"$wdev\"}"
+	for wdev in $(list_phy_interfaces "$phy"); do
 		ip link set dev "$wdev" down 2>/dev/null
 		iw dev "$wdev" del
 	done
 }
 
-mac80211_interface_cleanup() {
-	local phy="$1"
-	local primary_ap=$(uci -q -P /var/state get wireless._${phy}.aplist)
-	primary_ap=${primary_ap%% *}
-
-	mac80211_vap_cleanup hostapd "${primary_ap}"
-	mac80211_vap_cleanup wpa_supplicant "$(uci -q -P /var/state get wireless._${phy}.splist)"
-	mac80211_vap_cleanup none "$(uci -q -P /var/state get wireless._${phy}.umlist)"
-}
-
 mac80211_set_noscan() {
 	hostapd_noscan=1
 }
@@ -855,32 +735,8 @@ drv_mac80211_setup() {
 		return 1
 	}
 
-	[ -z "$(uci -q -P /var/state show wireless._${phy})" ] && {
-		uci -q -P /var/state set wireless._${phy}=phy
-		wireless_set_data phy="$phy"
-	}
-
-	OLDAPLIST=$(uci -q -P /var/state get wireless._${phy}.aplist)
-	OLDSPLIST=$(uci -q -P /var/state get wireless._${phy}.splist)
-	OLDUMLIST=$(uci -q -P /var/state get wireless._${phy}.umlist)
-
-	local wdev
-	local cwdev
-	local found
-
-	for wdev in $(list_phy_interfaces "$phy"); do
-		found=0
-		for cwdev in $OLDAPLIST $OLDSPLIST $OLDUMLIST; do
-			if [ "$wdev" = "$cwdev" ]; then
-				found=1
-				break
-			fi
-		done
-		if [ "$found" = "0" ]; then
-			ip link set dev "$wdev" down
-			iw dev "$wdev" del
-		fi
-	done
+	wireless_set_data phy="$phy"
+	mac80211_interface_cleanup "$phy"
 
 	# convert channel to frequency
 	[ "$auto_channel" -gt 0 ] || freq="$(get_freq "$phy" "$channel")"
@@ -899,7 +755,7 @@ drv_mac80211_setup() {
 	staidx=0
 
 	[ -n "$chanbw" ] && {
-		for file in /sys/kernel/debug/ieee80211/$phy/ath9k*/chanbw /sys/kernel/debug/ieee80211/$phy/ath5k/bwmode; do
+		for file in /sys/kernel/debug/ieee80211/$phy/ath9k/chanbw /sys/kernel/debug/ieee80211/$phy/ath5k/bwmode; do
 			[ -f "$file" ] && echo "$chanbw" > "$file"
 		done
 	}
@@ -916,18 +772,11 @@ drv_mac80211_setup() {
 	iw phy "$phy" set antenna_gain $antenna_gain
 	iw phy "$phy" set distance "$distance"
 
-	if [ -n "$txpower" ]; then
-		iw phy "$phy" set txpower fixed "${txpower%%.*}00"
-	else
-		iw phy "$phy" set txpower auto
-	fi
-
 	[ -n "$frag" ] && iw phy "$phy" set frag "${frag%%.*}"
 	[ -n "$rts" ] && iw phy "$phy" set rts "${rts%%.*}"
 
 	has_ap=
 	hostapd_ctrl=
-	ap_ifname=
 	hostapd_noscan=
 	for_each_interface "ap" mac80211_check_ap
 
@@ -938,69 +787,24 @@ drv_mac80211_setup() {
 
 	mac80211_prepare_iw_htmode
 	for_each_interface "sta adhoc mesh monitor" mac80211_prepare_vif
-	NEWAPLIST=
 	for_each_interface "ap" mac80211_prepare_vif
-	NEW_MD5=$(test -e "${hostapd_conf_file}" && md5sum ${hostapd_conf_file})
-	OLD_MD5=$(uci -q -P /var/state get wireless._${phy}.md5)
-	if [ "${NEWAPLIST}" != "${OLDAPLIST}" ]; then
-		mac80211_vap_cleanup hostapd "${OLDAPLIST}"
-		[ -n "${NEWAPLIST}" ] && mac80211_iw_interface_add "$phy" "${NEWAPLIST%% *}" __ap || return
-	fi
-	local add_ap=0
-	local primary_ap=${NEWAPLIST%% *}
+
 	[ -n "$hostapd_ctrl" ] && {
-		local no_reload=1
-		if [ -n "$(ubus list | grep hostapd.$primary_ap)" ]; then
-			[ "${NEW_MD5}" = "${OLD_MD5}" ] || {
-				ubus call hostapd.$primary_ap reload
-				no_reload=$?
-				if [ "$no_reload" != "0" ]; then
-					mac80211_vap_cleanup hostapd "${OLDAPLIST}"
-			                [ -n "${NEWAPLIST}" ] && mac80211_iw_interface_add "$phy" "${NEWAPLIST%% *}" __ap || return
-				fi
-			}
-		fi
-		if [ "$no_reload" != "0" ]; then
-			add_ap=1
-			ubus wait_for hostapd.$phy
-			ubus call hostapd.${phy} config_add "{\"iface\":\"$primary_ap\", \"config\":\"${hostapd_conf_file}\"}"
-			local hostapd_pid=$(ubus call service list '{"name": "hostapd"}' | jsonfilter -l 1 -e "@['hostapd'].instances['hostapd-${phy}'].pid")
-			wireless_add_process "$hostapd_pid" "/usr/sbin/hostapd" 1
-		fi
+		/usr/sbin/hostapd -s -P /var/run/wifi-$phy.pid -B "$hostapd_conf_file"
 		ret="$?"
+		wireless_add_process "$(cat /var/run/wifi-$phy.pid)" "/usr/sbin/hostapd" 1
 		[ "$ret" != 0 ] && {
 			wireless_setup_failed HOSTAPD_START_FAILED
 			return
 		}
 	}
-	uci -q -P /var/state set wireless._${phy}.aplist="${NEWAPLIST}"
-	uci -q -P /var/state set wireless._${phy}.md5="${NEW_MD5}"
 
-	[ "${add_ap}" = 1 ] && sleep 1
-	for_each_interface "ap" mac80211_setup_vif
+	for_each_interface "ap sta adhoc mesh monitor" mac80211_setup_vif
 
-	NEWSPLIST=
-	NEWUMLIST=
-
-	for_each_interface "sta adhoc mesh monitor" mac80211_setup_vif
-
-	uci -q -P /var/state set wireless._${phy}.splist="${NEWSPLIST}"
-	uci -q -P /var/state set wireless._${phy}.umlist="${NEWUMLIST}"
-
-	local foundvap
-	local dropvap=""
-	for oldvap in $OLDSPLIST; do
-		foundvap=0
-		for newvap in $NEWSPLIST; do
-			[ "$oldvap" = "$newvap" ] && foundvap=1
-		done
-		[ "$foundvap" = "0" ] && dropvap="$dropvap $oldvap"
-	done
-	[ -n "$dropvap" ] && mac80211_vap_cleanup wpa_supplicant "$dropvap"
 	wireless_set_up
 }
 
-_list_phy_interfaces() {
+list_phy_interfaces() {
 	local phy="$1"
 	if [ -d "/sys/class/ieee80211/${phy}/device/net" ]; then
 		ls "/sys/class/ieee80211/${phy}/device/net" 2>/dev/null;
@@ -1009,15 +813,6 @@ _list_phy_interfaces() {
 	fi
 }
 
-list_phy_interfaces() {
-	local phy="$1"
-
-	for dev in $(_list_phy_interfaces "$phy"); do
-		readlink "/sys/class/net/${dev}/phy80211" | grep -q "/${phy}\$" || continue
-		echo "$dev"
-	done
-}
-
 drv_mac80211_teardown() {
 	wireless_process_kill_all
 
@@ -1026,7 +821,6 @@ drv_mac80211_teardown() {
 	json_select ..
 
 	mac80211_interface_cleanup "$phy"
-	uci -q -P /var/state revert wireless._${phy}
 }
 
 add_driver mac80211
diff -uprN a/package/kernel/mac80211/files/lib/wifi/mac80211.sh b/package/kernel/mac80211/files/lib/wifi/mac80211.sh
--- a/package/kernel/mac80211/files/lib/wifi/mac80211.sh	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/files/lib/wifi/mac80211.sh	2022-04-04 20:20:32.943829000 +0800
@@ -1,6 +1,4 @@
 #!/bin/sh
-. /lib/netifd/mac80211.sh
-
 append DRIVERS "mac80211"
 
 lookup_phy() {
@@ -11,8 +9,11 @@ lookup_phy() {
 	local devpath
 	config_get devpath "$device" path
 	[ -n "$devpath" ] && {
-		phy="$(mac80211_path_to_phy "$devpath")"
-		[ -n "$phy" ] && return
+		for phy in $(ls /sys/class/ieee80211 2>/dev/null); do
+			case "$(readlink -f /sys/class/ieee80211/$phy/device)" in
+				*$devpath) return;;
+			esac
+		done
 	}
 
 	local macaddr="$(config_get "$device" macaddr | tr 'A-Z' 'a-z')"
@@ -90,8 +91,16 @@ detect_mac80211() {
 
 		[ -n "$htmode" ] && ht_capab="set wireless.radio${devidx}.htmode=$htmode"
 
-		path="$(mac80211_phy_to_path "$dev")"
+		if [ -x /usr/bin/readlink -a -h /sys/class/ieee80211/${dev} ]; then
+			path="$(readlink -f /sys/class/ieee80211/${dev}/device)"
+		else
+			path=""
+		fi
 		if [ -n "$path" ]; then
+			path="${path##/sys/devices/}"
+			case "$path" in
+				platform*/pci*) path="${path##platform/}";;
+			esac
 			dev_id="set wireless.radio${devidx}.path='$path'"
 		else
 			dev_id="set wireless.radio${devidx}.macaddr=$(cat /sys/class/ieee80211/${dev}/macaddress)"
@@ -104,7 +113,7 @@ detect_mac80211() {
 			set wireless.radio${devidx}.hwmode=11${mode_band}
 			${dev_id}
 			${ht_capab}
-			set wireless.radio${devidx}.disabled=0
+			set wireless.radio${devidx}.disabled=1
 
 			set wireless.default_radio${devidx}=wifi-iface
 			set wireless.default_radio${devidx}.device=radio${devidx}
diff -uprN a/package/kernel/mac80211/Makefile b/package/kernel/mac80211/Makefile
--- a/package/kernel/mac80211/Makefile	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/Makefile	2022-04-04 20:20:32.943829000 +0800
@@ -10,10 +10,10 @@ include $(INCLUDE_DIR)/kernel.mk
 
 PKG_NAME:=mac80211
 
-PKG_VERSION:=5.4.27-1
+PKG_VERSION:=4.19.193-1
 PKG_RELEASE:=1
-PKG_SOURCE_URL:=@KERNEL/linux/kernel/projects/backports/stable/v5.4.27/
-PKG_HASH:=4c853a2f4c4fcc81cf60a3d59c5efbdb60c3e4acda22996cb192443581753950
+PKG_SOURCE_URL:=@KERNEL/linux/kernel/projects/backports/stable/v4.19.193/
+PKG_HASH:=560c0ce9e4079fd26d046e188453e008a5e766e5409d950c4749a23da53d6d0a
 
 PKG_SOURCE:=backports-$(PKG_VERSION).tar.xz
 PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/backports-$(PKG_VERSION)
@@ -162,7 +162,7 @@ endef
 define KernelPackage/airo
   $(call KernelPackage/mac80211/Default)
   TITLE:=Cisco Aironet driver
-  DEPENDS+=@PCI_SUPPORT +@DRIVER_WEXT_SUPPORT +kmod-cfg80211 @TARGET_x86 @BROKEN
+  DEPENDS+=@PCI_SUPPORT +@DRIVER_WEXT_SUPPORT +kmod-cfg80211 @TARGET_x86
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/cisco/airo.ko
   AUTOLOAD:=$(call AutoProbe,airo)
 endef
@@ -223,7 +223,7 @@ endef
 define KernelPackage/lib80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=802.11 Networking stack
-  DEPENDS:=+kmod-cfg80211 +kmod-crypto-hash +kmod-crypto-ccm
+  DEPENDS:=+kmod-cfg80211 +kmod-crypto-hash
   FILES:= \
 	$(PKG_BUILD_DIR)/net/wireless/lib80211.ko \
 	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_wep.ko \
@@ -521,10 +521,31 @@ define Build/InstallDev
 endef
 
 
+define KernelPackage/b43/install
+	rm -rf $(1)/lib/firmware/
+ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
+	tar xzf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
+else
+	tar xjf "$(DL_DIR)/$(PKG_B43_FWV4_SOURCE)" -C "$(PKG_BUILD_DIR)"
+endif
+	$(INSTALL_DIR) $(1)/lib/firmware/
+ifeq ($(CONFIG_B43_OPENFIRMWARE),y)
+	$(MAKE) -C "$(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/"
+	$(INSTALL_DIR) $(1)/lib/firmware/b43-open/
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/ucode5.fw $(1)/lib/firmware/b43-open/ucode5.fw
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0bsinitvals5.fw $(1)/lib/firmware/b43-open/b0g0bsinitvals5.fw
+	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)/b0g0initvals5.fw $(1)/lib/firmware/b43-open/b0g0initvals5.fw
+else
+	b43-fwcutter -w $(1)/lib/firmware/ $(PKG_BUILD_DIR)/$(PKG_B43_FWV4_OBJECT)
+endif
+ifneq ($(CONFIG_B43_FW_SQUASH),)
+	b43-fwsquash.py "$(CONFIG_B43_FW_SQUASH_PHYTYPES)" "$(CONFIG_B43_FW_SQUASH_COREREVS)" "$(1)/lib/firmware/b43"
+endif
+endef
+
 define KernelPackage/cfg80211/install
 	$(INSTALL_DIR) $(1)/lib/wifi $(1)/lib/netifd/wireless
 	$(INSTALL_DATA) ./files/lib/wifi/mac80211.sh $(1)/lib/wifi
-	$(INSTALL_DATA) ./files/lib/netifd/mac80211.sh $(1)/lib/netifd
 	$(INSTALL_BIN) ./files/lib/netifd/wireless/mac80211.sh $(1)/lib/netifd/wireless
 	$(INSTALL_DIR) $(1)/etc/hotplug.d/ieee80211
 	$(INSTALL_DATA) ./files/mac80211.hotplug $(1)/etc/hotplug.d/ieee80211/10-wifi-detect
diff -uprN a/package/kernel/mac80211/patches/ath/070-ath_common_config.patch b/package/kernel/mac80211/patches/ath/070-ath_common_config.patch
--- a/package/kernel/mac80211/patches/ath/070-ath_common_config.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/070-ath_common_config.patch	2022-04-04 20:20:32.943829000 +0800
@@ -1,7 +1,6 @@
 --- a/drivers/net/wireless/ath/Kconfig
 +++ b/drivers/net/wireless/ath/Kconfig
-@@ -1,6 +1,6 @@
- # SPDX-License-Identifier: ISC
+@@ -1,5 +1,5 @@
  config ATH_COMMON
 -	tristate
 +	tristate "ath.ko"
diff -uprN a/package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch b/package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch
--- a/package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/080-ath10k_thermal_config.patch	2022-04-04 20:20:32.943829000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/Kconfig
 +++ b/drivers/net/wireless/ath/ath10k/Kconfig
-@@ -87,6 +87,12 @@ config ATH10K_TRACING
+@@ -85,6 +85,12 @@ config ATH10K_TRACING
  	---help---
  	  Select this to ath10k use tracing infrastructure.
  
@@ -26,7 +26,7 @@
  ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
 --- a/drivers/net/wireless/ath/ath10k/thermal.h
 +++ b/drivers/net/wireless/ath/ath10k/thermal.h
-@@ -25,7 +25,7 @@ struct ath10k_thermal {
+@@ -36,7 +36,7 @@ struct ath10k_thermal {
  	int temperature;
  };
  
@@ -37,7 +37,7 @@
  void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
 --- a/local-symbols
 +++ b/local-symbols
-@@ -142,6 +142,7 @@ ATH10K_SNOC=
+@@ -139,6 +139,7 @@ ATH10K_SNOC=
  ATH10K_DEBUG=
  ATH10K_DEBUGFS=
  ATH10K_SPECTRAL=
diff -uprN a/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch b/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch
--- a/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/120-owl-loader-compat.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,53 +0,0 @@
-From: Christian Lamparter <chunkeey@gmail.com>
-Date: Sat, 16 Nov 2019 19:25:24 +0100
-Subject: [PATCH] owl_loader: compatibility patch
-
-This patch includes OpenWrt specific changes that are
-not included in the upstream owl-loader.
-
-This includes a platform data handling changes for ar71xx.
-
-Signed-off-by: Christian Lamparter <chunkeey@gmail.com>
-
---- a/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c
-+++ b/drivers/net/wireless/ath/ath9k/ath9k_pci_owl_loader.c
-@@ -104,6 +104,7 @@ static void owl_fw_cb(const struct firmw
- {
- 	struct pci_dev *pdev = (struct pci_dev *)context;
- 	struct owl_ctx *ctx = (struct owl_ctx *)pci_get_drvdata(pdev);
-+	struct ath9k_platform_data *pdata = dev_get_platdata(&pdev->dev);
- 	struct pci_bus *bus;
- 
- 	complete(&ctx->eeprom_load);
-@@ -119,6 +120,16 @@ static void owl_fw_cb(const struct firmw
- 		goto release;
- 	}
- 
-+	if (pdata) {
-+		memcpy(pdata->eeprom_data, fw->data, fw->size);
-+
-+		/*
-+		 * eeprom has been successfully loaded - pass the data to ath9k
-+		 * but remove the eeprom_name, so it doesn't try to load it too.
-+		 */
-+		pdata->eeprom_name = NULL;
-+	}
-+
- 	if (ath9k_pci_fixup(pdev, (const u16 *)fw->data, fw->size))
- 		goto release;
- 
-@@ -138,8 +149,14 @@ release:
- static const char *owl_get_eeprom_name(struct pci_dev *pdev)
- {
- 	struct device *dev = &pdev->dev;
-+	struct ath9k_platform_data *pdata;
- 	char *eeprom_name;
- 
-+	/* try the existing platform data first */
-+	pdata = dev_get_platdata(dev);
-+	if (pdata && pdata->eeprom_name)
-+		return pdata->eeprom_name;
-+
- 	dev_dbg(dev, "using auto-generated eeprom filename\n");
- 
- 	eeprom_name = devm_kzalloc(dev, EEPROM_FILENAME_LEN, GFP_KERNEL);
diff -uprN a/package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch b/package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch
--- a/package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/356-Revert-ath9k-interpret-requested-txpower-in-EIRP-dom.patch	2022-04-04 20:20:32.943829000 +0800
@@ -8,7 +8,7 @@ This reverts commit 71f5137bf010c6faffab
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2977,7 +2977,8 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2976,7 +2976,8 @@ void ath9k_hw_apply_txpower(struct ath_h
  {
  	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
  	struct ieee80211_channel *channel;
@@ -18,9 +18,9 @@ This reverts commit 71f5137bf010c6faffab
  	u16 ctl = NO_CTL;
  
  	if (!chan)
-@@ -2989,9 +2990,14 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2988,9 +2989,14 @@ void ath9k_hw_apply_txpower(struct ath_h
  	channel = chan->chan;
- 	chan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);
+ 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
  	new_pwr = min_t(int, chan_pwr, reg->power_limit);
 +	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
 +
diff -uprN a/package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch b/package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch
--- a/package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/365-ath9k-adjust-tx-power-reduction-for-US-regulatory-do.patch	2022-04-04 20:20:32.947828000 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -2996,6 +2996,10 @@ void ath9k_hw_apply_txpower(struct ath_h
+@@ -2995,6 +2995,10 @@ void ath9k_hw_apply_txpower(struct ath_h
  	if (ant_gain > max_gain)
  		ant_reduction = ant_gain - max_gain;
  
diff -uprN a/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch b/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch
--- a/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/402-ath_regd_optional.patch	2022-04-04 20:20:32.947828000 +0800
@@ -70,7 +70,7 @@
  
 --- a/drivers/net/wireless/ath/Kconfig
 +++ b/drivers/net/wireless/ath/Kconfig
-@@ -24,6 +24,9 @@ config WLAN_VENDOR_ATH
+@@ -23,6 +23,9 @@ config WLAN_VENDOR_ATH
  
  if WLAN_VENDOR_ATH
  
@@ -82,7 +82,7 @@
  	---help---
 --- a/local-symbols
 +++ b/local-symbols
-@@ -85,6 +85,7 @@ ADM8211=
+@@ -83,6 +83,7 @@ ADM8211=
  ATH_COMMON=
  WLAN_VENDOR_ATH=
  ATH_DEBUG=
diff -uprN a/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch b/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch
--- a/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/404-regd_no_assoc_hints.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/net/wireless/reg.c
 +++ b/net/wireless/reg.c
-@@ -3039,6 +3039,8 @@ void regulatory_hint_country_ie(struct w
+@@ -3037,6 +3037,8 @@ void regulatory_hint_country_ie(struct w
  	enum environment_cap env = ENVIRON_ANY;
  	struct regulatory_request *request = NULL, *lr;
  
@@ -9,7 +9,7 @@
  	/* IE len must be evenly divisible by 2 */
  	if (country_ie_len & 0x01)
  		return;
-@@ -3290,6 +3292,7 @@ static bool is_wiphy_all_set_reg_flag(en
+@@ -3262,6 +3264,7 @@ static bool is_wiphy_all_set_reg_flag(en
  
  void regulatory_hint_disconnect(void)
  {
diff -uprN a/package/kernel/mac80211/patches/ath/405-ath_regd_us.patch b/package/kernel/mac80211/patches/ath/405-ath_regd_us.patch
--- a/package/kernel/mac80211/patches/ath/405-ath_regd_us.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/405-ath_regd_us.patch	2022-04-04 20:20:32.947828000 +0800
@@ -21,6 +21,6 @@
  	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
  	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
 +	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
- 	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
- 	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
  	/* This "PS" is for US public safety actually... to support this we
+ 	 * would need to assign new special alpha2 to CRDA db as with the world
+ 	 * regdomain and use another alpha2 */
diff -uprN a/package/kernel/mac80211/patches/ath/407-regd_add_extra_country_codes.patch b/package/kernel/mac80211/patches/ath/407-regd_add_extra_country_codes.patch
--- a/package/kernel/mac80211/patches/ath/407-regd_add_extra_country_codes.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/407-regd_add_extra_country_codes.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,35 @@
+From: Oever Gonzalez <notengobattery@gmail.com>
+Date: Mon, 7 Jan 2019 01:07:12 +0200
+Subject: [PATCH] ath: regd: add extra coutry codes
+
+This patch adds several country codes to the regd.h and regd_common.h
+files in order to support devices whose country codes are not present in
+the original list. Without this patch, all devices whose manufacturer
+programmed any of these code in their EEPROM will not work.
+
+Signed-off-by: Oever Gonzalez <notengobattery@gmail.com>
+---
+
+--- a/drivers/net/wireless/ath/regd.h
++++ b/drivers/net/wireless/ath/regd.h
+@@ -185,7 +185,9 @@ enum CountryCode {
+ 	CTRY_UKRAINE = 804,
+ 	CTRY_UNITED_KINGDOM = 826,
+ 	CTRY_UNITED_STATES = 840,
++	CTRY_UNITED_STATES2 = 841,
+ 	CTRY_UNITED_STATES_FCC49 = 842,
++	CTRY_UNITED_STATES3 = 843,
+ 	CTRY_URUGUAY = 858,
+ 	CTRY_UZBEKISTAN = 860,
+ 	CTRY_VENEZUELA = 862,
+--- a/drivers/net/wireless/ath/regd_common.h
++++ b/drivers/net/wireless/ath/regd_common.h
+@@ -486,6 +486,8 @@ static struct country_code_to_enum_rd al
+ 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
+ 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
+ 	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
++	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
++	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
+ 	/* This "PS" is for US public safety actually... to support this we
+ 	 * would need to assign new special alpha2 to CRDA db as with the world
+ 	 * regdomain and use another alpha2 */
diff -uprN a/package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch b/package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch
--- a/package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/410-ath9k_allow_adhoc_and_ap.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -831,6 +831,7 @@ static const struct ieee80211_iface_limi
+@@ -833,6 +833,7 @@ static const struct ieee80211_iface_limi
  				 BIT(NL80211_IFTYPE_AP) },
  	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
  				 BIT(NL80211_IFTYPE_P2P_GO) },
diff -uprN a/package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch b/package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch
--- a/package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/411-ath5k_allow_adhoc_and_ap.patch	2022-04-04 20:20:32.947828000 +0800
@@ -18,7 +18,7 @@
  		goto end;
 --- a/drivers/net/wireless/ath/ath5k/base.c
 +++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1964,7 +1964,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
+@@ -1965,7 +1965,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
  	}
  
  	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
@@ -27,7 +27,7 @@
  			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
  		u64 tsf = ath5k_hw_get_tsf64(ah);
  		u32 tsftu = TSF_TO_TU(tsf);
-@@ -2050,7 +2050,7 @@ ath5k_beacon_update_timers(struct ath5k_
+@@ -2051,7 +2051,7 @@ ath5k_beacon_update_timers(struct ath5k_
  
  	intval = ah->bintval & AR5K_BEACON_PERIOD;
  	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
@@ -36,7 +36,7 @@
  		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
  		if (intval < 15)
  			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
-@@ -2516,6 +2516,7 @@ static const struct ieee80211_iface_limi
+@@ -2518,6 +2518,7 @@ static const struct ieee80211_iface_limi
  				 BIT(NL80211_IFTYPE_MESH_POINT) |
  #endif
  				 BIT(NL80211_IFTYPE_AP) },
diff -uprN a/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch b/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch
--- a/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/431-add_platform_eeprom_support_to_ath5k.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,14 +1,14 @@
 --- a/drivers/net/wireless/ath/ath5k/pci.c
 +++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -20,6 +20,7 @@
- #include <linux/pci.h>
+@@ -21,6 +21,7 @@
+ #include <linux/pci-aspm.h>
  #include <linux/etherdevice.h>
  #include <linux/module.h>
 +#include <linux/ath5k_platform.h>
  #include "../ath.h"
  #include "ath5k.h"
  #include "debug.h"
-@@ -71,7 +72,7 @@ static void ath5k_pci_read_cachesize(str
+@@ -72,7 +73,7 @@ static void ath5k_pci_read_cachesize(str
  }
  
  /*
@@ -17,7 +17,7 @@
   */
  static bool
  ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
-@@ -79,6 +80,19 @@ ath5k_pci_eeprom_read(struct ath_common
+@@ -80,6 +81,19 @@ ath5k_pci_eeprom_read(struct ath_common
  	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
  	u32 status, timeout;
  
@@ -37,7 +37,7 @@
  	/*
  	 * Initialize EEPROM access
  	 */
-@@ -122,6 +136,16 @@ static int ath5k_pci_eeprom_read_mac(str
+@@ -123,6 +137,16 @@ static int ath5k_pci_eeprom_read_mac(str
  	u16 data;
  	int octet;
  
diff -uprN a/package/kernel/mac80211/patches/ath/432-ath5k_add_pciids.patch b/package/kernel/mac80211/patches/ath/432-ath5k_add_pciids.patch
--- a/package/kernel/mac80211/patches/ath/432-ath5k_add_pciids.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/432-ath5k_add_pciids.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/pci.c
 +++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -47,6 +47,8 @@ static const struct pci_device_id ath5k_
+@@ -48,6 +48,8 @@ static const struct pci_device_id ath5k_
  	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
  	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
  	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
diff -uprN a/package/kernel/mac80211/patches/ath/500-ath9k_eeprom_debugfs.patch b/package/kernel/mac80211/patches/ath/500-ath9k_eeprom_debugfs.patch
--- a/package/kernel/mac80211/patches/ath/500-ath9k_eeprom_debugfs.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/500-ath9k_eeprom_debugfs.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1361,6 +1361,53 @@ void ath9k_deinit_debug(struct ath_softc
+@@ -1377,6 +1377,53 @@ void ath9k_deinit_debug(struct ath_softc
  	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
  }
  
@@ -54,7 +54,7 @@
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1380,6 +1427,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1396,6 +1443,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  	ath9k_tx99_init_debug(sc);
  	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
  
diff -uprN a/package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch b/package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch
--- a/package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/501-ath9k_ahb_init.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1143,25 +1143,25 @@ static int __init ath9k_init(void)
+@@ -1144,25 +1144,25 @@ static int __init ath9k_init(void)
  {
  	int error;
  
diff -uprN a/package/kernel/mac80211/patches/ath/512-ath9k_channelbw_debugfs.patch b/package/kernel/mac80211/patches/ath/512-ath9k_channelbw_debugfs.patch
--- a/package/kernel/mac80211/patches/ath/512-ath9k_channelbw_debugfs.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/512-ath9k_channelbw_debugfs.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1408,6 +1408,52 @@ static const struct file_operations fops
+@@ -1424,6 +1424,52 @@ static const struct file_operations fops
  	.owner = THIS_MODULE
  };
  
@@ -53,7 +53,7 @@
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1429,6 +1475,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1445,6 +1491,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  
  	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
  			    &fops_eeprom);
diff -uprN a/package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch b/package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch
--- a/package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/530-ath9k_extra_leds.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -843,6 +843,9 @@ static inline int ath9k_dump_btcoex(stru
+@@ -851,6 +851,9 @@ static inline int ath9k_dump_btcoex(stru
  #ifdef CPTCFG_MAC80211_LEDS
  void ath_init_leds(struct ath_softc *sc);
  void ath_deinit_leds(struct ath_softc *sc);
@@ -10,9 +10,9 @@
  #else
  static inline void ath_init_leds(struct ath_softc *sc)
  {
-@@ -979,6 +982,13 @@ void ath_ant_comb_scan(struct ath_softc
- 
- #define ATH9K_NUM_CHANCTX  2 /* supports 2 operating channels */
+@@ -992,6 +995,13 @@ void ath_ant_comb_scan(struct ath_softc
+ #define AIRTIME_USE_NEW_QUEUES	BIT(2)
+ #define AIRTIME_ACTIVE(flags) (!!(flags & (AIRTIME_USE_TX|AIRTIME_USE_RX)))
  
 +struct ath_led {
 +	struct list_head list;
@@ -24,7 +24,7 @@
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -1032,9 +1042,8 @@ struct ath_softc {
+@@ -1047,9 +1057,8 @@ struct ath_softc {
  	spinlock_t chan_lock;
  
  #ifdef CPTCFG_MAC80211_LEDS
@@ -181,7 +181,7 @@
  
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -1055,7 +1055,7 @@ int ath9k_init_device(u16 devid, struct
+@@ -1056,7 +1056,7 @@ int ath9k_init_device(u16 devid, struct
  
  #ifdef CPTCFG_MAC80211_LEDS
  	/* must be initialized before ieee80211_register_hw */
@@ -192,7 +192,7 @@
  #endif
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1453,6 +1453,61 @@ static const struct file_operations fops
+@@ -1469,6 +1469,61 @@ static const struct file_operations fops
  	.llseek = default_llseek,
  };
  
@@ -254,7 +254,7 @@
  
  int ath9k_init_debug(struct ath_hw *ah)
  {
-@@ -1477,6 +1532,10 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1493,6 +1548,10 @@ int ath9k_init_debug(struct ath_hw *ah)
  			    &fops_eeprom);
  	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
  			    sc, &fops_chanbw);
diff -uprN a/package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch b/package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch
--- a/package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/542-ath9k_debugfs_diag.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1509,6 +1509,50 @@ static const struct file_operations fops
+@@ -1525,6 +1525,50 @@ static const struct file_operations fops
  #endif
  
  
@@ -51,7 +51,7 @@
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1536,6 +1580,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1552,6 +1596,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  	debugfs_create_file("gpio_led", S_IWUSR,
  			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
  #endif
@@ -62,7 +62,7 @@
  	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
 --- a/drivers/net/wireless/ath/ath9k/hw.h
 +++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -521,6 +521,12 @@ enum {
+@@ -520,6 +520,12 @@ enum {
  	ATH9K_RESET_COLD,
  };
  
@@ -75,7 +75,7 @@
  struct ath9k_hw_version {
  	u32 magic;
  	u16 devid;
-@@ -809,6 +815,8 @@ struct ath_hw {
+@@ -808,6 +814,8 @@ struct ath_hw {
  	u32 ah_flags;
  	s16 nf_override;
  
@@ -84,7 +84,7 @@
  	bool reset_power_on;
  	bool htc_reset_init;
  
-@@ -1074,6 +1082,7 @@ void ath9k_hw_check_nav(struct ath_hw *a
+@@ -1073,6 +1081,7 @@ void ath9k_hw_check_nav(struct ath_hw *a
  bool ath9k_hw_check_alive(struct ath_hw *ah);
  
  bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
diff -uprN a/package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch b/package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch
--- a/package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/543-ath9k_entropy_from_adc.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.h
 +++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -722,6 +722,7 @@ struct ath_spec_scan {
+@@ -721,6 +721,7 @@ struct ath_spec_scan {
   * @config_pci_powersave:
   * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
   *
@@ -8,7 +8,7 @@
   * @spectral_scan_config: set parameters for spectral scan and enable/disable it
   * @spectral_scan_trigger: trigger a spectral scan run
   * @spectral_scan_wait: wait for a spectral scan run to finish
-@@ -744,6 +745,7 @@ struct ath_hw_ops {
+@@ -743,6 +744,7 @@ struct ath_hw_ops {
  			struct ath_hw_antcomb_conf *antconf);
  	void (*antdiv_comb_conf_set)(struct ath_hw *ah,
  			struct ath_hw_antcomb_conf *antconf);
@@ -18,7 +18,7 @@
  	void (*spectral_scan_trigger)(struct ath_hw *ah);
 --- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -1927,6 +1927,26 @@ void ar9003_hw_init_rate_txpower(struct
+@@ -1945,6 +1945,26 @@ void ar9003_hw_init_rate_txpower(struct
  	}
  }
  
@@ -45,7 +45,7 @@
  void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
  {
  	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
-@@ -1963,6 +1983,7 @@ void ar9003_hw_attach_phy_ops(struct ath
+@@ -1981,6 +2001,7 @@ void ar9003_hw_attach_phy_ops(struct ath
  	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
  	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
  
@@ -55,7 +55,7 @@
  	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -819,7 +819,8 @@ static void ath9k_init_txpower_limits(st
+@@ -821,7 +821,8 @@ static void ath9k_init_txpower_limits(st
  	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
  		ath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);
  
@@ -65,8 +65,8 @@
  }
  
  static const struct ieee80211_iface_limit if_limits[] = {
-@@ -1015,6 +1016,18 @@ static void ath9k_set_hw_capab(struct at
- 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);
+@@ -1016,6 +1017,18 @@ static void ath9k_set_hw_capab(struct at
+ 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
  }
  
 +static void ath_get_initial_entropy(struct ath_softc *sc)
@@ -84,7 +84,7 @@
  int ath9k_init_device(u16 devid, struct ath_softc *sc,
  		    const struct ath_bus_ops *bus_ops)
  {
-@@ -1060,6 +1073,8 @@ int ath9k_init_device(u16 devid, struct
+@@ -1061,6 +1074,8 @@ int ath9k_init_device(u16 devid, struct
  		ARRAY_SIZE(ath9k_tpt_blink));
  #endif
  
@@ -110,7 +110,7 @@
  static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
 --- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -1320,9 +1320,30 @@ void ar5008_hw_init_rate_txpower(struct
+@@ -1324,9 +1324,30 @@ void ar5008_hw_init_rate_txpower(struct
  	}
  }
  
@@ -141,7 +141,7 @@
  	static const u32 ar5416_cca_regs[6] = {
  		AR_PHY_CCA,
  		AR_PHY_CH1_CCA,
-@@ -1337,6 +1358,8 @@ int ar5008_hw_attach_phy_ops(struct ath_
+@@ -1341,6 +1362,8 @@ int ar5008_hw_attach_phy_ops(struct ath_
  	if (ret)
  	    return ret;
  
diff -uprN a/package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch b/package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch
--- a/package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/545-ath9k_ani_ws_detect.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
 +++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -949,55 +949,6 @@ static bool ar5008_hw_ani_control_new(st
+@@ -953,55 +953,6 @@ static bool ar5008_hw_ani_control_new(st
  		 * on == 0 means more noise imm
  		 */
  		u32 on = param ? 1 : 0;
@@ -79,7 +79,7 @@
  static const u8 ofdm2pwr[] = {
  	ALL_TARGET_LEGACY_6_24,
  	ALL_TARGET_LEGACY_6_24,
-@@ -1077,11 +1063,6 @@ static bool ar9003_hw_ani_control(struct
+@@ -1095,11 +1081,6 @@ static bool ar9003_hw_ani_control(struct
  	struct ath_common *common = ath9k_hw_common(ah);
  	struct ath9k_channel *chan = ah->curchan;
  	struct ar5416AniState *aniState = &ah->ani;
@@ -91,7 +91,7 @@
  	s32 value, value2;
  
  	switch (cmd & ah->ani_function) {
-@@ -1095,61 +1076,6 @@ static bool ar9003_hw_ani_control(struct
+@@ -1113,61 +1094,6 @@ static bool ar9003_hw_ani_control(struct
  		 */
  		u32 on = param ? 1 : 0;
  
diff -uprN a/package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch b/package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch
--- a/package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/548-ath9k_enable_gpio_chip.patch	2022-04-04 20:20:32.947828000 +0800
@@ -18,7 +18,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  
  #include "common.h"
  #include "debug.h"
-@@ -989,6 +990,14 @@ struct ath_led {
+@@ -1002,6 +1003,14 @@ struct ath_led {
  	struct led_classdev cdev;
  };
  
@@ -33,7 +33,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -1044,6 +1053,9 @@ struct ath_softc {
+@@ -1059,6 +1068,9 @@ struct ath_softc {
  #ifdef CPTCFG_MAC80211_LEDS
  	const char *led_default_trigger;
  	struct list_head leds;
diff -uprN a/package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch b/package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch
--- a/package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/549-ath9k_enable_gpio_buttons.patch	2022-04-04 20:20:32.947828000 +0800
@@ -10,7 +10,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 ---
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -1055,6 +1055,7 @@ struct ath_softc {
+@@ -1070,6 +1070,7 @@ struct ath_softc {
  	struct list_head leds;
  #ifdef CONFIG_GPIOLIB
  	struct ath9k_gpio_chip *gpiochip;
diff -uprN a/package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch b/package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch
--- a/package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/551-ath9k_ubnt_uap_plus_hsr.patch	2022-04-04 20:20:32.947828000 +0800
@@ -386,17 +386,17 @@
  #endif /* _LINUX_ATH9K_PLATFORM_H */
 --- a/local-symbols
 +++ b/local-symbols
-@@ -112,6 +112,7 @@ ATH9K_WOW=
+@@ -110,6 +110,7 @@ ATH9K_WOW=
  ATH9K_RFKILL=
  ATH9K_CHANNEL_CONTEXT=
  ATH9K_PCOEM=
 +ATH9K_UBNTHSR=
- ATH9K_PCI_NO_EEPROM=
  ATH9K_HTC=
  ATH9K_HTC_DEBUGFS=
+ ATH9K_HWRNG=
 --- a/drivers/net/wireless/ath/ath9k/Kconfig
 +++ b/drivers/net/wireless/ath/ath9k/Kconfig
-@@ -60,6 +60,19 @@ config ATH9K_AHB
+@@ -59,6 +59,19 @@ config ATH9K_AHB
  	  Say Y, if you have a SoC with a compatible built-in
  	  wireless MAC. Say N if unsure.
  
diff -uprN a/package/kernel/mac80211/patches/ath/552-ahb_of.patch b/package/kernel/mac80211/patches/ath/552-ahb_of.patch
--- a/package/kernel/mac80211/patches/ath/552-ahb_of.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/552-ahb_of.patch	2022-04-04 20:20:32.947828000 +0800
@@ -325,7 +325,7 @@
  
  #include "common.h"
  #include "debug.h"
-@@ -1011,6 +1012,9 @@ struct ath_softc {
+@@ -1024,6 +1025,9 @@ struct ath_softc {
  	struct ath_hw *sc_ah;
  	void __iomem *mem;
  	int irq;
diff -uprN a/package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch b/package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch
--- a/package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/553-ath9k_of_gpio_mask.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,25 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -654,6 +654,12 @@ static int ath9k_of_init(struct ath_soft
- 	return 0;
- }
- 
-+static void ath9k_of_gpio_mask(struct ath_softc *sc)
-+{
-+	of_property_read_u32(sc->dev->of_node, "qca,gpio-mask",
-+			     &sc->sc_ah->caps.gpio_mask);
-+}
-+
- static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
- 			    const struct ath_bus_ops *bus_ops)
- {
-@@ -758,6 +764,9 @@ static int ath9k_init_softc(u16 devid, s
- 	if (ret)
- 		goto err_hw;
- 
-+	/* GPIO mask quirk */
-+	ath9k_of_gpio_mask(sc);
-+
- 	ret = ath9k_init_queues(sc);
- 	if (ret)
- 		goto err_queues;
diff -uprN a/package/kernel/mac80211/patches/ath/554-ath9k-dynack-move-debug-log-after-buffer-increments.patch b/package/kernel/mac80211/patches/ath/554-ath9k-dynack-move-debug-log-after-buffer-increments.patch
--- a/package/kernel/mac80211/patches/ath/554-ath9k-dynack-move-debug-log-after-buffer-increments.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/554-ath9k-dynack-move-debug-log-after-buffer-increments.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,88 @@
+From: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
+Date: Fri, 2 Nov 2018 21:49:56 +0100
+Subject: [PATCH] ath9k: dynack: move debug log after buffer increments
+
+Move debug log in ath_dynack_sample_tx_ts and ath_dynack_sample_ack_ts
+after timestamp buffer head/tail increments in order to make debugging
+more user friendly
+
+Tested-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
+---
+
+--- a/drivers/net/wireless/ath/ath9k/dynack.c
++++ b/drivers/net/wireless/ath/ath9k/dynack.c
+@@ -178,11 +178,12 @@ void ath_dynack_sample_tx_ts(struct ath_
+ 			     struct ath_tx_status *ts,
+ 			     struct ieee80211_sta *sta)
+ {
+-	u8 ridx;
+ 	struct ieee80211_hdr *hdr;
+ 	struct ath_dynack *da = &ah->dynack;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
++	u32 dur = ts->duration;
++	u8 ridx;
+ 
+ 	if (!da->enabled || (info->flags & IEEE80211_TX_CTL_NO_ACK))
+ 		return;
+@@ -217,14 +218,13 @@ void ath_dynack_sample_tx_ts(struct ath_
+ 	ridx = ts->ts_rateindex;
+ 
+ 	da->st_rbf.ts[da->st_rbf.t_rb].tstamp = ts->ts_tstamp;
+-	da->st_rbf.ts[da->st_rbf.t_rb].dur = ts->duration;
+ 	ether_addr_copy(da->st_rbf.addr[da->st_rbf.t_rb].h_dest, hdr->addr1);
+ 	ether_addr_copy(da->st_rbf.addr[da->st_rbf.t_rb].h_src, hdr->addr2);
+ 
+ 	if (!(info->status.rates[ridx].flags & IEEE80211_TX_RC_MCS)) {
+-		u32 phy, sifs;
+ 		const struct ieee80211_rate *rate;
+ 		struct ieee80211_tx_rate *rates = info->status.rates;
++		u32 phy;
+ 
+ 		rate = &common->sbands[info->band].bitrates[rates[ridx].idx];
+ 		if (info->band == NL80211_BAND_2GHZ &&
+@@ -233,19 +233,18 @@ void ath_dynack_sample_tx_ts(struct ath_
+ 		else
+ 			phy = WLAN_RC_PHY_OFDM;
+ 
+-		sifs = ath_dynack_get_sifs(ah, phy);
+-		da->st_rbf.ts[da->st_rbf.t_rb].dur -= sifs;
++		dur -= ath_dynack_get_sifs(ah, phy);
+ 	}
+-
+-	ath_dbg(common, DYNACK, "{%pM} tx sample %u [dur %u][h %u-t %u]\n",
+-		hdr->addr1, da->st_rbf.ts[da->st_rbf.t_rb].tstamp,
+-		da->st_rbf.ts[da->st_rbf.t_rb].dur, da->st_rbf.h_rb,
+-		(da->st_rbf.t_rb + 1) % ATH_DYN_BUF);
++	da->st_rbf.ts[da->st_rbf.t_rb].dur = dur;
+ 
+ 	INCR(da->st_rbf.t_rb, ATH_DYN_BUF);
+ 	if (da->st_rbf.t_rb == da->st_rbf.h_rb)
+ 		INCR(da->st_rbf.h_rb, ATH_DYN_BUF);
+ 
++	ath_dbg(common, DYNACK, "{%pM} tx sample %u [dur %u][h %u-t %u]\n",
++		hdr->addr1, ts->ts_tstamp, dur, da->st_rbf.h_rb,
++		da->st_rbf.t_rb);
++
+ 	ath_dynack_compute_to(ah);
+ 
+ 	spin_unlock_bh(&da->qlock);
+@@ -272,14 +271,13 @@ void ath_dynack_sample_ack_ts(struct ath
+ 	spin_lock_bh(&da->qlock);
+ 	da->ack_rbf.tstamp[da->ack_rbf.t_rb] = ts;
+ 
+-	ath_dbg(common, DYNACK, "rx sample %u [h %u-t %u]\n",
+-		da->ack_rbf.tstamp[da->ack_rbf.t_rb],
+-		da->ack_rbf.h_rb, (da->ack_rbf.t_rb + 1) % ATH_DYN_BUF);
+-
+ 	INCR(da->ack_rbf.t_rb, ATH_DYN_BUF);
+ 	if (da->ack_rbf.t_rb == da->ack_rbf.h_rb)
+ 		INCR(da->ack_rbf.h_rb, ATH_DYN_BUF);
+ 
++	ath_dbg(common, DYNACK, "rx sample %u [h %u-t %u]\n",
++		ts, da->ack_rbf.h_rb, da->ack_rbf.t_rb);
++
+ 	ath_dynack_compute_to(ah);
+ 
+ 	spin_unlock_bh(&da->qlock);
diff -uprN a/package/kernel/mac80211/patches/ath/557-ath9k-dynack-remove-experimental-tag.patch b/package/kernel/mac80211/patches/ath/557-ath9k-dynack-remove-experimental-tag.patch
--- a/package/kernel/mac80211/patches/ath/557-ath9k-dynack-remove-experimental-tag.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/557-ath9k-dynack-remove-experimental-tag.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,22 @@
+From: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
+Date: Fri, 2 Nov 2018 21:49:59 +0100
+Subject: [PATCH] ath9k: dynack: remove 'experimental' tag
+
+Remove experimental tag from dynack Kconfig entry since it has
+been tested on outdoor 25Km links
+
+Tested-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo.bianconi@redhat.com>
+---
+
+--- a/drivers/net/wireless/ath/ath9k/Kconfig
++++ b/drivers/net/wireless/ath/ath9k/Kconfig
+@@ -132,7 +132,7 @@ config ATH9K_DFS_CERTIFIED
+ 	  except increase code size.
+ 
+ config ATH9K_DYNACK
+-	bool "Atheros ath9k ACK timeout estimation algorithm (EXPERIMENTAL)"
++	bool "Atheros ath9k ACK timeout estimation algorithm"
+ 	depends on ATH9K
+ 	default n
+ 	---help---
diff -uprN a/package/kernel/mac80211/patches/ath/558-ath9k-dynack-introduce-ath_dynack_set_timeout-routin.patch b/package/kernel/mac80211/patches/ath/558-ath9k-dynack-introduce-ath_dynack_set_timeout-routin.patch
--- a/package/kernel/mac80211/patches/ath/558-ath9k-dynack-introduce-ath_dynack_set_timeout-routin.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/558-ath9k-dynack-introduce-ath_dynack_set_timeout-routin.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,89 @@
+From 4420866ef1b602682b009e0186fbb8aefd2125be Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 20 Aug 2019 18:20:19 +0200
+Subject: [PATCH 1/4] ath9k: dynack: introduce ath_dynack_set_timeout routine
+
+Introduce ath_dynack_set_timeout routine to configure slottime/ack/cts
+timeouts and remove duplicated code
+
+Tested-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+---
+ drivers/net/wireless/ath/ath9k/dynack.c | 37 ++++++++++++++-----------
+ 1 file changed, 21 insertions(+), 16 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath9k/dynack.c
++++ b/drivers/net/wireless/ath/ath9k/dynack.c
+@@ -79,6 +79,24 @@ static inline bool ath_dynack_bssidmask(
+ }
+ 
+ /**
++ * ath_dynack_set_timeout - configure timeouts/slottime registers
++ * @ah: ath hw
++ * @to: timeout value
++ *
++ */
++static void ath_dynack_set_timeout(struct ath_hw *ah, int to)
++{
++	struct ath_common *common = ath9k_hw_common(ah);
++	int slottime = (to - 3) / 2;
++
++	ath_dbg(common, DYNACK, "ACK timeout %u slottime %u\n",
++		to, slottime);
++	ath9k_hw_setslottime(ah, slottime);
++	ath9k_hw_set_ack_timeout(ah, to);
++	ath9k_hw_set_cts_timeout(ah, to);
++}
++
++/**
+  * ath_dynack_compute_ackto - compute ACK timeout as the maximum STA timeout
+  * @ah: ath hw
+  *
+@@ -86,7 +104,6 @@ static inline bool ath_dynack_bssidmask(
+  */
+ static void ath_dynack_compute_ackto(struct ath_hw *ah)
+ {
+-	struct ath_common *common = ath9k_hw_common(ah);
+ 	struct ath_dynack *da = &ah->dynack;
+ 	struct ath_node *an;
+ 	int to = 0;
+@@ -96,15 +113,8 @@ static void ath_dynack_compute_ackto(str
+ 			to = an->ackto;
+ 
+ 	if (to && da->ackto != to) {
+-		u32 slottime;
+-
+-		slottime = (to - 3) / 2;
++		ath_dynack_set_timeout(ah, to);
+ 		da->ackto = to;
+-		ath_dbg(common, DYNACK, "ACK timeout %u slottime %u\n",
+-			da->ackto, slottime);
+-		ath9k_hw_setslottime(ah, slottime);
+-		ath9k_hw_set_ack_timeout(ah, da->ackto);
+-		ath9k_hw_set_cts_timeout(ah, da->ackto);
+ 	}
+ }
+ 
+@@ -198,10 +208,7 @@ void ath_dynack_sample_tx_ts(struct ath_
+ 		    ieee80211_is_assoc_resp(hdr->frame_control) ||
+ 		    ieee80211_is_auth(hdr->frame_control)) {
+ 			ath_dbg(common, DYNACK, "late ack\n");
+-
+-			ath9k_hw_setslottime(ah, (LATEACK_TO - 3) / 2);
+-			ath9k_hw_set_ack_timeout(ah, LATEACK_TO);
+-			ath9k_hw_set_cts_timeout(ah, LATEACK_TO);
++			ath_dynack_set_timeout(ah, LATEACK_TO);
+ 			if (sta) {
+ 				struct ath_node *an;
+ 
+@@ -340,9 +347,7 @@ void ath_dynack_reset(struct ath_hw *ah)
+ 	da->ack_rbf.h_rb = 0;
+ 
+ 	/* init acktimeout */
+-	ath9k_hw_setslottime(ah, (ackto - 3) / 2);
+-	ath9k_hw_set_ack_timeout(ah, ackto);
+-	ath9k_hw_set_cts_timeout(ah, ackto);
++	ath_dynack_set_timeout(ah, ackto);
+ }
+ EXPORT_SYMBOL(ath_dynack_reset);
+ 
diff -uprN a/package/kernel/mac80211/patches/ath/559-ath9k-dynack-properly-set-last-timeout-timestamp-in-.patch b/package/kernel/mac80211/patches/ath/559-ath9k-dynack-properly-set-last-timeout-timestamp-in-.patch
--- a/package/kernel/mac80211/patches/ath/559-ath9k-dynack-properly-set-last-timeout-timestamp-in-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/559-ath9k-dynack-properly-set-last-timeout-timestamp-in-.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,27 @@
+From e5b56ce50eab31d24df6a70cf025db3acc4aa3ac Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 20 Aug 2019 18:20:20 +0200
+Subject: [PATCH 2/4] ath9k: dynack: properly set last timeout timestamp in
+ ath_dynack_reset
+
+Add compute timeout to last computation timestamp in
+ath_dynack_reset in order to not run ath_dynack_compute_ackto
+immediately
+
+Tested-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+---
+ drivers/net/wireless/ath/ath9k/dynack.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ath/ath9k/dynack.c
++++ b/drivers/net/wireless/ath/ath9k/dynack.c
+@@ -338,7 +338,7 @@ void ath_dynack_reset(struct ath_hw *ah)
+ 	u32 ackto = 9 + 16 + 64;
+ 	struct ath_dynack *da = &ah->dynack;
+ 
+-	da->lto = jiffies;
++	da->lto = jiffies + COMPUTE_TO;
+ 	da->ackto = ackto;
+ 
+ 	da->st_rbf.t_rb = 0;
diff -uprN a/package/kernel/mac80211/patches/ath/560-ath9k-dynack-set-max-timeout-according-to-channel-wi.patch b/package/kernel/mac80211/patches/ath/560-ath9k-dynack-set-max-timeout-according-to-channel-wi.patch
--- a/package/kernel/mac80211/patches/ath/560-ath9k-dynack-set-max-timeout-according-to-channel-wi.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/560-ath9k-dynack-set-max-timeout-according-to-channel-wi.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,92 @@
+From 3f737abb7d53cc80d619a3b4a30b6fa63cdc8df7 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 20 Aug 2019 18:20:21 +0200
+Subject: [PATCH 3/4] ath9k: dynack: set max timeout according to channel width
+
+Compute maximum configurable ackimeout/ctstimeout according to channel
+width (clockrate)
+
+Tested-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+---
+ drivers/net/wireless/ath/ath9k/dynack.c | 38 +++++++++++++++++++------
+ 1 file changed, 30 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath9k/dynack.c
++++ b/drivers/net/wireless/ath/ath9k/dynack.c
+@@ -20,12 +20,31 @@
+ 
+ #define COMPUTE_TO		(5 * HZ)
+ #define LATEACK_DELAY		(10 * HZ)
+-#define LATEACK_TO		256
+-#define MAX_DELAY		300
+ #define EWMA_LEVEL		96
+ #define EWMA_DIV		128
+ 
+ /**
++ * ath_dynack_get_max_to - set max timeout according to channel width
++ * @ah: ath hw
++ *
++ */
++static u32 ath_dynack_get_max_to(struct ath_hw *ah)
++{
++	const struct ath9k_channel *chan = ah->curchan;
++
++	if (!chan)
++		return 300;
++
++	if (IS_CHAN_HT40(chan))
++		return 300;
++	if (IS_CHAN_HALF_RATE(chan))
++		return 750;
++	if (IS_CHAN_QUARTER_RATE(chan))
++		return 1500;
++	return 600;
++}
++
++/**
+  * ath_dynack_ewma - EWMA (Exponentially Weighted Moving Average) calculation
+  *
+  */
+@@ -126,15 +145,16 @@ static void ath_dynack_compute_ackto(str
+  */
+ static void ath_dynack_compute_to(struct ath_hw *ah)
+ {
+-	u32 ackto, ack_ts;
+-	u8 *dst, *src;
++	struct ath_dynack *da = &ah->dynack;
++	u32 ackto, ack_ts, max_to;
+ 	struct ieee80211_sta *sta;
+-	struct ath_node *an;
+ 	struct ts_info *st_ts;
+-	struct ath_dynack *da = &ah->dynack;
++	struct ath_node *an;
++	u8 *dst, *src;
+ 
+ 	rcu_read_lock();
+ 
++	max_to = ath_dynack_get_max_to(ah);
+ 	while (da->st_rbf.h_rb != da->st_rbf.t_rb &&
+ 	       da->ack_rbf.h_rb != da->ack_rbf.t_rb) {
+ 		ack_ts = da->ack_rbf.tstamp[da->ack_rbf.h_rb];
+@@ -150,7 +170,7 @@ static void ath_dynack_compute_to(struct
+ 		if (ack_ts > st_ts->tstamp + st_ts->dur) {
+ 			ackto = ack_ts - st_ts->tstamp - st_ts->dur;
+ 
+-			if (ackto < MAX_DELAY) {
++			if (ackto < max_to) {
+ 				sta = ieee80211_find_sta_by_ifaddr(ah->hw, dst,
+ 								   src);
+ 				if (sta) {
+@@ -207,8 +227,10 @@ void ath_dynack_sample_tx_ts(struct ath_
+ 		if (ieee80211_is_assoc_req(hdr->frame_control) ||
+ 		    ieee80211_is_assoc_resp(hdr->frame_control) ||
+ 		    ieee80211_is_auth(hdr->frame_control)) {
++			u32 max_to = ath_dynack_get_max_to(ah);
++
+ 			ath_dbg(common, DYNACK, "late ack\n");
+-			ath_dynack_set_timeout(ah, LATEACK_TO);
++			ath_dynack_set_timeout(ah, max_to);
+ 			if (sta) {
+ 				struct ath_node *an;
+ 
diff -uprN a/package/kernel/mac80211/patches/ath/561-ath9k-dynack-set-ackto-to-max-timeout-in-ath_dynack_.patch b/package/kernel/mac80211/patches/ath/561-ath9k-dynack-set-ackto-to-max-timeout-in-ath_dynack_.patch
--- a/package/kernel/mac80211/patches/ath/561-ath9k-dynack-set-ackto-to-max-timeout-in-ath_dynack_.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/561-ath9k-dynack-set-ackto-to-max-timeout-in-ath_dynack_.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,73 @@
+From cc783bfa67e87d2e6206f7626b7bbb74d5c5f269 Mon Sep 17 00:00:00 2001
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 20 Aug 2019 18:20:22 +0200
+Subject: [PATCH 4/4] ath9k: dynack: set ackto to max timeout in
+ ath_dynack_reset
+
+Initialize acktimeout to the maximum configurable value in
+ath_dynack_reset in order to not disconnect long distance static links
+enabling dynack and even to take care of possible errors configuring
+a static timeout. Moreover initialize station timeout value to the current
+acktimeout value
+
+Tested-by: Koen Vandeputte <koen.vandeputte@ncentric.com>
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+---
+ drivers/net/wireless/ath/ath9k/dynack.c | 20 +++++++++++++-------
+ 1 file changed, 13 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath9k/dynack.c
++++ b/drivers/net/wireless/ath/ath9k/dynack.c
+@@ -321,11 +321,9 @@ EXPORT_SYMBOL(ath_dynack_sample_ack_ts);
+  */
+ void ath_dynack_node_init(struct ath_hw *ah, struct ath_node *an)
+ {
+-	/* ackto = slottime + sifs + air delay */
+-	u32 ackto = 9 + 16 + 64;
+ 	struct ath_dynack *da = &ah->dynack;
+ 
+-	an->ackto = ackto;
++	an->ackto = da->ackto;
+ 
+ 	spin_lock_bh(&da->qlock);
+ 	list_add_tail(&an->list, &da->nodes);
+@@ -356,20 +354,26 @@ EXPORT_SYMBOL(ath_dynack_node_deinit);
+  */
+ void ath_dynack_reset(struct ath_hw *ah)
+ {
+-	/* ackto = slottime + sifs + air delay */
+-	u32 ackto = 9 + 16 + 64;
+ 	struct ath_dynack *da = &ah->dynack;
++	struct ath_node *an;
++
++	spin_lock_bh(&da->qlock);
+ 
+ 	da->lto = jiffies + COMPUTE_TO;
+-	da->ackto = ackto;
+ 
+ 	da->st_rbf.t_rb = 0;
+ 	da->st_rbf.h_rb = 0;
+ 	da->ack_rbf.t_rb = 0;
+ 	da->ack_rbf.h_rb = 0;
+ 
++	da->ackto = ath_dynack_get_max_to(ah);
++	list_for_each_entry(an, &da->nodes, list)
++		an->ackto = da->ackto;
++
+ 	/* init acktimeout */
+-	ath_dynack_set_timeout(ah, ackto);
++	ath_dynack_set_timeout(ah, da->ackto);
++
++	spin_unlock_bh(&da->qlock);
+ }
+ EXPORT_SYMBOL(ath_dynack_reset);
+ 
+@@ -386,6 +390,8 @@ void ath_dynack_init(struct ath_hw *ah)
+ 
+ 	spin_lock_init(&da->qlock);
+ 	INIT_LIST_HEAD(&da->nodes);
++	/* ackto = slottime + sifs + air delay */
++	da->ackto = 9 + 16 + 64;
+ 
+ 	ah->hw->wiphy->features |= NL80211_FEATURE_ACKTO_ESTIMATION;
+ }
diff -uprN a/package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch
--- a/package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/921-ath10k_init_devices_synchronously.patch	2022-04-04 20:20:32.947828000 +0800
@@ -14,8 +14,8 @@ Signed-off-by: Sven Eckelmann <sven@open
 
 --- a/drivers/net/wireless/ath/ath10k/core.c
 +++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -3074,6 +3074,16 @@ int ath10k_core_register(struct ath10k *
- 
+@@ -2735,6 +2735,16 @@ int ath10k_core_register(struct ath10k *
+ 	ar->chip_id = chip_id;
  	queue_work(ar->workqueue, &ar->register_work);
  
 +	/* OpenWrt requires all PHYs to be initialized to create the
diff -uprN a/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch b/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch
--- a/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/922-ath10k-increase-rx-buffer-size-to-2048.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,37 @@
+From: Linus Lüssing <ll@simonwunderlich.de>
+Date: Wed, 5 Feb 2020 20:10:43 +0100
+Subject: ath10k: increase rx buffer size to 2048
+
+Before, only frames with a maximum size of 1528 bytes could be
+transmitted between two 802.11s nodes.
+
+For batman-adv for instance, which adds its own header to each frame,
+we typically need an MTU of at least 1532 bytes to be able to transmit
+without fragmentation.
+
+This patch now increases the maxmimum frame size from 1528 to 1656
+bytes.
+
+Tested with two ath10k devices in 802.11s mode, as well as with
+batman-adv on top of 802.11s with forwarding disabled.
+
+Fix originally found and developed by Ben Greear.
+
+Link: https://github.com/greearb/ath10k-ct/issues/89
+Link: https://github.com/greearb/ath10k-ct/commit/9e5ab25027e0971fa24ccf93373324c08c4e992d
+Cc: Ben Greear <greearb@candelatech.com>
+Signed-off-by: Linus Lüssing <ll@simonwunderlich.de>
+
+Forwarded: https://patchwork.kernel.org/patch/11367055/
+
+--- a/drivers/net/wireless/ath/ath10k/htt.h
++++ b/drivers/net/wireless/ath/ath10k/htt.h
+@@ -2004,7 +2004,7 @@ struct htt_rx_desc {
+  * Should be: sizeof(struct htt_host_rx_desc) + max rx MSDU size,
+  * rounded up to a cache line size.
+  */
+-#define HTT_RX_BUF_SIZE 1920
++#define HTT_RX_BUF_SIZE 2048
+ #define HTT_RX_MSDU_SIZE (HTT_RX_BUF_SIZE - (int)sizeof(struct htt_rx_desc))
+ 
+ /* Refill a bunch of RX buffers for each refill round so that FW/HW can handle
diff -uprN a/package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch b/package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch
--- a/package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/930-ath10k_add_tpt_led_trigger.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -8673,6 +8673,21 @@ static int ath10k_mac_init_rd(struct ath
+@@ -8293,6 +8293,21 @@ static int ath10k_mac_init_rd(struct ath
  	return 0;
  }
  
@@ -22,9 +22,9 @@
  int ath10k_mac_register(struct ath10k *ar)
  {
  	static const u32 cipher_suites[] = {
-@@ -9000,6 +9015,12 @@ int ath10k_mac_register(struct ath10k *a
+@@ -8577,6 +8592,12 @@ int ath10k_mac_register(struct ath10k *a
  
- 	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
+ 	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
  
 +#ifdef CPTCFG_MAC80211_LEDS
 +	ieee80211_create_tpt_led_trigger(ar->hw,
diff -uprN a/package/kernel/mac80211/patches/ath/960-0010-ath10k-limit-htt-rx-ring-size.patch b/package/kernel/mac80211/patches/ath/960-0010-ath10k-limit-htt-rx-ring-size.patch
--- a/package/kernel/mac80211/patches/ath/960-0010-ath10k-limit-htt-rx-ring-size.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/960-0010-ath10k-limit-htt-rx-ring-size.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,11 @@
+--- a/drivers/net/wireless/ath/ath10k/htt.h
++++ b/drivers/net/wireless/ath/ath10k/htt.h
+@@ -238,7 +238,7 @@ enum htt_rx_ring_flags {
+ };
+ 
+ #define HTT_RX_RING_SIZE_MIN 128
+-#define HTT_RX_RING_SIZE_MAX 2048
++#define HTT_RX_RING_SIZE_MAX 512
+ #define HTT_RX_RING_SIZE HTT_RX_RING_SIZE_MAX
+ #define HTT_RX_RING_FILL_LEVEL (((HTT_RX_RING_SIZE) / 2) - 1)
+ #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
diff -uprN a/package/kernel/mac80211/patches/ath/960-0011-ath10k-limit-pci-buffer-size.patch b/package/kernel/mac80211/patches/ath/960-0011-ath10k-limit-pci-buffer-size.patch
--- a/package/kernel/mac80211/patches/ath/960-0011-ath10k-limit-pci-buffer-size.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/960-0011-ath10k-limit-pci-buffer-size.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,38 @@
+--- a/drivers/net/wireless/ath/ath10k/pci.c
++++ b/drivers/net/wireless/ath/ath10k/pci.c
+@@ -142,7 +142,7 @@ static struct ce_attr host_ce_config_wla
+ 		.flags = CE_ATTR_FLAGS,
+ 		.src_nentries = 0,
+ 		.src_sz_max = 2048,
+-		.dest_nentries = 512,
++		.dest_nentries = 128,
+ 		.recv_cb = ath10k_pci_htt_htc_rx_cb,
+ 	},
+ 
+@@ -151,7 +151,7 @@ static struct ce_attr host_ce_config_wla
+ 		.flags = CE_ATTR_FLAGS,
+ 		.src_nentries = 0,
+ 		.src_sz_max = 2048,
+-		.dest_nentries = 128,
++		.dest_nentries = 64,
+ 		.recv_cb = ath10k_pci_htc_rx_cb,
+ 	},
+ 
+@@ -178,7 +178,7 @@ static struct ce_attr host_ce_config_wla
+ 		.flags = CE_ATTR_FLAGS,
+ 		.src_nentries = 0,
+ 		.src_sz_max = 512,
+-		.dest_nentries = 512,
++		.dest_nentries = 128,
+ 		.recv_cb = ath10k_pci_htt_rx_cb,
+ 	},
+ 
+@@ -203,7 +203,7 @@ static struct ce_attr host_ce_config_wla
+ 		.flags = CE_ATTR_FLAGS,
+ 		.src_nentries = 0,
+ 		.src_sz_max = 2048,
+-		.dest_nentries = 128,
++		.dest_nentries = 96,
+ 		.recv_cb = ath10k_pci_pktlog_rx_cb,
+ 	},
+ 
diff -uprN a/package/kernel/mac80211/patches/ath/972-ath10k_fix-crash-due-to-wrong-handling-of-peer_bw_rxnss_override-parameter.patch b/package/kernel/mac80211/patches/ath/972-ath10k_fix-crash-due-to-wrong-handling-of-peer_bw_rxnss_override-parameter.patch
--- a/package/kernel/mac80211/patches/ath/972-ath10k_fix-crash-due-to-wrong-handling-of-peer_bw_rxnss_override-parameter.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/972-ath10k_fix-crash-due-to-wrong-handling-of-peer_bw_rxnss_override-parameter.patch	2022-04-04 20:20:32.947828000 +0800
@@ -23,7 +23,7 @@ v9: use SM/MS macros from code.h to simp
  3 files changed, 52 insertions(+), 23 deletions(-)
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -2515,7 +2515,7 @@ static void ath10k_peer_assoc_h_vht(stru
+@@ -2474,7 +2474,7 @@ static void ath10k_peer_assoc_h_vht(stru
  	const u16 *vht_mcs_mask;
  	u8 ampdu_factor;
  	u8 max_nss, vht_mcs;
@@ -32,7 +32,7 @@ v9: use SM/MS macros from code.h to simp
  
  	if (WARN_ON(ath10k_mac_vif_chan(vif, &def)))
  		return;
-@@ -2575,23 +2575,45 @@ static void ath10k_peer_assoc_h_vht(stru
+@@ -2534,23 +2534,45 @@ static void ath10k_peer_assoc_h_vht(stru
  		__le16_to_cpu(vht_cap->vht_mcs.tx_highest);
  	arg->peer_vht_rates.tx_mcs_set = ath10k_peer_assoc_h_vht_limit(
  		__le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);
@@ -92,7 +92,7 @@ v9: use SM/MS macros from code.h to simp
  }
  
  static void ath10k_peer_assoc_h_qos(struct ath10k *ar,
-@@ -2743,9 +2765,9 @@ static int ath10k_peer_assoc_prepare(str
+@@ -2702,9 +2724,9 @@ static int ath10k_peer_assoc_prepare(str
  	ath10k_peer_assoc_h_crypto(ar, vif, sta, arg);
  	ath10k_peer_assoc_h_rates(ar, vif, sta, arg);
  	ath10k_peer_assoc_h_ht(ar, vif, sta, arg);
@@ -105,7 +105,7 @@ v9: use SM/MS macros from code.h to simp
  }
 --- a/drivers/net/wireless/ath/ath10k/wmi.c
 +++ b/drivers/net/wireless/ath/ath10k/wmi.c
-@@ -7552,12 +7552,7 @@ ath10k_wmi_peer_assoc_fill_10_4(struct a
+@@ -7396,12 +7396,7 @@ ath10k_wmi_peer_assoc_fill_10_4(struct a
  	struct wmi_10_4_peer_assoc_complete_cmd *cmd = buf;
  
  	ath10k_wmi_peer_assoc_fill_10_2(ar, buf, arg);
@@ -121,7 +121,7 @@ v9: use SM/MS macros from code.h to simp
  static int
 --- a/drivers/net/wireless/ath/ath10k/wmi.h
 +++ b/drivers/net/wireless/ath/ath10k/wmi.h
-@@ -6478,7 +6478,19 @@ struct wmi_10_2_peer_assoc_complete_cmd
+@@ -6357,7 +6357,19 @@ struct wmi_10_2_peer_assoc_complete_cmd
  	__le32 info0; /* WMI_PEER_ASSOC_INFO0_ */
  } __packed;
  
diff -uprN a/package/kernel/mac80211/patches/ath/973-ath10k_fix-band_center_freq-handling-for-VHT160-in-recent-firmwares.patch b/package/kernel/mac80211/patches/ath/973-ath10k_fix-band_center_freq-handling-for-VHT160-in-recent-firmwares.patch
--- a/package/kernel/mac80211/patches/ath/973-ath10k_fix-band_center_freq-handling-for-VHT160-in-recent-firmwares.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/973-ath10k_fix-band_center_freq-handling-for-VHT160-in-recent-firmwares.patch	2022-04-04 20:20:32.947828000 +0800
@@ -13,7 +13,7 @@ v2: fix trailing whitespace issue and fi
  2 files changed, 8 insertions(+), 10 deletions(-)
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -4575,13 +4575,6 @@ static struct ieee80211_sta_vht_cap ath1
+@@ -4476,13 +4476,6 @@ static struct ieee80211_sta_vht_cap ath1
  		vht_cap.cap |= val;
  	}
  
@@ -29,7 +29,7 @@ v2: fix trailing whitespace issue and fi
  		if ((i < ar->num_rf_chains) && (ar->cfg_tx_chainmask & BIT(i)))
 --- a/drivers/net/wireless/ath/ath10k/wmi.c
 +++ b/drivers/net/wireless/ath/ath10k/wmi.c
-@@ -1700,13 +1700,18 @@ void ath10k_wmi_put_wmi_channel(struct w
+@@ -1677,13 +1677,18 @@ void ath10k_wmi_put_wmi_channel(struct w
  		flags |= WMI_CHAN_FLAG_HT40_PLUS;
  	if (arg->chan_radar)
  		flags |= WMI_CHAN_FLAG_DFS;
diff -uprN a/package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch b/package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch
--- a/package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/974-ath10k_add-LED-and-GPIO-controlling-support-for-various-chipsets.patch	2022-04-04 20:20:32.947828000 +0800
@@ -85,7 +85,7 @@ v13:
  create mode 100644 drivers/net/wireless/ath/ath10k/leds.h
 --- a/drivers/net/wireless/ath/ath10k/Kconfig
 +++ b/drivers/net/wireless/ath/ath10k/Kconfig
-@@ -71,6 +71,16 @@ config ATH10K_DEBUGFS
+@@ -69,6 +69,16 @@ config ATH10K_DEBUGFS
  
  	  If unsure, say Y to make it easier to debug problems.
  
@@ -114,7 +114,7 @@ v13:
  ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
 --- a/local-symbols
 +++ b/local-symbols
-@@ -145,6 +145,7 @@ ATH10K_DEBUG=
+@@ -142,6 +142,7 @@ ATH10K_DEBUG=
  ATH10K_DEBUGFS=
  ATH10K_SPECTRAL=
  ATH10K_THERMAL=
@@ -124,57 +124,57 @@ v13:
  WCN36XX=
 --- a/drivers/net/wireless/ath/ath10k/core.c
 +++ b/drivers/net/wireless/ath/ath10k/core.c
-@@ -24,6 +24,7 @@
+@@ -34,6 +34,7 @@
  #include "testmode.h"
  #include "wmi-ops.h"
  #include "coredump.h"
 +#include "leds.h"
  
  unsigned int ath10k_debug_mask;
- EXPORT_SYMBOL(ath10k_debug_mask);
-@@ -60,6 +61,7 @@ static const struct ath10k_hw_params ath
+ static unsigned int ath10k_cryptmode_param;
+@@ -64,6 +65,7 @@ static const struct ath10k_hw_params ath
+ 		.id = QCA988X_HW_2_0_VERSION,
  		.dev_id = QCA988X_2_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
  		.name = "qca988x hw2.0",
 +		.led_pin = 1,
  		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
-@@ -130,6 +132,7 @@ static const struct ath10k_hw_params ath
+@@ -131,6 +133,7 @@ static const struct ath10k_hw_params ath
+ 		.id = QCA9887_HW_1_0_VERSION,
  		.dev_id = QCA9887_1_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
  		.name = "qca9887 hw1.0",
 +		.led_pin = 1,
  		.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
-@@ -337,6 +340,7 @@ static const struct ath10k_hw_params ath
+@@ -300,6 +303,7 @@ static const struct ath10k_hw_params ath
+ 		.id = QCA99X0_HW_2_0_DEV_VERSION,
  		.dev_id = QCA99X0_2_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
  		.name = "qca99x0 hw2.0",
 +		.led_pin = 17,
  		.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.otp_exe_param = 0x00000700,
-@@ -378,6 +382,7 @@ static const struct ath10k_hw_params ath
+@@ -339,6 +343,7 @@ static const struct ath10k_hw_params ath
+ 		.id = QCA9984_HW_1_0_DEV_VERSION,
  		.dev_id = QCA9984_1_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
  		.name = "qca9984/qca9994 hw1.0",
 +		.led_pin = 17,
  		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
-@@ -426,6 +431,7 @@ static const struct ath10k_hw_params ath
+@@ -383,6 +388,7 @@ static const struct ath10k_hw_params ath
+ 		.id = QCA9888_HW_2_0_DEV_VERSION,
  		.dev_id = QCA9888_2_0_DEVICE_ID,
- 		.bus = ATH10K_BUS_PCI,
  		.name = "qca9888 hw2.0",
 +		.led_pin = 17,
  		.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,
  		.uart_pin = 7,
  		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
-@@ -2791,6 +2797,10 @@ int ath10k_core_start(struct ath10k *ar,
+@@ -2456,6 +2462,10 @@ int ath10k_core_start(struct ath10k *ar,
+ 	if (status)
  		goto err_hif_stop;
- 	}
  
 +	status = ath10k_leds_start(ar);
 +	if (status)
@@ -183,7 +183,7 @@ v13:
  	return 0;
  
  err_hif_stop:
-@@ -3047,9 +3057,18 @@ static void ath10k_core_register_work(st
+@@ -2710,9 +2720,18 @@ static void ath10k_core_register_work(st
  		goto err_spectral_destroy;
  	}
  
@@ -202,7 +202,7 @@ v13:
  err_spectral_destroy:
  	ath10k_spectral_destroy(ar);
  err_debug_destroy:
-@@ -3095,6 +3114,8 @@ void ath10k_core_unregister(struct ath10
+@@ -2756,6 +2775,8 @@ void ath10k_core_unregister(struct ath10
  	if (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
  		return;
  
@@ -213,7 +213,7 @@ v13:
  	 * relayfs debugfs file cleanly. Otherwise the parent debugfs tree
 --- a/drivers/net/wireless/ath/ath10k/core.h
 +++ b/drivers/net/wireless/ath/ath10k/core.h
-@@ -14,6 +14,7 @@
+@@ -25,6 +25,7 @@
  #include <linux/pci.h>
  #include <linux/uuid.h>
  #include <linux/time.h>
@@ -221,7 +221,15 @@ v13:
  
  #include "htt.h"
  #include "htc.h"
-@@ -1170,6 +1171,13 @@ struct ath10k {
+@@ -908,7 +909,6 @@ struct ath10k {
+ 	u32 low_5ghz_chan;
+ 	u32 high_5ghz_chan;
+ 	bool ani_enabled;
+-
+ 	bool p2p;
+ 
+ 	struct {
+@@ -1100,6 +1100,13 @@ struct ath10k {
  	} testmode;
  
  	struct {
@@ -237,7 +245,7 @@ v13:
  		u32 fw_warm_reset_counter;
 --- a/drivers/net/wireless/ath/ath10k/hw.h
 +++ b/drivers/net/wireless/ath/ath10k/hw.h
-@@ -514,6 +514,7 @@ struct ath10k_hw_params {
+@@ -504,6 +504,7 @@ struct ath10k_hw_params {
  	const char *name;
  	u32 patch_load_addr;
  	int uart_pin;
@@ -397,7 +405,7 @@ v13:
 +#endif /* _LEDS_H_ */
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -23,6 +23,7 @@
+@@ -34,6 +34,7 @@
  #include "wmi-tlv.h"
  #include "wmi-ops.h"
  #include "wow.h"
@@ -407,10 +415,10 @@ v13:
  /* Rates */
 --- a/drivers/net/wireless/ath/ath10k/wmi-ops.h
 +++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h
-@@ -216,7 +216,10 @@ struct wmi_ops {
- 	struct sk_buff *(*gen_bb_timing)
- 			(struct ath10k *ar,
- 			 const struct wmi_bb_timing_cfg_arg *arg);
+@@ -217,7 +217,10 @@ struct wmi_ops {
+ 	struct sk_buff *(*gen_echo)(struct ath10k *ar, u32 value);
+ 	struct sk_buff *(*gen_pdev_get_tpc_table_cmdid)(struct ath10k *ar,
+ 							u32 param);
 +	struct sk_buff *(*gen_gpio_config)(struct ath10k *ar, u32 gpio_num,
 +					   u32 input, u32 pull_type, u32 intr_mode);
  
@@ -418,7 +426,7 @@ v13:
  };
  
  int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id);
-@@ -1080,6 +1083,35 @@ ath10k_wmi_force_fw_hang(struct ath10k *
+@@ -1064,6 +1067,35 @@ ath10k_wmi_force_fw_hang(struct ath10k *
  	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->force_fw_hang_cmdid);
  }
  
@@ -456,7 +464,7 @@ v13:
  {
 --- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c
 +++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
-@@ -4367,6 +4367,8 @@ static const struct wmi_ops wmi_tlv_ops
+@@ -3999,6 +3999,8 @@ static const struct wmi_ops wmi_tlv_ops
  	.gen_echo = ath10k_wmi_tlv_op_gen_echo,
  	.gen_vdev_spectral_conf = ath10k_wmi_tlv_op_gen_vdev_spectral_conf,
  	.gen_vdev_spectral_enable = ath10k_wmi_tlv_op_gen_vdev_spectral_enable,
@@ -467,7 +475,7 @@ v13:
  static const struct wmi_peer_flags_map wmi_tlv_peer_flags_map = {
 --- a/drivers/net/wireless/ath/ath10k/wmi.c
 +++ b/drivers/net/wireless/ath/ath10k/wmi.c
-@@ -7372,6 +7372,49 @@ ath10k_wmi_op_gen_peer_set_param(struct
+@@ -7216,6 +7216,49 @@ ath10k_wmi_op_gen_peer_set_param(struct
  	return skb;
  }
  
@@ -517,7 +525,7 @@ v13:
  static struct sk_buff *
  ath10k_wmi_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,
  			     enum wmi_sta_ps_mode psmode)
-@@ -9029,6 +9072,9 @@ static const struct wmi_ops wmi_ops = {
+@@ -8827,6 +8870,9 @@ static const struct wmi_ops wmi_ops = {
  	.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,
  	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
  	.gen_echo = ath10k_wmi_op_gen_echo,
@@ -527,7 +535,7 @@ v13:
  	/* .gen_bcn_tmpl not implemented */
  	/* .gen_prb_tmpl not implemented */
  	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -9099,6 +9145,8 @@ static const struct wmi_ops wmi_10_1_ops
+@@ -8897,6 +8943,8 @@ static const struct wmi_ops wmi_10_1_ops
  	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
  	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
  	.gen_echo = ath10k_wmi_op_gen_echo,
@@ -536,7 +544,7 @@ v13:
  	/* .gen_bcn_tmpl not implemented */
  	/* .gen_prb_tmpl not implemented */
  	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -9171,6 +9219,8 @@ static const struct wmi_ops wmi_10_2_ops
+@@ -8968,6 +9016,8 @@ static const struct wmi_ops wmi_10_2_ops
  	.gen_delba_send = ath10k_wmi_op_gen_delba_send,
  	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
  	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
@@ -545,16 +553,16 @@ v13:
  	/* .gen_pdev_enable_adaptive_cca not implemented */
  };
  
-@@ -9242,6 +9292,8 @@ static const struct wmi_ops wmi_10_2_4_o
+@@ -9038,6 +9088,8 @@ static const struct wmi_ops wmi_10_2_4_o
+ 	.gen_pdev_enable_adaptive_cca =
  		ath10k_wmi_op_gen_pdev_enable_adaptive_cca,
  	.get_vdev_subtype = ath10k_wmi_10_2_4_op_get_vdev_subtype,
- 	.gen_bb_timing = ath10k_wmi_10_2_4_op_gen_bb_timing,
 +	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
 +	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
  	/* .gen_bcn_tmpl not implemented */
  	/* .gen_prb_tmpl not implemented */
  	/* .gen_p2p_go_bcn_ie not implemented */
-@@ -9322,6 +9374,8 @@ static const struct wmi_ops wmi_10_4_ops
+@@ -9117,6 +9169,8 @@ static const struct wmi_ops wmi_10_4_ops
  	.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,
  	.gen_echo = ath10k_wmi_op_gen_echo,
  	.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,
@@ -565,7 +573,7 @@ v13:
  int ath10k_wmi_attach(struct ath10k *ar)
 --- a/drivers/net/wireless/ath/ath10k/wmi.h
 +++ b/drivers/net/wireless/ath/ath10k/wmi.h
-@@ -3005,6 +3005,41 @@ enum wmi_10_4_feature_mask {
+@@ -2942,6 +2942,41 @@ enum wmi_10_4_feature_mask {
  
  };
  
diff -uprN a/package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch b/package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch
--- a/package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/975-ath10k-use-tpt-trigger-by-default.patch	2022-04-04 20:20:32.947828000 +0800
@@ -16,9 +16,9 @@ Signed-off-by: Mathias Kresin <dev@kresi
 
 --- a/drivers/net/wireless/ath/ath10k/core.h
 +++ b/drivers/net/wireless/ath/ath10k/core.h
-@@ -1219,6 +1219,10 @@ struct ath10k {
- 	struct ath10k_bus_params bus_param;
- 	struct completion peer_delete_done;
+@@ -1145,6 +1145,10 @@ struct ath10k {
+ 	struct ath10k_radar_found_info last_radar_info;
+ 	struct work_struct radar_confirmation_work;
  
 +#ifdef CPTCFG_MAC80211_LEDS
 +	const char *led_default_trigger;
@@ -42,8 +42,8 @@ Signed-off-by: Mathias Kresin <dev@kresi
  	if (ret)
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -9032,7 +9032,7 @@ int ath10k_mac_register(struct ath10k *a
- 	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
+@@ -8609,7 +8609,7 @@ int ath10k_mac_register(struct ath10k *a
+ 	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
  
  #ifdef CPTCFG_MAC80211_LEDS
 -	ieee80211_create_tpt_led_trigger(ar->hw,
diff -uprN a/package/kernel/mac80211/patches/ath/977-ath10k-add-support-for-configuring-management-packet.patch b/package/kernel/mac80211/patches/ath/977-ath10k-add-support-for-configuring-management-packet.patch
--- a/package/kernel/mac80211/patches/ath/977-ath10k-add-support-for-configuring-management-packet.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/977-ath10k-add-support-for-configuring-management-packet.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,89 @@
+From: Sriram R <srirrama@codeaurora.org>
+Date: Mon, 10 Sep 2018 11:09:40 +0530
+Subject: [PATCH] ath10k: add support for configuring management packet rate
+
+By default the firmware uses 1Mbps and 6Mbps rate for management packets
+in 2G and 5G bands respectively. But when the user selects different
+basic rates from the userspace, we need to send the management
+packets at the lowest basic rate selected by the user.
+
+This change makes use of WMI_VDEV_PARAM_MGMT_RATE param for configuring the
+management packets rate to the firmware.
+
+Chipsets Tested : QCA988X, QCA9887, QCA9984
+FW Tested 	: 10.2.4-1.0-41, 10.4-3.6.104
+
+Signed-off-by: Sriram R <srirrama@codeaurora.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+
+Origin: backport, https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f279294e9ee22a8f306fdc8e4181cf555e6f0f70
+---
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -158,6 +158,22 @@ u8 ath10k_mac_bitrate_to_idx(const struc
+ 	return 0;
+ }
+ 
++static int ath10k_mac_get_rate_hw_value(int bitrate)
++{
++	int i;
++	u8 hw_value_prefix = 0;
++
++	if (ath10k_mac_bitrate_is_cck(bitrate))
++		hw_value_prefix = WMI_RATE_PREAMBLE_CCK << 6;
++
++	for (i = 0; i < sizeof(ath10k_rates); i++) {
++		if (ath10k_rates[i].bitrate == bitrate)
++			return hw_value_prefix | ath10k_rates[i].hw_value;
++	}
++
++	return -EINVAL;
++}
++
+ static int ath10k_mac_get_max_vht_mcs_map(u16 mcs_map, int nss)
+ {
+ 	switch ((mcs_map >> (2 * nss)) & 0x3) {
+@@ -5478,9 +5494,10 @@ static void ath10k_bss_info_changed(stru
+ 	struct cfg80211_chan_def def;
+ 	u32 vdev_param, pdev_param, slottime, preamble;
+ 	u16 bitrate, hw_value;
+-	u8 rate;
+-	int rateidx, ret = 0;
++	u8 rate, basic_rate_idx;
++	int rateidx, ret = 0, hw_rate_code;
+ 	enum nl80211_band band;
++	const struct ieee80211_supported_band *sband;
+ 
+ 	mutex_lock(&ar->conf_mutex);
+ 
+@@ -5686,6 +5703,30 @@ static void ath10k_bss_info_changed(stru
+ 				    arvif->vdev_id,  ret);
+ 	}
+ 
++	if (changed & BSS_CHANGED_BASIC_RATES) {
++		if (WARN_ON(ath10k_mac_vif_chan(vif, &def))) {
++			mutex_unlock(&ar->conf_mutex);
++			return;
++		}
++
++	sband = ar->hw->wiphy->bands[def.chan->band];
++	basic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;
++	bitrate = sband->bitrates[basic_rate_idx].bitrate;
++
++	hw_rate_code = ath10k_mac_get_rate_hw_value(bitrate);
++	if (hw_rate_code < 0) {
++		ath10k_warn(ar, "bitrate not supported %d\n", bitrate);
++		mutex_unlock(&ar->conf_mutex);
++		return;
++	}
++
++	vdev_param = ar->wmi.vdev_param->mgmt_rate;
++	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
++					hw_rate_code);
++	if (ret)
++		ath10k_warn(ar, "failed to set mgmt tx rate %d\n", ret);
++	}
++
+ 	mutex_unlock(&ar->conf_mutex);
+ }
+ 
diff -uprN a/package/kernel/mac80211/patches/ath/978-ath10k-fix-possible-out-of-bound-access-of-ath10k_ra.patch b/package/kernel/mac80211/patches/ath/978-ath10k-fix-possible-out-of-bound-access-of-ath10k_ra.patch
--- a/package/kernel/mac80211/patches/ath/978-ath10k-fix-possible-out-of-bound-access-of-ath10k_ra.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/978-ath10k-fix-possible-out-of-bound-access-of-ath10k_ra.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,66 @@
+From: Sriram R <srirrama@codeaurora.org>
+Date: Wed, 3 Oct 2018 08:43:50 +0530
+Subject: [PATCH] ath10k: fix possible out of bound access of ath10k_rates array
+
+While using 'ath10k_mac_get_rate_hw_value()' to obtain the hw value
+from the passed bitrate, there is a chance of out of bound array access
+when wrong bitrate is passed. This is fixed by comparing the bitrates
+within the correct size of the ath10k_rates array.
+
+Fixes commit f279294e9ee2 ("ath10k: add support for configuring management
+packet rate"). Also correction made to some indents used in the above commit.
+
+Signed-off-by: Sriram R <srirrama@codeaurora.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+
+Origin: backport, https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e141eea7dd8525dd1ef7a925459e455b4d307f
+---
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -166,7 +166,7 @@ static int ath10k_mac_get_rate_hw_value(
+ 	if (ath10k_mac_bitrate_is_cck(bitrate))
+ 		hw_value_prefix = WMI_RATE_PREAMBLE_CCK << 6;
+ 
+-	for (i = 0; i < sizeof(ath10k_rates); i++) {
++	for (i = 0; i < ARRAY_SIZE(ath10k_rates); i++) {
+ 		if (ath10k_rates[i].bitrate == bitrate)
+ 			return hw_value_prefix | ath10k_rates[i].hw_value;
+ 	}
+@@ -5709,22 +5709,22 @@ static void ath10k_bss_info_changed(stru
+ 			return;
+ 		}
+ 
+-	sband = ar->hw->wiphy->bands[def.chan->band];
+-	basic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;
+-	bitrate = sband->bitrates[basic_rate_idx].bitrate;
+-
+-	hw_rate_code = ath10k_mac_get_rate_hw_value(bitrate);
+-	if (hw_rate_code < 0) {
+-		ath10k_warn(ar, "bitrate not supported %d\n", bitrate);
+-		mutex_unlock(&ar->conf_mutex);
+-		return;
+-	}
++		sband = ar->hw->wiphy->bands[def.chan->band];
++		basic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;
++		bitrate = sband->bitrates[basic_rate_idx].bitrate;
++
++		hw_rate_code = ath10k_mac_get_rate_hw_value(bitrate);
++		if (hw_rate_code < 0) {
++			ath10k_warn(ar, "bitrate not supported %d\n", bitrate);
++			mutex_unlock(&ar->conf_mutex);
++			return;
++		}
+ 
+-	vdev_param = ar->wmi.vdev_param->mgmt_rate;
+-	ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
+-					hw_rate_code);
+-	if (ret)
+-		ath10k_warn(ar, "failed to set mgmt tx rate %d\n", ret);
++		vdev_param = ar->wmi.vdev_param->mgmt_rate;
++		ret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,
++						hw_rate_code);
++		if (ret)
++			ath10k_warn(ar, "failed to set mgmt tx rate %d\n", ret);
+ 	}
+ 
+ 	mutex_unlock(&ar->conf_mutex);
diff -uprN a/package/kernel/mac80211/patches/ath/979-ath10k-fix-incorrect-multicast-broadcast-rate-settin.patch b/package/kernel/mac80211/patches/ath/979-ath10k-fix-incorrect-multicast-broadcast-rate-settin.patch
--- a/package/kernel/mac80211/patches/ath/979-ath10k-fix-incorrect-multicast-broadcast-rate-settin.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/979-ath10k-fix-incorrect-multicast-broadcast-rate-settin.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,43 @@
+From: Pradeep kumar Chitrapu <pradeepc@codeaurora.org>
+Date: Mon, 10 Dec 2018 20:56:11 -0800
+Subject: ath10k: fix incorrect multicast/broadcast rate setting
+
+Invalid rate code is sent to firmware when multicast rate value of 0 is
+sent to driver indicating disabled case, causing broken mesh path.
+so fix that.
+
+Tested on QCA9984 with firmware 10.4-3.6.1-00827
+
+Fixes: cd93b83ad92 ("ath10k: support for multicast rate control")
+Co-developed-by: Zhi Chen <zhichen@codeaurora.org>
+Signed-off-by: Zhi Chen <zhichen@codeaurora.org>
+Signed-off-by: Pradeep Kumar Chitrapu <pradeepc@codeaurora.org>
+
+Origin: other, https://patchwork.kernel.org/patch/10723033/
+
+--- a/drivers/net/wireless/ath/ath10k/mac.c
++++ b/drivers/net/wireless/ath/ath10k/mac.c
+@@ -5494,8 +5494,8 @@ static void ath10k_bss_info_changed(stru
+ 	struct cfg80211_chan_def def;
+ 	u32 vdev_param, pdev_param, slottime, preamble;
+ 	u16 bitrate, hw_value;
+-	u8 rate, basic_rate_idx;
+-	int rateidx, ret = 0, hw_rate_code;
++	u8 rate, basic_rate_idx, rateidx;
++	int ret = 0, hw_rate_code, mcast_rate;
+ 	enum nl80211_band band;
+ 	const struct ieee80211_supported_band *sband;
+ 
+@@ -5668,7 +5668,11 @@ static void ath10k_bss_info_changed(stru
+ 	if (changed & BSS_CHANGED_MCAST_RATE &&
+ 	    !ath10k_mac_vif_chan(arvif->vif, &def)) {
+ 		band = def.chan->band;
+-		rateidx = vif->bss_conf.mcast_rate[band] - 1;
++		mcast_rate = vif->bss_conf.mcast_rate[band];
++		if (mcast_rate > 0)
++			rateidx = mcast_rate - 1;
++		else
++			rateidx = ffs(vif->bss_conf.basic_rates) - 1;
+ 
+ 		if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)
+ 			rateidx += ATH10K_MAC_FIRST_OFDM_RATE_IDX;
diff -uprN a/package/kernel/mac80211/patches/ath/980-ath10k-fix-max-antenna-gain-unit.patch b/package/kernel/mac80211/patches/ath/980-ath10k-fix-max-antenna-gain-unit.patch
--- a/package/kernel/mac80211/patches/ath/980-ath10k-fix-max-antenna-gain-unit.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/980-ath10k-fix-max-antenna-gain-unit.patch	2022-04-04 20:20:32.947828000 +0800
@@ -20,7 +20,7 @@ Forwarded: https://patchwork.kernel.org/
 
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -1041,7 +1041,7 @@ static int ath10k_monitor_vdev_start(str
+@@ -1020,7 +1020,7 @@ static int ath10k_monitor_vdev_start(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = channel->max_power * 2;
  	arg.channel.max_reg_power = channel->max_reg_power * 2;
@@ -28,8 +28,8 @@ Forwarded: https://patchwork.kernel.org/
 +	arg.channel.max_antenna_gain = channel->max_antenna_gain;
  
  	reinit_completion(&ar->vdev_setup_done);
- 	reinit_completion(&ar->vdev_delete_done);
-@@ -1487,7 +1487,7 @@ static int ath10k_vdev_start_restart(str
+ 
+@@ -1462,7 +1462,7 @@ static int ath10k_vdev_start_restart(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = chandef->chan->max_power * 2;
  	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
@@ -38,7 +38,7 @@ Forwarded: https://patchwork.kernel.org/
  
  	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
  		arg.ssid = arvif->u.ap.ssid;
-@@ -3168,7 +3168,7 @@ static int ath10k_update_channel_list(st
+@@ -3143,7 +3143,7 @@ static int ath10k_update_channel_list(st
  			ch->min_power = 0;
  			ch->max_power = channel->max_power * 2;
  			ch->max_reg_power = channel->max_reg_power * 2;
diff -uprN a/package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch b/package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch
--- a/package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/981-ath10k-adjust-tx-power-reduction-for-US-regulatory-d.patch	2022-04-04 20:20:32.947828000 +0800
@@ -28,7 +28,7 @@ Forwarded: no
 
 --- a/drivers/net/wireless/ath/ath10k/mac.c
 +++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -1009,6 +1009,40 @@ static inline int ath10k_vdev_setup_sync
+@@ -988,6 +988,40 @@ static inline int ath10k_vdev_setup_sync
  	return ar->last_wmi_vdev_start_status;
  }
  
@@ -69,7 +69,7 @@ Forwarded: no
  static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
  {
  	struct cfg80211_chan_def *chandef = NULL;
-@@ -1041,7 +1075,8 @@ static int ath10k_monitor_vdev_start(str
+@@ -1020,7 +1054,8 @@ static int ath10k_monitor_vdev_start(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = channel->max_power * 2;
  	arg.channel.max_reg_power = channel->max_reg_power * 2;
@@ -78,8 +78,8 @@ Forwarded: no
 +						channel->max_antenna_gain);
  
  	reinit_completion(&ar->vdev_setup_done);
- 	reinit_completion(&ar->vdev_delete_done);
-@@ -1487,7 +1522,8 @@ static int ath10k_vdev_start_restart(str
+ 
+@@ -1462,7 +1497,8 @@ static int ath10k_vdev_start_restart(str
  	arg.channel.min_power = 0;
  	arg.channel.max_power = chandef->chan->max_power * 2;
  	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
@@ -89,7 +89,7 @@ Forwarded: no
  
  	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
  		arg.ssid = arvif->u.ap.ssid;
-@@ -3168,7 +3204,8 @@ static int ath10k_update_channel_list(st
+@@ -3143,7 +3179,8 @@ static int ath10k_update_channel_list(st
  			ch->min_power = 0;
  			ch->max_power = channel->max_power * 2;
  			ch->max_reg_power = channel->max_reg_power * 2;
diff -uprN a/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch
--- a/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/ath/983-ath10k-allow-vht-on-2g.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,10 +0,0 @@
---- a/drivers/net/wireless/ath/ath10k/mac.c
-+++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -4718,6 +4718,7 @@ static void ath10k_mac_setup_ht_vht_cap(
- 	if (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {
- 		band = &ar->mac.sbands[NL80211_BAND_2GHZ];
- 		band->ht_cap = ht_cap;
-+		band->vht_cap = vht_cap;
- 	}
- 	if (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {
- 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
diff -uprN a/package/kernel/mac80211/patches/brcm/040-brcmutil_option.patch b/package/kernel/mac80211/patches/brcm/040-brcmutil_option.patch
--- a/package/kernel/mac80211/patches/brcm/040-brcmutil_option.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/040-brcmutil_option.patch	2022-04-04 20:20:32.947828000 +0800
@@ -1,7 +1,6 @@
 --- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
 +++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
-@@ -1,6 +1,6 @@
- # SPDX-License-Identifier: GPL-2.0-only
+@@ -1,5 +1,5 @@
  config BRCMUTIL
 -	tristate
 +	tristate "Broadcom 802.11 driver utility functions"
diff -uprN a/package/kernel/mac80211/patches/brcm/101-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch b/package/kernel/mac80211/patches/brcm/101-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch
--- a/package/kernel/mac80211/patches/brcm/101-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/101-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-From 1524cbf3621576c639405e7aabeac415f9617c8d Mon Sep 17 00:00:00 2001
-From: Adrian Ratiu <adrian.ratiu@collabora.com>
-Date: Wed, 25 Sep 2019 16:44:57 +0300
-Subject: [PATCH] brcmfmac: don't WARN when there are no requests
-
-When n_reqs == 0 there is nothing to do so it doesn't make sense to
-search for requests and issue a warning because none is found.
-
-Signed-off-by: Martyn Welch <martyn.welch@collabora.com>
-Signed-off-by: Adrian Ratiu <adrian.ratiu@collabora.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c | 4 ++++
- 1 file changed, 4 insertions(+)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
-@@ -57,6 +57,10 @@ static int brcmf_pno_remove_request(stru
- 
- 	mutex_lock(&pi->req_lock);
- 
-+	/* Nothing to do if we have no requests */
-+	if (pi->n_reqs == 0)
-+		goto done;
-+
- 	/* find request */
- 	for (i = 0; i < pi->n_reqs; i++) {
- 		if (pi->reqs[i]->reqid == reqid)
diff -uprN a/package/kernel/mac80211/patches/brcm/101-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch b/package/kernel/mac80211/patches/brcm/101-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch
--- a/package/kernel/mac80211/patches/brcm/101-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/101-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,109 +0,0 @@
-From e0ae4bac22effbd644add326f658a3aeeb8d45ee Mon Sep 17 00:00:00 2001
-From: Adrian Ratiu <adrian.ratiu@collabora.com>
-Date: Wed, 25 Sep 2019 16:44:58 +0300
-Subject: [PATCH] brcmfmac: fix suspend/resume when power is cut off
-
-brcmfmac assumed the wifi device always remains powered on and thus
-hardcoded the MMC_PM_KEEP_POWER flag expecting the wifi device to
-remain on even during suspend/resume cycles.
-
-This is not always the case, some appliances cut power to everything
-connected via SDIO for efficiency reasons and this leads to wifi not
-being usable after coming out of suspend because the device was not
-correctly reinitialized.
-
-So we check for the keep_power capability and if it's not present then
-we remove the device and probe it again during resume to mirror what's
-happening in hardware and ensure correct reinitialization in the case
-when MMC_PM_KEEP_POWER is not supported.
-
-Suggested-by: Gustavo Padovan <gustavo.padovan@collabora.com>
-Signed-off-by: Adrian Ratiu <adrian.ratiu@collabora.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../broadcom/brcm80211/brcmfmac/bcmsdh.c      | 53 ++++++++++++++-----
- 1 file changed, 39 insertions(+), 14 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-@@ -1108,7 +1108,8 @@ static int brcmf_ops_sdio_suspend(struct
- 	struct sdio_func *func;
- 	struct brcmf_bus *bus_if;
- 	struct brcmf_sdio_dev *sdiodev;
--	mmc_pm_flag_t sdio_flags;
-+	mmc_pm_flag_t pm_caps, sdio_flags;
-+	int ret = 0;
- 
- 	func = container_of(dev, struct sdio_func, dev);
- 	brcmf_dbg(SDIO, "Enter: F%d\n", func->num);
-@@ -1119,19 +1120,33 @@ static int brcmf_ops_sdio_suspend(struct
- 	bus_if = dev_get_drvdata(dev);
- 	sdiodev = bus_if->bus_priv.sdio;
- 
--	brcmf_sdiod_freezer_on(sdiodev);
--	brcmf_sdio_wd_timer(sdiodev->bus, 0);
-+	pm_caps = sdio_get_host_pm_caps(func);
- 
--	sdio_flags = MMC_PM_KEEP_POWER;
--	if (sdiodev->wowl_enabled) {
--		if (sdiodev->settings->bus.sdio.oob_irq_supported)
--			enable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
--		else
--			sdio_flags |= MMC_PM_WAKE_SDIO_IRQ;
-+	if (pm_caps & MMC_PM_KEEP_POWER) {
-+		/* preserve card power during suspend */
-+		brcmf_sdiod_freezer_on(sdiodev);
-+		brcmf_sdio_wd_timer(sdiodev->bus, 0);
-+
-+		sdio_flags = MMC_PM_KEEP_POWER;
-+		if (sdiodev->wowl_enabled) {
-+			if (sdiodev->settings->bus.sdio.oob_irq_supported)
-+				enable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
-+			else
-+				sdio_flags |= MMC_PM_WAKE_SDIO_IRQ;
-+		}
-+
-+		if (sdio_set_host_pm_flags(sdiodev->func1, sdio_flags))
-+			brcmf_err("Failed to set pm_flags %x\n", sdio_flags);
-+
-+	} else {
-+		/* power will be cut so remove device, probe again in resume */
-+		brcmf_sdiod_intr_unregister(sdiodev);
-+		ret = brcmf_sdiod_remove(sdiodev);
-+		if (ret)
-+			brcmf_err("Failed to remove device on suspend\n");
- 	}
--	if (sdio_set_host_pm_flags(sdiodev->func1, sdio_flags))
--		brcmf_err("Failed to set pm_flags %x\n", sdio_flags);
--	return 0;
-+
-+	return ret;
- }
- 
- static int brcmf_ops_sdio_resume(struct device *dev)
-@@ -1139,13 +1154,23 @@ static int brcmf_ops_sdio_resume(struct
- 	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
- 	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
- 	struct sdio_func *func = container_of(dev, struct sdio_func, dev);
-+	mmc_pm_flag_t pm_caps = sdio_get_host_pm_caps(func);
-+	int ret = 0;
- 
- 	brcmf_dbg(SDIO, "Enter: F%d\n", func->num);
- 	if (func->num != 2)
- 		return 0;
- 
--	brcmf_sdiod_freezer_off(sdiodev);
--	return 0;
-+	if (!(pm_caps & MMC_PM_KEEP_POWER)) {
-+		/* bus was powered off and device removed, probe again */
-+		ret = brcmf_sdiod_probe(sdiodev);
-+		if (ret)
-+			brcmf_err("Failed to probe device on resume\n");
-+	} else {
-+		brcmf_sdiod_freezer_off(sdiodev);
-+	}
-+
-+	return ret;
- }
- 
- static const struct dev_pm_ops brcmf_sdio_pm_ops = {
diff -uprN a/package/kernel/mac80211/patches/brcm/103-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch b/package/kernel/mac80211/patches/brcm/103-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch
--- a/package/kernel/mac80211/patches/brcm/103-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/103-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,58 +0,0 @@
-From 7af496b9eb0433bc4cb478c9a46f85509cdb5541 Mon Sep 17 00:00:00 2001
-From: zhengbin <zhengbin13@huawei.com>
-Date: Sat, 16 Nov 2019 15:22:47 +0800
-Subject: [PATCH] brcmfmac: remove set but not used variable
- 'mpnum','nsp','nmp'
-
-Fixes gcc '-Wunused-but-set-variable' warning:
-
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c: In function brcmf_chip_dmp_get_regaddr:
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:790:5: warning: variable mpnum set but not used [-Wunused-but-set-variable]
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c: In function brcmf_chip_dmp_erom_scan:
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:866:10: warning: variable nsp set but not used [-Wunused-but-set-variable]
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c: In function brcmf_chip_dmp_erom_scan:
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:866:5: warning: variable nmp set but not used [-Wunused-but-set-variable]
-
-Reported-by: Hulk Robot <hulkci@huawei.com>
-Signed-off-by: zhengbin <zhengbin13@huawei.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c | 6 +-----
- 1 file changed, 1 insertion(+), 5 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-@@ -778,7 +778,6 @@ static int brcmf_chip_dmp_get_regaddr(st
- {
- 	u8 desc;
- 	u32 val, szdesc;
--	u8 mpnum = 0;
- 	u8 stype, sztype, wraptype;
- 
- 	*regbase = 0;
-@@ -786,7 +785,6 @@ static int brcmf_chip_dmp_get_regaddr(st
- 
- 	val = brcmf_chip_dmp_get_desc(ci, eromaddr, &desc);
- 	if (desc == DMP_DESC_MASTER_PORT) {
--		mpnum = (val & DMP_MASTER_PORT_NUM) >> DMP_MASTER_PORT_NUM_S;
- 		wraptype = DMP_SLAVE_TYPE_MWRAP;
- 	} else if (desc == DMP_DESC_ADDRESS) {
- 		/* revert erom address */
-@@ -854,7 +852,7 @@ int brcmf_chip_dmp_erom_scan(struct brcm
- 	u8 desc_type = 0;
- 	u32 val;
- 	u16 id;
--	u8 nmp, nsp, nmw, nsw, rev;
-+	u8 nmw, nsw, rev;
- 	u32 base, wrap;
- 	int err;
- 
-@@ -880,8 +878,6 @@ int brcmf_chip_dmp_erom_scan(struct brcm
- 			return -EFAULT;
- 
- 		/* only look at cores with master port(s) */
--		nmp = (val & DMP_COMP_NUM_MPORT) >> DMP_COMP_NUM_MPORT_S;
--		nsp = (val & DMP_COMP_NUM_SPORT) >> DMP_COMP_NUM_SPORT_S;
- 		nmw = (val & DMP_COMP_NUM_MWRAP) >> DMP_COMP_NUM_MWRAP_S;
- 		nsw = (val & DMP_COMP_NUM_SWRAP) >> DMP_COMP_NUM_SWRAP_S;
- 		rev = (val & DMP_COMP_REVISION) >> DMP_COMP_REVISION_S;
diff -uprN a/package/kernel/mac80211/patches/brcm/112-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch b/package/kernel/mac80211/patches/brcm/112-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch
--- a/package/kernel/mac80211/patches/brcm/112-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/112-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
-From 8d9627b05b2c33e4468e65739eb7caf9c3f274d8 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Tue, 10 Dec 2019 12:35:55 +0100
-Subject: [PATCH] brcmfmac: set interface carrier to off by default
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-It's important as brcmfmac creates one main interface for each PHY and
-doesn't allow deleting it. Not setting carrier could result in other
-subsystems misbehaving (e.g. LEDs "netdev" trigger turning LED on).
-
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c | 2 ++
- 1 file changed, 2 insertions(+)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -678,6 +678,8 @@ int brcmf_net_attach(struct brcmf_if *if
- 		goto fail;
- 	}
- 
-+	netif_carrier_off(ndev);
-+
- 	netdev_set_priv_destructor(ndev, brcmf_cfg80211_free_netdev);
- 	brcmf_dbg(INFO, "%s: Broadcom Dongle Host Driver\n", ndev->name);
- 	return 0;
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,121 +0,0 @@
-From 1b8d2e0a9e4221b99eea375c079507ce8ef655f5 Mon Sep 17 00:00:00 2001
-From: Wright Feng <wright.feng@cypress.com>
-Date: Thu, 12 Dec 2019 00:52:45 +0100
-Subject: [PATCH 1/7] brcmfmac: reset two D11 cores if chip has two D11 cores
-
-There are two D11 cores in RSDB chips like 4359. We have to reset two
-D11 cores simutaneously before firmware download, or the firmware may
-not be initialized correctly and cause "fw initialized failed" error.
-
-Signed-off-by: Wright Feng <wright.feng@cypress.com>
-Signed-off-by: Soeren Moch <smoch@web.de>
-Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../broadcom/brcm80211/brcmfmac/chip.c        | 50 +++++++++++++++++++
- .../broadcom/brcm80211/brcmfmac/chip.h        |  1 +
- .../broadcom/brcm80211/brcmfmac/pcie.c        |  2 +-
- 3 files changed, 52 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-@@ -433,11 +433,25 @@ static void brcmf_chip_ai_resetcore(stru
- {
- 	struct brcmf_chip_priv *ci;
- 	int count;
-+	struct brcmf_core *d11core2 = NULL;
-+	struct brcmf_core_priv *d11priv2 = NULL;
- 
- 	ci = core->chip;
- 
-+	/* special handle two D11 cores reset */
-+	if (core->pub.id == BCMA_CORE_80211) {
-+		d11core2 = brcmf_chip_get_d11core(&ci->pub, 1);
-+		if (d11core2) {
-+			brcmf_dbg(INFO, "found two d11 cores, reset both\n");
-+			d11priv2 = container_of(d11core2,
-+						struct brcmf_core_priv, pub);
-+		}
-+	}
-+
- 	/* must disable first to work for arbitrary current core state */
- 	brcmf_chip_ai_coredisable(core, prereset, reset);
-+	if (d11priv2)
-+		brcmf_chip_ai_coredisable(d11priv2, prereset, reset);
- 
- 	count = 0;
- 	while (ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) &
-@@ -449,9 +463,30 @@ static void brcmf_chip_ai_resetcore(stru
- 		usleep_range(40, 60);
- 	}
- 
-+	if (d11priv2) {
-+		count = 0;
-+		while (ci->ops->read32(ci->ctx,
-+				       d11priv2->wrapbase + BCMA_RESET_CTL) &
-+				       BCMA_RESET_CTL_RESET) {
-+			ci->ops->write32(ci->ctx,
-+					 d11priv2->wrapbase + BCMA_RESET_CTL,
-+					 0);
-+			count++;
-+			if (count > 50)
-+				break;
-+			usleep_range(40, 60);
-+		}
-+	}
-+
- 	ci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,
- 			 postreset | BCMA_IOCTL_CLK);
- 	ci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);
-+
-+	if (d11priv2) {
-+		ci->ops->write32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL,
-+				 postreset | BCMA_IOCTL_CLK);
-+		ci->ops->read32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL);
-+	}
- }
- 
- char *brcmf_chip_name(u32 id, u32 rev, char *buf, uint len)
-@@ -1109,6 +1144,21 @@ void brcmf_chip_detach(struct brcmf_chip
- 	kfree(chip);
- }
- 
-+struct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit)
-+{
-+	struct brcmf_chip_priv *chip;
-+	struct brcmf_core_priv *core;
-+
-+	chip = container_of(pub, struct brcmf_chip_priv, pub);
-+	list_for_each_entry(core, &chip->cores, list) {
-+		if (core->pub.id == BCMA_CORE_80211) {
-+			if (unit-- == 0)
-+				return &core->pub;
-+		}
-+	}
-+	return NULL;
-+}
-+
- struct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *pub, u16 coreid)
- {
- 	struct brcmf_chip_priv *chip;
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
-@@ -74,6 +74,7 @@ struct brcmf_chip *brcmf_chip_attach(voi
- 				     const struct brcmf_buscore_ops *ops);
- void brcmf_chip_detach(struct brcmf_chip *chip);
- struct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *chip, u16 coreid);
-+struct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit);
- struct brcmf_core *brcmf_chip_get_chipcommon(struct brcmf_chip *chip);
- struct brcmf_core *brcmf_chip_get_pmu(struct brcmf_chip *pub);
- bool brcmf_chip_iscoreup(struct brcmf_core *core);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
-@@ -78,7 +78,7 @@ static const struct brcmf_firmware_mappi
- 	BRCMF_FW_ENTRY(BRCM_CC_4371_CHIP_ID, 0xFFFFFFFF, 4371),
- };
- 
--#define BRCMF_PCIE_FW_UP_TIMEOUT		2000 /* msec */
-+#define BRCMF_PCIE_FW_UP_TIMEOUT		5000 /* msec */
- 
- #define BRCMF_PCIE_REG_MAP_SIZE			(32 * 1024)
- 
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-From 172f6854551d48d1c9530f84513b421db944e714 Mon Sep 17 00:00:00 2001
-From: Chung-Hsien Hsu <stanley.hsu@cypress.com>
-Date: Thu, 12 Dec 2019 00:52:46 +0100
-Subject: [PATCH 2/7] brcmfmac: set F2 blocksize and watermark for 4359
-
-Set F2 blocksize to 256 bytes and watermark to 0x40 for 4359. Also
-enable and configure F1 MesBusyCtrl. It fixes DMA error while having
-UDP bi-directional traffic.
-
-Signed-off-by: Chung-Hsien Hsu <stanley.hsu@cypress.com>
-[slightly adapted for rebase on mainline linux]
-Signed-off-by: Soeren Moch <smoch@web.de>
-Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c |  6 +++++-
- .../wireless/broadcom/brcm80211/brcmfmac/sdio.c   | 15 +++++++++++++++
- 2 files changed, 20 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-@@ -43,6 +43,7 @@
- 
- #define SDIO_FUNC1_BLOCKSIZE		64
- #define SDIO_FUNC2_BLOCKSIZE		512
-+#define SDIO_4359_FUNC2_BLOCKSIZE	256
- /* Maximum milliseconds to wait for F2 to come up */
- #define SDIO_WAIT_F2RDY	3000
- 
-@@ -903,6 +904,7 @@ static void brcmf_sdiod_host_fixup(struc
- static int brcmf_sdiod_probe(struct brcmf_sdio_dev *sdiodev)
- {
- 	int ret = 0;
-+	unsigned int f2_blksz = SDIO_FUNC2_BLOCKSIZE;
- 
- 	sdio_claim_host(sdiodev->func1);
- 
-@@ -912,7 +914,9 @@ static int brcmf_sdiod_probe(struct brcm
- 		sdio_release_host(sdiodev->func1);
- 		goto out;
- 	}
--	ret = sdio_set_block_size(sdiodev->func2, SDIO_FUNC2_BLOCKSIZE);
-+	if (sdiodev->func2->device == SDIO_DEVICE_ID_BROADCOM_4359)
-+		f2_blksz = SDIO_4359_FUNC2_BLOCKSIZE;
-+	ret = sdio_set_block_size(sdiodev->func2, f2_blksz);
- 	if (ret) {
- 		brcmf_err("Failed to set F2 blocksize\n");
- 		sdio_release_host(sdiodev->func1);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-@@ -42,6 +42,8 @@
- #define DEFAULT_F2_WATERMARK    0x8
- #define CY_4373_F2_WATERMARK    0x40
- #define CY_43012_F2_WATERMARK    0x60
-+#define CY_4359_F2_WATERMARK	0x40
-+#define CY_4359_F1_MESBUSYCTRL	(CY_4359_F2_WATERMARK | SBSDIO_MESBUSYCTRL_ENAB)
- 
- #ifdef DEBUG
- 
-@@ -4206,6 +4208,19 @@ static void brcmf_sdio_firmware_callback
- 			brcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,
- 					   &err);
- 			break;
-+		case SDIO_DEVICE_ID_BROADCOM_4359:
-+			brcmf_dbg(INFO, "set F2 watermark to 0x%x*4 bytes\n",
-+				  CY_4359_F2_WATERMARK);
-+			brcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,
-+					   CY_4359_F2_WATERMARK, &err);
-+			devctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,
-+						   &err);
-+			devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
-+			brcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,
-+					   &err);
-+			brcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,
-+					   CY_4359_F1_MESBUSYCTRL, &err);
-+			break;
- 		default:
- 			brcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,
- 					   DEFAULT_F2_WATERMARK, &err);
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,34 +0,0 @@
-From 6647274ed995a172369cb04754eb5f8b85f68f6d Mon Sep 17 00:00:00 2001
-From: Soeren Moch <smoch@web.de>
-Date: Thu, 12 Dec 2019 00:52:47 +0100
-Subject: [PATCH 3/7] brcmfmac: fix rambase for 4359/9
-
-Newer 4359 chip revisions need a different rambase address.
-This fixes firmware download on such devices which fails otherwise.
-
-Signed-off-by: Soeren Moch <smoch@web.de>
-Acked-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c | 3 ++-
- 1 file changed, 2 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-@@ -712,7 +712,6 @@ static u32 brcmf_chip_tcm_rambase(struct
- 	case BRCM_CC_43569_CHIP_ID:
- 	case BRCM_CC_43570_CHIP_ID:
- 	case BRCM_CC_4358_CHIP_ID:
--	case BRCM_CC_4359_CHIP_ID:
- 	case BRCM_CC_43602_CHIP_ID:
- 	case BRCM_CC_4371_CHIP_ID:
- 		return 0x180000;
-@@ -722,6 +721,8 @@ static u32 brcmf_chip_tcm_rambase(struct
- 	case BRCM_CC_4366_CHIP_ID:
- 	case BRCM_CC_43664_CHIP_ID:
- 		return 0x200000;
-+	case BRCM_CC_4359_CHIP_ID:
-+		return (ci->pub.chiprev < 9) ? 0x180000 : 0x160000;
- 	case CY_CC_4373_CHIP_ID:
- 		return 0x160000;
- 	default:
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,42 +0,0 @@
-From c12c8913d79c49ceccb38f42714d25b783833758 Mon Sep 17 00:00:00 2001
-From: Soeren Moch <smoch@web.de>
-Date: Thu, 12 Dec 2019 00:52:48 +0100
-Subject: [PATCH 4/7] brcmfmac: make errors when setting roaming parameters
- non-fatal
-
-4359 dongles do not support setting roaming parameters (error -52).
-Do not fail the 80211 configuration in this case.
-
-Signed-off-by: Soeren Moch <smoch@web.de>
-Acked-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../wireless/broadcom/brcm80211/brcmfmac/cfg80211.c    | 10 ++++------
- 1 file changed, 4 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -5944,19 +5944,17 @@ static s32 brcmf_dongle_roam(struct brcm
- 	roamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);
- 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,
- 				     (void *)roamtrigger, sizeof(roamtrigger));
--	if (err) {
-+	if (err)
- 		bphy_err(drvr, "WLC_SET_ROAM_TRIGGER error (%d)\n", err);
--		goto roam_setup_done;
--	}
- 
- 	roam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);
- 	roam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);
- 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,
- 				     (void *)roam_delta, sizeof(roam_delta));
--	if (err) {
-+	if (err)
- 		bphy_err(drvr, "WLC_SET_ROAM_DELTA error (%d)\n", err);
--		goto roam_setup_done;
--	}
-+
-+	return 0;
- 
- roam_setup_done:
- 	return err;
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,75 +0,0 @@
-From d4aef159394d5940bd7158ab789969dab82f7c76 Mon Sep 17 00:00:00 2001
-From: Soeren Moch <smoch@web.de>
-Date: Thu, 12 Dec 2019 00:52:49 +0100
-Subject: [PATCH 5/7] brcmfmac: add support for BCM4359 SDIO chipset
-
-BCM4359 is a 2x2 802.11 abgn+ac Dual-Band HT80 combo chip and it
-supports Real Simultaneous Dual Band feature.
-
-Based on a similar patch by: Wright Feng <wright.feng@cypress.com>
-
-Signed-off-by: Soeren Moch <smoch@web.de>
-Acked-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c | 2 ++
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c   | 1 +
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c   | 2 ++
- include/linux/mmc/sdio_ids.h                              | 2 ++
- 4 files changed, 7 insertions(+)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-@@ -973,8 +973,10 @@ static const struct sdio_device_id brcmf
- 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43455),
- 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4354),
- 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4356),
-+	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4359),
- 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_4373),
- 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_43012),
-+	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_89359),
- 	{ /* end: all zeroes */ }
- };
- MODULE_DEVICE_TABLE(sdio, brcmf_sdmmc_ids);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
-@@ -1408,6 +1408,7 @@ bool brcmf_chip_sr_capable(struct brcmf_
- 		addr = CORE_CC_REG(base, sr_control0);
- 		reg = chip->ops->read32(chip->ctx, addr);
- 		return (reg & CC_SR_CTL0_ENABLE_MASK) != 0;
-+	case BRCM_CC_4359_CHIP_ID:
- 	case CY_CC_43012_CHIP_ID:
- 		addr = CORE_CC_REG(pmu->base, retention_ctl);
- 		reg = chip->ops->read32(chip->ctx, addr);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
-@@ -616,6 +616,7 @@ BRCMF_FW_DEF(43455, "brcmfmac43455-sdio"
- BRCMF_FW_DEF(43456, "brcmfmac43456-sdio");
- BRCMF_FW_DEF(4354, "brcmfmac4354-sdio");
- BRCMF_FW_DEF(4356, "brcmfmac4356-sdio");
-+BRCMF_FW_DEF(4359, "brcmfmac4359-sdio");
- BRCMF_FW_DEF(4373, "brcmfmac4373-sdio");
- BRCMF_FW_DEF(43012, "brcmfmac43012-sdio");
- 
-@@ -638,6 +639,7 @@ static const struct brcmf_firmware_mappi
- 	BRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFDC0, 43455),
- 	BRCMF_FW_ENTRY(BRCM_CC_4354_CHIP_ID, 0xFFFFFFFF, 4354),
- 	BRCMF_FW_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),
-+	BRCMF_FW_ENTRY(BRCM_CC_4359_CHIP_ID, 0xFFFFFFFF, 4359),
- 	BRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373),
- 	BRCMF_FW_ENTRY(CY_CC_43012_CHIP_ID, 0xFFFFFFFF, 43012)
- };
---- a/include/linux/mmc/sdio_ids.h
-+++ b/include/linux/mmc/sdio_ids.h
-@@ -41,8 +41,10 @@
- #define SDIO_DEVICE_ID_BROADCOM_43455		0xa9bf
- #define SDIO_DEVICE_ID_BROADCOM_4354		0x4354
- #define SDIO_DEVICE_ID_BROADCOM_4356		0x4356
-+#define SDIO_DEVICE_ID_BROADCOM_4359		0x4359
- #define SDIO_DEVICE_ID_CYPRESS_4373		0x4373
- #define SDIO_DEVICE_ID_CYPRESS_43012		43012
-+#define SDIO_DEVICE_ID_CYPRESS_89359		0x4355
- 
- #define SDIO_VENDOR_ID_INTEL			0x0089
- #define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,130 +0,0 @@
-From 837482e69a3f0d7cbc73922020012f83635f5ddb Mon Sep 17 00:00:00 2001
-From: Wright Feng <wright.feng@cypress.com>
-Date: Thu, 12 Dec 2019 00:52:50 +0100
-Subject: [PATCH 6/7] brcmfmac: add RSDB condition when setting interface
- combinations
-
-With firmware RSDB feature
-1. The maximum support interface is four.
-2. The maximum difference channel is two.
-3. The maximum interfaces of {station/p2p client/AP} are two.
-4. The maximum interface of p2p device is one.
-
-Signed-off-by: Wright Feng <wright.feng@cypress.com>
-Signed-off-by: Soeren Moch <smoch@web.de>
-Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 54 ++++++++++++++++---
- 1 file changed, 46 insertions(+), 8 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -6452,6 +6452,9 @@ brcmf_txrx_stypes[NUM_NL80211_IFTYPES] =
-  *	#STA <= 1, #AP <= 1, channels = 1, 2 total
-  *	#AP <= 4, matching BI, channels = 1, 4 total
-  *
-+ * no p2p and rsdb:
-+ *	#STA <= 2, #AP <= 2, channels = 2, 4 total
-+ *
-  * p2p, no mchan, and mbss:
-  *
-  *	#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 1, 3 total
-@@ -6463,6 +6466,10 @@ brcmf_txrx_stypes[NUM_NL80211_IFTYPES] =
-  *	#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 2, 3 total
-  *	#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total
-  *	#AP <= 4, matching BI, channels = 1, 4 total
-+ *
-+ * p2p, rsdb, and no mbss:
-+ *	#STA <= 2, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 2, AP <= 2,
-+ *	 channels = 2, 4 total
-  */
- static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)
- {
-@@ -6470,13 +6477,14 @@ static int brcmf_setup_ifmodes(struct wi
- 	struct ieee80211_iface_limit *c0_limits = NULL;
- 	struct ieee80211_iface_limit *p2p_limits = NULL;
- 	struct ieee80211_iface_limit *mbss_limits = NULL;
--	bool mbss, p2p;
-+	bool mbss, p2p, rsdb;
- 	int i, c, n_combos;
- 
- 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
- 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
-+	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
- 
--	n_combos = 1 + !!p2p + !!mbss;
-+	n_combos = 1 + !!(p2p && !rsdb) + !!mbss;
- 	combo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);
- 	if (!combo)
- 		goto err;
-@@ -6487,16 +6495,36 @@ static int brcmf_setup_ifmodes(struct wi
- 
- 	c = 0;
- 	i = 0;
--	c0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);
-+	if (p2p && rsdb)
-+		c0_limits = kcalloc(4, sizeof(*c0_limits), GFP_KERNEL);
-+	else if (p2p)
-+		c0_limits = kcalloc(3, sizeof(*c0_limits), GFP_KERNEL);
-+	else
-+		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
- 	if (!c0_limits)
- 		goto err;
--	c0_limits[i].max = 1;
--	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
--	if (p2p) {
-+	if (p2p && rsdb) {
-+		combo[c].num_different_channels = 2;
-+		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
-+					  BIT(NL80211_IFTYPE_P2P_GO) |
-+					  BIT(NL80211_IFTYPE_P2P_DEVICE);
-+		c0_limits[i].max = 2;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-+		c0_limits[i].max = 1;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
-+		c0_limits[i].max = 2;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
-+				       BIT(NL80211_IFTYPE_P2P_GO);
-+		c0_limits[i].max = 2;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
-+		combo[c].max_interfaces = 5;
-+	} else if (p2p) {
- 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))
- 			combo[c].num_different_channels = 2;
- 		else
- 			combo[c].num_different_channels = 1;
-+		c0_limits[i].max = 1;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
- 		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
- 					  BIT(NL80211_IFTYPE_P2P_GO) |
- 					  BIT(NL80211_IFTYPE_P2P_DEVICE);
-@@ -6505,16 +6533,26 @@ static int brcmf_setup_ifmodes(struct wi
- 		c0_limits[i].max = 1;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
- 				       BIT(NL80211_IFTYPE_P2P_GO);
-+		combo[c].max_interfaces = i;
-+	} else if (rsdb) {
-+		combo[c].num_different_channels = 2;
-+		c0_limits[i].max = 2;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-+		c0_limits[i].max = 2;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
-+		combo[c].max_interfaces = 3;
- 	} else {
- 		combo[c].num_different_channels = 1;
- 		c0_limits[i].max = 1;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-+		c0_limits[i].max = 1;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
-+		combo[c].max_interfaces = i;
- 	}
--	combo[c].max_interfaces = i;
- 	combo[c].n_limits = i;
- 	combo[c].limits = c0_limits;
- 
--	if (p2p) {
-+	if (p2p && !rsdb) {
- 		c++;
- 		i = 0;
- 		p2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);
diff -uprN a/package/kernel/mac80211/patches/brcm/114-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch b/package/kernel/mac80211/patches/brcm/114-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch
--- a/package/kernel/mac80211/patches/brcm/114-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/114-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From 2635853ce4ab7654a77ab7080fb56de83408606b Mon Sep 17 00:00:00 2001
-From: Wright Feng <wright.feng@cypress.com>
-Date: Thu, 12 Dec 2019 00:52:51 +0100
-Subject: [PATCH 7/7] brcmfmac: not set mbss in vif if firmware does not
- support MBSS
-
-With RSDB mode, FMAC and firmware are able to create 2 or more AP,
-so we should not set mbss in vif structure if firmware does not
-support MBSS feature.
-
-Signed-off-by: Wright Feng <wright.feng@cypress.com>
-Signed-off-by: Soeren Moch <smoch@web.de>
-Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 4 +++-
- 1 file changed, 3 insertions(+), 1 deletion(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -5301,6 +5301,7 @@ struct brcmf_cfg80211_vif *brcmf_alloc_v
- 	struct brcmf_cfg80211_vif *vif_walk;
- 	struct brcmf_cfg80211_vif *vif;
- 	bool mbss;
-+	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
- 
- 	brcmf_dbg(TRACE, "allocating virtual interface (size=%zu)\n",
- 		  sizeof(*vif));
-@@ -5313,7 +5314,8 @@ struct brcmf_cfg80211_vif *brcmf_alloc_v
- 
- 	brcmf_init_prof(&vif->profile);
- 
--	if (type == NL80211_IFTYPE_AP) {
-+	if (type == NL80211_IFTYPE_AP &&
-+	    brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) {
- 		mbss = false;
- 		list_for_each_entry(vif_walk, &cfg->vif_list, list) {
- 			if (vif_walk->wdev.iftype == NL80211_IFTYPE_AP) {
diff -uprN a/package/kernel/mac80211/patches/brcm/116-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch b/package/kernel/mac80211/patches/brcm/116-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch
--- a/package/kernel/mac80211/patches/brcm/116-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/116-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,66 +0,0 @@
-From a32de68edab7b73ded850bcf76cdf6858e92a7e5 Mon Sep 17 00:00:00 2001
-From: Dmitry Osipenko <digetx@gmail.com>
-Date: Sun, 15 Dec 2019 21:42:24 +0300
-Subject: [PATCH] brcmfmac: Keep OOB wake-interrupt disabled when it shouldn't
- be enabled
-
-NVIDIA Tegra SoCs do not like when OOB wake is enabled and WiFi interface
-is in DOWN state during suspend. This results in a CPU hang on programming
-OOB wake-up state of the GPIO controller during of system's suspend.
-
-The solution is trivial: don't enable wake for the OOB interrupt when it
-should be disabled.
-
-This fixes hang on Tegra20 (Acer A500) and Tegra30 (Nexus 7) devices which
-are using BCM4329 and BCM4330 WiFi chips respectively.
-
-Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c  | 10 +++++-----
- .../net/wireless/broadcom/brcm80211/brcmfmac/sdio.h    |  1 -
- 2 files changed, 5 insertions(+), 6 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
-@@ -120,7 +120,7 @@ int brcmf_sdiod_intr_register(struct brc
- 			brcmf_err("enable_irq_wake failed %d\n", ret);
- 			return ret;
- 		}
--		sdiodev->irq_wake = true;
-+		disable_irq_wake(pdata->oob_irq_nr);
- 
- 		sdio_claim_host(sdiodev->func1);
- 
-@@ -179,10 +179,6 @@ void brcmf_sdiod_intr_unregister(struct
- 		sdio_release_host(sdiodev->func1);
- 
- 		sdiodev->oob_irq_requested = false;
--		if (sdiodev->irq_wake) {
--			disable_irq_wake(pdata->oob_irq_nr);
--			sdiodev->irq_wake = false;
--		}
- 		free_irq(pdata->oob_irq_nr, &sdiodev->func1->dev);
- 		sdiodev->irq_en = false;
- 		sdiodev->oob_irq_requested = false;
-@@ -1173,6 +1169,10 @@ static int brcmf_ops_sdio_resume(struct
- 		if (ret)
- 			brcmf_err("Failed to probe device on resume\n");
- 	} else {
-+		if (sdiodev->wowl_enabled &&
-+		    sdiodev->settings->bus.sdio.oob_irq_supported)
-+			disable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
-+
- 		brcmf_sdiod_freezer_off(sdiodev);
- 	}
- 
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
-@@ -178,7 +178,6 @@ struct brcmf_sdio_dev {
- 	bool sd_irq_requested;
- 	bool irq_en;			/* irq enable flags */
- 	spinlock_t irq_en_lock;
--	bool irq_wake;			/* irq wake enable flags */
- 	bool sg_support;
- 	uint max_request_size;
- 	ushort max_segment_count;
diff -uprN a/package/kernel/mac80211/patches/brcm/117-v5.6-brcmfmac-use-true-false-for-bool-variable.patch b/package/kernel/mac80211/patches/brcm/117-v5.6-brcmfmac-use-true-false-for-bool-variable.patch
--- a/package/kernel/mac80211/patches/brcm/117-v5.6-brcmfmac-use-true-false-for-bool-variable.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/117-v5.6-brcmfmac-use-true-false-for-bool-variable.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,27 +0,0 @@
-From b92c017deda819e45a0f054f6df6b53e645d7fe4 Mon Sep 17 00:00:00 2001
-From: zhengbin <zhengbin13@huawei.com>
-Date: Tue, 24 Dec 2019 22:16:06 +0800
-Subject: [PATCH] brcmfmac: use true,false for bool variable
-
-Fixes coccicheck warning:
-
-drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c:911:2-24: WARNING: Assignment of 0/1 to bool variable
-
-Reported-by: Hulk Robot <hulkci@huawei.com>
-Signed-off-by: zhengbin <zhengbin13@huawei.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
-@@ -908,7 +908,7 @@ static u8 brcmf_fws_hdrpush(struct brcmf
- 	wlh += wlh[1] + 2;
- 
- 	if (entry->send_tim_signal) {
--		entry->send_tim_signal = 0;
-+		entry->send_tim_signal = false;
- 		wlh[0] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP;
- 		wlh[1] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN;
- 		wlh[2] = entry->mac_handle;
diff -uprN a/package/kernel/mac80211/patches/brcm/119-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch b/package/kernel/mac80211/patches/brcm/119-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch
--- a/package/kernel/mac80211/patches/brcm/119-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/119-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,103 +0,0 @@
-From 24332f8068ff6df7f16aefee45d514de1de4de80 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Thu, 26 Dec 2019 14:30:49 +0100
-Subject: [PATCH] brcmfmac: simplify building interface combinations
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Move similar/duplicated code out of combination specific code blocks.
-This simplifies code a bit and allows adding more combinations later.
-A list of combinations remains unchanged.
-
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 43 ++++++-------------
- 1 file changed, 14 insertions(+), 29 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -6479,12 +6479,13 @@ static int brcmf_setup_ifmodes(struct wi
- 	struct ieee80211_iface_limit *c0_limits = NULL;
- 	struct ieee80211_iface_limit *p2p_limits = NULL;
- 	struct ieee80211_iface_limit *mbss_limits = NULL;
--	bool mbss, p2p, rsdb;
-+	bool mbss, p2p, rsdb, mchan;
- 	int i, c, n_combos;
- 
- 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
- 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
- 	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
-+	mchan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN);
- 
- 	n_combos = 1 + !!(p2p && !rsdb) + !!mbss;
- 	combo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);
-@@ -6494,6 +6495,10 @@ static int brcmf_setup_ifmodes(struct wi
- 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
- 				 BIT(NL80211_IFTYPE_ADHOC) |
- 				 BIT(NL80211_IFTYPE_AP);
-+	if (p2p)
-+		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
-+					  BIT(NL80211_IFTYPE_P2P_GO) |
-+					  BIT(NL80211_IFTYPE_P2P_DEVICE);
- 
- 	c = 0;
- 	i = 0;
-@@ -6505,48 +6510,28 @@ static int brcmf_setup_ifmodes(struct wi
- 		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
- 	if (!c0_limits)
- 		goto err;
--	if (p2p && rsdb) {
--		combo[c].num_different_channels = 2;
--		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
--					  BIT(NL80211_IFTYPE_P2P_GO) |
--					  BIT(NL80211_IFTYPE_P2P_DEVICE);
--		c0_limits[i].max = 2;
--		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-+
-+	combo[c].num_different_channels = 1 + (rsdb || (p2p && mchan));
-+	c0_limits[i].max = 1 + rsdb;
-+	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-+	if (p2p) {
- 		c0_limits[i].max = 1;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
--		c0_limits[i].max = 2;
-+		c0_limits[i].max = 1 + rsdb;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
- 				       BIT(NL80211_IFTYPE_P2P_GO);
-+	}
-+	if (p2p && rsdb) {
- 		c0_limits[i].max = 2;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
- 		combo[c].max_interfaces = 5;
- 	} else if (p2p) {
--		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))
--			combo[c].num_different_channels = 2;
--		else
--			combo[c].num_different_channels = 1;
--		c0_limits[i].max = 1;
--		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
--		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
--					  BIT(NL80211_IFTYPE_P2P_GO) |
--					  BIT(NL80211_IFTYPE_P2P_DEVICE);
--		c0_limits[i].max = 1;
--		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
--		c0_limits[i].max = 1;
--		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
--				       BIT(NL80211_IFTYPE_P2P_GO);
- 		combo[c].max_interfaces = i;
- 	} else if (rsdb) {
--		combo[c].num_different_channels = 2;
--		c0_limits[i].max = 2;
--		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
- 		c0_limits[i].max = 2;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
- 		combo[c].max_interfaces = 3;
- 	} else {
--		combo[c].num_different_channels = 1;
--		c0_limits[i].max = 1;
--		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
- 		c0_limits[i].max = 1;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
- 		combo[c].max_interfaces = i;
diff -uprN a/package/kernel/mac80211/patches/brcm/119-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch b/package/kernel/mac80211/patches/brcm/119-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch
--- a/package/kernel/mac80211/patches/brcm/119-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/119-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,345 +0,0 @@
-From 20f2c5fa3af060401c72e444999470a4cab641cf Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Thu, 26 Dec 2019 14:30:50 +0100
-Subject: [PATCH] brcmfmac: add initial support for monitor mode
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Report monitor interface availability using cfg80211 and support it in
-the add_virtual_intf() and del_virtual_intf() callbacks. This new
-feature is conditional and depends on firmware flagging monitor packets.
-Receiving monitor frames is already handled by the brcmf_netif_mon_rx().
-
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 112 ++++++++++++++++--
- .../broadcom/brcm80211/brcmfmac/core.c        |  68 ++++++++++-
- .../broadcom/brcm80211/brcmfmac/core.h        |   2 +
- .../broadcom/brcm80211/brcmfmac/feature.c     |   1 +
- .../broadcom/brcm80211/brcmfmac/feature.h     |   2 +
- .../broadcom/brcm80211/brcmfmac/fwil.h        |   2 +
- 6 files changed, 174 insertions(+), 13 deletions(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -11,6 +11,7 @@
- #include <linux/vmalloc.h>
- #include <net/cfg80211.h>
- #include <net/netlink.h>
-+#include <uapi/linux/if_arp.h>
- 
- #include <brcmu_utils.h>
- #include <defs.h>
-@@ -619,6 +620,82 @@ static bool brcmf_is_ibssmode(struct brc
- 	return vif->wdev.iftype == NL80211_IFTYPE_ADHOC;
- }
- 
-+/**
-+ * brcmf_mon_add_vif() - create monitor mode virtual interface
-+ *
-+ * @wiphy: wiphy device of new interface.
-+ * @name: name of the new interface.
-+ */
-+static struct wireless_dev *brcmf_mon_add_vif(struct wiphy *wiphy,
-+					      const char *name)
-+{
-+	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
-+	struct brcmf_cfg80211_vif *vif;
-+	struct net_device *ndev;
-+	struct brcmf_if *ifp;
-+	int err;
-+
-+	if (cfg->pub->mon_if) {
-+		err = -EEXIST;
-+		goto err_out;
-+	}
-+
-+	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_MONITOR);
-+	if (IS_ERR(vif)) {
-+		err = PTR_ERR(vif);
-+		goto err_out;
-+	}
-+
-+	ndev = alloc_netdev(sizeof(*ifp), name, NET_NAME_UNKNOWN, ether_setup);
-+	if (!ndev) {
-+		err = -ENOMEM;
-+		goto err_free_vif;
-+	}
-+	ndev->type = ARPHRD_IEEE80211_RADIOTAP;
-+	ndev->ieee80211_ptr = &vif->wdev;
-+	ndev->needs_free_netdev = true;
-+	ndev->priv_destructor = brcmf_cfg80211_free_netdev;
-+	SET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));
-+
-+	ifp = netdev_priv(ndev);
-+	ifp->vif = vif;
-+	ifp->ndev = ndev;
-+	ifp->drvr = cfg->pub;
-+
-+	vif->ifp = ifp;
-+	vif->wdev.netdev = ndev;
-+
-+	err = brcmf_net_mon_attach(ifp);
-+	if (err) {
-+		brcmf_err("Failed to attach %s device\n", ndev->name);
-+		free_netdev(ndev);
-+		goto err_free_vif;
-+	}
-+
-+	cfg->pub->mon_if = ifp;
-+
-+	return &vif->wdev;
-+
-+err_free_vif:
-+	brcmf_free_vif(vif);
-+err_out:
-+	return ERR_PTR(err);
-+}
-+
-+static int brcmf_mon_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)
-+{
-+	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
-+	struct net_device *ndev = wdev->netdev;
-+
-+	ndev->netdev_ops->ndo_stop(ndev);
-+
-+	brcmf_net_detach(ndev, true);
-+
-+	cfg->pub->mon_if = NULL;
-+
-+	return 0;
-+}
-+
- static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
- 						     const char *name,
- 						     unsigned char name_assign_type,
-@@ -641,9 +718,10 @@ static struct wireless_dev *brcmf_cfg802
- 	case NL80211_IFTYPE_STATION:
- 	case NL80211_IFTYPE_AP_VLAN:
- 	case NL80211_IFTYPE_WDS:
--	case NL80211_IFTYPE_MONITOR:
- 	case NL80211_IFTYPE_MESH_POINT:
- 		return ERR_PTR(-EOPNOTSUPP);
-+	case NL80211_IFTYPE_MONITOR:
-+		return brcmf_mon_add_vif(wiphy, name);
- 	case NL80211_IFTYPE_AP:
- 		wdev = brcmf_ap_add_vif(wiphy, name, params);
- 		break;
-@@ -826,9 +904,10 @@ int brcmf_cfg80211_del_iface(struct wiph
- 	case NL80211_IFTYPE_STATION:
- 	case NL80211_IFTYPE_AP_VLAN:
- 	case NL80211_IFTYPE_WDS:
--	case NL80211_IFTYPE_MONITOR:
- 	case NL80211_IFTYPE_MESH_POINT:
- 		return -EOPNOTSUPP;
-+	case NL80211_IFTYPE_MONITOR:
-+		return brcmf_mon_del_vif(wiphy, wdev);
- 	case NL80211_IFTYPE_AP:
- 		return brcmf_cfg80211_del_ap_iface(wiphy, wdev);
- 	case NL80211_IFTYPE_P2P_CLIENT:
-@@ -6479,9 +6558,10 @@ static int brcmf_setup_ifmodes(struct wi
- 	struct ieee80211_iface_limit *c0_limits = NULL;
- 	struct ieee80211_iface_limit *p2p_limits = NULL;
- 	struct ieee80211_iface_limit *mbss_limits = NULL;
--	bool mbss, p2p, rsdb, mchan;
--	int i, c, n_combos;
-+	bool mon_flag, mbss, p2p, rsdb, mchan;
-+	int i, c, n_combos, n_limits;
- 
-+	mon_flag = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FLAG);
- 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
- 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
- 	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
-@@ -6495,6 +6575,8 @@ static int brcmf_setup_ifmodes(struct wi
- 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
- 				 BIT(NL80211_IFTYPE_ADHOC) |
- 				 BIT(NL80211_IFTYPE_AP);
-+	if (mon_flag)
-+		wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);
- 	if (p2p)
- 		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
- 					  BIT(NL80211_IFTYPE_P2P_GO) |
-@@ -6502,18 +6584,18 @@ static int brcmf_setup_ifmodes(struct wi
- 
- 	c = 0;
- 	i = 0;
--	if (p2p && rsdb)
--		c0_limits = kcalloc(4, sizeof(*c0_limits), GFP_KERNEL);
--	else if (p2p)
--		c0_limits = kcalloc(3, sizeof(*c0_limits), GFP_KERNEL);
--	else
--		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
-+	n_limits = 1 + mon_flag + (p2p ? 2 : 0) + (rsdb || !p2p);
-+	c0_limits = kcalloc(n_limits, sizeof(*c0_limits), GFP_KERNEL);
- 	if (!c0_limits)
- 		goto err;
- 
- 	combo[c].num_different_channels = 1 + (rsdb || (p2p && mchan));
- 	c0_limits[i].max = 1 + rsdb;
- 	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
-+	if (mon_flag) {
-+		c0_limits[i].max = 1;
-+		c0_limits[i++].types = BIT(NL80211_IFTYPE_MONITOR);
-+	}
- 	if (p2p) {
- 		c0_limits[i].max = 1;
- 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
-@@ -6562,14 +6644,20 @@ static int brcmf_setup_ifmodes(struct wi
- 	if (mbss) {
- 		c++;
- 		i = 0;
--		mbss_limits = kcalloc(1, sizeof(*mbss_limits), GFP_KERNEL);
-+		n_limits = 1 + mon_flag;
-+		mbss_limits = kcalloc(n_limits, sizeof(*mbss_limits),
-+				      GFP_KERNEL);
- 		if (!mbss_limits)
- 			goto err;
- 		mbss_limits[i].max = 4;
- 		mbss_limits[i++].types = BIT(NL80211_IFTYPE_AP);
-+		if (mon_flag) {
-+			mbss_limits[i].max = 1;
-+			mbss_limits[i++].types = BIT(NL80211_IFTYPE_MONITOR);
-+		}
- 		combo[c].beacon_int_infra_match = true;
- 		combo[c].num_different_channels = 1;
--		combo[c].max_interfaces = 4;
-+		combo[c].max_interfaces = 4 + mon_flag;
- 		combo[c].n_limits = i;
- 		combo[c].limits = mbss_limits;
- 	}
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -690,7 +690,7 @@ fail:
- 	return -EBADE;
- }
- 
--static void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked)
-+void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked)
- {
- 	if (ndev->reg_state == NETREG_REGISTERED) {
- 		if (rtnl_locked)
-@@ -703,6 +703,72 @@ static void brcmf_net_detach(struct net_
- 	}
- }
- 
-+static int brcmf_net_mon_open(struct net_device *ndev)
-+{
-+	struct brcmf_if *ifp = netdev_priv(ndev);
-+	struct brcmf_pub *drvr = ifp->drvr;
-+	u32 monitor;
-+	int err;
-+
-+	brcmf_dbg(TRACE, "Enter\n");
-+
-+	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_MONITOR, &monitor);
-+	if (err) {
-+		bphy_err(drvr, "BRCMF_C_GET_MONITOR error (%d)\n", err);
-+		return err;
-+	} else if (monitor) {
-+		bphy_err(drvr, "Monitor mode is already enabled\n");
-+		return -EEXIST;
-+	}
-+
-+	monitor = 3;
-+	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_MONITOR, monitor);
-+	if (err)
-+		bphy_err(drvr, "BRCMF_C_SET_MONITOR error (%d)\n", err);
-+
-+	return err;
-+}
-+
-+static int brcmf_net_mon_stop(struct net_device *ndev)
-+{
-+	struct brcmf_if *ifp = netdev_priv(ndev);
-+	struct brcmf_pub *drvr = ifp->drvr;
-+	u32 monitor;
-+	int err;
-+
-+	brcmf_dbg(TRACE, "Enter\n");
-+
-+	monitor = 0;
-+	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_MONITOR, monitor);
-+	if (err)
-+		bphy_err(drvr, "BRCMF_C_SET_MONITOR error (%d)\n", err);
-+
-+	return err;
-+}
-+
-+static const struct net_device_ops brcmf_netdev_ops_mon = {
-+	.ndo_open = brcmf_net_mon_open,
-+	.ndo_stop = brcmf_net_mon_stop,
-+};
-+
-+int brcmf_net_mon_attach(struct brcmf_if *ifp)
-+{
-+	struct brcmf_pub *drvr = ifp->drvr;
-+	struct net_device *ndev;
-+	int err;
-+
-+	brcmf_dbg(TRACE, "Enter\n");
-+
-+	ndev = ifp->ndev;
-+	ndev->netdev_ops = &brcmf_netdev_ops_mon;
-+
-+	err = register_netdevice(ndev);
-+	if (err)
-+		bphy_err(drvr, "Failed to register %s device\n", ndev->name);
-+
-+	return err;
-+}
-+
- void brcmf_net_setcarrier(struct brcmf_if *ifp, bool on)
- {
- 	struct net_device *ndev;
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-@@ -210,6 +210,8 @@ void brcmf_txflowblock_if(struct brcmf_i
- void brcmf_txfinalize(struct brcmf_if *ifp, struct sk_buff *txp, bool success);
- void brcmf_netif_rx(struct brcmf_if *ifp, struct sk_buff *skb);
- void brcmf_netif_mon_rx(struct brcmf_if *ifp, struct sk_buff *skb);
-+void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked);
-+int brcmf_net_mon_attach(struct brcmf_if *ifp);
- void brcmf_net_setcarrier(struct brcmf_if *ifp, bool on);
- int __init brcmf_core_init(void);
- void __exit brcmf_core_exit(void);
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
-@@ -38,6 +38,7 @@ static const struct brcmf_feat_fwcap brc
- 	{ BRCMF_FEAT_MCHAN, "mchan" },
- 	{ BRCMF_FEAT_P2P, "p2p" },
- 	{ BRCMF_FEAT_MONITOR, "monitor" },
-+	{ BRCMF_FEAT_MONITOR_FLAG, "rtap" },
- 	{ BRCMF_FEAT_MONITOR_FMT_RADIOTAP, "rtap" },
- 	{ BRCMF_FEAT_DOT11H, "802.11h" }
- };
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
-@@ -23,6 +23,7 @@
-  * GSCAN: enhanced scan offload feature.
-  * FWSUP: Firmware supplicant.
-  * MONITOR: firmware can pass monitor packets to host.
-+ * MONITOR_FLAG: firmware flags monitor packets.
-  * MONITOR_FMT_RADIOTAP: firmware provides monitor packets with radiotap header
-  * MONITOR_FMT_HW_RX_HDR: firmware provides monitor packets with hw/ucode header
-  * DOT11H: firmware supports 802.11h
-@@ -43,6 +44,7 @@
- 	BRCMF_FEAT_DEF(GSCAN) \
- 	BRCMF_FEAT_DEF(FWSUP) \
- 	BRCMF_FEAT_DEF(MONITOR) \
-+	BRCMF_FEAT_DEF(MONITOR_FLAG) \
- 	BRCMF_FEAT_DEF(MONITOR_FMT_RADIOTAP) \
- 	BRCMF_FEAT_DEF(MONITOR_FMT_HW_RX_HDR) \
- 	BRCMF_FEAT_DEF(DOT11H)
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
-@@ -49,6 +49,8 @@
- #define BRCMF_C_GET_PM				85
- #define BRCMF_C_SET_PM				86
- #define BRCMF_C_GET_REVINFO			98
-+#define BRCMF_C_GET_MONITOR			107
-+#define BRCMF_C_SET_MONITOR			108
- #define BRCMF_C_GET_CURR_RATESET		114
- #define BRCMF_C_GET_AP				117
- #define BRCMF_C_SET_AP				118
diff -uprN a/package/kernel/mac80211/patches/brcm/120-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch b/package/kernel/mac80211/patches/brcm/120-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch
--- a/package/kernel/mac80211/patches/brcm/120-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/120-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,24 +0,0 @@
-From 627b0d094240c38393b2f2d40626c33a8fff6103 Mon Sep 17 00:00:00 2001
-From: yuehaibing <yuehaibing@huawei.com>
-Date: Wed, 8 Jan 2020 21:57:48 +0800
-Subject: [PATCH] brcmfmac: Remove always false 'idx < 0' statement
-
-idx is declared as u32, it will never less than 0.
-
-Signed-off-by: yuehaibing <yuehaibing@huawei.com>
-Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c | 2 +-
- 1 file changed, 1 insertion(+), 1 deletion(-)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
-@@ -365,7 +365,7 @@ brcmf_msgbuf_get_pktid(struct device *de
- 	struct brcmf_msgbuf_pktid *pktid;
- 	struct sk_buff *skb;
- 
--	if (idx < 0 || idx >= pktids->array_size) {
-+	if (idx >= pktids->array_size) {
- 		brcmf_err("Invalid packet id %d (max %d)\n", idx,
- 			  pktids->array_size);
- 		return NULL;
diff -uprN a/package/kernel/mac80211/patches/brcm/300-brcmfmac-add-stub-for-monitor-interface-xmit.patch b/package/kernel/mac80211/patches/brcm/300-brcmfmac-add-stub-for-monitor-interface-xmit.patch
--- a/package/kernel/mac80211/patches/brcm/300-brcmfmac-add-stub-for-monitor-interface-xmit.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/300-brcmfmac-add-stub-for-monitor-interface-xmit.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,100 +0,0 @@
-From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
-Date: Fri, 27 Mar 2020 13:40:50 +0100
-Subject: [PATCH] brcmfmac: add stub for monitor interface xmit
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-According to the struct net_device_ops documentation .ndo_start_xmit is
-"Required; cannot be NULL.". Missing it may crash kernel easily:
-
-[  341.216709] Unable to handle kernel NULL pointer dereference at virtual address 00000000
-[  341.224836] pgd = 26088755
-[  341.227544] [00000000] *pgd=00000000
-[  341.231135] Internal error: Oops: 80000007 [#1] SMP ARM
-[  341.236367] Modules linked in: pppoe ppp_async iptable_nat brcmfmac xt_state xt_nat xt_conntrack xt_REDIRECT xt_MASQU
-[  341.304689] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.24 #0
-[  341.310621] Hardware name: BCM5301X
-[  341.314116] PC is at 0x0
-[  341.316664] LR is at dev_hard_start_xmit+0x8c/0x11c
-[  341.321546] pc : [<00000000>]    lr : [<c0469fa8>]    psr: 60000113
-[  341.327821] sp : c0801c30  ip : c610cf00  fp : c08048e4
-[  341.333051] r10: c073a63a  r9 : c08044dc  r8 : c6c04e00
-[  341.338283] r7 : 00000000  r6 : c60f5000  r5 : 00000000  r4 : c6a9c3c0
-[  341.344820] r3 : 00000000  r2 : bf25a13c  r1 : c60f5000  r0 : c6a9c3c0
-[  341.351358] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
-[  341.358504] Control: 10c5387d  Table: 0611c04a  DAC: 00000051
-[  341.364257] Process swapper/0 (pid: 0, stack limit = 0xc68ed0ca)
-[  341.370271] Stack: (0xc0801c30 to 0xc0802000)
-[  341.374633] 1c20:                                     c6e7d480 c0802d00 c60f5050 c0801c6c
-[  341.382825] 1c40: c60f5000 c6a9c3c0 c6f90000 c6f9005c c6c04e00 c60f5000 00000000 c6f9005c
-[  341.391015] 1c60: 00000000 c04a033c 00f90200 00000010 c6a9c3c0 c6a9c3c0 c6f90000 00000000
-[  341.399205] 1c80: 00000000 00000000 00000000 c046a7ac c6f9005c 00000001 fffffff4 00000000
-[  341.407395] 1ca0: c6f90200 00000000 c60f5000 c0479550 00000000 c6f90200 c6a9c3c0 16000000
-[  341.415586] 1cc0: 0000001c 6f4ad52f c6197040 b6df9387 36000000 c0520404 c073a80c c6a9c3c0
-[  341.423777] 1ce0: 00000000 c6d643c0 c6a9c3c0 c0800024 00000001 00000001 c6d643c8 c6a9c3c0
-[  341.431967] 1d00: c081b9c0 c7abca80 c610c840 c081b9c0 0000001c 00400000 c6bc5e6c c0522fb4
-[  341.440157] 1d20: c6d64400 00000004 c6bc5e0a 00000000 c60f5000 c7abca80 c081b9c0 c0522f54
-[  341.448348] 1d40: c6a9c3c0 c7abca80 c0803e48 c0549c94 c610c828 0000000a c0801d74 00000003
-[  341.456538] 1d60: c6ec8f0a 00000000 c60f5000 c7abca80 c081b9c0 c0548520 0000000a 00000000
-[  341.464728] 1d80: 00000000 003a0000 00000000 00000000 00000000 00000000 00000000 00000000
-[  341.472919] 1da0: 000002ff 00000000 00000000 16000000 00000000 00000000 00000000 00000000
-[  341.481110] 1dc0: 00000000 0000008f 00000000 00000000 00000000 2d132a69 c6bc5e40 00000000
-[  341.489300] 1de0: c6bc5e40 c6a9c3c0 00000000 c6ec8e50 00000001 c054b070 00000001 00000000
-[  341.497490] 1e00: c0807200 c6bc5e00 00000000 ffffe000 00000100 c054aea4 00000000 00000000
-[  341.505681] 1e20: 00000122 00400000 c0802d00 c0172e80 6f56a70e ffffffff 6f56a70e c7eb9cc0
-[  341.513871] 1e40: c7eb82c0 00000000 c0801e60 c017309c 00000000 00000000 07780000 c07382c0
-[  341.522061] 1e60: 00000000 c7eb9cc0 c0739cc0 c0803f74 c0801e70 c0801e70 c0801ea4 c013d380
-[  341.530253] 1e80: 00000000 000000a0 00000001 c0802084 c0802080 40000001 ffffe000 00000100
-[  341.538443] 1ea0: c0802080 c01021e8 c8803100 10c5387d 00000000 c07341f0 c0739880 0000000a
-[  341.546633] 1ec0: c0734180 00001017 c0802d00 c062aa98 00200002 c062aa60 c8803100 c073984c
-[  341.554823] 1ee0: 00000000 00000001 00000000 c7810000 c8803100 10c5387d 00000000 c011c188
-[  341.563014] 1f00: c073984c c015f0f8 c0804244 c0815ae4 c880210c c8802100 c0801f40 c037c584
-[  341.571204] 1f20: c01035f8 60000013 ffffffff c0801f74 c080afd4 c0800000 10c5387d c0101a8c
-[  341.579395] 1f40: 00000000 004ac9dc c7eba4b4 c010ee60 ffffe000 c0803e68 c0803ea8 00000001
-[  341.587587] 1f60: c080afd4 c062ca20 10c5387d 00000000 00000000 c0801f90 c01035f4 c01035f8
-[  341.595776] 1f80: 60000013 ffffffff 00000051 00000000 ffffe000 c013ff50 000000ce c0803e40
-[  341.603967] 1fa0: c082216c 00000000 00000001 c072ba38 10c5387d c0140214 c0822184 c0700df8
-[  341.612157] 1fc0: ffffffff ffffffff 00000000 c070058c c072ba38 2d162e71 00000000 c0700330
-[  341.620348] 1fe0: 00000051 10c0387d 000000ff 00a521d0 413fc090 00000000 00000000 00000000
-[  341.628558] [<c0469fa8>] (dev_hard_start_xmit) from [<c04a033c>] (sch_direct_xmit+0xe4/0x2bc)
-[  341.637106] [<c04a033c>] (sch_direct_xmit) from [<c046a7ac>] (__dev_queue_xmit+0x6a4/0x72c)
-[  341.645481] [<c046a7ac>] (__dev_queue_xmit) from [<c0520404>] (ip6_finish_output2+0x18c/0x434)
-[  341.654112] [<c0520404>] (ip6_finish_output2) from [<c0522fb4>] (ip6_output+0x5c/0xd0)
-[  341.662053] [<c0522fb4>] (ip6_output) from [<c0549c94>] (mld_sendpack+0x1a0/0x1a8)
-[  341.669640] [<c0549c94>] (mld_sendpack) from [<c054b070>] (mld_ifc_timer_expire+0x1cc/0x2e4)
-[  341.678111] [<c054b070>] (mld_ifc_timer_expire) from [<c0172e80>] (call_timer_fn.constprop.3+0x24/0x98)
-[  341.687527] [<c0172e80>] (call_timer_fn.constprop.3) from [<c017309c>] (run_timer_softirq+0x1a8/0x1e4)
-[  341.696860] [<c017309c>] (run_timer_softirq) from [<c01021e8>] (__do_softirq+0x120/0x2b0)
-[  341.705066] [<c01021e8>] (__do_softirq) from [<c011c188>] (irq_exit+0x78/0x84)
-[  341.712317] [<c011c188>] (irq_exit) from [<c015f0f8>] (__handle_domain_irq+0x60/0xb4)
-[  341.720179] [<c015f0f8>] (__handle_domain_irq) from [<c037c584>] (gic_handle_irq+0x4c/0x90)
-[  341.728549] [<c037c584>] (gic_handle_irq) from [<c0101a8c>] (__irq_svc+0x6c/0x90)
-
-Fixes: 20f2c5fa3af0 ("brcmfmac: add initial support for monitor mode")
-Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
----
- drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c | 9 +++++++++
- 1 file changed, 9 insertions(+)
-
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -746,9 +746,18 @@ static int brcmf_net_mon_stop(struct net
- 	return err;
- }
- 
-+static netdev_tx_t brcmf_net_mon_start_xmit(struct sk_buff *skb,
-+					    struct net_device *ndev)
-+{
-+	dev_kfree_skb_any(skb);
-+
-+	return NETDEV_TX_OK;
-+}
-+
- static const struct net_device_ops brcmf_netdev_ops_mon = {
- 	.ndo_open = brcmf_net_mon_open,
- 	.ndo_stop = brcmf_net_mon_stop,
-+	.ndo_start_xmit = brcmf_net_mon_start_xmit,
- };
- 
- int brcmf_net_mon_attach(struct brcmf_if *ifp)
diff -uprN a/package/kernel/mac80211/patches/brcm/300-v4.20-0001-brcmfmac-add-CYW89342-mini-PCIe-device.patch b/package/kernel/mac80211/patches/brcm/300-v4.20-0001-brcmfmac-add-CYW89342-mini-PCIe-device.patch
--- a/package/kernel/mac80211/patches/brcm/300-v4.20-0001-brcmfmac-add-CYW89342-mini-PCIe-device.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/300-v4.20-0001-brcmfmac-add-CYW89342-mini-PCIe-device.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,25 @@
+From 2fef681a4cf7994c882190fd2417b95f30510afb Mon Sep 17 00:00:00 2001
+From: Jia-Shyr Chuang <saint.chuang@cypress.com>
+Date: Wed, 15 Aug 2018 04:23:09 -0500
+Subject: [PATCH] brcmfmac: add CYW89342 mini-PCIe device
+
+CYW89342 is a 2x2 MIMO, 802.11a/b/g/n/ac for WLAN. It is a member of
+4355/4359 family.
+
+Signed-off-by: Jia-Shyr Chuang <saint.chuang@cypress.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -2017,6 +2017,7 @@ static const struct dev_pm_ops brcmf_pci
+ 
+ static const struct pci_device_id brcmf_pcie_devid_table[] = {
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_4350_DEVICE_ID),
++	BRCMF_PCIE_DEVICE_SUB(0x4355, BRCM_PCIE_VENDOR_ID_BROADCOM, 0x4355),
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_4356_DEVICE_ID),
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_43567_DEVICE_ID),
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_43570_DEVICE_ID),
diff -uprN a/package/kernel/mac80211/patches/brcm/305-v4.20-0001-brcmfmac-remove-set-but-not-used-variables-sfdoff-an.patch b/package/kernel/mac80211/patches/brcm/305-v4.20-0001-brcmfmac-remove-set-but-not-used-variables-sfdoff-an.patch
--- a/package/kernel/mac80211/patches/brcm/305-v4.20-0001-brcmfmac-remove-set-but-not-used-variables-sfdoff-an.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/305-v4.20-0001-brcmfmac-remove-set-but-not-used-variables-sfdoff-an.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,57 @@
+From a8254fa4ba60b85829b6e5ede6564f81cd70d59f Mon Sep 17 00:00:00 2001
+From: YueHaibing <yuehaibing@huawei.com>
+Date: Tue, 11 Sep 2018 11:24:04 +0800
+Subject: [PATCH] brcmfmac: remove set but not used variables 'sfdoff' and
+ 'pad_size'
+
+Fixes gcc '-Wunused-but-set-variable' warning:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c: In function 'brcmf_sdio_rxglom':
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:1466:11: warning:
+ variable 'sfdoff' set but not used [-Wunused-but-set-variable]
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c: In function 'brcmf_sdio_bus_preinit':
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c:3408:7: warning:
+ variable 'pad_size' set but not used [-Wunused-but-set-variable]
+
+Signed-off-by: YueHaibing <yuehaibing@huawei.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c | 5 +----
+ 1 file changed, 1 insertion(+), 4 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -1480,7 +1480,7 @@ static u8 brcmf_sdio_rxglom(struct brcmf
+ 	struct sk_buff *pfirst, *pnext;
+ 
+ 	int errcode;
+-	u8 doff, sfdoff;
++	u8 doff;
+ 
+ 	struct brcmf_sdio_hdrinfo rd_new;
+ 
+@@ -1614,7 +1614,6 @@ static u8 brcmf_sdio_rxglom(struct brcmf
+ 
+ 		/* Remove superframe header, remember offset */
+ 		skb_pull(pfirst, rd_new.dat_offset);
+-		sfdoff = rd_new.dat_offset;
+ 		num = 0;
+ 
+ 		/* Validate all the subframe headers */
+@@ -3428,7 +3427,6 @@ static int brcmf_sdio_bus_preinit(struct
+ 	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+ 	struct brcmf_sdio *bus = sdiodev->bus;
+ 	struct brcmf_core *core = bus->sdio_core;
+-	uint pad_size;
+ 	u32 value;
+ 	int err;
+ 
+@@ -3469,7 +3467,6 @@ static int brcmf_sdio_bus_preinit(struct
+ 	if (sdiodev->sg_support) {
+ 		bus->txglom = false;
+ 		value = 1;
+-		pad_size = bus->sdiodev->func2->cur_blksize << 1;
+ 		err = brcmf_iovar_data_set(bus->sdiodev->dev, "bus:rxglom",
+ 					   &value, sizeof(u32));
+ 		if (err < 0) {
diff -uprN a/package/kernel/mac80211/patches/brcm/320-v5.0-0001-brcmfmac-Remove-firmware-loading-code-duplication.patch b/package/kernel/mac80211/patches/brcm/320-v5.0-0001-brcmfmac-Remove-firmware-loading-code-duplication.patch
--- a/package/kernel/mac80211/patches/brcm/320-v5.0-0001-brcmfmac-Remove-firmware-loading-code-duplication.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/320-v5.0-0001-brcmfmac-Remove-firmware-loading-code-duplication.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,102 @@
+From a1a3b762163868ad07a4499a73df324f40d5ab0b Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Wed, 10 Oct 2018 13:00:58 +0200
+Subject: [PATCH] brcmfmac: Remove firmware-loading code duplication
+
+brcmf_fw_request_next_item and brcmf_fw_request_done both have identical
+code to complete the fw-request depending on the item-type.
+
+This commit adds a new brcmf_fw_complete_request helper removing this code
+duplication.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/firmware.c         | 62 +++++++++++-----------
+ 1 file changed, 31 insertions(+), 31 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -504,6 +504,34 @@ fail:
+ 	return -ENOENT;
+ }
+ 
++static int brcmf_fw_complete_request(const struct firmware *fw,
++				     struct brcmf_fw *fwctx)
++{
++	struct brcmf_fw_item *cur = &fwctx->req->items[fwctx->curpos];
++	int ret = 0;
++
++	brcmf_dbg(TRACE, "firmware %s %sfound\n", cur->path, fw ? "" : "not ");
++
++	switch (cur->type) {
++	case BRCMF_FW_TYPE_NVRAM:
++		ret = brcmf_fw_request_nvram_done(fw, fwctx);
++		break;
++	case BRCMF_FW_TYPE_BINARY:
++		if (fw)
++			cur->binary = fw;
++		else
++			ret = -ENOENT;
++		break;
++	default:
++		/* something fishy here so bail out early */
++		brcmf_err("unknown fw type: %d\n", cur->type);
++		release_firmware(fw);
++		ret = -EINVAL;
++	}
++
++	return (cur->flags & BRCMF_FW_REQF_OPTIONAL) ? 0 : ret;
++}
++
+ static int brcmf_fw_request_next_item(struct brcmf_fw *fwctx, bool async)
+ {
+ 	struct brcmf_fw_item *cur;
+@@ -525,15 +553,7 @@ static int brcmf_fw_request_next_item(st
+ 	if (ret < 0) {
+ 		brcmf_fw_request_done(NULL, fwctx);
+ 	} else if (!async && fw) {
+-		brcmf_dbg(TRACE, "firmware %s %sfound\n", cur->path,
+-			  fw ? "" : "not ");
+-		if (cur->type == BRCMF_FW_TYPE_BINARY)
+-			cur->binary = fw;
+-		else if (cur->type == BRCMF_FW_TYPE_NVRAM)
+-			brcmf_fw_request_nvram_done(fw, fwctx);
+-		else
+-			release_firmware(fw);
+-
++		brcmf_fw_complete_request(fw, fwctx);
+ 		return -EAGAIN;
+ 	}
+ 	return 0;
+@@ -547,28 +567,8 @@ static void brcmf_fw_request_done(const
+ 
+ 	cur = &fwctx->req->items[fwctx->curpos];
+ 
+-	brcmf_dbg(TRACE, "enter: firmware %s %sfound\n", cur->path,
+-		  fw ? "" : "not ");
+-
+-	if (!fw)
+-		ret = -ENOENT;
+-
+-	switch (cur->type) {
+-	case BRCMF_FW_TYPE_NVRAM:
+-		ret = brcmf_fw_request_nvram_done(fw, fwctx);
+-		break;
+-	case BRCMF_FW_TYPE_BINARY:
+-		cur->binary = fw;
+-		break;
+-	default:
+-		/* something fishy here so bail out early */
+-		brcmf_err("unknown fw type: %d\n", cur->type);
+-		release_firmware(fw);
+-		ret = -EINVAL;
+-		goto fail;
+-	}
+-
+-	if (ret < 0 && !(cur->flags & BRCMF_FW_REQF_OPTIONAL))
++	ret = brcmf_fw_complete_request(fw, fwctx);
++	if (ret < 0)
+ 		goto fail;
+ 
+ 	do {
diff -uprN a/package/kernel/mac80211/patches/brcm/320-v5.0-0002-brcmfmac-Remove-recursion-from-firmware-load-error-h.patch b/package/kernel/mac80211/patches/brcm/320-v5.0-0002-brcmfmac-Remove-recursion-from-firmware-load-error-h.patch
--- a/package/kernel/mac80211/patches/brcm/320-v5.0-0002-brcmfmac-Remove-recursion-from-firmware-load-error-h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/320-v5.0-0002-brcmfmac-Remove-recursion-from-firmware-load-error-h.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,127 @@
+From 5b587496dc63595b71265d986ce69728c2724370 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Wed, 10 Oct 2018 13:00:59 +0200
+Subject: [PATCH] brcmfmac: Remove recursion from firmware load error handling
+
+Before this commit brcmf_fw_request_done would call
+brcmf_fw_request_next_item to load the next item, which on an error would
+call brcmf_fw_request_done, which if the error is recoverable (*) will
+then continue calling brcmf_fw_request_next_item for the next item again
+which on an error will call brcmf_fw_request_done again...
+
+This does not blow up because we only have a limited number of items so
+we never recurse too deep. But the recursion is still quite ugly and
+frankly is giving me a headache, so lets fix this.
+
+This commit fixes this by removing brcmf_fw_request_next_item and by
+making brcmf_fw_get_firmwares and brcmf_fw_request_done directly call
+firmware_request_nowait resp. firmware_request themselves.
+
+*) brcmf_fw_request_nvram_done fallback path succeeds or
+   BRCMF_FW_REQF_OPTIONAL is set
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/firmware.c         | 65 +++++++---------------
+ 1 file changed, 19 insertions(+), 46 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -532,33 +532,6 @@ static int brcmf_fw_complete_request(con
+ 	return (cur->flags & BRCMF_FW_REQF_OPTIONAL) ? 0 : ret;
+ }
+ 
+-static int brcmf_fw_request_next_item(struct brcmf_fw *fwctx, bool async)
+-{
+-	struct brcmf_fw_item *cur;
+-	const struct firmware *fw = NULL;
+-	int ret;
+-
+-	cur = &fwctx->req->items[fwctx->curpos];
+-
+-	brcmf_dbg(TRACE, "%srequest for %s\n", async ? "async " : "",
+-		  cur->path);
+-
+-	if (async)
+-		ret = request_firmware_nowait(THIS_MODULE, true, cur->path,
+-					      fwctx->dev, GFP_KERNEL, fwctx,
+-					      brcmf_fw_request_done);
+-	else
+-		ret = request_firmware(&fw, cur->path, fwctx->dev);
+-
+-	if (ret < 0) {
+-		brcmf_fw_request_done(NULL, fwctx);
+-	} else if (!async && fw) {
+-		brcmf_fw_complete_request(fw, fwctx);
+-		return -EAGAIN;
+-	}
+-	return 0;
+-}
+-
+ static void brcmf_fw_request_done(const struct firmware *fw, void *ctx)
+ {
+ 	struct brcmf_fw *fwctx = ctx;
+@@ -568,26 +541,19 @@ static void brcmf_fw_request_done(const
+ 	cur = &fwctx->req->items[fwctx->curpos];
+ 
+ 	ret = brcmf_fw_complete_request(fw, fwctx);
+-	if (ret < 0)
+-		goto fail;
+ 
+-	do {
+-		if (++fwctx->curpos == fwctx->req->n_items) {
+-			ret = 0;
+-			goto done;
+-		}
+-
+-		ret = brcmf_fw_request_next_item(fwctx, false);
+-	} while (ret == -EAGAIN);
+-
+-	return;
+-
+-fail:
+-	brcmf_dbg(TRACE, "failed err=%d: dev=%s, fw=%s\n", ret,
+-		  dev_name(fwctx->dev), cur->path);
+-	brcmf_fw_free_request(fwctx->req);
+-	fwctx->req = NULL;
+-done:
++	while (ret == 0 && ++fwctx->curpos < fwctx->req->n_items) {
++		cur = &fwctx->req->items[fwctx->curpos];
++		request_firmware(&fw, cur->path, fwctx->dev);
++		ret = brcmf_fw_complete_request(fw, ctx);
++	}
++
++	if (ret) {
++		brcmf_dbg(TRACE, "failed err=%d: dev=%s, fw=%s\n", ret,
++			  dev_name(fwctx->dev), cur->path);
++		brcmf_fw_free_request(fwctx->req);
++		fwctx->req = NULL;
++	}
+ 	fwctx->done(fwctx->dev, ret, fwctx->req);
+ 	kfree(fwctx);
+ }
+@@ -611,7 +577,9 @@ int brcmf_fw_get_firmwares(struct device
+ 			   void (*fw_cb)(struct device *dev, int err,
+ 					 struct brcmf_fw_request *req))
+ {
++	struct brcmf_fw_item *first = &req->items[0];
+ 	struct brcmf_fw *fwctx;
++	int ret;
+ 
+ 	brcmf_dbg(TRACE, "enter: dev=%s\n", dev_name(dev));
+ 	if (!fw_cb)
+@@ -628,7 +596,12 @@ int brcmf_fw_get_firmwares(struct device
+ 	fwctx->req = req;
+ 	fwctx->done = fw_cb;
+ 
+-	brcmf_fw_request_next_item(fwctx, true);
++	ret = request_firmware_nowait(THIS_MODULE, true, first->path,
++				      fwctx->dev, GFP_KERNEL, fwctx,
++				      brcmf_fw_request_done);
++	if (ret < 0)
++		brcmf_fw_request_done(NULL, fwctx);
++
+ 	return 0;
+ }
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/320-v5.0-0003-brcmfmac-Add-support-for-first-trying-to-get-a-board.patch b/package/kernel/mac80211/patches/brcm/320-v5.0-0003-brcmfmac-Add-support-for-first-trying-to-get-a-board.patch
--- a/package/kernel/mac80211/patches/brcm/320-v5.0-0003-brcmfmac-Add-support-for-first-trying-to-get-a-board.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/320-v5.0-0003-brcmfmac-Add-support-for-first-trying-to-get-a-board.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,77 @@
+From eae8e50669e15002b195177212a6e25afbe7cf4d Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Wed, 10 Oct 2018 13:01:00 +0200
+Subject: [PATCH] brcmfmac: Add support for first trying to get a board
+ specific nvram file
+
+The nvram files which some brcmfmac chips need are board-specific. To be
+able to distribute these as part of linux-firmware, so that devices with
+such a wifi chip will work OOTB, multiple (one per board) versions must
+co-exist under /lib/firmware.
+
+This commit adds support for callers of the brcmfmac/firmware.c code to
+pass in a board_type parameter through the request structure.
+
+If that parameter is set then the code will first try to load
+chipmodel.board_type.txt before falling back to the old chipmodel.txt name.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/firmware.c         | 27 +++++++++++++++++++++-
+ .../broadcom/brcm80211/brcmfmac/firmware.h         |  1 +
+ 2 files changed, 27 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -532,6 +532,31 @@ static int brcmf_fw_complete_request(con
+ 	return (cur->flags & BRCMF_FW_REQF_OPTIONAL) ? 0 : ret;
+ }
+ 
++static int brcmf_fw_request_firmware(const struct firmware **fw,
++				     struct brcmf_fw *fwctx)
++{
++	struct brcmf_fw_item *cur = &fwctx->req->items[fwctx->curpos];
++	int ret;
++
++	/* nvram files are board-specific, first try a board-specific path */
++	if (cur->type == BRCMF_FW_TYPE_NVRAM && fwctx->req->board_type) {
++		char alt_path[BRCMF_FW_NAME_LEN];
++
++		strlcpy(alt_path, cur->path, BRCMF_FW_NAME_LEN);
++		/* strip .txt at the end */
++		alt_path[strlen(alt_path) - 4] = 0;
++		strlcat(alt_path, ".", BRCMF_FW_NAME_LEN);
++		strlcat(alt_path, fwctx->req->board_type, BRCMF_FW_NAME_LEN);
++		strlcat(alt_path, ".txt", BRCMF_FW_NAME_LEN);
++
++		ret = request_firmware(fw, alt_path, fwctx->dev);
++		if (ret == 0)
++			return ret;
++	}
++
++	return request_firmware(fw, cur->path, fwctx->dev);
++}
++
+ static void brcmf_fw_request_done(const struct firmware *fw, void *ctx)
+ {
+ 	struct brcmf_fw *fwctx = ctx;
+@@ -544,7 +569,7 @@ static void brcmf_fw_request_done(const
+ 
+ 	while (ret == 0 && ++fwctx->curpos < fwctx->req->n_items) {
+ 		cur = &fwctx->req->items[fwctx->curpos];
+-		request_firmware(&fw, cur->path, fwctx->dev);
++		brcmf_fw_request_firmware(&fw, fwctx);
+ 		ret = brcmf_fw_complete_request(fw, ctx);
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h
+@@ -70,6 +70,7 @@ struct brcmf_fw_request {
+ 	u16 domain_nr;
+ 	u16 bus_nr;
+ 	u32 n_items;
++	const char *board_type;
+ 	struct brcmf_fw_item items[0];
+ };
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/320-v5.0-0004-brcmfmac-Set-board_type-used-for-nvram-file-selectio.patch b/package/kernel/mac80211/patches/brcm/320-v5.0-0004-brcmfmac-Set-board_type-used-for-nvram-file-selectio.patch
--- a/package/kernel/mac80211/patches/brcm/320-v5.0-0004-brcmfmac-Set-board_type-used-for-nvram-file-selectio.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/320-v5.0-0004-brcmfmac-Set-board_type-used-for-nvram-file-selectio.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,77 @@
+From 0ad4b55b2f29784f93875e6231bf57cd233624a2 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Wed, 10 Oct 2018 13:01:01 +0200
+Subject: [PATCH] brcmfmac: Set board_type used for nvram file selection to
+ machine-compatible
+
+For of/devicetree using machines, set the board_type used for nvram file
+selection to the first string listed in the top-level's node compatible
+string, aka the machine-compatible as used by of_machine_is_compatible().
+
+The board_type setting is used to load the board-specific nvram file with
+a board-specific name so that we can ship files for each supported board
+in linux-firmware.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h |  1 +
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c     | 11 ++++++++++-
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c   |  1 +
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c   |  1 +
+ 4 files changed, 13 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
+@@ -59,6 +59,7 @@ struct brcmf_mp_device {
+ 	bool		iapp;
+ 	bool		ignore_probe_fail;
+ 	struct brcmfmac_pd_cc *country_codes;
++	const char	*board_type;
+ 	union {
+ 		struct brcmfmac_sdio_pd sdio;
+ 	} bus;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
+@@ -27,11 +27,20 @@ void brcmf_of_probe(struct device *dev,
+ 		    struct brcmf_mp_device *settings)
+ {
+ 	struct brcmfmac_sdio_pd *sdio = &settings->bus.sdio;
+-	struct device_node *np = dev->of_node;
++	struct device_node *root, *np = dev->of_node;
++	struct property *prop;
+ 	int irq;
+ 	u32 irqf;
+ 	u32 val;
+ 
++	/* Set board-type to the first string of the machine compatible prop */
++	root = of_find_node_by_path("/");
++	if (root) {
++		prop = of_find_property(root, "compatible", NULL);
++		settings->board_type = of_prop_next_string(prop, NULL);
++		of_node_put(root);
++	}
++
+ 	if (!np || bus_type != BRCMF_BUSTYPE_SDIO ||
+ 	    !of_device_is_compatible(np, "brcm,bcm4329-fmac"))
+ 		return;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1785,6 +1785,7 @@ brcmf_pcie_prepare_fw_request(struct brc
+ 	fwreq->items[BRCMF_PCIE_FW_CODE].type = BRCMF_FW_TYPE_BINARY;
+ 	fwreq->items[BRCMF_PCIE_FW_NVRAM].type = BRCMF_FW_TYPE_NVRAM;
+ 	fwreq->items[BRCMF_PCIE_FW_NVRAM].flags = BRCMF_FW_REQF_OPTIONAL;
++	fwreq->board_type = devinfo->settings->board_type;
+ 	/* NVRAM reserves PCI domain 0 for Broadcom's SDK faked bus */
+ 	fwreq->domain_nr = pci_domain_nr(devinfo->pdev->bus) + 1;
+ 	fwreq->bus_nr = devinfo->pdev->bus->number;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -4219,6 +4219,7 @@ brcmf_sdio_prepare_fw_request(struct brc
+ 
+ 	fwreq->items[BRCMF_SDIO_FW_CODE].type = BRCMF_FW_TYPE_BINARY;
+ 	fwreq->items[BRCMF_SDIO_FW_NVRAM].type = BRCMF_FW_TYPE_NVRAM;
++	fwreq->board_type = bus->sdiodev->settings->board_type;
+ 
+ 	return fwreq;
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/320-v5.0-0005-brcmfmac-Set-board_type-from-DMI-on-x86-based-machin.patch b/package/kernel/mac80211/patches/brcm/320-v5.0-0005-brcmfmac-Set-board_type-from-DMI-on-x86-based-machin.patch
--- a/package/kernel/mac80211/patches/brcm/320-v5.0-0005-brcmfmac-Set-board_type-from-DMI-on-x86-based-machin.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/320-v5.0-0005-brcmfmac-Set-board_type-from-DMI-on-x86-based-machin.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,179 @@
+From bd1e82bb420adf4ad7cd468d8a482cde622dd69d Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Wed, 10 Oct 2018 13:01:02 +0200
+Subject: [PATCH] brcmfmac: Set board_type from DMI on x86 based machines
+
+For x86 based machines, set the board_type used for nvram file selection
+based on the DMI sys-vendor and product-name strings.
+
+Since on some models these strings are too generic, this commit also adds
+a quirk table overriding the strings for models listed in that table.
+
+The board_type setting is used to load the board-specific nvram file with
+a board-specific name so that we can ship files for each supported board
+in linux-firmware.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/Makefile  |   2 +
+ .../wireless/broadcom/brcm80211/brcmfmac/common.c  |   3 +-
+ .../wireless/broadcom/brcm80211/brcmfmac/common.h  |   7 ++
+ .../net/wireless/broadcom/brcm80211/brcmfmac/dmi.c | 116 +++++++++++++++++++++
+ 4 files changed, 127 insertions(+), 1 deletion(-)
+ create mode 100644 drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
+@@ -54,3 +54,5 @@ brcmfmac-$(CPTCFG_BRCM_TRACING) += \
+ 		tracepoint.o
+ brcmfmac-$(CONFIG_OF) += \
+ 		of.o
++brcmfmac-$(CONFIG_DMI) += \
++		dmi.o
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -448,8 +448,9 @@ struct brcmf_mp_device *brcmf_get_module
+ 		}
+ 	}
+ 	if (!found) {
+-		/* No platform data for this device, try OF (Open Firwmare) */
++		/* No platform data for this device, try OF and DMI data */
+ 		brcmf_of_probe(dev, bus_type, settings);
++		brcmf_dmi_probe(settings, chip, chiprev);
+ 	}
+ 	return settings;
+ }
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
+@@ -75,4 +75,11 @@ void brcmf_release_module_param(struct b
+ /* Sets dongle media info (drv_version, mac address). */
+ int brcmf_c_preinit_dcmds(struct brcmf_if *ifp);
+ 
++#ifdef CONFIG_DMI
++void brcmf_dmi_probe(struct brcmf_mp_device *settings, u32 chip, u32 chiprev);
++#else
++static inline void
++brcmf_dmi_probe(struct brcmf_mp_device *settings, u32 chip, u32 chiprev) {}
++#endif
++
+ #endif /* BRCMFMAC_COMMON_H */
+--- /dev/null
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
+@@ -0,0 +1,116 @@
++/*
++ * Copyright 2018 Hans de Goede <hdegoede@redhat.com>
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
++ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
++ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
++ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++#include <linux/dmi.h>
++#include <linux/mod_devicetable.h>
++#include "core.h"
++#include "common.h"
++#include "brcm_hw_ids.h"
++
++/* The DMI data never changes so we can use a static buf for this */
++static char dmi_board_type[128];
++
++struct brcmf_dmi_data {
++	u32 chip;
++	u32 chiprev;
++	const char *board_type;
++};
++
++/* NOTE: Please keep all entries sorted alphabetically */
++
++static const struct brcmf_dmi_data gpd_win_pocket_data = {
++	BRCM_CC_4356_CHIP_ID, 2, "gpd-win-pocket"
++};
++
++static const struct brcmf_dmi_data jumper_ezpad_mini3_data = {
++	BRCM_CC_43430_CHIP_ID, 0, "jumper-ezpad-mini3"
++};
++
++static const struct brcmf_dmi_data meegopad_t08_data = {
++	BRCM_CC_43340_CHIP_ID, 2, "meegopad-t08"
++};
++
++static const struct dmi_system_id dmi_platform_data[] = {
++	{
++		/* Match for the GPDwin which unfortunately uses somewhat
++		 * generic dmi strings, which is why we test for 4 strings.
++		 * Comparing against 23 other byt/cht boards, board_vendor
++		 * and board_name are unique to the GPDwin, where as only one
++		 * other board has the same board_serial and 3 others have
++		 * the same default product_name. Also the GPDwin is the
++		 * only device to have both board_ and product_name not set.
++		 */
++		.matches = {
++			DMI_MATCH(DMI_BOARD_VENDOR, "AMI Corporation"),
++			DMI_MATCH(DMI_BOARD_NAME, "Default string"),
++			DMI_MATCH(DMI_BOARD_SERIAL, "Default string"),
++			DMI_MATCH(DMI_PRODUCT_NAME, "Default string"),
++		},
++		.driver_data = (void *)&gpd_win_pocket_data,
++	},
++	{
++		/* Jumper EZpad mini3 */
++		.matches = {
++			DMI_MATCH(DMI_SYS_VENDOR, "Insyde"),
++			DMI_MATCH(DMI_PRODUCT_NAME, "CherryTrail"),
++			/* jumperx.T87.KFBNEEA02 with the version-nr dropped */
++			DMI_MATCH(DMI_BIOS_VERSION, "jumperx.T87.KFBNEEA"),
++		},
++		.driver_data = (void *)&jumper_ezpad_mini3_data,
++	},
++	{
++		/* Meegopad T08 */
++		.matches = {
++			DMI_MATCH(DMI_SYS_VENDOR, "Default string"),
++			DMI_MATCH(DMI_PRODUCT_NAME, "Default string"),
++			DMI_MATCH(DMI_BOARD_NAME, "T3 MRD"),
++			DMI_MATCH(DMI_BOARD_VERSION, "V1.1"),
++		},
++		.driver_data = (void *)&meegopad_t08_data,
++	},
++	{}
++};
++
++void brcmf_dmi_probe(struct brcmf_mp_device *settings, u32 chip, u32 chiprev)
++{
++	const struct dmi_system_id *match;
++	const struct brcmf_dmi_data *data;
++	const char *sys_vendor;
++	const char *product_name;
++
++	/* Some models have DMI strings which are too generic, e.g.
++	 * "Default string", we use a quirk table for these.
++	 */
++	for (match = dmi_first_match(dmi_platform_data);
++	     match;
++	     match = dmi_first_match(match + 1)) {
++		data = match->driver_data;
++
++		if (data->chip == chip && data->chiprev == chiprev) {
++			settings->board_type = data->board_type;
++			return;
++		}
++	}
++
++	/* Not found in the quirk-table, use sys_vendor-product_name */
++	sys_vendor = dmi_get_system_info(DMI_SYS_VENDOR);
++	product_name = dmi_get_system_info(DMI_PRODUCT_NAME);
++	if (sys_vendor && product_name) {
++		snprintf(dmi_board_type, sizeof(dmi_board_type), "%s-%s",
++			 sys_vendor, product_name);
++		settings->board_type = dmi_board_type;
++	}
++}
diff -uprN a/package/kernel/mac80211/patches/brcm/320-v5.0-0006-brcmfmac-Cleanup-brcmf_fw_request_done.patch b/package/kernel/mac80211/patches/brcm/320-v5.0-0006-brcmfmac-Cleanup-brcmf_fw_request_done.patch
--- a/package/kernel/mac80211/patches/brcm/320-v5.0-0006-brcmfmac-Cleanup-brcmf_fw_request_done.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/320-v5.0-0006-brcmfmac-Cleanup-brcmf_fw_request_done.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,41 @@
+From 55e491edbf14b2da5419c2a319ea3b1d6368d9a2 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Wed, 10 Oct 2018 13:01:03 +0200
+Subject: [PATCH] brcmfmac: Cleanup brcmf_fw_request_done()
+
+The "cur" variable is now only used for a debug print and we already
+print the same info from brcmf_fw_complete_request(), so the debug print
+does not provide any extra info and we can remove it.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c | 8 +-------
+ 1 file changed, 1 insertion(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -560,22 +560,16 @@ static int brcmf_fw_request_firmware(con
+ static void brcmf_fw_request_done(const struct firmware *fw, void *ctx)
+ {
+ 	struct brcmf_fw *fwctx = ctx;
+-	struct brcmf_fw_item *cur;
+-	int ret = 0;
+-
+-	cur = &fwctx->req->items[fwctx->curpos];
++	int ret;
+ 
+ 	ret = brcmf_fw_complete_request(fw, fwctx);
+ 
+ 	while (ret == 0 && ++fwctx->curpos < fwctx->req->n_items) {
+-		cur = &fwctx->req->items[fwctx->curpos];
+ 		brcmf_fw_request_firmware(&fw, fwctx);
+ 		ret = brcmf_fw_complete_request(fw, ctx);
+ 	}
+ 
+ 	if (ret) {
+-		brcmf_dbg(TRACE, "failed err=%d: dev=%s, fw=%s\n", ret,
+-			  dev_name(fwctx->dev), cur->path);
+ 		brcmf_fw_free_request(fwctx->req);
+ 		fwctx->req = NULL;
+ 	}
diff -uprN a/package/kernel/mac80211/patches/brcm/321-v5.0-0001-brcmfmac-Add-support-for-getting-nvram-contents-from.patch b/package/kernel/mac80211/patches/brcm/321-v5.0-0001-brcmfmac-Add-support-for-getting-nvram-contents-from.patch
--- a/package/kernel/mac80211/patches/brcm/321-v5.0-0001-brcmfmac-Add-support-for-getting-nvram-contents-from.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/321-v5.0-0001-brcmfmac-Add-support-for-getting-nvram-contents-from.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,132 @@
+From ce2e6db554fad444fa0b3904fc3015336e0ef765 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Thu, 11 Oct 2018 11:51:06 +0200
+Subject: [PATCH] brcmfmac: Add support for getting nvram contents from EFI
+ variables
+
+Various X86 laptops with a SDIO attached brcmfmac wifi chip, store the
+nvram contents in a special EFI variable. This commit adds support for
+getting nvram directly from this EFI variable, without the user needing
+to manually copy it.
+
+This makes Wifi / Bluetooth work out of the box on these devices instead of
+requiring manual setup.
+
+This has been tested on the following models: Acer Iconia Tab8 w1-810,
+Acer One 10, Asus T100CHI, Asus T100HA, Asus T100TA, Asus T200TA and a
+Lenovo Mixx 2 8.
+
+Tested-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/firmware.c         | 63 +++++++++++++++++++---
+ 1 file changed, 57 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -14,6 +14,7 @@
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
++#include <linux/efi.h>
+ #include <linux/kernel.h>
+ #include <linux/slab.h>
+ #include <linux/device.h>
+@@ -445,6 +446,51 @@ struct brcmf_fw {
+ 
+ static void brcmf_fw_request_done(const struct firmware *fw, void *ctx);
+ 
++#ifdef CONFIG_EFI
++static u8 *brcmf_fw_nvram_from_efi(size_t *data_len_ret)
++{
++	const u16 name[] = { 'n', 'v', 'r', 'a', 'm', 0 };
++	struct efivar_entry *nvram_efivar;
++	unsigned long data_len = 0;
++	u8 *data = NULL;
++	int err;
++
++	nvram_efivar = kzalloc(sizeof(*nvram_efivar), GFP_KERNEL);
++	if (!nvram_efivar)
++		return NULL;
++
++	memcpy(&nvram_efivar->var.VariableName, name, sizeof(name));
++	nvram_efivar->var.VendorGuid = EFI_GUID(0x74b00bd9, 0x805a, 0x4d61,
++						0xb5, 0x1f, 0x43, 0x26,
++						0x81, 0x23, 0xd1, 0x13);
++
++	err = efivar_entry_size(nvram_efivar, &data_len);
++	if (err)
++		goto fail;
++
++	data = kmalloc(data_len, GFP_KERNEL);
++	if (!data)
++		goto fail;
++
++	err = efivar_entry_get(nvram_efivar, NULL, &data_len, data);
++	if (err)
++		goto fail;
++
++	brcmf_info("Using nvram EFI variable\n");
++
++	kfree(nvram_efivar);
++	*data_len_ret = data_len;
++	return data;
++
++fail:
++	kfree(data);
++	kfree(nvram_efivar);
++	return NULL;
++}
++#else
++static u8 *brcmf_fw_nvram_from_efi(size_t *data_len) { return NULL; }
++#endif
++
+ static void brcmf_fw_free_request(struct brcmf_fw_request *req)
+ {
+ 	struct brcmf_fw_item *item;
+@@ -463,11 +509,12 @@ static int brcmf_fw_request_nvram_done(c
+ {
+ 	struct brcmf_fw *fwctx = ctx;
+ 	struct brcmf_fw_item *cur;
++	bool free_bcm47xx_nvram = false;
++	bool kfree_nvram = false;
+ 	u32 nvram_length = 0;
+ 	void *nvram = NULL;
+ 	u8 *data = NULL;
+ 	size_t data_len;
+-	bool raw_nvram;
+ 
+ 	brcmf_dbg(TRACE, "enter: dev=%s\n", dev_name(fwctx->dev));
+ 
+@@ -476,12 +523,13 @@ static int brcmf_fw_request_nvram_done(c
+ 	if (fw && fw->data) {
+ 		data = (u8 *)fw->data;
+ 		data_len = fw->size;
+-		raw_nvram = false;
+ 	} else {
+-		data = bcm47xx_nvram_get_contents(&data_len);
+-		if (!data && !(cur->flags & BRCMF_FW_REQF_OPTIONAL))
++		if ((data = bcm47xx_nvram_get_contents(&data_len)))
++			free_bcm47xx_nvram = true;
++		else if ((data = brcmf_fw_nvram_from_efi(&data_len)))
++			kfree_nvram = true;
++		else if (!(cur->flags & BRCMF_FW_REQF_OPTIONAL))
+ 			goto fail;
+-		raw_nvram = true;
+ 	}
+ 
+ 	if (data)
+@@ -489,8 +537,11 @@ static int brcmf_fw_request_nvram_done(c
+ 					     fwctx->req->domain_nr,
+ 					     fwctx->req->bus_nr);
+ 
+-	if (raw_nvram)
++	if (free_bcm47xx_nvram)
+ 		bcm47xx_nvram_release_contents(data);
++	if (kfree_nvram)
++		kfree(data);
++
+ 	release_firmware(fw);
+ 	if (!nvram && !(cur->flags & BRCMF_FW_REQF_OPTIONAL))
+ 		goto fail;
diff -uprN a/package/kernel/mac80211/patches/brcm/321-v5.0-0002-brcmfmac-Fix-ccode-from-EFI-nvram-when-necessary.patch b/package/kernel/mac80211/patches/brcm/321-v5.0-0002-brcmfmac-Fix-ccode-from-EFI-nvram-when-necessary.patch
--- a/package/kernel/mac80211/patches/brcm/321-v5.0-0002-brcmfmac-Fix-ccode-from-EFI-nvram-when-necessary.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/321-v5.0-0002-brcmfmac-Fix-ccode-from-EFI-nvram-when-necessary.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,97 @@
+From 29ec3394f0bd85c22674ab6693d92da5e2324610 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Thu, 11 Oct 2018 11:51:07 +0200
+Subject: [PATCH] brcmfmac: Fix ccode from EFI nvram when necessary
+
+In some cases the EFI-var stored nvram contains "ccode=ALL" or "ccode=XV"
+to specify "worldwide" compatible settings, but these 2 ccode-s do not work
+properly.
+
+I've tested the different known "worldwide" ccode-s used in various nvram
+sources with the latest firmwares from linux-firmware for various brcmfmac
+models, here is a simplified (*) table with what each setting results in:
+
+ALL: 12-14 disab, U-NII-1, U-NII-2 no-IR/radar, U-NII-3
+XV:  12-14 no-IR, disables all 5G channels
+XY:  12-13 enab, 14 disab, U-NII-1 enab, U-NII-2 no-IR/radar, U-NII-3 disab
+X2:  12-13 no-IR, 14 dis, U-NII-1 no-IR, U-NII-2 no-IR/radar, U-NII-3 no-IR
+
+Where 12,13,14 are 2.4G channels 12-14 and U-NII-1/2/3 are the 3 different
+5G channel groups. no-IR is no-Initiate-Radiation, we will never send on
+these channels without first having received valid wifi traffic there.
+
+This immediately shows that both ALL and XV are not as worldwide as we want
+them to be. ALL causes channels 12 and 13 to not be available and XV causes
+all 5GHz channels to not be available. Also ALL unconditionally enables the
+U-NII-1 and U-NII-3 5G groups, while we really should be using no-IR for
+these.
+
+This commit replace XV and ALL with X2, which allows usage of chan 12-13
+and 5G channels, but only after receiving valid wifi traffic there first.
+
+Note that this configure the firmware's channel limits, the kernels own
+regulatory restrictions based on e.g. regulatory info received from the
+access-point, will be applied on top of this.
+
+This fixes channels 12+13 not working on the Asus T200TA and the Lenovo
+Mixx 2 8 and 5G channels not working on the Asus T100HA.
+
+This has been tested on the following models: Acer Iconia Tab8 w1-810,
+Acer One 10, Asus T100CHI, Asus T100HA, Asus T100TA, Asus T200TA and a
+Lenovo Mixx 2 8.
+
+*) There are some exceptions to this table:
+1) On really old firmware e.g. linux-firmware's 2011 brcmfmac4330-sdio.bin
+   ALL really means all, unconditionally enabling everything
+2) The exact meaning might be influenced by setting the regrev nvram var.
+   Specifically using ccode=XV + regrev=1 on brcmfmac43241b4 leads to:
+   12-14 no-ir, U-NII-1 no-ir, U-NII-2 no-ir/radar, U-NII-3 no-ir
+   But only on the brcmfmac43241b4 and not on e.g. the brcmfmac43340
+
+Tested-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/firmware.c         | 24 ++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -447,6 +447,29 @@ struct brcmf_fw {
+ static void brcmf_fw_request_done(const struct firmware *fw, void *ctx);
+ 
+ #ifdef CONFIG_EFI
++/* In some cases the EFI-var stored nvram contains "ccode=ALL" or "ccode=XV"
++ * to specify "worldwide" compatible settings, but these 2 ccode-s do not work
++ * properly. "ccode=ALL" causes channels 12 and 13 to not be available,
++ * "ccode=XV" causes all 5GHz channels to not be available. So we replace both
++ * with "ccode=X2" which allows channels 12+13 and 5Ghz channels in
++ * no-Initiate-Radiation mode. This means that we will never send on these
++ * channels without first having received valid wifi traffic on the channel.
++ */
++static void brcmf_fw_fix_efi_nvram_ccode(char *data, unsigned long data_len)
++{
++	char *ccode;
++
++	ccode = strnstr((char *)data, "ccode=ALL", data_len);
++	if (!ccode)
++		ccode = strnstr((char *)data, "ccode=XV\r", data_len);
++	if (!ccode)
++		return;
++
++	ccode[6] = 'X';
++	ccode[7] = '2';
++	ccode[8] = '\r';
++}
++
+ static u8 *brcmf_fw_nvram_from_efi(size_t *data_len_ret)
+ {
+ 	const u16 name[] = { 'n', 'v', 'r', 'a', 'm', 0 };
+@@ -476,6 +499,7 @@ static u8 *brcmf_fw_nvram_from_efi(size_
+ 	if (err)
+ 		goto fail;
+ 
++	brcmf_fw_fix_efi_nvram_ccode(data, data_len);
+ 	brcmf_info("Using nvram EFI variable\n");
+ 
+ 	kfree(nvram_efivar);
diff -uprN a/package/kernel/mac80211/patches/brcm/322-v5.0-0001-brcmfmac-fix-spelling-mistake-Retreiving-Retrieving.patch b/package/kernel/mac80211/patches/brcm/322-v5.0-0001-brcmfmac-fix-spelling-mistake-Retreiving-Retrieving.patch
--- a/package/kernel/mac80211/patches/brcm/322-v5.0-0001-brcmfmac-fix-spelling-mistake-Retreiving-Retrieving.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/322-v5.0-0001-brcmfmac-fix-spelling-mistake-Retreiving-Retrieving.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,34 @@
+From e966a79c2f761a696dec9cfb0e2d4aa977bf78cb Mon Sep 17 00:00:00 2001
+From: Colin Ian King <colin.king@canonical.com>
+Date: Tue, 16 Oct 2018 18:43:42 +0100
+Subject: [PATCH] brcmfmac: fix spelling mistake "Retreiving" -> "Retrieving"
+
+Trivial fix to spelling mistake in brcmf_err error message.
+
+Signed-off-by: Colin Ian King <colin.king@canonical.com>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -214,7 +214,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	err = brcmf_fil_iovar_data_get(ifp, "cur_etheraddr", ifp->mac_addr,
+ 				       sizeof(ifp->mac_addr));
+ 	if (err < 0) {
+-		brcmf_err("Retreiving cur_etheraddr failed, %d\n", err);
++		brcmf_err("Retrieving cur_etheraddr failed, %d\n", err);
+ 		goto done;
+ 	}
+ 	memcpy(ifp->drvr->wiphy->perm_addr, ifp->drvr->mac, ETH_ALEN);
+@@ -269,7 +269,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	strcpy(buf, "ver");
+ 	err = brcmf_fil_iovar_data_get(ifp, "ver", buf, sizeof(buf));
+ 	if (err < 0) {
+-		brcmf_err("Retreiving version information failed, %d\n",
++		brcmf_err("Retrieving version information failed, %d\n",
+ 			  err);
+ 		goto done;
+ 	}
diff -uprN a/package/kernel/mac80211/patches/brcm/323-v5.0-0001-brcmutil-print-invalid-chanspec-when-WARN-ing.patch b/package/kernel/mac80211/patches/brcm/323-v5.0-0001-brcmutil-print-invalid-chanspec-when-WARN-ing.patch
--- a/package/kernel/mac80211/patches/brcm/323-v5.0-0001-brcmutil-print-invalid-chanspec-when-WARN-ing.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/323-v5.0-0001-brcmutil-print-invalid-chanspec-when-WARN-ing.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,83 @@
+From ae5848cb4511bbbfe0306fcdbe5d9a95cd9546a9 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 26 Oct 2018 13:22:32 +0200
+Subject: [PATCH] brcmutil: print invalid chanspec when WARN-ing
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+On one of my devices I got WARNINGs when brcmfmac tried to decode
+chanspec. I couldn't tell if it was some unsupported format or just a
+malformed value passed by a firmware.
+
+Print chanspec value so it's possible to debug a possible problem.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmutil/d11.c | 14 +++++++-------
+ 1 file changed, 7 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmutil/d11.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmutil/d11.c
+@@ -128,7 +128,7 @@ static void brcmu_d11n_decchspec(struct
+ 		}
+ 		break;
+ 	default:
+-		WARN_ON_ONCE(1);
++		WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 		break;
+ 	}
+ 
+@@ -140,7 +140,7 @@ static void brcmu_d11n_decchspec(struct
+ 		ch->band = BRCMU_CHAN_BAND_2G;
+ 		break;
+ 	default:
+-		WARN_ON_ONCE(1);
++		WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 		break;
+ 	}
+ }
+@@ -167,7 +167,7 @@ static void brcmu_d11ac_decchspec(struct
+ 			ch->sb = BRCMU_CHAN_SB_U;
+ 			ch->control_ch_num += CH_10MHZ_APART;
+ 		} else {
+-			WARN_ON_ONCE(1);
++			WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 		}
+ 		break;
+ 	case BRCMU_CHSPEC_D11AC_BW_80:
+@@ -188,7 +188,7 @@ static void brcmu_d11ac_decchspec(struct
+ 			ch->control_ch_num += CH_30MHZ_APART;
+ 			break;
+ 		default:
+-			WARN_ON_ONCE(1);
++			WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 			break;
+ 		}
+ 		break;
+@@ -222,13 +222,13 @@ static void brcmu_d11ac_decchspec(struct
+ 			ch->control_ch_num += CH_70MHZ_APART;
+ 			break;
+ 		default:
+-			WARN_ON_ONCE(1);
++			WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 			break;
+ 		}
+ 		break;
+ 	case BRCMU_CHSPEC_D11AC_BW_8080:
+ 	default:
+-		WARN_ON_ONCE(1);
++		WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 		break;
+ 	}
+ 
+@@ -240,7 +240,7 @@ static void brcmu_d11ac_decchspec(struct
+ 		ch->band = BRCMU_CHAN_BAND_2G;
+ 		break;
+ 	default:
+-		WARN_ON_ONCE(1);
++		WARN_ONCE(1, "Invalid chanspec 0x%04x\n", ch->chspec);
+ 		break;
+ 	}
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/325-v5.0-brcmfmac-support-STA-info-struct-v7.patch b/package/kernel/mac80211/patches/brcm/325-v5.0-brcmfmac-support-STA-info-struct-v7.patch
--- a/package/kernel/mac80211/patches/brcm/325-v5.0-brcmfmac-support-STA-info-struct-v7.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/325-v5.0-brcmfmac-support-STA-info-struct-v7.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,80 @@
+From 4282ff17e557d319e1b988fa4f582792cfaf6fff Mon Sep 17 00:00:00 2001
+From: Dan Haab <riproute@gmail.com>
+Date: Fri, 9 Nov 2018 09:38:55 -0700
+Subject: [PATCH] brcmfmac: support STA info struct v7
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+The newest firmwares provide STA info using v7 of the struct. As v7
+isn't backward compatible, a union is needed.
+
+Even though brcmfmac does not use any of the new info it's important to
+provide the proper struct buffer. Without this change new firmwares will
+fallback to the very limited v3 instead of something in between such as
+v4.
+
+Signed-off-by: Dan Haab <dan.haab@luxul.com>
+Reviewed-by: Rafał Miłecki <rafal@milecki.pl>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/fwil_types.h  | 40 +++++++++++++++----
+ 1 file changed, 33 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
+@@ -176,6 +176,8 @@
+ 
+ #define BRCMF_VHT_CAP_MCS_MAP_NSS_MAX	8
+ 
++#define BRCMF_HE_CAP_MCS_MAP_NSS_MAX	8
++
+ /* MAX_CHUNK_LEN is the maximum length for data passing to firmware in each
+  * ioctl. It is relatively small because firmware has small maximum size input
+  * playload restriction for ioctls.
+@@ -601,13 +603,37 @@ struct brcmf_sta_info_le {
+ 	__le32 rx_pkts_retried;        /* # rx with retry bit set */
+ 	__le32 tx_rate_fallback;       /* lowest fallback TX rate */
+ 
+-	/* Fields valid for ver >= 5 */
+-	struct {
+-		__le32 count;					/* # rates in this set */
+-		u8 rates[BRCMF_MAXRATES_IN_SET];		/* rates in 500kbps units w/hi bit set if basic */
+-		u8 mcs[BRCMF_MCSSET_LEN];			/* supported mcs index bit map */
+-		__le16 vht_mcs[BRCMF_VHT_CAP_MCS_MAP_NSS_MAX];	/* supported mcs index bit map per nss */
+-	} rateset_adv;
++	union {
++		struct {
++			struct {
++				__le32 count;					/* # rates in this set */
++				u8 rates[BRCMF_MAXRATES_IN_SET];		/* rates in 500kbps units w/hi bit set if basic */
++				u8 mcs[BRCMF_MCSSET_LEN];			/* supported mcs index bit map */
++				__le16 vht_mcs[BRCMF_VHT_CAP_MCS_MAP_NSS_MAX];	/* supported mcs index bit map per nss */
++			} rateset_adv;
++		} v5;
++
++		struct {
++			__le32 rx_dur_total;	/* total user RX duration (estimated) */
++			__le16 chanspec;	/** chanspec this sta is on */
++			__le16 pad_1;
++			struct {
++				__le16 version;					/* version */
++				__le16 len;					/* length */
++				__le32 count;					/* # rates in this set */
++				u8 rates[BRCMF_MAXRATES_IN_SET];		/* rates in 500kbps units w/hi bit set if basic */
++				u8 mcs[BRCMF_MCSSET_LEN];			/* supported mcs index bit map */
++				__le16 vht_mcs[BRCMF_VHT_CAP_MCS_MAP_NSS_MAX];	/* supported mcs index bit map per nss */
++				__le16 he_mcs[BRCMF_HE_CAP_MCS_MAP_NSS_MAX];	/* supported he mcs index bit map per nss */
++			} rateset_adv;		/* rateset along with mcs index bitmap */
++			__le16 wpauth;		/* authentication type */
++			u8 algo;		/* crypto algorithm */
++			u8 pad_2;
++			__le32 tx_rspec;	/* Rate of last successful tx frame */
++			__le32 rx_rspec;	/* Rate of last successful rx frame */
++			__le32 wnm_cap;		/* wnm capabilities */
++		} v7;
++	};
+ };
+ 
+ struct brcmf_chanspec_list {
diff -uprN a/package/kernel/mac80211/patches/brcm/326-v5.0-brcmfmac-Call-brcmf_dmi_probe-before-brcmf_of_probe.patch b/package/kernel/mac80211/patches/brcm/326-v5.0-brcmfmac-Call-brcmf_dmi_probe-before-brcmf_of_probe.patch
--- a/package/kernel/mac80211/patches/brcm/326-v5.0-brcmfmac-Call-brcmf_dmi_probe-before-brcmf_of_probe.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/326-v5.0-brcmfmac-Call-brcmf_dmi_probe-before-brcmf_of_probe.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,39 @@
+From 554da3868eb1d7174710c18b4ddd6ff01f6d612c Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Fri, 23 Nov 2018 10:11:48 +0100
+Subject: [PATCH] brcmfmac: Call brcmf_dmi_probe before brcmf_of_probe
+
+ARM systems with UEFI may have both devicetree (of) and DMI data in this
+case we end up setting brcmf_mp_device.board_type twice.
+
+In this case we should prefer the devicetree data, because:
+1) The devicerree data is more reliable
+2) Some ARM systems (e.g. the Raspberry Pi 3 models) support both UEFI and
+   classic uboot booting, the devicetree data is always there, so using it
+   makes sure we ask for the same nvram file independent of how we booted.
+
+This commit moves the brcmf_dmi_probe call to before the brcmf_of_probe
+call, so that the latter can override the value of the first if both are
+set.
+
+Fixes: bd1e82bb420a ("brcmfmac: Set board_type from DMI on x86 based ...")
+Cc: Peter Robinson <pbrobinson@gmail.com>
+Tested-and-reported-by: Peter Robinson <pbrobinson@gmail.com>
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -449,8 +449,8 @@ struct brcmf_mp_device *brcmf_get_module
+ 	}
+ 	if (!found) {
+ 		/* No platform data for this device, try OF and DMI data */
+-		brcmf_of_probe(dev, bus_type, settings);
+ 		brcmf_dmi_probe(settings, chip, chiprev);
++		brcmf_of_probe(dev, bus_type, settings);
+ 	}
+ 	return settings;
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/328-v5.0-0001-brcmfmac-add-credit-numbers-updating-support.patch b/package/kernel/mac80211/patches/brcm/328-v5.0-0001-brcmfmac-add-credit-numbers-updating-support.patch
--- a/package/kernel/mac80211/patches/brcm/328-v5.0-0001-brcmfmac-add-credit-numbers-updating-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/328-v5.0-0001-brcmfmac-add-credit-numbers-updating-support.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,95 @@
+From 153e22c0ff1260035cd7fe72c8aeead1f5fac757 Mon Sep 17 00:00:00 2001
+From: Wright Feng <Wright.Feng@cypress.com>
+Date: Mon, 5 Nov 2018 05:51:54 +0000
+Subject: [PATCH] brcmfmac: add credit numbers updating support
+
+The credit numbers are static and tunable per chip in firmware side.
+However the credit number may be changed that is based on packet pool
+length and will send BRCMF_E_FIFO_CREDIT_MAP event to notify host driver
+updates the credit numbers during interface up.
+The purpose of this patch is making host driver has ability of updating
+the credit numbers when receiving the BRCMF_E_FIFO_CREDIT_MAP event.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/fwsignal.c    | 23 ++++++++++++-------
+ 1 file changed, 15 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+@@ -511,6 +511,7 @@ struct brcmf_fws_info {
+ 	struct work_struct fws_dequeue_work;
+ 	u32 fifo_enqpkt[BRCMF_FWS_FIFO_COUNT];
+ 	int fifo_credit[BRCMF_FWS_FIFO_COUNT];
++	int init_fifo_credit[BRCMF_FWS_FIFO_COUNT];
+ 	int credits_borrowed[BRCMF_FWS_FIFO_AC_VO + 1];
+ 	int deq_node_pos[BRCMF_FWS_FIFO_COUNT];
+ 	u32 fifo_credit_map;
+@@ -1245,6 +1246,9 @@ static void brcmf_fws_return_credits(str
+ 	}
+ 
+ 	fws->fifo_credit[fifo] += credits;
++	if (fws->fifo_credit[fifo] > fws->init_fifo_credit[fifo])
++		fws->fifo_credit[fifo] = fws->init_fifo_credit[fifo];
++
+ }
+ 
+ static void brcmf_fws_schedule_deq(struct brcmf_fws_info *fws)
+@@ -1603,19 +1607,21 @@ static int brcmf_fws_notify_credit_map(s
+ 		brcmf_err("event payload too small (%d)\n", e->datalen);
+ 		return -EINVAL;
+ 	}
+-	if (fws->creditmap_received)
+-		return 0;
+ 
+ 	fws->creditmap_received = true;
+ 
+ 	brcmf_dbg(TRACE, "enter: credits %pM\n", credits);
+ 	brcmf_fws_lock(fws);
+ 	for (i = 0; i < ARRAY_SIZE(fws->fifo_credit); i++) {
+-		if (*credits)
++		fws->fifo_credit[i] += credits[i] - fws->init_fifo_credit[i];
++		fws->init_fifo_credit[i] = credits[i];
++		if (fws->fifo_credit[i] > 0)
+ 			fws->fifo_credit_map |= 1 << i;
+ 		else
+ 			fws->fifo_credit_map &= ~(1 << i);
+-		fws->fifo_credit[i] = *credits++;
++		WARN_ONCE(fws->fifo_credit[i] < 0,
++			  "fifo_credit[%d] is negative(%d)\n", i,
++			  fws->fifo_credit[i]);
+ 	}
+ 	brcmf_fws_schedule_deq(fws);
+ 	brcmf_fws_unlock(fws);
+@@ -2021,7 +2027,7 @@ static int brcmf_fws_borrow_credit(struc
+ 	}
+ 
+ 	for (lender_ac = 0; lender_ac <= BRCMF_FWS_FIFO_AC_VO; lender_ac++) {
+-		if (fws->fifo_credit[lender_ac]) {
++		if (fws->fifo_credit[lender_ac] > 0) {
+ 			fws->credits_borrowed[lender_ac]++;
+ 			fws->fifo_credit[lender_ac]--;
+ 			if (fws->fifo_credit[lender_ac] == 0)
+@@ -2220,8 +2226,9 @@ static void brcmf_fws_dequeue_worker(str
+ 			}
+ 			continue;
+ 		}
+-		while ((fws->fifo_credit[fifo]) || ((!fws->bcmc_credit_check) &&
+-		       (fifo == BRCMF_FWS_FIFO_BCMC))) {
++		while ((fws->fifo_credit[fifo] > 0) ||
++		       ((!fws->bcmc_credit_check) &&
++			(fifo == BRCMF_FWS_FIFO_BCMC))) {
+ 			skb = brcmf_fws_deq(fws, fifo);
+ 			if (!skb)
+ 				break;
+@@ -2232,7 +2239,7 @@ static void brcmf_fws_dequeue_worker(str
+ 				break;
+ 		}
+ 		if ((fifo == BRCMF_FWS_FIFO_AC_BE) &&
+-		    (fws->fifo_credit[fifo] == 0) &&
++		    (fws->fifo_credit[fifo] <= 0) &&
+ 		    (!fws->bus_flow_blocked)) {
+ 			while (brcmf_fws_borrow_credit(fws) == 0) {
+ 				skb = brcmf_fws_deq(fws, fifo);
diff -uprN a/package/kernel/mac80211/patches/brcm/328-v5.0-0002-brcmfmac-enable-frameburst-mode-in-default-firmware-.patch b/package/kernel/mac80211/patches/brcm/328-v5.0-0002-brcmfmac-enable-frameburst-mode-in-default-firmware-.patch
--- a/package/kernel/mac80211/patches/brcm/328-v5.0-0002-brcmfmac-enable-frameburst-mode-in-default-firmware-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/328-v5.0-0002-brcmfmac-enable-frameburst-mode-in-default-firmware-.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,42 @@
+From a3bdc6deb60bf6be4405058ca49a686c4db08c39 Mon Sep 17 00:00:00 2001
+From: Wright Feng <Wright.Feng@cypress.com>
+Date: Mon, 5 Nov 2018 05:51:59 +0000
+Subject: [PATCH] brcmfmac: enable frameburst mode in default firmware setting
+
+The frameburst feature can enable per-packet framebursting in firmware
+side and get higher TX throughput in High Throughput(HT) mode. To enhance
+TX throughput, we enable frameburst mode in default firmware setting.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 6 ++++++
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h     | 1 +
+ 2 files changed, 7 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -6657,6 +6657,12 @@ static s32 brcmf_config_dongle(struct br
+ 
+ 	brcmf_configure_arp_nd_offload(ifp, true);
+ 
++	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_FAKEFRAG, 1);
++	if (err) {
++		brcmf_err("failed to set frameburst mode\n");
++		goto default_conf_out;
++	}
++
+ 	cfg->dongle_up = true;
+ default_conf_out:
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
+@@ -80,6 +80,7 @@
+ #define BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON	201
+ #define BRCMF_C_SET_ASSOC_PREFER		205
+ #define BRCMF_C_GET_VALID_CHANNELS		217
++#define BRCMF_C_SET_FAKEFRAG			219
+ #define BRCMF_C_GET_KEY_PRIMARY			235
+ #define BRCMF_C_SET_KEY_PRIMARY			236
+ #define BRCMF_C_SET_SCAN_PASSIVE_TIME		258
diff -uprN a/package/kernel/mac80211/patches/brcm/328-v5.0-0003-brcmfmac-handle-compressed-tx-status-signal.patch b/package/kernel/mac80211/patches/brcm/328-v5.0-0003-brcmfmac-handle-compressed-tx-status-signal.patch
--- a/package/kernel/mac80211/patches/brcm/328-v5.0-0003-brcmfmac-handle-compressed-tx-status-signal.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/328-v5.0-0003-brcmfmac-handle-compressed-tx-status-signal.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,229 @@
+From e4af3ffb43d50f070134aa1b40d5c3573f57deb1 Mon Sep 17 00:00:00 2001
+From: Chung-Hsien Hsu <stanley.hsu@cypress.com>
+Date: Mon, 5 Nov 2018 05:52:05 +0000
+Subject: [PATCH] brcmfmac: handle compressed tx status signal
+
+Firmware inform the driver about tx status by normal tx status signal
+or compressed tx status signal. This patch adds support to handle the
+compressed tx status signal.
+
+Signed-off-by: Chung-Hsien Hsu <stanley.hsu@cypress.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/fwsignal.c    | 121 ++++++++++--------
+ 1 file changed, 71 insertions(+), 50 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+@@ -1463,9 +1463,10 @@ static int brcmf_fws_txstatus_suppressed
+ 
+ static int
+ brcmf_fws_txs_process(struct brcmf_fws_info *fws, u8 flags, u32 hslot,
+-		      u32 genbit, u16 seq)
++		      u32 genbit, u16 seq, u8 compcnt)
+ {
+ 	u32 fifo;
++	u8 cnt = 0;
+ 	int ret;
+ 	bool remove_from_hanger = true;
+ 	struct sk_buff *skb;
+@@ -1476,60 +1477,71 @@ brcmf_fws_txs_process(struct brcmf_fws_i
+ 	brcmf_dbg(DATA, "flags %d\n", flags);
+ 
+ 	if (flags == BRCMF_FWS_TXSTATUS_DISCARD)
+-		fws->stats.txs_discard++;
++		fws->stats.txs_discard += compcnt;
+ 	else if (flags == BRCMF_FWS_TXSTATUS_CORE_SUPPRESS) {
+-		fws->stats.txs_supp_core++;
++		fws->stats.txs_supp_core += compcnt;
+ 		remove_from_hanger = false;
+ 	} else if (flags == BRCMF_FWS_TXSTATUS_FW_PS_SUPPRESS) {
+-		fws->stats.txs_supp_ps++;
++		fws->stats.txs_supp_ps += compcnt;
+ 		remove_from_hanger = false;
+ 	} else if (flags == BRCMF_FWS_TXSTATUS_FW_TOSSED)
+-		fws->stats.txs_tossed++;
++		fws->stats.txs_tossed += compcnt;
+ 	else if (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)
+-		fws->stats.txs_host_tossed++;
++		fws->stats.txs_host_tossed += compcnt;
+ 	else
+ 		brcmf_err("unexpected txstatus\n");
+ 
+-	ret = brcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,
+-				      remove_from_hanger);
+-	if (ret != 0) {
+-		brcmf_err("no packet in hanger slot: hslot=%d\n", hslot);
+-		return ret;
+-	}
++	while (cnt < compcnt) {
++		ret = brcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,
++					      remove_from_hanger);
++		if (ret != 0) {
++			brcmf_err("no packet in hanger slot: hslot=%d\n",
++				  hslot);
++			goto cont;
++		}
+ 
+-	skcb = brcmf_skbcb(skb);
+-	entry = skcb->mac;
+-	if (WARN_ON(!entry)) {
+-		brcmu_pkt_buf_free_skb(skb);
+-		return -EINVAL;
+-	}
+-	entry->transit_count--;
+-	if (entry->suppressed && entry->suppr_transit_count)
+-		entry->suppr_transit_count--;
+-
+-	brcmf_dbg(DATA, "%s flags %d htod %X seq %X\n", entry->name, flags,
+-		  skcb->htod, seq);
+-
+-	/* pick up the implicit credit from this packet */
+-	fifo = brcmf_skb_htod_tag_get_field(skb, FIFO);
+-	if ((fws->fcmode == BRCMF_FWS_FCMODE_IMPLIED_CREDIT) ||
+-	    (brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) ||
+-	    (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)) {
+-		brcmf_fws_return_credits(fws, fifo, 1);
+-		brcmf_fws_schedule_deq(fws);
+-	}
+-	brcmf_fws_macdesc_return_req_credit(skb);
++		skcb = brcmf_skbcb(skb);
++		entry = skcb->mac;
++		if (WARN_ON(!entry)) {
++			brcmu_pkt_buf_free_skb(skb);
++			goto cont;
++		}
++		entry->transit_count--;
++		if (entry->suppressed && entry->suppr_transit_count)
++			entry->suppr_transit_count--;
+ 
+-	ret = brcmf_proto_hdrpull(fws->drvr, false, skb, &ifp);
+-	if (ret) {
+-		brcmu_pkt_buf_free_skb(skb);
+-		return -EINVAL;
++		brcmf_dbg(DATA, "%s flags %d htod %X seq %X\n", entry->name,
++			  flags, skcb->htod, seq);
++
++		/* pick up the implicit credit from this packet */
++		fifo = brcmf_skb_htod_tag_get_field(skb, FIFO);
++		if (fws->fcmode == BRCMF_FWS_FCMODE_IMPLIED_CREDIT ||
++		    (brcmf_skb_if_flags_get_field(skb, REQ_CREDIT)) ||
++		    flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED) {
++			brcmf_fws_return_credits(fws, fifo, 1);
++			brcmf_fws_schedule_deq(fws);
++		}
++		brcmf_fws_macdesc_return_req_credit(skb);
++
++		ret = brcmf_proto_hdrpull(fws->drvr, false, skb, &ifp);
++		if (ret) {
++			brcmu_pkt_buf_free_skb(skb);
++			goto cont;
++		}
++		if (!remove_from_hanger)
++			ret = brcmf_fws_txstatus_suppressed(fws, fifo, skb,
++							    genbit, seq);
++		if (remove_from_hanger || ret)
++			brcmf_txfinalize(ifp, skb, true);
++
++cont:
++		hslot = (hslot + 1) & (BRCMF_FWS_TXSTAT_HSLOT_MASK >>
++				       BRCMF_FWS_TXSTAT_HSLOT_SHIFT);
++		if (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode))
++			seq = (seq + 1) & BRCMF_SKB_HTOD_SEQ_NR_MASK;
++
++		cnt++;
+ 	}
+-	if (!remove_from_hanger)
+-		ret = brcmf_fws_txstatus_suppressed(fws, fifo, skb,
+-						    genbit, seq);
+-	if (remove_from_hanger || ret)
+-		brcmf_txfinalize(ifp, skb, true);
+ 
+ 	return 0;
+ }
+@@ -1555,7 +1567,8 @@ static int brcmf_fws_fifocreditback_indi
+ 	return BRCMF_FWS_RET_OK_SCHEDULE;
+ }
+ 
+-static int brcmf_fws_txstatus_indicate(struct brcmf_fws_info *fws, u8 *data)
++static int brcmf_fws_txstatus_indicate(struct brcmf_fws_info *fws, u8 type,
++				       u8 *data)
+ {
+ 	__le32 status_le;
+ 	__le16 seq_le;
+@@ -1564,23 +1577,31 @@ static int brcmf_fws_txstatus_indicate(s
+ 	u32 genbit;
+ 	u8 flags;
+ 	u16 seq;
++	u8 compcnt;
++	u8 compcnt_offset = BRCMF_FWS_TYPE_TXSTATUS_LEN;
+ 
+-	fws->stats.txs_indicate++;
+ 	memcpy(&status_le, data, sizeof(status_le));
+ 	status = le32_to_cpu(status_le);
+ 	flags = brcmf_txstatus_get_field(status, FLAGS);
+ 	hslot = brcmf_txstatus_get_field(status, HSLOT);
+ 	genbit = brcmf_txstatus_get_field(status, GENERATION);
+ 	if (BRCMF_FWS_MODE_GET_REUSESEQ(fws->mode)) {
+-		memcpy(&seq_le, &data[BRCMF_FWS_TYPE_PKTTAG_LEN],
++		memcpy(&seq_le, &data[BRCMF_FWS_TYPE_TXSTATUS_LEN],
+ 		       sizeof(seq_le));
+ 		seq = le16_to_cpu(seq_le);
++		compcnt_offset += BRCMF_FWS_TYPE_SEQ_LEN;
+ 	} else {
+ 		seq = 0;
+ 	}
+ 
++	if (type == BRCMF_FWS_TYPE_COMP_TXSTATUS)
++		compcnt = data[compcnt_offset];
++	else
++		compcnt = 1;
++	fws->stats.txs_indicate += compcnt;
++
+ 	brcmf_fws_lock(fws);
+-	brcmf_fws_txs_process(fws, flags, hslot, genbit, seq);
++	brcmf_fws_txs_process(fws, flags, hslot, genbit, seq, compcnt);
+ 	brcmf_fws_unlock(fws);
+ 	return BRCMF_FWS_RET_OK_NOSCHEDULE;
+ }
+@@ -1896,8 +1917,6 @@ void brcmf_fws_hdrpull(struct brcmf_if *
+ 
+ 		err = BRCMF_FWS_RET_OK_NOSCHEDULE;
+ 		switch (type) {
+-		case BRCMF_FWS_TYPE_COMP_TXSTATUS:
+-			break;
+ 		case BRCMF_FWS_TYPE_HOST_REORDER_RXPKTS:
+ 			rd = (struct brcmf_skb_reorder_data *)skb->cb;
+ 			rd->reorder = data;
+@@ -1920,7 +1939,8 @@ void brcmf_fws_hdrpull(struct brcmf_if *
+ 			err = brcmf_fws_request_indicate(fws, type, data);
+ 			break;
+ 		case BRCMF_FWS_TYPE_TXSTATUS:
+-			brcmf_fws_txstatus_indicate(fws, data);
++		case BRCMF_FWS_TYPE_COMP_TXSTATUS:
++			brcmf_fws_txstatus_indicate(fws, type, data);
+ 			break;
+ 		case BRCMF_FWS_TYPE_FIFO_CREDITBACK:
+ 			err = brcmf_fws_fifocreditback_indicate(fws, data);
+@@ -2009,7 +2029,7 @@ static void brcmf_fws_rollback_toq(struc
+ 		fws->stats.rollback_failed++;
+ 		hslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);
+ 		brcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED,
+-				      hslot, 0, 0);
++				      hslot, 0, 0, 1);
+ 	} else {
+ 		fws->stats.rollback_success++;
+ 		brcmf_fws_return_credits(fws, fifo, 1);
+@@ -2480,7 +2500,8 @@ void brcmf_fws_bustxfail(struct brcmf_fw
+ 	}
+ 	brcmf_fws_lock(fws);
+ 	hslot = brcmf_skb_htod_tag_get_field(skb, HSLOT);
+-	brcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED, hslot, 0, 0);
++	brcmf_fws_txs_process(fws, BRCMF_FWS_TXSTATUS_HOST_TOSSED, hslot, 0, 0,
++			      1);
+ 	brcmf_fws_unlock(fws);
+ }
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/329-v5.0-0001-brcmfmac-add-4354-raw-pcie-device-id.patch b/package/kernel/mac80211/patches/brcm/329-v5.0-0001-brcmfmac-add-4354-raw-pcie-device-id.patch
--- a/package/kernel/mac80211/patches/brcm/329-v5.0-0001-brcmfmac-add-4354-raw-pcie-device-id.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/329-v5.0-0001-brcmfmac-add-4354-raw-pcie-device-id.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,36 @@
+From eb6b33bfb8f56859df7264dccc2ca8ab7c57342a Mon Sep 17 00:00:00 2001
+From: Winnie Chang <winnie.chang@cypress.com>
+Date: Wed, 21 Nov 2018 07:53:42 +0000
+Subject: [PATCH] brcmfmac: add 4354 raw pcie device id
+
+Add the raw 4354 PCIe device ID for unprogrammed Cypress boards.
+
+Reviewed-by: Arend Van Spriel <arend@broadcom.com>
+Signed-off-by: Winnie Chang <winnie.chang@cypress.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c       | 1 +
+ drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h | 1 +
+ 2 files changed, 2 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -2019,6 +2019,7 @@ static const struct dev_pm_ops brcmf_pci
+ static const struct pci_device_id brcmf_pcie_devid_table[] = {
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_4350_DEVICE_ID),
+ 	BRCMF_PCIE_DEVICE_SUB(0x4355, BRCM_PCIE_VENDOR_ID_BROADCOM, 0x4355),
++	BRCMF_PCIE_DEVICE(BRCM_PCIE_4354_RAW_DEVICE_ID),
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_4356_DEVICE_ID),
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_43567_DEVICE_ID),
+ 	BRCMF_PCIE_DEVICE(BRCM_PCIE_43570_DEVICE_ID),
+--- a/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
++++ b/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
+@@ -74,6 +74,7 @@
+ /* PCIE Device IDs */
+ #define BRCM_PCIE_4350_DEVICE_ID	0x43a3
+ #define BRCM_PCIE_4354_DEVICE_ID	0x43df
++#define BRCM_PCIE_4354_RAW_DEVICE_ID	0x4354
+ #define BRCM_PCIE_4356_DEVICE_ID	0x43ec
+ #define BRCM_PCIE_43567_DEVICE_ID	0x43d3
+ #define BRCM_PCIE_43570_DEVICE_ID	0x43d9
diff -uprN a/package/kernel/mac80211/patches/brcm/329-v5.0-0004-brcmfmac-add-support-for-CYW43012-SDIO-chipset.patch b/package/kernel/mac80211/patches/brcm/329-v5.0-0004-brcmfmac-add-support-for-CYW43012-SDIO-chipset.patch
--- a/package/kernel/mac80211/patches/brcm/329-v5.0-0004-brcmfmac-add-support-for-CYW43012-SDIO-chipset.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/329-v5.0-0004-brcmfmac-add-support-for-CYW43012-SDIO-chipset.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,253 @@
+From 35cb51b2162a1a7c5cd977f92595e60ab14d3b22 Mon Sep 17 00:00:00 2001
+From: Chi-Hsien Lin <Chi-Hsien.Lin@cypress.com>
+Date: Wed, 21 Nov 2018 07:53:47 +0000
+Subject: [PATCH] brcmfmac: add support for CYW43012 SDIO chipset
+
+CYW43012 is a 1x1 802.11a/b/g/n Dual-Band HT20, 256-QAM/Turbo QAM. It
+is an Ultra Low Power WLAN+BT combo chip.
+
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Praveen Babu C <praveen.chandran@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/bcmsdh.c      |  1 +
+ .../broadcom/brcm80211/brcmfmac/chip.c        | 14 +++-
+ .../broadcom/brcm80211/brcmfmac/sdio.c        | 74 ++++++++++++++++---
+ .../broadcom/brcm80211/include/brcm_hw_ids.h  |  1 +
+ include/linux/mmc/sdio_ids.h                  |  1 +
+ 5 files changed, 78 insertions(+), 13 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+@@ -970,6 +970,7 @@ static const struct sdio_device_id brcmf
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4354),
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4356),
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_4373),
++	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_43012),
+ 	{ /* end: all zeroes */ }
+ };
+ MODULE_DEVICE_TABLE(sdio, brcmf_sdmmc_ids);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -165,6 +165,7 @@ struct sbconfig {
+ #define SRCI_LSS_MASK		0x00f00000
+ #define SRCI_LSS_SHIFT		20
+ #define	SRCI_SRNB_MASK		0xf0
++#define	SRCI_SRNB_MASK_EXT	0x100
+ #define	SRCI_SRNB_SHIFT		4
+ #define	SRCI_SRBSZ_MASK		0xf
+ #define	SRCI_SRBSZ_SHIFT	0
+@@ -592,7 +593,13 @@ static void brcmf_chip_socram_ramsize(st
+ 		if (lss != 0)
+ 			*ramsize += (1 << ((lss - 1) + SR_BSZ_BASE));
+ 	} else {
+-		nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
++		/* length of SRAM Banks increased for corerev greater than 23 */
++		if (sr->pub.rev >= 23) {
++			nb = (coreinfo & (SRCI_SRNB_MASK | SRCI_SRNB_MASK_EXT))
++				>> SRCI_SRNB_SHIFT;
++		} else {
++			nb = (coreinfo & SRCI_SRNB_MASK) >> SRCI_SRNB_SHIFT;
++		}
+ 		for (i = 0; i < nb; i++) {
+ 			retent = brcmf_chip_socram_banksize(sr, i, &banksize);
+ 			*ramsize += banksize;
+@@ -1356,6 +1363,11 @@ bool brcmf_chip_sr_capable(struct brcmf_
+ 		addr = CORE_CC_REG(base, sr_control1);
+ 		reg = chip->ops->read32(chip->ctx, addr);
+ 		return reg != 0;
++	case CY_CC_43012_CHIP_ID:
++		addr = CORE_CC_REG(pmu->base, retention_ctl);
++		reg = chip->ops->read32(chip->ctx, addr);
++		return (reg & (PMU_RCTL_MACPHY_DISABLE_MASK |
++			       PMU_RCTL_LOGIC_DISABLE_MASK)) == 0;
+ 	default:
+ 		addr = CORE_CC_REG(pmu->base, pmucapabilities_ext);
+ 		reg = chip->ops->read32(chip->ctx, addr);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -624,6 +624,7 @@ BRCMF_FW_DEF(43455, "brcmfmac43455-sdio"
+ BRCMF_FW_DEF(4354, "brcmfmac4354-sdio");
+ BRCMF_FW_DEF(4356, "brcmfmac4356-sdio");
+ BRCMF_FW_DEF(4373, "brcmfmac4373-sdio");
++BRCMF_FW_DEF(43012, "brcmfmac43012-sdio");
+ 
+ static const struct brcmf_firmware_mapping brcmf_sdio_fwnames[] = {
+ 	BRCMF_FW_ENTRY(BRCM_CC_43143_CHIP_ID, 0xFFFFFFFF, 43143),
+@@ -643,7 +644,8 @@ static const struct brcmf_firmware_mappi
+ 	BRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFFC0, 43455),
+ 	BRCMF_FW_ENTRY(BRCM_CC_4354_CHIP_ID, 0xFFFFFFFF, 4354),
+ 	BRCMF_FW_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),
+-	BRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373)
++	BRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373),
++	BRCMF_FW_ENTRY(CY_CC_43012_CHIP_ID, 0xFFFFFFFF, 43012)
+ };
+ 
+ static void pkt_align(struct sk_buff *p, int len, int align)
+@@ -683,6 +685,14 @@ brcmf_sdio_kso_control(struct brcmf_sdio
+ 	/* 1st KSO write goes to AOS wake up core if device is asleep  */
+ 	brcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_SLEEPCSR, wr_val, &err);
+ 
++	/* In case of 43012 chip, the chip could go down immediately after
++	 * KSO bit is cleared. So the further reads of KSO register could
++	 * fail. Thereby just bailing out immediately after clearing KSO
++	 * bit, to avoid polling of KSO bit.
++	 */
++	if (!on && bus->ci->chip == CY_CC_43012_CHIP_ID)
++		return err;
++
+ 	if (on) {
+ 		/* device WAKEUP through KSO:
+ 		 * write bit 0 & read back until
+@@ -2416,6 +2426,14 @@ static int brcmf_sdio_tx_ctrlframe(struc
+ 	return ret;
+ }
+ 
++static bool brcmf_chip_is_ulp(struct brcmf_chip *ci)
++{
++	if (ci->chip == CY_CC_43012_CHIP_ID)
++		return true;
++	else
++		return false;
++}
++
+ static void brcmf_sdio_bus_stop(struct device *dev)
+ {
+ 	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
+@@ -2423,7 +2441,7 @@ static void brcmf_sdio_bus_stop(struct d
+ 	struct brcmf_sdio *bus = sdiodev->bus;
+ 	struct brcmf_core *core = bus->sdio_core;
+ 	u32 local_hostintmask;
+-	u8 saveclk;
++	u8 saveclk, bpreq;
+ 	int err;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+@@ -2450,9 +2468,14 @@ static void brcmf_sdio_bus_stop(struct d
+ 		/* Force backplane clocks to assure F2 interrupt propagates */
+ 		saveclk = brcmf_sdiod_readb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
+ 					    &err);
+-		if (!err)
+-			brcmf_sdiod_writeb(sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
+-					   (saveclk | SBSDIO_FORCE_HT), &err);
++		if (!err) {
++			bpreq = saveclk;
++			bpreq |= brcmf_chip_is_ulp(bus->ci) ?
++				SBSDIO_HT_AVAIL_REQ : SBSDIO_FORCE_HT;
++			brcmf_sdiod_writeb(sdiodev,
++					   SBSDIO_FUNC1_CHIPCLKCSR,
++					   bpreq, &err);
++		}
+ 		if (err)
+ 			brcmf_err("Failed to force clock for F2: err %d\n",
+ 				  err);
+@@ -3345,20 +3368,45 @@ err:
+ 	return bcmerror;
+ }
+ 
++static bool brcmf_sdio_aos_no_decode(struct brcmf_sdio *bus)
++{
++	if (bus->ci->chip == CY_CC_43012_CHIP_ID)
++		return true;
++	else
++		return false;
++}
++
+ static void brcmf_sdio_sr_init(struct brcmf_sdio *bus)
+ {
+ 	int err = 0;
+ 	u8 val;
++	u8 wakeupctrl;
++	u8 cardcap;
++	u8 chipclkcsr;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+ 
++	if (brcmf_chip_is_ulp(bus->ci)) {
++		wakeupctrl = SBSDIO_FUNC1_WCTRL_ALPWAIT_SHIFT;
++		chipclkcsr = SBSDIO_HT_AVAIL_REQ;
++	} else {
++		wakeupctrl = SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT;
++		chipclkcsr = SBSDIO_FORCE_HT;
++	}
++
++	if (brcmf_sdio_aos_no_decode(bus)) {
++		cardcap = SDIO_CCCR_BRCM_CARDCAP_CMD_NODEC;
++	} else {
++		cardcap = (SDIO_CCCR_BRCM_CARDCAP_CMD14_SUPPORT |
++			   SDIO_CCCR_BRCM_CARDCAP_CMD14_EXT);
++	}
++
+ 	val = brcmf_sdiod_readb(bus->sdiodev, SBSDIO_FUNC1_WAKEUPCTRL, &err);
+ 	if (err) {
+ 		brcmf_err("error reading SBSDIO_FUNC1_WAKEUPCTRL\n");
+ 		return;
+ 	}
+-
+-	val |= 1 << SBSDIO_FUNC1_WCTRL_HTWAIT_SHIFT;
++	val |= 1 << wakeupctrl;
+ 	brcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_WAKEUPCTRL, val, &err);
+ 	if (err) {
+ 		brcmf_err("error writing SBSDIO_FUNC1_WAKEUPCTRL\n");
+@@ -3367,8 +3415,7 @@ static void brcmf_sdio_sr_init(struct br
+ 
+ 	/* Add CMD14 Support */
+ 	brcmf_sdiod_func0_wb(bus->sdiodev, SDIO_CCCR_BRCM_CARDCAP,
+-			     (SDIO_CCCR_BRCM_CARDCAP_CMD14_SUPPORT |
+-			      SDIO_CCCR_BRCM_CARDCAP_CMD14_EXT),
++			     cardcap,
+ 			     &err);
+ 	if (err) {
+ 		brcmf_err("error writing SDIO_CCCR_BRCM_CARDCAP\n");
+@@ -3376,7 +3423,7 @@ static void brcmf_sdio_sr_init(struct br
+ 	}
+ 
+ 	brcmf_sdiod_writeb(bus->sdiodev, SBSDIO_FUNC1_CHIPCLKCSR,
+-			   SBSDIO_FORCE_HT, &err);
++			   chipclkcsr, &err);
+ 	if (err) {
+ 		brcmf_err("error writing SBSDIO_FUNC1_CHIPCLKCSR\n");
+ 		return;
+@@ -4071,7 +4118,7 @@ static void brcmf_sdio_firmware_callback
+ 	const struct firmware *code;
+ 	void *nvram;
+ 	u32 nvram_len;
+-	u8 saveclk;
++	u8 saveclk, bpreq;
+ 	u8 devctl;
+ 
+ 	brcmf_dbg(TRACE, "Enter: dev=%s, err=%d\n", dev_name(dev), err);
+@@ -4105,8 +4152,11 @@ static void brcmf_sdio_firmware_callback
+ 	/* Force clocks on backplane to be sure F2 interrupt propagates */
+ 	saveclk = brcmf_sdiod_readb(sdiod, SBSDIO_FUNC1_CHIPCLKCSR, &err);
+ 	if (!err) {
++		bpreq = saveclk;
++		bpreq |= brcmf_chip_is_ulp(bus->ci) ?
++			SBSDIO_HT_AVAIL_REQ : SBSDIO_FORCE_HT;
+ 		brcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_CHIPCLKCSR,
+-				   (saveclk | SBSDIO_FORCE_HT), &err);
++				   bpreq, &err);
+ 	}
+ 	if (err) {
+ 		brcmf_err("Failed to force clock for F2: err %d\n", err);
+--- a/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
++++ b/drivers/net/wireless/broadcom/brcm80211/include/brcm_hw_ids.h
+@@ -60,6 +60,7 @@
+ #define BRCM_CC_43664_CHIP_ID		43664
+ #define BRCM_CC_4371_CHIP_ID		0x4371
+ #define CY_CC_4373_CHIP_ID		0x4373
++#define CY_CC_43012_CHIP_ID		43012
+ 
+ /* USB Device IDs */
+ #define BRCM_USB_43143_DEVICE_ID	0xbd1e
+--- a/include/linux/mmc/sdio_ids.h
++++ b/include/linux/mmc/sdio_ids.h
+@@ -42,6 +42,7 @@
+ #define SDIO_DEVICE_ID_BROADCOM_4354		0x4354
+ #define SDIO_DEVICE_ID_BROADCOM_4356		0x4356
+ #define SDIO_DEVICE_ID_CYPRESS_4373		0x4373
++#define SDIO_DEVICE_ID_CYPRESS_43012		43012
+ 
+ #define SDIO_VENDOR_ID_INTEL			0x0089
+ #define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
diff -uprN a/package/kernel/mac80211/patches/brcm/329-v5.0-0005-brcmfmac-allow-GCI-core-enumuration.patch b/package/kernel/mac80211/patches/brcm/329-v5.0-0005-brcmfmac-allow-GCI-core-enumuration.patch
--- a/package/kernel/mac80211/patches/brcm/329-v5.0-0005-brcmfmac-allow-GCI-core-enumuration.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/329-v5.0-0005-brcmfmac-allow-GCI-core-enumuration.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,60 @@
+From b021a6bc1175442609af0b66d64f850883e155fb Mon Sep 17 00:00:00 2001
+From: Chi-Hsien Lin <Chi-Hsien.Lin@cypress.com>
+Date: Wed, 21 Nov 2018 07:53:48 +0000
+Subject: [PATCH] brcmfmac: allow GCI core enumuration
+
+GCI core is needed for ULP operation. Allow GCI core enumuration with
+below changes:
+ - Allow GCI to be added to core list even when it doesn't have a wrapper.
+ - Allow 8K address space size.
+ - Don't overwrite the address value when an additional size descriptor
+   is in place.
+
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/chip.c    | 14 ++++++++------
+ 1 file changed, 8 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -786,7 +786,7 @@ static int brcmf_chip_dmp_get_regaddr(st
+ 				      u32 *regbase, u32 *wrapbase)
+ {
+ 	u8 desc;
+-	u32 val;
++	u32 val, szdesc;
+ 	u8 mpnum = 0;
+ 	u8 stype, sztype, wraptype;
+ 
+@@ -832,14 +832,15 @@ static int brcmf_chip_dmp_get_regaddr(st
+ 
+ 		/* next size descriptor can be skipped */
+ 		if (sztype == DMP_SLAVE_SIZE_DESC) {
+-			val = brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);
++			szdesc = brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);
+ 			/* skip upper size descriptor if present */
+-			if (val & DMP_DESC_ADDRSIZE_GT32)
++			if (szdesc & DMP_DESC_ADDRSIZE_GT32)
+ 				brcmf_chip_dmp_get_desc(ci, eromaddr, NULL);
+ 		}
+ 
+-		/* only look for 4K register regions */
+-		if (sztype != DMP_SLAVE_SIZE_4K)
++		/* look for 4K or 8K register regions */
++		if (sztype != DMP_SLAVE_SIZE_4K &&
++		    sztype != DMP_SLAVE_SIZE_8K)
+ 			continue;
+ 
+ 		stype = (val & DMP_SLAVE_TYPE) >> DMP_SLAVE_TYPE_S;
+@@ -896,7 +897,8 @@ int brcmf_chip_dmp_erom_scan(struct brcm
+ 
+ 		/* need core with ports */
+ 		if (nmw + nsw == 0 &&
+-		    id != BCMA_CORE_PMU)
++		    id != BCMA_CORE_PMU &&
++		    id != BCMA_CORE_GCI)
+ 			continue;
+ 
+ 		/* try to obtain register address info */
diff -uprN a/package/kernel/mac80211/patches/brcm/329-v5.0-0006-brcmfmac-update-43012-F2-watermark-setting-to-fix-DM.patch b/package/kernel/mac80211/patches/brcm/329-v5.0-0006-brcmfmac-update-43012-F2-watermark-setting-to-fix-DM.patch
--- a/package/kernel/mac80211/patches/brcm/329-v5.0-0006-brcmfmac-update-43012-F2-watermark-setting-to-fix-DM.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/329-v5.0-0006-brcmfmac-update-43012-F2-watermark-setting-to-fix-DM.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,49 @@
+From f95a8d9c6aca196f1ace5b2e53a3dd3bc491b1b3 Mon Sep 17 00:00:00 2001
+From: Naveen Gupta <naveen.gupta@cypress.com>
+Date: Wed, 21 Nov 2018 07:53:49 +0000
+Subject: [PATCH] brcmfmac: update 43012 F2 watermark setting to fix DMA Error
+ during UDP RX Traffic
+
+The number of words that the read FIFO has to contain except
+the end of frame before sends data back to the host.
+Max watermark = (512B - 2* (BurstLength))/4 =
+(512 - 128)/4 = 384/4 = 0x60
+so if burst length (i.e. BurstLength = 64) is increased,
+watermark has to be reduced. This is the optimal setting for this chip.
+
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Naveen Gupta <naveen.gupta@cypress.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/sdio.c  | 12 ++++++++++++
+ 1 file changed, 12 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -52,6 +52,7 @@
+ /* watermark expressed in number of words */
+ #define DEFAULT_F2_WATERMARK    0x8
+ #define CY_4373_F2_WATERMARK    0x40
++#define CY_43012_F2_WATERMARK    0x60
+ 
+ #ifdef DEBUG
+ 
+@@ -4193,6 +4194,17 @@ static void brcmf_sdio_firmware_callback
+ 					   CY_4373_F2_WATERMARK |
+ 					   SBSDIO_MESBUSYCTRL_ENAB, &err);
+ 			break;
++		case SDIO_DEVICE_ID_CYPRESS_43012:
++			brcmf_dbg(INFO, "set F2 watermark to 0x%x*4 bytes\n",
++				  CY_43012_F2_WATERMARK);
++			brcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,
++					   CY_43012_F2_WATERMARK, &err);
++			devctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,
++						   &err);
++			devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
++			brcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,
++					   &err);
++			break;
+ 		default:
+ 			brcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,
+ 					   DEFAULT_F2_WATERMARK, &err);
diff -uprN a/package/kernel/mac80211/patches/brcm/329-v5.0-0007-brcmfmac-4373-save-restore-support.patch b/package/kernel/mac80211/patches/brcm/329-v5.0-0007-brcmfmac-4373-save-restore-support.patch
--- a/package/kernel/mac80211/patches/brcm/329-v5.0-0007-brcmfmac-4373-save-restore-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/329-v5.0-0007-brcmfmac-4373-save-restore-support.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,57 @@
+From 2f2d389efda4caa4c1b69cb4fa2ab217f0fe6d6f Mon Sep 17 00:00:00 2001
+From: Chi-Hsien Lin <Chi-Hsien.Lin@cypress.com>
+Date: Wed, 21 Nov 2018 07:53:50 +0000
+Subject: [PATCH] brcmfmac: 4373 save-restore support
+
+Use chipcommon sr_control0 register to check 4373 sr support.
+
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/chip.c        |  5 +++++
+ .../broadcom/brcm80211/include/chipcommon.h   | 19 +++++++++++++++++++
+ 2 files changed, 24 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -1365,6 +1365,11 @@ bool brcmf_chip_sr_capable(struct brcmf_
+ 		addr = CORE_CC_REG(base, sr_control1);
+ 		reg = chip->ops->read32(chip->ctx, addr);
+ 		return reg != 0;
++	case CY_CC_4373_CHIP_ID:
++		/* explicitly check SR engine enable bit */
++		addr = CORE_CC_REG(base, sr_control0);
++		reg = chip->ops->read32(chip->ctx, addr);
++		return (reg & CC_SR_CTL0_ENABLE_MASK) != 0;
+ 	case CY_CC_43012_CHIP_ID:
+ 		addr = CORE_CC_REG(pmu->base, retention_ctl);
+ 		reg = chip->ops->read32(chip->ctx, addr);
+--- a/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
++++ b/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
+@@ -269,6 +269,25 @@ struct chipcregs {
+ /* GSIO (spi/i2c) present, rev >= 37 */
+ #define	CC_CAP2_GSIO		0x00000002
+ 
++/* sr_control0, rev >= 48 */
++#define CC_SR_CTL0_ENABLE_MASK			BIT(0)
++#define CC_SR_CTL0_ENABLE_SHIFT		0
++#define CC_SR_CTL0_EN_SR_ENG_CLK_SHIFT	1 /* sr_clk to sr_memory enable */
++#define CC_SR_CTL0_RSRC_TRIGGER_SHIFT	2 /* Rising edge resource trigger 0 to
++					   * sr_engine
++					   */
++#define CC_SR_CTL0_MIN_DIV_SHIFT	6 /* Min division value for fast clk
++					   * in sr_engine
++					   */
++#define CC_SR_CTL0_EN_SBC_STBY_SHIFT		16
++#define CC_SR_CTL0_EN_SR_ALP_CLK_MASK_SHIFT	18
++#define CC_SR_CTL0_EN_SR_HT_CLK_SHIFT		19
++#define CC_SR_CTL0_ALLOW_PIC_SHIFT	20 /* Allow pic to separate power
++					    * domains
++					    */
++#define CC_SR_CTL0_MAX_SR_LQ_CLK_CNT_SHIFT	25
++#define CC_SR_CTL0_EN_MEM_DISABLE_FOR_SLEEP	30
++
+ /* pmucapabilities */
+ #define PCAP_REV_MASK	0x000000ff
+ #define PCAP_RC_MASK	0x00001f00
diff -uprN a/package/kernel/mac80211/patches/brcm/329-v5.0-0008-brcmfmac-disable-command-decode-in-sdio_aos.patch b/package/kernel/mac80211/patches/brcm/329-v5.0-0008-brcmfmac-disable-command-decode-in-sdio_aos.patch
--- a/package/kernel/mac80211/patches/brcm/329-v5.0-0008-brcmfmac-disable-command-decode-in-sdio_aos.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/329-v5.0-0008-brcmfmac-disable-command-decode-in-sdio_aos.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,45 @@
+From 29f6589140a10ece8c1d73f58043ea5b3473ab3e Mon Sep 17 00:00:00 2001
+From: Wright Feng <wright.feng@cypress.com>
+Date: Wed, 21 Nov 2018 07:53:52 +0000
+Subject: [PATCH] brcmfmac: disable command decode in sdio_aos
+
+AOS is a part of the SDIOD core that becomes active when the rest of
+SDIOD is sleeping to keep SDIO bus alive responding to reduced set of
+commands.
+
+Transaction between AOS and SDIOD is not protected, and if cmd 52 is
+received in AOS and in the middle of response state changed from AOS to
+SDIOD, response is corrupted and it causes to SDIO Host controller to
+hang.
+
+Command decode for below chips are disabled in this commit:
+ - 4339
+ - 4345
+ - 4354
+ - 4373
+
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Signed-off-by: Double Lo <double.lo@cypress.com>
+Signed-off-by: Madhan Mohan R <madhanmohan.r@cypress.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -3371,7 +3371,11 @@ err:
+ 
+ static bool brcmf_sdio_aos_no_decode(struct brcmf_sdio *bus)
+ {
+-	if (bus->ci->chip == CY_CC_43012_CHIP_ID)
++	if (bus->ci->chip == CY_CC_43012_CHIP_ID ||
++	    bus->ci->chip == CY_CC_4373_CHIP_ID ||
++	    bus->ci->chip == BRCM_CC_4339_CHIP_ID ||
++	    bus->ci->chip == BRCM_CC_4345_CHIP_ID ||
++	    bus->ci->chip == BRCM_CC_4354_CHIP_ID)
+ 		return true;
+ 	else
+ 		return false;
diff -uprN a/package/kernel/mac80211/patches/brcm/330-v5.0-0001-brcmfmac-fix-false-positive-Wmaybe-unintialized-warn.patch b/package/kernel/mac80211/patches/brcm/330-v5.0-0001-brcmfmac-fix-false-positive-Wmaybe-unintialized-warn.patch
--- a/package/kernel/mac80211/patches/brcm/330-v5.0-0001-brcmfmac-fix-false-positive-Wmaybe-unintialized-warn.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/330-v5.0-0001-brcmfmac-fix-false-positive-Wmaybe-unintialized-warn.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,34 @@
+From 412dd15c8177d93abe0c8787b83b31c5eb061405 Mon Sep 17 00:00:00 2001
+From: Arnd Bergmann <arnd@arndb.de>
+Date: Mon, 10 Dec 2018 21:55:37 +0100
+Subject: [PATCH] brcmfmac: fix false-positive -Wmaybe-unintialized warning
+
+When CONFIG_NO_AUTO_INLINE is set, we get a false-postive warning
+for the brcmf_fw_request_nvram_done() function, after gcc figures
+out that brcmf_fw_nvram_from_efi() might not set the 'data_len'
+variable, but fails to notice that it always returns NULL:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c: In function 'brcmf_fw_request_nvram_done':
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c:560:11: error: 'data_len' may be used uninitialized in this function [-Werror=maybe-uninitialized]
+
+Mark it 'inline' to force gcc to understand this.
+
+Fixes: ce2e6db554fa ("brcmfmac: Add support for getting nvram contents from EFI variables")
+Signed-off-by: Arnd Bergmann <arnd@arndb.de>
+Reviewed-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -512,7 +512,7 @@ fail:
+ 	return NULL;
+ }
+ #else
+-static u8 *brcmf_fw_nvram_from_efi(size_t *data_len) { return NULL; }
++static inline u8 *brcmf_fw_nvram_from_efi(size_t *data_len) { return NULL; }
+ #endif
+ 
+ static void brcmf_fw_free_request(struct brcmf_fw_request *req)
diff -uprN a/package/kernel/mac80211/patches/brcm/340-v5.1-brcmfmac-Add-DMI-nvram-filename-quirk-for-PoV-TAB-P1.patch b/package/kernel/mac80211/patches/brcm/340-v5.1-brcmfmac-Add-DMI-nvram-filename-quirk-for-PoV-TAB-P1.patch
--- a/package/kernel/mac80211/patches/brcm/340-v5.1-brcmfmac-Add-DMI-nvram-filename-quirk-for-PoV-TAB-P1.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/340-v5.1-brcmfmac-Add-DMI-nvram-filename-quirk-for-PoV-TAB-P1.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,51 @@
+From 4d95f99c59b8b814bcf09ba86020d937ec7caa86 Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Thu, 20 Dec 2018 17:40:58 +0100
+Subject: [PATCH] brcmfmac: Add DMI nvram filename quirk for PoV TAB-P1006W-232
+ tablet
+
+The Point of View TAB-P1006W-232 tablet contains quite generic names in
+the sys_vendor and product_name DMI strings, without this patch brcmfmac
+will try to load: brcmfmac43340-sdio.Insyde-BayTrail.txt as nvram file
+which is a bit too generic.
+
+Add a DMI quirk so that a unique and clearly identifiable nvram file
+name is used on the PoV TAB-P1006W-232 tablet.
+
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/dmi.c    | 15 +++++++++++++++
+ 1 file changed, 15 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
+@@ -43,6 +43,10 @@ static const struct brcmf_dmi_data meego
+ 	BRCM_CC_43340_CHIP_ID, 2, "meegopad-t08"
+ };
+ 
++static const struct brcmf_dmi_data pov_tab_p1006w_data = {
++	BRCM_CC_43340_CHIP_ID, 2, "pov-tab-p1006w-data"
++};
++
+ static const struct dmi_system_id dmi_platform_data[] = {
+ 	{
+ 		/* Match for the GPDwin which unfortunately uses somewhat
+@@ -81,6 +85,17 @@ static const struct dmi_system_id dmi_pl
+ 		},
+ 		.driver_data = (void *)&meegopad_t08_data,
+ 	},
++	{
++		/* Point of View TAB-P1006W-232 */
++		.matches = {
++			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Insyde"),
++			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "BayTrail"),
++			/* Note 105b is Foxcon's USB/PCI vendor id */
++			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "105B"),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "0E57"),
++		},
++		.driver_data = (void *)&pov_tab_p1006w_data,
++	},
+ 	{}
+ };
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/341-v5.1-brcmfmac-add-a-check-for-the-status-of-usb_register.patch b/package/kernel/mac80211/patches/brcm/341-v5.1-brcmfmac-add-a-check-for-the-status-of-usb_register.patch
--- a/package/kernel/mac80211/patches/brcm/341-v5.1-brcmfmac-add-a-check-for-the-status-of-usb_register.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/341-v5.1-brcmfmac-add-a-check-for-the-status-of-usb_register.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,28 @@
+From 42daad3343be4a4e1ee03e30a5f5cc731dadfef5 Mon Sep 17 00:00:00 2001
+From: Kangjie Lu <kjlu@umn.edu>
+Date: Tue, 25 Dec 2018 19:22:24 -0600
+Subject: [PATCH] brcmfmac: add a check for the status of usb_register
+
+usb_register() may fail, so let's check its status and issue an error
+message if it fails.
+
+Signed-off-by: Kangjie Lu <kjlu@umn.edu>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -1558,6 +1558,10 @@ void brcmf_usb_exit(void)
+ 
+ void brcmf_usb_register(void)
+ {
++	int ret;
++
+ 	brcmf_dbg(USB, "Enter\n");
+-	usb_register(&brcmf_usbdrvr);
++	ret = usb_register(&brcmf_usbdrvr);
++	if (ret)
++		brcmf_err("usb_register failed %d\n", ret);
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/342-v5.1-brcmfmac-fix-system-warning-message-during-wowl-susp.patch b/package/kernel/mac80211/patches/brcm/342-v5.1-brcmfmac-fix-system-warning-message-during-wowl-susp.patch
--- a/package/kernel/mac80211/patches/brcm/342-v5.1-brcmfmac-fix-system-warning-message-during-wowl-susp.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/342-v5.1-brcmfmac-fix-system-warning-message-during-wowl-susp.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,33 @@
+From 3a33bd840523aaa06f4429fbfd38922bf0dc2e8d Mon Sep 17 00:00:00 2001
+From: Lo-Hsiang Lo <double.lo@cypress.com>
+Date: Mon, 7 Jan 2019 08:46:16 +0000
+Subject: [PATCH] brcmfmac: fix system warning message during wowl suspend
+
+There is a system warning message, warn_slowpath-fmt, during suspend
+while using supplicant join AP and enable wowl feature by IW command.
+It's caused by brcmf_pno_remove_request path can't find the reqid.
+This fix will not go to remove pno request function if there is no
+pno scan.
+
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Lo-Hsiang Lo <double.lo@cypress.com>
+Signed-off-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
+@@ -496,6 +496,11 @@ int brcmf_pno_stop_sched_scan(struct brc
+ 	brcmf_dbg(TRACE, "reqid=%llu\n", reqid);
+ 
+ 	pi = ifp_to_pno(ifp);
++
++	/* No PNO request */
++	if (!pi->n_reqs)
++		return 0;
++
+ 	err = brcmf_pno_remove_request(pi, reqid);
+ 	if (err)
+ 		return err;
diff -uprN a/package/kernel/mac80211/patches/brcm/344-v5.1-brcmfmac-modify-__brcmf_err-to-take-bus-as-a-paramet.patch b/package/kernel/mac80211/patches/brcm/344-v5.1-brcmfmac-modify-__brcmf_err-to-take-bus-as-a-paramet.patch
--- a/package/kernel/mac80211/patches/brcm/344-v5.1-brcmfmac-modify-__brcmf_err-to-take-bus-as-a-paramet.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/344-v5.1-brcmfmac-modify-__brcmf_err-to-take-bus-as-a-paramet.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,104 @@
+From 5cc898fbcb352b764f8d51c16e10e2eb0056173d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 6 Feb 2019 12:28:15 +0100
+Subject: [PATCH] brcmfmac: modify __brcmf_err() to take bus as a parameter
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+So far __brcmf_err() was using pr_err() which didn't allow identifying
+device that was affected by an error. It's crucial for systems with more
+than 1 device supported by brcmfmac (a common case for home routers).
+
+This change allows passing struct brcmf_bus to the __brcmf_err(). That
+struct has been agreed to be the most common one. It allows accessing
+struct device easily & using dev_err() printing helper.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/common.c    | 7 +++++--
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h | 8 +++++---
+ .../wireless/broadcom/brcm80211/brcmfmac/tracepoint.c    | 9 +++++++--
+ 3 files changed, 17 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -350,7 +350,7 @@ done:
+ }
+ 
+ #ifndef CPTCFG_BRCM_TRACING
+-void __brcmf_err(const char *func, const char *fmt, ...)
++void __brcmf_err(struct brcmf_bus *bus, const char *func, const char *fmt, ...)
+ {
+ 	struct va_format vaf;
+ 	va_list args;
+@@ -359,7 +359,10 @@ void __brcmf_err(const char *func, const
+ 
+ 	vaf.fmt = fmt;
+ 	vaf.va = &args;
+-	pr_err("%s: %pV", func, &vaf);
++	if (bus)
++		dev_err(bus->dev, "%s: %pV", func, &vaf);
++	else
++		pr_err("%s: %pV", func, &vaf);
+ 
+ 	va_end(args);
+ }
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+@@ -45,8 +45,10 @@
+ #undef pr_fmt
+ #define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
+ 
+-__printf(2, 3)
+-void __brcmf_err(const char *func, const char *fmt, ...);
++struct brcmf_bus;
++
++__printf(3, 4)
++void __brcmf_err(struct brcmf_bus *bus, const char *func, const char *fmt, ...);
+ /* Macro for error messages. When debugging / tracing the driver all error
+  * messages are important to us.
+  */
+@@ -55,7 +57,7 @@ void __brcmf_err(const char *func, const
+ 		if (IS_ENABLED(CPTCFG_BRCMDBG) ||			\
+ 		    IS_ENABLED(CPTCFG_BRCM_TRACING) ||			\
+ 		    net_ratelimit())					\
+-			__brcmf_err(__func__, fmt, ##__VA_ARGS__);	\
++			__brcmf_err(NULL, __func__, fmt, ##__VA_ARGS__);\
+ 	} while (0)
+ 
+ #if defined(DEBUG) || defined(CPTCFG_BRCM_TRACING)
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.c
+@@ -14,14 +14,16 @@
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
++#include <linux/device.h>
+ #include <linux/module.h> /* bug in tracepoint.h, it should include this */
+ 
+ #ifndef __CHECKER__
+ #define CREATE_TRACE_POINTS
++#include "bus.h"
+ #include "tracepoint.h"
+ #include "debug.h"
+ 
+-void __brcmf_err(const char *func, const char *fmt, ...)
++void __brcmf_err(struct brcmf_bus *bus, const char *func, const char *fmt, ...)
+ {
+ 	struct va_format vaf = {
+ 		.fmt = fmt,
+@@ -30,7 +32,10 @@ void __brcmf_err(const char *func, const
+ 
+ 	va_start(args, fmt);
+ 	vaf.va = &args;
+-	pr_err("%s: %pV", func, &vaf);
++	if (bus)
++		dev_err(bus->dev, "%s: %pV", func, &vaf);
++	else
++		pr_err("%s: %pV", func, &vaf);
+ 	trace_brcmf_err(func, &vaf);
+ 	va_end(args);
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/345-v5.1-brcmfmac-pass-bus-to-the-__brcmf_err-in-pcie.c.patch b/package/kernel/mac80211/patches/brcm/345-v5.1-brcmfmac-pass-bus-to-the-__brcmf_err-in-pcie.c.patch
--- a/package/kernel/mac80211/patches/brcm/345-v5.1-brcmfmac-pass-bus-to-the-__brcmf_err-in-pcie.c.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/345-v5.1-brcmfmac-pass-bus-to-the-__brcmf_err-in-pcie.c.patch	2022-04-04 20:20:32.947828000 +0800
@@ -0,0 +1,266 @@
+From 8602e62441aba276cafd68034b72162fbc5ca0a6 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 6 Feb 2019 12:28:16 +0100
+Subject: [PATCH] brcmfmac: pass bus to the __brcmf_err() in pcie.c
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This enables dev_err() usage (instead of pr_err()) in the __brcmf_err().
+It makes error messages more meaningful and is important for debugging
+errors/bugs on systems with multiple brcmfmac supported devices.
+
+All bus files should follow & get updated similarly (soon).
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/debug.h       |  2 +
+ .../broadcom/brcm80211/brcmfmac/pcie.c        | 59 +++++++++++--------
+ 2 files changed, 38 insertions(+), 23 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+@@ -52,6 +52,7 @@ void __brcmf_err(struct brcmf_bus *bus,
+ /* Macro for error messages. When debugging / tracing the driver all error
+  * messages are important to us.
+  */
++#ifndef brcmf_err
+ #define brcmf_err(fmt, ...)						\
+ 	do {								\
+ 		if (IS_ENABLED(CPTCFG_BRCMDBG) ||			\
+@@ -59,6 +60,7 @@ void __brcmf_err(struct brcmf_bus *bus,
+ 		    net_ratelimit())					\
+ 			__brcmf_err(NULL, __func__, fmt, ##__VA_ARGS__);\
+ 	} while (0)
++#endif
+ 
+ #if defined(DEBUG) || defined(CPTCFG_BRCM_TRACING)
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -30,6 +30,15 @@
+ #include <brcmu_wifi.h>
+ #include <brcm_hw_ids.h>
+ 
++/* Custom brcmf_err() that takes bus arg and passes it further */
++#define brcmf_err(bus, fmt, ...)					\
++	do {								\
++		if (IS_ENABLED(CPTCFG_BRCMDBG) ||			\
++		    IS_ENABLED(CPTCFG_BRCM_TRACING) ||			\
++		    net_ratelimit())					\
++			__brcmf_err(bus, __func__, fmt, ##__VA_ARGS__);	\
++	} while (0)
++
+ #include "debug.h"
+ #include "bus.h"
+ #include "commonring.h"
+@@ -531,6 +540,7 @@ static void
+ brcmf_pcie_select_core(struct brcmf_pciedev_info *devinfo, u16 coreid)
+ {
+ 	const struct pci_dev *pdev = devinfo->pdev;
++	struct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);
+ 	struct brcmf_core *core;
+ 	u32 bar0_win;
+ 
+@@ -548,7 +558,7 @@ brcmf_pcie_select_core(struct brcmf_pcie
+ 			}
+ 		}
+ 	} else {
+-		brcmf_err("Unsupported core selected %x\n", coreid);
++		brcmf_err(bus, "Unsupported core selected %x\n", coreid);
+ 	}
+ }
+ 
+@@ -848,9 +858,8 @@ static irqreturn_t brcmf_pcie_isr_thread
+ 
+ static int brcmf_pcie_request_irq(struct brcmf_pciedev_info *devinfo)
+ {
+-	struct pci_dev *pdev;
+-
+-	pdev = devinfo->pdev;
++	struct pci_dev *pdev = devinfo->pdev;
++	struct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);
+ 
+ 	brcmf_pcie_intr_disable(devinfo);
+ 
+@@ -861,7 +870,7 @@ static int brcmf_pcie_request_irq(struct
+ 				 brcmf_pcie_isr_thread, IRQF_SHARED,
+ 				 "brcmf_pcie_intr", devinfo)) {
+ 		pci_disable_msi(pdev);
+-		brcmf_err("Failed to request IRQ %d\n", pdev->irq);
++		brcmf_err(bus, "Failed to request IRQ %d\n", pdev->irq);
+ 		return -EIO;
+ 	}
+ 	devinfo->irq_allocated = true;
+@@ -871,15 +880,14 @@ static int brcmf_pcie_request_irq(struct
+ 
+ static void brcmf_pcie_release_irq(struct brcmf_pciedev_info *devinfo)
+ {
+-	struct pci_dev *pdev;
++	struct pci_dev *pdev = devinfo->pdev;
++	struct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);
+ 	u32 status;
+ 	u32 count;
+ 
+ 	if (!devinfo->irq_allocated)
+ 		return;
+ 
+-	pdev = devinfo->pdev;
+-
+ 	brcmf_pcie_intr_disable(devinfo);
+ 	free_irq(pdev->irq, devinfo);
+ 	pci_disable_msi(pdev);
+@@ -891,7 +899,7 @@ static void brcmf_pcie_release_irq(struc
+ 		count++;
+ 	}
+ 	if (devinfo->in_irq)
+-		brcmf_err("Still in IRQ (processing) !!!\n");
++		brcmf_err(bus, "Still in IRQ (processing) !!!\n");
+ 
+ 	status = brcmf_pcie_read_reg32(devinfo, BRCMF_PCIE_PCIE2REG_MAILBOXINT);
+ 	brcmf_pcie_write_reg32(devinfo, BRCMF_PCIE_PCIE2REG_MAILBOXINT, status);
+@@ -1102,6 +1110,7 @@ static void brcmf_pcie_release_ringbuffe
+ 
+ static int brcmf_pcie_init_ringbuffers(struct brcmf_pciedev_info *devinfo)
+ {
++	struct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);
+ 	struct brcmf_pcie_ringbuf *ring;
+ 	struct brcmf_pcie_ringbuf *rings;
+ 	u32 d2h_w_idx_ptr;
+@@ -1254,7 +1263,7 @@ static int brcmf_pcie_init_ringbuffers(s
+ 	return 0;
+ 
+ fail:
+-	brcmf_err("Allocating ring buffers failed\n");
++	brcmf_err(bus, "Allocating ring buffers failed\n");
+ 	brcmf_pcie_release_ringbuffers(devinfo);
+ 	return -ENOMEM;
+ }
+@@ -1277,6 +1286,7 @@ brcmf_pcie_release_scratchbuffers(struct
+ 
+ static int brcmf_pcie_init_scratchbuffers(struct brcmf_pciedev_info *devinfo)
+ {
++	struct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);
+ 	u64 address;
+ 	u32 addr;
+ 
+@@ -1316,7 +1326,7 @@ static int brcmf_pcie_init_scratchbuffer
+ 	return 0;
+ 
+ fail:
+-	brcmf_err("Allocating scratch buffers failed\n");
++	brcmf_err(bus, "Allocating scratch buffers failed\n");
+ 	brcmf_pcie_release_scratchbuffers(devinfo);
+ 	return -ENOMEM;
+ }
+@@ -1437,6 +1447,7 @@ static int
+ brcmf_pcie_init_share_ram_info(struct brcmf_pciedev_info *devinfo,
+ 			       u32 sharedram_addr)
+ {
++	struct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);
+ 	struct brcmf_pcie_shared_info *shared;
+ 	u32 addr;
+ 
+@@ -1448,7 +1459,8 @@ brcmf_pcie_init_share_ram_info(struct br
+ 	brcmf_dbg(PCIE, "PCIe protocol version %d\n", shared->version);
+ 	if ((shared->version > BRCMF_PCIE_MAX_SHARED_VERSION) ||
+ 	    (shared->version < BRCMF_PCIE_MIN_SHARED_VERSION)) {
+-		brcmf_err("Unsupported PCIE version %d\n", shared->version);
++		brcmf_err(bus, "Unsupported PCIE version %d\n",
++			  shared->version);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -1490,6 +1502,7 @@ static int brcmf_pcie_download_fw_nvram(
+ 					const struct firmware *fw, void *nvram,
+ 					u32 nvram_len)
+ {
++	struct brcmf_bus *bus = dev_get_drvdata(&devinfo->pdev->dev);
+ 	u32 sharedram_addr;
+ 	u32 sharedram_addr_written;
+ 	u32 loop_counter;
+@@ -1544,7 +1557,7 @@ static int brcmf_pcie_download_fw_nvram(
+ 		loop_counter--;
+ 	}
+ 	if (sharedram_addr == sharedram_addr_written) {
+-		brcmf_err("FW failed to initialize\n");
++		brcmf_err(bus, "FW failed to initialize\n");
+ 		return -ENODEV;
+ 	}
+ 	brcmf_dbg(PCIE, "Shared RAM addr: 0x%08x\n", sharedram_addr);
+@@ -1555,16 +1568,15 @@ static int brcmf_pcie_download_fw_nvram(
+ 
+ static int brcmf_pcie_get_resource(struct brcmf_pciedev_info *devinfo)
+ {
+-	struct pci_dev *pdev;
++	struct pci_dev *pdev = devinfo->pdev;
++	struct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);
+ 	int err;
+ 	phys_addr_t  bar0_addr, bar1_addr;
+ 	ulong bar1_size;
+ 
+-	pdev = devinfo->pdev;
+-
+ 	err = pci_enable_device(pdev);
+ 	if (err) {
+-		brcmf_err("pci_enable_device failed err=%d\n", err);
++		brcmf_err(bus, "pci_enable_device failed err=%d\n", err);
+ 		return err;
+ 	}
+ 
+@@ -1577,7 +1589,7 @@ static int brcmf_pcie_get_resource(struc
+ 	/* read Bar-1 mapped memory range */
+ 	bar1_size = pci_resource_len(pdev, 2);
+ 	if ((bar1_size == 0) || (bar1_addr == 0)) {
+-		brcmf_err("BAR1 Not enabled, device size=%ld, addr=%#016llx\n",
++		brcmf_err(bus, "BAR1 Not enabled, device size=%ld, addr=%#016llx\n",
+ 			  bar1_size, (unsigned long long)bar1_addr);
+ 		return -EINVAL;
+ 	}
+@@ -1586,7 +1598,7 @@ static int brcmf_pcie_get_resource(struc
+ 	devinfo->tcm = ioremap_nocache(bar1_addr, bar1_size);
+ 
+ 	if (!devinfo->regs || !devinfo->tcm) {
+-		brcmf_err("ioremap() failed (%p,%p)\n", devinfo->regs,
++		brcmf_err(bus, "ioremap() failed (%p,%p)\n", devinfo->regs,
+ 			  devinfo->tcm);
+ 		return -EINVAL;
+ 	}
+@@ -1873,7 +1885,7 @@ fail_bus:
+ 	kfree(bus->msgbuf);
+ 	kfree(bus);
+ fail:
+-	brcmf_err("failed %x:%x\n", pdev->vendor, pdev->device);
++	brcmf_err(NULL, "failed %x:%x\n", pdev->vendor, pdev->device);
+ 	brcmf_pcie_release_resource(devinfo);
+ 	if (devinfo->ci)
+ 		brcmf_chip_detach(devinfo->ci);
+@@ -1947,7 +1959,7 @@ static int brcmf_pcie_pm_enter_D3(struct
+ 	wait_event_timeout(devinfo->mbdata_resp_wait, devinfo->mbdata_completed,
+ 			   BRCMF_PCIE_MBDATA_TIMEOUT);
+ 	if (!devinfo->mbdata_completed) {
+-		brcmf_err("Timeout on response for entering D3 substate\n");
++		brcmf_err(bus, "Timeout on response for entering D3 substate\n");
+ 		brcmf_bus_change_state(bus, BRCMF_BUS_UP);
+ 		return -EIO;
+ 	}
+@@ -1993,7 +2005,7 @@ cleanup:
+ 
+ 	err = brcmf_pcie_probe(pdev, NULL);
+ 	if (err)
+-		brcmf_err("probe after resume failed, err=%d\n", err);
++		brcmf_err(bus, "probe after resume failed, err=%d\n", err);
+ 
+ 	return err;
+ }
+@@ -2066,7 +2078,8 @@ void brcmf_pcie_register(void)
+ 	brcmf_dbg(PCIE, "Enter\n");
+ 	err = pci_register_driver(&brcmf_pciedrvr);
+ 	if (err)
+-		brcmf_err("PCIE driver registration failed, err=%d\n", err);
++		brcmf_err(NULL, "PCIE driver registration failed, err=%d\n",
++			  err);
+ }
+ 
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/346-v5.1-brcmfmac-add-bphy_err-and-use-it-in-the-cfg80211.c.patch b/package/kernel/mac80211/patches/brcm/346-v5.1-brcmfmac-add-bphy_err-and-use-it-in-the-cfg80211.c.patch
--- a/package/kernel/mac80211/patches/brcm/346-v5.1-brcmfmac-add-bphy_err-and-use-it-in-the-cfg80211.c.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/346-v5.1-brcmfmac-add-bphy_err-and-use-it-in-the-cfg80211.c.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,2025 @@
+From 3ef005b82e2ad68107fc5814eaa743d171a6c362 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 16 Jan 2019 07:28:54 +0100
+Subject: [PATCH] brcmfmac: add bphy_err() and use it in the cfg80211.c
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This new macro uses wiphy_err() which:
+1) Should be the best choice with wiphy already created
+2) Uses dev_err() which allows identifying error-affected device
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 497 ++++++++++--------
+ .../broadcom/brcm80211/brcmfmac/debug.h       |   9 +
+ 2 files changed, 282 insertions(+), 224 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -457,6 +457,7 @@ static void convert_key_from_CPU(struct
+ static int
+ send_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	int err;
+ 	struct brcmf_wsec_key_le key_le;
+ 
+@@ -468,7 +469,7 @@ send_key_to_dongle(struct brcmf_if *ifp,
+ 					sizeof(key_le));
+ 
+ 	if (err)
+-		brcmf_err("wsec_key error (%d)\n", err);
++		bphy_err(wiphy, "wsec_key error (%d)\n", err);
+ 	return err;
+ }
+ 
+@@ -508,6 +509,7 @@ static int brcmf_get_first_free_bsscfgid
+ 
+ static int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_mbss_ssid_le mbss_ssid_le;
+ 	int bsscfgidx;
+ 	int err;
+@@ -524,7 +526,7 @@ static int brcmf_cfg80211_request_ap_if(
+ 	err = brcmf_fil_bsscfg_data_set(ifp, "bsscfg:ssid", &mbss_ssid_le,
+ 					sizeof(mbss_ssid_le));
+ 	if (err < 0)
+-		brcmf_err("setting ssid failed %d\n", err);
++		bphy_err(wiphy, "setting ssid failed %d\n", err);
+ 
+ 	return err;
+ }
+@@ -567,7 +569,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ 					    BRCMF_VIF_EVENT_TIMEOUT);
+ 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
+ 	if (!err) {
+-		brcmf_err("timeout occurred\n");
++		bphy_err(wiphy, "timeout occurred\n");
+ 		err = -EIO;
+ 		goto fail;
+ 	}
+@@ -575,7 +577,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ 	/* interface created in firmware */
+ 	ifp = vif->ifp;
+ 	if (!ifp) {
+-		brcmf_err("no if pointer provided\n");
++		bphy_err(wiphy, "no if pointer provided\n");
+ 		err = -ENOENT;
+ 		goto fail;
+ 	}
+@@ -583,7 +585,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ 	strncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);
+ 	err = brcmf_net_attach(ifp, true);
+ 	if (err) {
+-		brcmf_err("Registering netdevice failed\n");
++		bphy_err(wiphy, "Registering netdevice failed\n");
+ 		free_netdev(ifp->ndev);
+ 		goto fail;
+ 	}
+@@ -620,7 +622,7 @@ static struct wireless_dev *brcmf_cfg802
+ 	brcmf_dbg(TRACE, "enter: %s type %d\n", name, type);
+ 	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
+ 	if (err) {
+-		brcmf_err("iface validation failed: err=%d\n", err);
++		bphy_err(wiphy, "iface validation failed: err=%d\n", err);
+ 		return ERR_PTR(err);
+ 	}
+ 	switch (type) {
+@@ -645,8 +647,8 @@ static struct wireless_dev *brcmf_cfg802
+ 	}
+ 
+ 	if (IS_ERR(wdev))
+-		brcmf_err("add iface %s type %d failed: err=%d\n",
+-			  name, type, (int)PTR_ERR(wdev));
++		bphy_err(wiphy, "add iface %s type %d failed: err=%d\n", name,
++			 type, (int)PTR_ERR(wdev));
+ 	else
+ 		brcmf_cfg80211_update_proto_addr_mode(wdev);
+ 
+@@ -661,12 +663,13 @@ static void brcmf_scan_config_mpc(struct
+ 
+ void brcmf_set_mpc(struct brcmf_if *ifp, int mpc)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err = 0;
+ 
+ 	if (check_vif_up(ifp->vif)) {
+ 		err = brcmf_fil_iovar_int_set(ifp, "mpc", mpc);
+ 		if (err) {
+-			brcmf_err("fail to set mpc\n");
++			bphy_err(wiphy, "fail to set mpc\n");
+ 			return;
+ 		}
+ 		brcmf_dbg(INFO, "MPC : %d\n", mpc);
+@@ -677,6 +680,7 @@ s32 brcmf_notify_escan_complete(struct b
+ 				struct brcmf_if *ifp, bool aborted,
+ 				bool fw_abort)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_scan_params_le params_le;
+ 	struct cfg80211_scan_request *scan_request;
+ 	u64 reqid;
+@@ -711,7 +715,7 @@ s32 brcmf_notify_escan_complete(struct b
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,
+ 					     &params_le, sizeof(params_le));
+ 		if (err)
+-			brcmf_err("Scan abort failed\n");
++			bphy_err(wiphy, "Scan abort failed\n");
+ 	}
+ 
+ 	brcmf_scan_config_mpc(ifp, 1);
+@@ -763,7 +767,7 @@ static int brcmf_cfg80211_del_ap_iface(s
+ 
+ 	err = brcmf_fil_bsscfg_data_set(ifp, "interface_remove", NULL, 0);
+ 	if (err) {
+-		brcmf_err("interface_remove failed %d\n", err);
++		bphy_err(wiphy, "interface_remove failed %d\n", err);
+ 		goto err_unarm;
+ 	}
+ 
+@@ -771,7 +775,7 @@ static int brcmf_cfg80211_del_ap_iface(s
+ 	ret = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,
+ 					    BRCMF_VIF_EVENT_TIMEOUT);
+ 	if (!ret) {
+-		brcmf_err("timeout occurred\n");
++		bphy_err(wiphy, "timeout occurred\n");
+ 		err = -EIO;
+ 		goto err_unarm;
+ 	}
+@@ -873,14 +877,14 @@ brcmf_cfg80211_change_iface(struct wiphy
+ 	}
+ 	err = brcmf_vif_change_validate(wiphy_to_cfg(wiphy), vif, type);
+ 	if (err) {
+-		brcmf_err("iface validation failed: err=%d\n", err);
++		bphy_err(wiphy, "iface validation failed: err=%d\n", err);
+ 		return err;
+ 	}
+ 	switch (type) {
+ 	case NL80211_IFTYPE_MONITOR:
+ 	case NL80211_IFTYPE_WDS:
+-		brcmf_err("type (%d) : currently we do not support this type\n",
+-			  type);
++		bphy_err(wiphy, "type (%d) : currently we do not support this type\n",
++			 type);
+ 		return -EOPNOTSUPP;
+ 	case NL80211_IFTYPE_ADHOC:
+ 		infra = 0;
+@@ -908,7 +912,7 @@ brcmf_cfg80211_change_iface(struct wiphy
+ 	} else {
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, infra);
+ 		if (err) {
+-			brcmf_err("WLC_SET_INFRA error (%d)\n", err);
++			bphy_err(wiphy, "WLC_SET_INFRA error (%d)\n", err);
+ 			err = -EAGAIN;
+ 			goto done;
+ 		}
+@@ -999,6 +1003,7 @@ static s32
+ brcmf_run_escan(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp,
+ 		struct cfg80211_scan_request *request)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	s32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +
+ 			  offsetof(struct brcmf_escan_params_le, params_le);
+ 	struct brcmf_escan_params_le *params;
+@@ -1030,7 +1035,7 @@ brcmf_run_escan(struct brcmf_cfg80211_in
+ 		if (err == -EBUSY)
+ 			brcmf_dbg(INFO, "system busy : escan canceled\n");
+ 		else
+-			brcmf_err("error (%d)\n", err);
++			bphy_err(wiphy, "error (%d)\n", err);
+ 	}
+ 
+ 	kfree(params);
+@@ -1076,21 +1081,22 @@ brcmf_cfg80211_scan(struct wiphy *wiphy,
+ 		return -EIO;
+ 
+ 	if (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {
+-		brcmf_err("Scanning already: status (%lu)\n", cfg->scan_status);
++		bphy_err(wiphy, "Scanning already: status (%lu)\n",
++			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 	if (test_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status)) {
+-		brcmf_err("Scanning being aborted: status (%lu)\n",
+-			  cfg->scan_status);
++		bphy_err(wiphy, "Scanning being aborted: status (%lu)\n",
++			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 	if (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {
+-		brcmf_err("Scanning suppressed: status (%lu)\n",
+-			  cfg->scan_status);
++		bphy_err(wiphy, "Scanning suppressed: status (%lu)\n",
++			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 	if (test_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state)) {
+-		brcmf_err("Connecting: status (%lu)\n", vif->sme_state);
++		bphy_err(wiphy, "Connecting: status (%lu)\n", vif->sme_state);
+ 		return -EAGAIN;
+ 	}
+ 
+@@ -1124,7 +1130,7 @@ brcmf_cfg80211_scan(struct wiphy *wiphy,
+ 	return 0;
+ 
+ scan_out:
+-	brcmf_err("scan error (%d)\n", err);
++	bphy_err(wiphy, "scan error (%d)\n", err);
+ 	clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);
+ 	cfg->scan_request = NULL;
+ 	return err;
+@@ -1132,36 +1138,41 @@ scan_out:
+ 
+ static s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err = 0;
+ 
+-	err = brcmf_fil_iovar_int_set(netdev_priv(ndev), "rtsthresh",
+-				      rts_threshold);
++	err = brcmf_fil_iovar_int_set(ifp, "rtsthresh", rts_threshold);
+ 	if (err)
+-		brcmf_err("Error (%d)\n", err);
++		bphy_err(wiphy, "Error (%d)\n", err);
+ 
+ 	return err;
+ }
+ 
+ static s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err = 0;
+ 
+-	err = brcmf_fil_iovar_int_set(netdev_priv(ndev), "fragthresh",
++	err = brcmf_fil_iovar_int_set(ifp, "fragthresh",
+ 				      frag_threshold);
+ 	if (err)
+-		brcmf_err("Error (%d)\n", err);
++		bphy_err(wiphy, "Error (%d)\n", err);
+ 
+ 	return err;
+ }
+ 
+ static s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err = 0;
+ 	u32 cmd = (l ? BRCMF_C_SET_LRL : BRCMF_C_SET_SRL);
+ 
+-	err = brcmf_fil_cmd_int_set(netdev_priv(ndev), cmd, retry);
++	err = brcmf_fil_cmd_int_set(ifp, cmd, retry);
+ 	if (err) {
+-		brcmf_err("cmd (%d) , error (%d)\n", cmd, err);
++		bphy_err(wiphy, "cmd (%d) , error (%d)\n", cmd, err);
+ 		return err;
+ 	}
+ 	return err;
+@@ -1237,6 +1248,7 @@ static u16 brcmf_map_fw_linkdown_reason(
+ 
+ static int brcmf_set_pmk(struct brcmf_if *ifp, const u8 *pmk_data, u16 pmk_len)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_wsec_pmk_le pmk;
+ 	int i, err;
+ 
+@@ -1250,8 +1262,8 @@ static int brcmf_set_pmk(struct brcmf_if
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_WSEC_PMK,
+ 				     &pmk, sizeof(pmk));
+ 	if (err < 0)
+-		brcmf_err("failed to change PSK in firmware (len=%u)\n",
+-			  pmk_len);
++		bphy_err(wiphy, "failed to change PSK in firmware (len=%u)\n",
++			 pmk_len);
+ 
+ 	return err;
+ }
+@@ -1259,6 +1271,7 @@ static int brcmf_set_pmk(struct brcmf_if
+ static void brcmf_link_down(struct brcmf_cfg80211_vif *vif, u16 reason)
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	s32 err = 0;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+@@ -1268,7 +1281,7 @@ static void brcmf_link_down(struct brcmf
+ 		err = brcmf_fil_cmd_data_set(vif->ifp,
+ 					     BRCMF_C_DISASSOC, NULL, 0);
+ 		if (err) {
+-			brcmf_err("WLC_DISASSOC failed (%d)\n", err);
++			bphy_err(wiphy, "WLC_DISASSOC failed (%d)\n", err);
+ 		}
+ 		if ((vif->wdev.iftype == NL80211_IFTYPE_STATION) ||
+ 		    (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))
+@@ -1356,7 +1369,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 
+ 	err = brcmf_fil_iovar_int_set(ifp, "wsec", wsec);
+ 	if (err) {
+-		brcmf_err("wsec failed (%d)\n", err);
++		bphy_err(wiphy, "wsec failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1368,7 +1381,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);
+ 	if (err) {
+-		brcmf_err("WLC_SET_BCNPRD failed (%d)\n", err);
++		bphy_err(wiphy, "WLC_SET_BCNPRD failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1413,7 +1426,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,
+ 					    target_channel);
+ 		if (err) {
+-			brcmf_err("WLC_SET_CHANNEL failed (%d)\n", err);
++			bphy_err(wiphy, "WLC_SET_CHANNEL failed (%d)\n", err);
+ 			goto done;
+ 		}
+ 	} else
+@@ -1425,7 +1438,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 				     &join_params, join_params_size);
+ 	if (err) {
+-		brcmf_err("WLC_SET_SSID failed (%d)\n", err);
++		bphy_err(wiphy, "WLC_SET_SSID failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1461,6 +1474,8 @@ brcmf_cfg80211_leave_ibss(struct wiphy *
+ static s32 brcmf_set_wpa_version(struct net_device *ndev,
+ 				 struct cfg80211_connect_params *sme)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 val = 0;
+@@ -1473,9 +1488,9 @@ static s32 brcmf_set_wpa_version(struct
+ 	else
+ 		val = WPA_AUTH_DISABLED;
+ 	brcmf_dbg(CONN, "setting wpa_auth to 0x%0x\n", val);
+-	err = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "wpa_auth", val);
++	err = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", val);
+ 	if (err) {
+-		brcmf_err("set wpa_auth failed (%d)\n", err);
++		bphy_err(wiphy, "set wpa_auth failed (%d)\n", err);
+ 		return err;
+ 	}
+ 	sec = &profile->sec;
+@@ -1486,6 +1501,8 @@ static s32 brcmf_set_wpa_version(struct
+ static s32 brcmf_set_auth_type(struct net_device *ndev,
+ 			       struct cfg80211_connect_params *sme)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 val = 0;
+@@ -1506,9 +1523,9 @@ static s32 brcmf_set_auth_type(struct ne
+ 		break;
+ 	}
+ 
+-	err = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "auth", val);
++	err = brcmf_fil_bsscfg_int_set(ifp, "auth", val);
+ 	if (err) {
+-		brcmf_err("set auth failed (%d)\n", err);
++		bphy_err(wiphy, "set auth failed (%d)\n", err);
+ 		return err;
+ 	}
+ 	sec = &profile->sec;
+@@ -1520,6 +1537,8 @@ static s32
+ brcmf_set_wsec_mode(struct net_device *ndev,
+ 		    struct cfg80211_connect_params *sme)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 pval = 0;
+@@ -1543,8 +1562,8 @@ brcmf_set_wsec_mode(struct net_device *n
+ 			pval = AES_ENABLED;
+ 			break;
+ 		default:
+-			brcmf_err("invalid cipher pairwise (%d)\n",
+-				  sme->crypto.ciphers_pairwise[0]);
++			bphy_err(wiphy, "invalid cipher pairwise (%d)\n",
++				 sme->crypto.ciphers_pairwise[0]);
+ 			return -EINVAL;
+ 		}
+ 	}
+@@ -1564,8 +1583,8 @@ brcmf_set_wsec_mode(struct net_device *n
+ 			gval = AES_ENABLED;
+ 			break;
+ 		default:
+-			brcmf_err("invalid cipher group (%d)\n",
+-				  sme->crypto.cipher_group);
++			bphy_err(wiphy, "invalid cipher group (%d)\n",
++				 sme->crypto.cipher_group);
+ 			return -EINVAL;
+ 		}
+ 	}
+@@ -1578,9 +1597,9 @@ brcmf_set_wsec_mode(struct net_device *n
+ 		pval = AES_ENABLED;
+ 
+ 	wsec = pval | gval;
+-	err = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "wsec", wsec);
++	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err) {
+-		brcmf_err("error (%d)\n", err);
++		bphy_err(wiphy, "error (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -1595,6 +1614,7 @@ static s32
+ brcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
+ 	s32 val;
+ 	s32 err;
+@@ -1613,7 +1633,7 @@ brcmf_set_key_mgmt(struct net_device *nd
+ 
+ 	err = brcmf_fil_bsscfg_int_get(netdev_priv(ndev), "wpa_auth", &val);
+ 	if (err) {
+-		brcmf_err("could not get wpa_auth (%d)\n", err);
++		bphy_err(wiphy, "could not get wpa_auth (%d)\n", err);
+ 		return err;
+ 	}
+ 	if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
+@@ -1627,8 +1647,8 @@ brcmf_set_key_mgmt(struct net_device *nd
+ 			val = WPA_AUTH_PSK;
+ 			break;
+ 		default:
+-			brcmf_err("invalid cipher group (%d)\n",
+-				  sme->crypto.cipher_group);
++			bphy_err(wiphy, "invalid cipher group (%d)\n",
++				 sme->crypto.cipher_group);
+ 			return -EINVAL;
+ 		}
+ 	} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {
+@@ -1650,8 +1670,8 @@ brcmf_set_key_mgmt(struct net_device *nd
+ 			val = WPA2_AUTH_PSK;
+ 			break;
+ 		default:
+-			brcmf_err("invalid cipher group (%d)\n",
+-				  sme->crypto.cipher_group);
++			bphy_err(wiphy, "invalid cipher group (%d)\n",
++				 sme->crypto.cipher_group);
+ 			return -EINVAL;
+ 		}
+ 	}
+@@ -1697,7 +1717,7 @@ skip_mfp_config:
+ 	brcmf_dbg(CONN, "setting wpa_auth to %d\n", val);
+ 	err = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "wpa_auth", val);
+ 	if (err) {
+-		brcmf_err("could not set wpa_auth (%d)\n", err);
++		bphy_err(wiphy, "could not set wpa_auth (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -1708,6 +1728,8 @@ static s32
+ brcmf_set_sharedkey(struct net_device *ndev,
+ 		    struct cfg80211_connect_params *sme)
+ {
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
+ 	struct brcmf_cfg80211_security *sec;
+ 	struct brcmf_wsec_key key;
+@@ -1734,7 +1756,7 @@ brcmf_set_sharedkey(struct net_device *n
+ 	key.len = (u32) sme->key_len;
+ 	key.index = (u32) sme->key_idx;
+ 	if (key.len > sizeof(key.data)) {
+-		brcmf_err("Too long key length (%u)\n", key.len);
++		bphy_err(wiphy, "Too long key length (%u)\n", key.len);
+ 		return -EINVAL;
+ 	}
+ 	memcpy(key.data, sme->key, key.len);
+@@ -1747,24 +1769,24 @@ brcmf_set_sharedkey(struct net_device *n
+ 		key.algo = CRYPTO_ALGO_WEP128;
+ 		break;
+ 	default:
+-		brcmf_err("Invalid algorithm (%d)\n",
+-			  sme->crypto.ciphers_pairwise[0]);
++		bphy_err(wiphy, "Invalid algorithm (%d)\n",
++			 sme->crypto.ciphers_pairwise[0]);
+ 		return -EINVAL;
+ 	}
+ 	/* Set the new key/index */
+ 	brcmf_dbg(CONN, "key length (%d) key index (%d) algo (%d)\n",
+ 		  key.len, key.index, key.algo);
+ 	brcmf_dbg(CONN, "key \"%s\"\n", key.data);
+-	err = send_key_to_dongle(netdev_priv(ndev), &key);
++	err = send_key_to_dongle(ifp, &key);
+ 	if (err)
+ 		return err;
+ 
+ 	if (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {
+ 		brcmf_dbg(CONN, "set auth_type to shared key\n");
+ 		val = WL_AUTH_SHARED_KEY;	/* shared key */
+-		err = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "auth", val);
++		err = brcmf_fil_bsscfg_int_set(ifp, "auth", val);
+ 		if (err)
+-			brcmf_err("set auth failed (%d)\n", err);
++			bphy_err(wiphy, "set auth failed (%d)\n", err);
+ 	}
+ 	return err;
+ }
+@@ -1784,6 +1806,7 @@ enum nl80211_auth_type brcmf_war_auth_ty
+ static void brcmf_set_join_pref(struct brcmf_if *ifp,
+ 				struct cfg80211_bss_selection *bss_select)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_join_pref_params join_pref_params[2];
+ 	enum nl80211_band band;
+ 	int err, i = 0;
+@@ -1822,7 +1845,7 @@ static void brcmf_set_join_pref(struct b
+ 	err = brcmf_fil_iovar_data_set(ifp, "join_pref", join_pref_params,
+ 				       sizeof(join_pref_params));
+ 	if (err)
+-		brcmf_err("Set join_pref error (%d)\n", err);
++		bphy_err(wiphy, "Set join_pref error (%d)\n", err);
+ }
+ 
+ static s32
+@@ -1849,7 +1872,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 		return -EIO;
+ 
+ 	if (!sme->ssid) {
+-		brcmf_err("Invalid ssid\n");
++		bphy_err(wiphy, "Invalid ssid\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+@@ -1878,7 +1901,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 	err = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,
+ 				    sme->ie, sme->ie_len);
+ 	if (err)
+-		brcmf_err("Set Assoc REQ IE Failed\n");
++		bphy_err(wiphy, "Set Assoc REQ IE Failed\n");
+ 	else
+ 		brcmf_dbg(TRACE, "Applied Vndr IEs for Assoc request\n");
+ 
+@@ -1899,32 +1922,32 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 
+ 	err = brcmf_set_wpa_version(ndev, sme);
+ 	if (err) {
+-		brcmf_err("wl_set_wpa_version failed (%d)\n", err);
++		bphy_err(wiphy, "wl_set_wpa_version failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	sme->auth_type = brcmf_war_auth_type(ifp, sme->auth_type);
+ 	err = brcmf_set_auth_type(ndev, sme);
+ 	if (err) {
+-		brcmf_err("wl_set_auth_type failed (%d)\n", err);
++		bphy_err(wiphy, "wl_set_auth_type failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = brcmf_set_wsec_mode(ndev, sme);
+ 	if (err) {
+-		brcmf_err("wl_set_set_cipher failed (%d)\n", err);
++		bphy_err(wiphy, "wl_set_set_cipher failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = brcmf_set_key_mgmt(ndev, sme);
+ 	if (err) {
+-		brcmf_err("wl_set_key_mgmt failed (%d)\n", err);
++		bphy_err(wiphy, "wl_set_key_mgmt failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = brcmf_set_sharedkey(ndev, sme);
+ 	if (err) {
+-		brcmf_err("brcmf_set_sharedkey failed (%d)\n", err);
++		bphy_err(wiphy, "brcmf_set_sharedkey failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1941,7 +1964,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 		/* enable firmware supplicant for this interface */
+ 		err = brcmf_fil_iovar_int_set(ifp, "sup_wpa", 1);
+ 		if (err < 0) {
+-			brcmf_err("failed to enable fw supplicant\n");
++			bphy_err(wiphy, "failed to enable fw supplicant\n");
+ 			goto done;
+ 		}
+ 	}
+@@ -2036,7 +2059,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 				     &join_params, join_params_size);
+ 	if (err)
+-		brcmf_err("BRCMF_C_SET_SSID failed (%d)\n", err);
++		bphy_err(wiphy, "BRCMF_C_SET_SSID failed (%d)\n", err);
+ 
+ done:
+ 	if (err)
+@@ -2067,7 +2090,7 @@ brcmf_cfg80211_disconnect(struct wiphy *
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_DISASSOC,
+ 				     &scbval, sizeof(scbval));
+ 	if (err)
+-		brcmf_err("error (%d)\n", err);
++		bphy_err(wiphy, "error (%d)\n", err);
+ 
+ 	brcmf_dbg(TRACE, "Exit\n");
+ 	return err;
+@@ -2094,7 +2117,7 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 	case NL80211_TX_POWER_LIMITED:
+ 	case NL80211_TX_POWER_FIXED:
+ 		if (mbm < 0) {
+-			brcmf_err("TX_POWER_FIXED - dbm is negative\n");
++			bphy_err(wiphy, "TX_POWER_FIXED - dbm is negative\n");
+ 			err = -EINVAL;
+ 			goto done;
+ 		}
+@@ -2104,7 +2127,7 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 		qdbm |= WL_TXPWR_OVERRIDE;
+ 		break;
+ 	default:
+-		brcmf_err("Unsupported type %d\n", type);
++		bphy_err(wiphy, "Unsupported type %d\n", type);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+@@ -2112,11 +2135,11 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 	disable = WL_RADIO_SW_DISABLE << 16;
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_RADIO, disable);
+ 	if (err)
+-		brcmf_err("WLC_SET_RADIO error (%d)\n", err);
++		bphy_err(wiphy, "WLC_SET_RADIO error (%d)\n", err);
+ 
+ 	err = brcmf_fil_iovar_int_set(ifp, "qtxpower", qdbm);
+ 	if (err)
+-		brcmf_err("qtxpower error (%d)\n", err);
++		bphy_err(wiphy, "qtxpower error (%d)\n", err);
+ 
+ done:
+ 	brcmf_dbg(TRACE, "Exit %d (qdbm)\n", qdbm & ~WL_TXPWR_OVERRIDE);
+@@ -2137,7 +2160,7 @@ brcmf_cfg80211_get_tx_power(struct wiphy
+ 
+ 	err = brcmf_fil_iovar_int_get(vif->ifp, "qtxpower", &qdbm);
+ 	if (err) {
+-		brcmf_err("error (%d)\n", err);
++		bphy_err(wiphy, "error (%d)\n", err);
+ 		goto done;
+ 	}
+ 	*dbm = (qdbm & ~WL_TXPWR_OVERRIDE) / 4;
+@@ -2163,7 +2186,7 @@ brcmf_cfg80211_config_default_key(struct
+ 
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		brcmf_err("WLC_GET_WSEC error (%d)\n", err);
++		bphy_err(wiphy, "WLC_GET_WSEC error (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -2173,7 +2196,7 @@ brcmf_cfg80211_config_default_key(struct
+ 		err = brcmf_fil_cmd_int_set(ifp,
+ 					    BRCMF_C_SET_KEY_PRIMARY, index);
+ 		if (err)
+-			brcmf_err("error (%d)\n", err);
++			bphy_err(wiphy, "error (%d)\n", err);
+ 	}
+ done:
+ 	brcmf_dbg(TRACE, "Exit\n");
+@@ -2237,7 +2260,7 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 
+ 	if (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {
+ 		/* we ignore this key index in this case */
+-		brcmf_err("invalid key index (%d)\n", key_idx);
++		bphy_err(wiphy, "invalid key index (%d)\n", key_idx);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -2246,7 +2269,7 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 					      mac_addr);
+ 
+ 	if (params->key_len > sizeof(key->data)) {
+-		brcmf_err("Too long key length (%u)\n", params->key_len);
++		bphy_err(wiphy, "Too long key length (%u)\n", params->key_len);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -2300,7 +2323,7 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 		brcmf_dbg(CONN, "WLAN_CIPHER_SUITE_CCMP\n");
+ 		break;
+ 	default:
+-		brcmf_err("Invalid cipher (0x%x)\n", params->cipher);
++		bphy_err(wiphy, "Invalid cipher (0x%x)\n", params->cipher);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+@@ -2311,13 +2334,13 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		brcmf_err("get wsec error (%d)\n", err);
++		bphy_err(wiphy, "get wsec error (%d)\n", err);
+ 		goto done;
+ 	}
+ 	wsec |= val;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err) {
+-		brcmf_err("set wsec error (%d)\n", err);
++		bphy_err(wiphy, "set wsec error (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -2348,7 +2371,7 @@ brcmf_cfg80211_get_key(struct wiphy *wip
+ 
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		brcmf_err("WLC_GET_WSEC error (%d)\n", err);
++		bphy_err(wiphy, "WLC_GET_WSEC error (%d)\n", err);
+ 		/* Ignore this error, may happen during DISASSOC */
+ 		err = -EAGAIN;
+ 		goto done;
+@@ -2369,7 +2392,7 @@ brcmf_cfg80211_get_key(struct wiphy *wip
+ 		params.cipher = WLAN_CIPHER_SUITE_AES_CMAC;
+ 		brcmf_dbg(CONN, "WLAN_CIPHER_SUITE_AES_CMAC\n");
+ 	} else  {
+-		brcmf_err("Invalid algo (0x%x)\n", wsec);
++		bphy_err(wiphy, "Invalid algo (0x%x)\n", wsec);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+@@ -2399,6 +2422,7 @@ brcmf_cfg80211_config_default_mgmt_key(s
+ static void
+ brcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err;
+ 	u8 key_idx;
+ 	struct brcmf_wsec_key *key;
+@@ -2415,18 +2439,18 @@ brcmf_cfg80211_reconfigure_wep(struct br
+ 
+ 	err = send_key_to_dongle(ifp, key);
+ 	if (err) {
+-		brcmf_err("Setting WEP key failed (%d)\n", err);
++		bphy_err(wiphy, "Setting WEP key failed (%d)\n", err);
+ 		return;
+ 	}
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		brcmf_err("get wsec error (%d)\n", err);
++		bphy_err(wiphy, "get wsec error (%d)\n", err);
+ 		return;
+ 	}
+ 	wsec |= WEP_ENABLED;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err)
+-		brcmf_err("set wsec error (%d)\n", err);
++		bphy_err(wiphy, "set wsec error (%d)\n", err);
+ }
+ 
+ static void brcmf_convert_sta_flags(u32 fw_sta_flags, struct station_info *si)
+@@ -2452,6 +2476,7 @@ static void brcmf_convert_sta_flags(u32
+ 
+ static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct {
+ 		__le32 len;
+ 		struct brcmf_bss_info_le bss_le;
+@@ -2467,7 +2492,7 @@ static void brcmf_fill_bss_param(struct
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO, buf,
+ 				     WL_BSS_INFO_MAX);
+ 	if (err) {
+-		brcmf_err("Failed to get bss info (%d)\n", err);
++		bphy_err(wiphy, "Failed to get bss info (%d)\n", err);
+ 		goto out_kfree;
+ 	}
+ 	si->filled |= BIT_ULL(NL80211_STA_INFO_BSS_PARAM);
+@@ -2489,6 +2514,7 @@ static s32
+ brcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,
+ 				struct station_info *sinfo)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_scb_val_le scbval;
+ 	struct brcmf_pktcnt_le pktcnt;
+ 	s32 err;
+@@ -2498,7 +2524,7 @@ brcmf_cfg80211_get_station_ibss(struct b
+ 	/* Get the current tx rate */
+ 	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);
+ 	if (err < 0) {
+-		brcmf_err("BRCMF_C_GET_RATE error (%d)\n", err);
++		bphy_err(wiphy, "BRCMF_C_GET_RATE error (%d)\n", err);
+ 		return err;
+ 	}
+ 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+@@ -2508,7 +2534,7 @@ brcmf_cfg80211_get_station_ibss(struct b
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,
+ 				     sizeof(scbval));
+ 	if (err) {
+-		brcmf_err("BRCMF_C_GET_RSSI error (%d)\n", err);
++		bphy_err(wiphy, "BRCMF_C_GET_RSSI error (%d)\n", err);
+ 		return err;
+ 	}
+ 	rssi = le32_to_cpu(scbval.val);
+@@ -2518,7 +2544,7 @@ brcmf_cfg80211_get_station_ibss(struct b
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,
+ 				     sizeof(pktcnt));
+ 	if (err) {
+-		brcmf_err("BRCMF_C_GET_GET_PKTCNTS error (%d)\n", err);
++		bphy_err(wiphy, "BRCMF_C_GET_GET_PKTCNTS error (%d)\n", err);
+ 		return err;
+ 	}
+ 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |
+@@ -2566,7 +2592,7 @@ brcmf_cfg80211_get_station(struct wiphy
+ 					       &sta_info_le,
+ 					       sizeof(sta_info_le));
+ 		if (err < 0) {
+-			brcmf_err("GET STA INFO failed, %d\n", err);
++			bphy_err(wiphy, "GET STA INFO failed, %d\n", err);
+ 			goto done;
+ 		}
+ 	}
+@@ -2635,7 +2661,8 @@ brcmf_cfg80211_get_station(struct wiphy
+ 			err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,
+ 						     &scb_val, sizeof(scb_val));
+ 			if (err) {
+-				brcmf_err("Could not get rssi (%d)\n", err);
++				bphy_err(wiphy, "Could not get rssi (%d)\n",
++					 err);
+ 				goto done;
+ 			} else {
+ 				rssi = le32_to_cpu(scb_val.val);
+@@ -2666,8 +2693,8 @@ brcmf_cfg80211_dump_station(struct wiphy
+ 					     &cfg->assoclist,
+ 					     sizeof(cfg->assoclist));
+ 		if (err) {
+-			brcmf_err("BRCMF_C_GET_ASSOCLIST unsupported, err=%d\n",
+-				  err);
++			bphy_err(wiphy, "BRCMF_C_GET_ASSOCLIST unsupported, err=%d\n",
++				 err);
+ 			cfg->assoclist.count = 0;
+ 			return -EOPNOTSUPP;
+ 		}
+@@ -2715,9 +2742,9 @@ brcmf_cfg80211_set_power_mgmt(struct wip
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, pm);
+ 	if (err) {
+ 		if (err == -ENODEV)
+-			brcmf_err("net_device is not ready yet\n");
++			bphy_err(wiphy, "net_device is not ready yet\n");
+ 		else
+-			brcmf_err("error (%d)\n", err);
++			bphy_err(wiphy, "error (%d)\n", err);
+ 	}
+ done:
+ 	brcmf_dbg(TRACE, "Exit\n");
+@@ -2740,7 +2767,7 @@ static s32 brcmf_inform_single_bss(struc
+ 	struct cfg80211_inform_bss bss_data = {};
+ 
+ 	if (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {
+-		brcmf_err("Bss info is larger than buffer. Discarding\n");
++		bphy_err(wiphy, "Bss info is larger than buffer. Discarding\n");
+ 		return 0;
+ 	}
+ 
+@@ -2799,6 +2826,7 @@ next_bss_le(struct brcmf_scan_results *l
+ 
+ static s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_scan_results *bss_list;
+ 	struct brcmf_bss_info_le *bi = NULL;	/* must be initialized */
+ 	s32 err = 0;
+@@ -2807,8 +2835,8 @@ static s32 brcmf_inform_bss(struct brcmf
+ 	bss_list = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;
+ 	if (bss_list->count != 0 &&
+ 	    bss_list->version != BRCMF_BSS_INFO_VERSION) {
+-		brcmf_err("Version %d != WL_BSS_INFO_VERSION\n",
+-			  bss_list->version);
++		bphy_err(wiphy, "Version %d != WL_BSS_INFO_VERSION\n",
++			 bss_list->version);
+ 		return -EOPNOTSUPP;
+ 	}
+ 	brcmf_dbg(SCAN, "scanned AP count (%d)\n", bss_list->count);
+@@ -2852,7 +2880,7 @@ static s32 brcmf_inform_ibss(struct brcm
+ 	err = brcmf_fil_cmd_data_get(netdev_priv(ndev), BRCMF_C_GET_BSS_INFO,
+ 				     buf, WL_BSS_INFO_MAX);
+ 	if (err) {
+-		brcmf_err("WLC_GET_BSS_INFO failed: %d\n", err);
++		bphy_err(wiphy, "WLC_GET_BSS_INFO failed: %d\n", err);
+ 		goto CleanUp;
+ 	}
+ 
+@@ -2906,6 +2934,7 @@ CleanUp:
+ static s32 brcmf_update_bss_info(struct brcmf_cfg80211_info *cfg,
+ 				 struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_bss_info_le *bi;
+ 	const struct brcmf_tlv *tim;
+ 	u16 beacon_interval;
+@@ -2922,7 +2951,7 @@ static s32 brcmf_update_bss_info(struct
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,
+ 				     cfg->extra_buf, WL_EXTRA_BUF_MAX);
+ 	if (err) {
+-		brcmf_err("Could not get bss info %d\n", err);
++		bphy_err(wiphy, "Could not get bss info %d\n", err);
+ 		goto update_bss_info_out;
+ 	}
+ 
+@@ -2947,7 +2976,7 @@ static s32 brcmf_update_bss_info(struct
+ 		u32 var;
+ 		err = brcmf_fil_iovar_int_get(ifp, "dtim_assoc", &var);
+ 		if (err) {
+-			brcmf_err("wl dtim_assoc failed (%d)\n", err);
++			bphy_err(wiphy, "wl dtim_assoc failed (%d)\n", err);
+ 			goto update_bss_info_out;
+ 		}
+ 		dtim_period = (u8)var;
+@@ -2985,9 +3014,10 @@ static void brcmf_escan_timeout(struct t
+ {
+ 	struct brcmf_cfg80211_info *cfg =
+ 			from_timer(cfg, t, escan_timeout);
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 
+ 	if (cfg->int_escan_map || cfg->scan_request) {
+-		brcmf_err("timer expired\n");
++		bphy_err(wiphy, "timer expired\n");
+ 		schedule_work(&cfg->escan_timeout_work);
+ 	}
+ }
+@@ -3036,6 +3066,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 			     const struct brcmf_event_msg *e, void *data)
+ {
+ 	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	s32 status;
+ 	struct brcmf_escan_result_le *escan_result_le;
+ 	u32 escan_buflen;
+@@ -3052,32 +3083,33 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 		goto exit;
+ 
+ 	if (!test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {
+-		brcmf_err("scan not ready, bsscfgidx=%d\n", ifp->bsscfgidx);
++		bphy_err(wiphy, "scan not ready, bsscfgidx=%d\n",
++			 ifp->bsscfgidx);
+ 		return -EPERM;
+ 	}
+ 
+ 	if (status == BRCMF_E_STATUS_PARTIAL) {
+ 		brcmf_dbg(SCAN, "ESCAN Partial result\n");
+ 		if (e->datalen < sizeof(*escan_result_le)) {
+-			brcmf_err("invalid event data length\n");
++			bphy_err(wiphy, "invalid event data length\n");
+ 			goto exit;
+ 		}
+ 		escan_result_le = (struct brcmf_escan_result_le *) data;
+ 		if (!escan_result_le) {
+-			brcmf_err("Invalid escan result (NULL pointer)\n");
++			bphy_err(wiphy, "Invalid escan result (NULL pointer)\n");
+ 			goto exit;
+ 		}
+ 		escan_buflen = le32_to_cpu(escan_result_le->buflen);
+ 		if (escan_buflen > BRCMF_ESCAN_BUF_SIZE ||
+ 		    escan_buflen > e->datalen ||
+ 		    escan_buflen < sizeof(*escan_result_le)) {
+-			brcmf_err("Invalid escan buffer length: %d\n",
+-				  escan_buflen);
++			bphy_err(wiphy, "Invalid escan buffer length: %d\n",
++				 escan_buflen);
+ 			goto exit;
+ 		}
+ 		if (le16_to_cpu(escan_result_le->bss_count) != 1) {
+-			brcmf_err("Invalid bss_count %d: ignoring\n",
+-				  escan_result_le->bss_count);
++			bphy_err(wiphy, "Invalid bss_count %d: ignoring\n",
++				 escan_result_le->bss_count);
+ 			goto exit;
+ 		}
+ 		bss_info_le = &escan_result_le->bss_info_le;
+@@ -3092,8 +3124,8 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 
+ 		bi_length = le32_to_cpu(bss_info_le->length);
+ 		if (bi_length != escan_buflen -	WL_ESCAN_RESULTS_FIXED_SIZE) {
+-			brcmf_err("Ignoring invalid bss_info length: %d\n",
+-				  bi_length);
++			bphy_err(wiphy, "Ignoring invalid bss_info length: %d\n",
++				 bi_length);
+ 			goto exit;
+ 		}
+ 
+@@ -3101,7 +3133,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 					BIT(NL80211_IFTYPE_ADHOC))) {
+ 			if (le16_to_cpu(bss_info_le->capability) &
+ 						WLAN_CAPABILITY_IBSS) {
+-				brcmf_err("Ignoring IBSS result\n");
++				bphy_err(wiphy, "Ignoring IBSS result\n");
+ 				goto exit;
+ 			}
+ 		}
+@@ -3109,7 +3141,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 		list = (struct brcmf_scan_results *)
+ 				cfg->escan_info.escan_buf;
+ 		if (bi_length > BRCMF_ESCAN_BUF_SIZE - list->buflen) {
+-			brcmf_err("Buffer is too small: ignoring\n");
++			bphy_err(wiphy, "Buffer is too small: ignoring\n");
+ 			goto exit;
+ 		}
+ 
+@@ -3301,14 +3333,14 @@ brcmf_notify_sched_scan_results(struct b
+ 	WARN_ON(status != BRCMF_PNO_SCAN_COMPLETE);
+ 	brcmf_dbg(SCAN, "PFN NET FOUND event. count: %d\n", result_count);
+ 	if (!result_count) {
+-		brcmf_err("FALSE PNO Event. (pfn_count == 0)\n");
++		bphy_err(wiphy, "FALSE PNO Event. (pfn_count == 0)\n");
+ 		goto out_err;
+ 	}
+ 
+ 	netinfo_start = brcmf_get_netinfo_array(pfn_result);
+ 	datalen = e->datalen - ((void *)netinfo_start - (void *)pfn_result);
+ 	if (datalen < result_count * sizeof(*netinfo)) {
+-		brcmf_err("insufficient event data\n");
++		bphy_err(wiphy, "insufficient event data\n");
+ 		goto out_err;
+ 	}
+ 
+@@ -3362,8 +3394,8 @@ brcmf_cfg80211_sched_scan_start(struct w
+ 		  req->n_match_sets, req->n_ssids);
+ 
+ 	if (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {
+-		brcmf_err("Scanning suppressed: status=%lu\n",
+-			  cfg->scan_status);
++		bphy_err(wiphy, "Scanning suppressed: status=%lu\n",
++			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 
+@@ -3442,6 +3474,7 @@ brcmf_wowl_nd_results(struct brcmf_if *i
+ 		      void *data)
+ {
+ 	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_pno_scanresults_le *pfn_result;
+ 	struct brcmf_pno_net_info_le *netinfo;
+ 
+@@ -3460,8 +3493,8 @@ brcmf_wowl_nd_results(struct brcmf_if *i
+ 	}
+ 
+ 	if (le32_to_cpu(pfn_result->count) < 1) {
+-		brcmf_err("Invalid result count, expected 1 (%d)\n",
+-			  le32_to_cpu(pfn_result->count));
++		bphy_err(wiphy, "Invalid result count, expected 1 (%d)\n",
++			 le32_to_cpu(pfn_result->count));
+ 		return -EINVAL;
+ 	}
+ 
+@@ -3500,7 +3533,7 @@ static void brcmf_report_wowl_wakeind(st
+ 	err = brcmf_fil_iovar_data_get(ifp, "wowl_wakeind", &wake_ind_le,
+ 				       sizeof(wake_ind_le));
+ 	if (err) {
+-		brcmf_err("Get wowl_wakeind failed, err = %d\n", err);
++		bphy_err(wiphy, "Get wowl_wakeind failed, err = %d\n", err);
+ 		return;
+ 	}
+ 
+@@ -3541,7 +3574,7 @@ static void brcmf_report_wowl_wakeind(st
+ 				cfg->wowl.nd_data_completed,
+ 				BRCMF_ND_INFO_TIMEOUT);
+ 			if (!timeout)
+-				brcmf_err("No result for wowl net detect\n");
++				bphy_err(wiphy, "No result for wowl net detect\n");
+ 			else
+ 				wakeup_data.net_detect = cfg->wowl.nd_info;
+ 		}
+@@ -3749,7 +3782,7 @@ brcmf_cfg80211_set_pmksa(struct wiphy *w
+ 			cfg->pmk_list.npmk = cpu_to_le32(npmk);
+ 		}
+ 	} else {
+-		brcmf_err("Too many PMKSA entries cached %d\n", npmk);
++		bphy_err(wiphy, "Too many PMKSA entries cached %d\n", npmk);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -3795,7 +3828,7 @@ brcmf_cfg80211_del_pmksa(struct wiphy *w
+ 		memset(&pmk[i], 0, sizeof(*pmk));
+ 		cfg->pmk_list.npmk = cpu_to_le32(npmk - 1);
+ 	} else {
+-		brcmf_err("Cache entry not found\n");
++		bphy_err(wiphy, "Cache entry not found\n");
+ 		return -EINVAL;
+ 	}
+ 
+@@ -3827,19 +3860,20 @@ brcmf_cfg80211_flush_pmksa(struct wiphy
+ 
+ static s32 brcmf_configure_opensecurity(struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err;
+ 	s32 wpa_val;
+ 
+ 	/* set auth */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "auth", 0);
+ 	if (err < 0) {
+-		brcmf_err("auth error %d\n", err);
++		bphy_err(wiphy, "auth error %d\n", err);
+ 		return err;
+ 	}
+ 	/* set wsec */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", 0);
+ 	if (err < 0) {
+-		brcmf_err("wsec error %d\n", err);
++		bphy_err(wiphy, "wsec error %d\n", err);
+ 		return err;
+ 	}
+ 	/* set upper-layer auth */
+@@ -3849,7 +3883,7 @@ static s32 brcmf_configure_opensecurity(
+ 		wpa_val = WPA_AUTH_DISABLED;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", wpa_val);
+ 	if (err < 0) {
+-		brcmf_err("wpa_auth error %d\n", err);
++		bphy_err(wiphy, "wpa_auth error %d\n", err);
+ 		return err;
+ 	}
+ 
+@@ -3869,6 +3903,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 		      const struct brcmf_vs_tlv *wpa_ie,
+ 		      bool is_rsn_ie)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	u32 auth = 0; /* d11 open authentication */
+ 	u16 count;
+ 	s32 err = 0;
+@@ -3899,13 +3934,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* check for multicast cipher suite */
+ 	if (offset + WPA_IE_MIN_OUI_LEN > len) {
+ 		err = -EINVAL;
+-		brcmf_err("no multicast cipher suite\n");
++		bphy_err(wiphy, "no multicast cipher suite\n");
+ 		goto exit;
+ 	}
+ 
+ 	if (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+ 		err = -EINVAL;
+-		brcmf_err("ivalid OUI\n");
++		bphy_err(wiphy, "ivalid OUI\n");
+ 		goto exit;
+ 	}
+ 	offset += TLV_OUI_LEN;
+@@ -3927,7 +3962,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+-		brcmf_err("Invalid multi cast cipher info\n");
++		bphy_err(wiphy, "Invalid multi cast cipher info\n");
+ 		goto exit;
+ 	}
+ 
+@@ -3938,13 +3973,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* Check for unicast suite(s) */
+ 	if (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {
+ 		err = -EINVAL;
+-		brcmf_err("no unicast cipher suite\n");
++		bphy_err(wiphy, "no unicast cipher suite\n");
+ 		goto exit;
+ 	}
+ 	for (i = 0; i < count; i++) {
+ 		if (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+ 			err = -EINVAL;
+-			brcmf_err("ivalid OUI\n");
++			bphy_err(wiphy, "ivalid OUI\n");
+ 			goto exit;
+ 		}
+ 		offset += TLV_OUI_LEN;
+@@ -3962,7 +3997,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 			pval |= AES_ENABLED;
+ 			break;
+ 		default:
+-			brcmf_err("Invalid unicast security info\n");
++			bphy_err(wiphy, "Invalid unicast security info\n");
+ 		}
+ 		offset++;
+ 	}
+@@ -3972,13 +4007,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* Check for auth key management suite(s) */
+ 	if (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {
+ 		err = -EINVAL;
+-		brcmf_err("no auth key mgmt suite\n");
++		bphy_err(wiphy, "no auth key mgmt suite\n");
+ 		goto exit;
+ 	}
+ 	for (i = 0; i < count; i++) {
+ 		if (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+ 			err = -EINVAL;
+-			brcmf_err("ivalid OUI\n");
++			bphy_err(wiphy, "ivalid OUI\n");
+ 			goto exit;
+ 		}
+ 		offset += TLV_OUI_LEN;
+@@ -4006,7 +4041,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 			wpa_auth |= WPA2_AUTH_1X_SHA256;
+ 			break;
+ 		default:
+-			brcmf_err("Invalid key mgmt info\n");
++			bphy_err(wiphy, "Invalid key mgmt info\n");
+ 		}
+ 		offset++;
+ 	}
+@@ -4048,7 +4083,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 		err = brcmf_fil_bsscfg_int_set(ifp, "wme_bss_disable",
+ 					       wme_bss_disable);
+ 		if (err < 0) {
+-			brcmf_err("wme_bss_disable error %d\n", err);
++			bphy_err(wiphy, "wme_bss_disable error %d\n", err);
+ 			goto exit;
+ 		}
+ 
+@@ -4062,7 +4097,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 							&data[offset],
+ 							WPA_IE_MIN_OUI_LEN);
+ 			if (err < 0) {
+-				brcmf_err("bip error %d\n", err);
++				bphy_err(wiphy, "bip error %d\n", err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4073,13 +4108,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* set auth */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "auth", auth);
+ 	if (err < 0) {
+-		brcmf_err("auth error %d\n", err);
++		bphy_err(wiphy, "auth error %d\n", err);
+ 		goto exit;
+ 	}
+ 	/* set wsec */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err < 0) {
+-		brcmf_err("wsec error %d\n", err);
++		bphy_err(wiphy, "wsec error %d\n", err);
+ 		goto exit;
+ 	}
+ 	/* Configure MFP, this needs to go after wsec otherwise the wsec command
+@@ -4088,14 +4123,14 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP)) {
+ 		err = brcmf_fil_bsscfg_int_set(ifp, "mfp", mfp);
+ 		if (err < 0) {
+-			brcmf_err("mfp error %d\n", err);
++			bphy_err(wiphy, "mfp error %d\n", err);
+ 			goto exit;
+ 		}
+ 	}
+ 	/* set upper-layer auth */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", wpa_auth);
+ 	if (err < 0) {
+-		brcmf_err("wpa_auth error %d\n", err);
++		bphy_err(wiphy, "wpa_auth error %d\n", err);
+ 		goto exit;
+ 	}
+ 
+@@ -4182,6 +4217,7 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 			  const u8 *vndr_ie_buf, u32 vndr_ie_len)
+ {
+ 	struct brcmf_if *ifp;
++	struct wiphy *wiphy;
+ 	struct vif_saved_ie *saved_ie;
+ 	s32 err = 0;
+ 	u8  *iovar_ie_buf;
+@@ -4202,6 +4238,7 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 	if (!vif)
+ 		return -ENODEV;
+ 	ifp = vif->ifp;
++	wiphy = ifp->drvr->wiphy;
+ 	saved_ie = &vif->saved_ie;
+ 
+ 	brcmf_dbg(TRACE, "bsscfgidx %d, pktflag : 0x%02X\n", ifp->bsscfgidx,
+@@ -4233,13 +4270,13 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 		break;
+ 	default:
+ 		err = -EPERM;
+-		brcmf_err("not suitable type\n");
++		bphy_err(wiphy, "not suitable type\n");
+ 		goto exit;
+ 	}
+ 
+ 	if (vndr_ie_len > mgmt_ie_buf_len) {
+ 		err = -ENOMEM;
+-		brcmf_err("extra IE size too big\n");
++		bphy_err(wiphy, "extra IE size too big\n");
+ 		goto exit;
+ 	}
+ 
+@@ -4300,8 +4337,8 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 			/* verify remained buf size before copy data */
+ 			if (remained_buf_len < (vndrie_info->vndrie.len +
+ 							VNDR_IE_VSIE_OFFSET)) {
+-				brcmf_err("no space in mgmt_ie_buf: len left %d",
+-					  remained_buf_len);
++				bphy_err(wiphy, "no space in mgmt_ie_buf: len left %d",
++					 remained_buf_len);
+ 				break;
+ 			}
+ 			remained_buf_len -= (vndrie_info->ie_len +
+@@ -4332,7 +4369,7 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 		err  = brcmf_fil_bsscfg_data_set(ifp, "vndr_ie", iovar_ie_buf,
+ 						 total_ie_buf_len);
+ 		if (err)
+-			brcmf_err("vndr ie set error : %d\n", err);
++			bphy_err(wiphy, "vndr ie set error : %d\n", err);
+ 	}
+ 
+ exit:
+@@ -4360,13 +4397,14 @@ static s32
+ brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,
+ 			struct cfg80211_beacon_data *beacon)
+ {
++	struct wiphy *wiphy = vif->ifp->drvr->wiphy;
+ 	s32 err;
+ 
+ 	/* Set Beacon IEs to FW */
+ 	err = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_BEACON_FLAG,
+ 				    beacon->tail, beacon->tail_len);
+ 	if (err) {
+-		brcmf_err("Set Beacon IE Failed\n");
++		bphy_err(wiphy, "Set Beacon IE Failed\n");
+ 		return err;
+ 	}
+ 	brcmf_dbg(TRACE, "Applied Vndr IEs for Beacon\n");
+@@ -4376,7 +4414,7 @@ brcmf_config_ap_mgmt_ie(struct brcmf_cfg
+ 				    beacon->proberesp_ies,
+ 				    beacon->proberesp_ies_len);
+ 	if (err)
+-		brcmf_err("Set Probe Resp IE Failed\n");
++		bphy_err(wiphy, "Set Probe Resp IE Failed\n");
+ 	else
+ 		brcmf_dbg(TRACE, "Applied Vndr IEs for Probe Resp\n");
+ 
+@@ -4485,7 +4523,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
+ 						    is_11d);
+ 			if (err < 0) {
+-				brcmf_err("Regulatory Set Error, %d\n", err);
++				bphy_err(wiphy, "Regulatory Set Error, %d\n",
++					 err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4493,8 +4532,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,
+ 						    settings->beacon_interval);
+ 			if (err < 0) {
+-				brcmf_err("Beacon Interval Set Error, %d\n",
+-					  err);
++				bphy_err(wiphy, "Beacon Interval Set Error, %d\n",
++					 err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4502,7 +4541,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,
+ 						    settings->dtim_period);
+ 			if (err < 0) {
+-				brcmf_err("DTIM Interval Set Error, %d\n", err);
++				bphy_err(wiphy, "DTIM Interval Set Error, %d\n",
++					 err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4512,7 +4552,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 		     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
+ 			if (err < 0) {
+-				brcmf_err("BRCMF_C_DOWN error %d\n", err);
++				bphy_err(wiphy, "BRCMF_C_DOWN error %d\n",
++					 err);
+ 				goto exit;
+ 			}
+ 			brcmf_fil_iovar_int_set(ifp, "apsta", 0);
+@@ -4520,7 +4561,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);
+ 		if (err < 0) {
+-			brcmf_err("SET INFRA error %d\n", err);
++			bphy_err(wiphy, "SET INFRA error %d\n", err);
+ 			goto exit;
+ 		}
+ 	} else if (WARN_ON(supports_11d && (is_11d != ifp->vif->is_11d))) {
+@@ -4536,7 +4577,8 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);
+ 		if (err < 0) {
+-			brcmf_err("setting AP mode failed %d\n", err);
++			bphy_err(wiphy, "setting AP mode failed %d\n",
++				 err);
+ 			goto exit;
+ 		}
+ 		if (!mbss) {
+@@ -4545,14 +4587,14 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			 */
+ 			err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
+ 			if (err < 0) {
+-				brcmf_err("Set Channel failed: chspec=%d, %d\n",
+-					  chanspec, err);
++				bphy_err(wiphy, "Set Channel failed: chspec=%d, %d\n",
++					 chanspec, err);
+ 				goto exit;
+ 			}
+ 		}
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
+ 		if (err < 0) {
+-			brcmf_err("BRCMF_C_UP error (%d)\n", err);
++			bphy_err(wiphy, "BRCMF_C_UP error (%d)\n", err);
+ 			goto exit;
+ 		}
+ 		/* On DOWN the firmware removes the WEP keys, reconfigure
+@@ -4567,14 +4609,14 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 					     &join_params, sizeof(join_params));
+ 		if (err < 0) {
+-			brcmf_err("SET SSID error (%d)\n", err);
++			bphy_err(wiphy, "SET SSID error (%d)\n", err);
+ 			goto exit;
+ 		}
+ 
+ 		if (settings->hidden_ssid) {
+ 			err = brcmf_fil_iovar_int_set(ifp, "closednet", 1);
+ 			if (err) {
+-				brcmf_err("closednet error (%d)\n", err);
++				bphy_err(wiphy, "closednet error (%d)\n", err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4583,14 +4625,14 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 	} else if (dev_role == NL80211_IFTYPE_P2P_GO) {
+ 		err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
+ 		if (err < 0) {
+-			brcmf_err("Set Channel failed: chspec=%d, %d\n",
+-				  chanspec, err);
++			bphy_err(wiphy, "Set Channel failed: chspec=%d, %d\n",
++				 chanspec, err);
+ 			goto exit;
+ 		}
+ 		err = brcmf_fil_bsscfg_data_set(ifp, "ssid", &ssid_le,
+ 						sizeof(ssid_le));
+ 		if (err < 0) {
+-			brcmf_err("setting ssid failed %d\n", err);
++			bphy_err(wiphy, "setting ssid failed %d\n", err);
+ 			goto exit;
+ 		}
+ 		bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);
+@@ -4598,7 +4640,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 		err = brcmf_fil_iovar_data_set(ifp, "bss", &bss_enable,
+ 					       sizeof(bss_enable));
+ 		if (err < 0) {
+-			brcmf_err("bss_enable config failed %d\n", err);
++			bphy_err(wiphy, "bss_enable config failed %d\n", err);
+ 			goto exit;
+ 		}
+ 
+@@ -4646,13 +4688,13 @@ static int brcmf_cfg80211_stop_ap(struct
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 					     &join_params, sizeof(join_params));
+ 		if (err < 0)
+-			brcmf_err("SET SSID error (%d)\n", err);
++			bphy_err(wiphy, "SET SSID error (%d)\n", err);
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
+ 		if (err < 0)
+-			brcmf_err("BRCMF_C_DOWN error %d\n", err);
++			bphy_err(wiphy, "BRCMF_C_DOWN error %d\n", err);
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
+ 		if (err < 0)
+-			brcmf_err("setting AP mode failed %d\n", err);
++			bphy_err(wiphy, "setting AP mode failed %d\n", err);
+ 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))
+ 			brcmf_fil_iovar_int_set(ifp, "mbss", 0);
+ 		brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
+@@ -4660,7 +4702,7 @@ static int brcmf_cfg80211_stop_ap(struct
+ 		/* Bring device back up so it can be used again */
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
+ 		if (err < 0)
+-			brcmf_err("BRCMF_C_UP error %d\n", err);
++			bphy_err(wiphy, "BRCMF_C_UP error %d\n", err);
+ 
+ 		brcmf_vif_clear_mgmt_ies(ifp->vif);
+ 	} else {
+@@ -4669,7 +4711,7 @@ static int brcmf_cfg80211_stop_ap(struct
+ 		err = brcmf_fil_iovar_data_set(ifp, "bss", &bss_enable,
+ 					       sizeof(bss_enable));
+ 		if (err < 0)
+-			brcmf_err("bss_enable config failed %d\n", err);
++			bphy_err(wiphy, "bss_enable config failed %d\n", err);
+ 	}
+ 	brcmf_set_mpc(ifp, 1);
+ 	brcmf_configure_arp_nd_offload(ifp, true);
+@@ -4717,7 +4759,8 @@ brcmf_cfg80211_del_station(struct wiphy
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON,
+ 				     &scbval, sizeof(scbval));
+ 	if (err)
+-		brcmf_err("SCB_DEAUTHENTICATE_FOR_REASON failed %d\n", err);
++		bphy_err(wiphy, "SCB_DEAUTHENTICATE_FOR_REASON failed %d\n",
++			 err);
+ 
+ 	brcmf_dbg(TRACE, "Exit\n");
+ 	return err;
+@@ -4747,7 +4790,7 @@ brcmf_cfg80211_change_station(struct wip
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_DEAUTHORIZE,
+ 					     (void *)mac, ETH_ALEN);
+ 	if (err < 0)
+-		brcmf_err("Setting SCB (de-)authorize failed, %d\n", err);
++		bphy_err(wiphy, "Setting SCB (de-)authorize failed, %d\n", err);
+ 
+ 	return err;
+ }
+@@ -4797,7 +4840,7 @@ brcmf_cfg80211_mgmt_tx(struct wiphy *wip
+ 	mgmt = (const struct ieee80211_mgmt *)buf;
+ 
+ 	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+-		brcmf_err("Driver only allows MGMT packet type\n");
++		bphy_err(wiphy, "Driver only allows MGMT packet type\n");
+ 		return -EPERM;
+ 	}
+ 
+@@ -4828,13 +4871,13 @@ brcmf_cfg80211_mgmt_tx(struct wiphy *wip
+ 					GFP_KERNEL);
+ 	} else if (ieee80211_is_action(mgmt->frame_control)) {
+ 		if (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {
+-			brcmf_err("invalid action frame length\n");
++			bphy_err(wiphy, "invalid action frame length\n");
+ 			err = -EINVAL;
+ 			goto exit;
+ 		}
+ 		af_params = kzalloc(sizeof(*af_params), GFP_KERNEL);
+ 		if (af_params == NULL) {
+-			brcmf_err("unable to allocate frame\n");
++			bphy_err(wiphy, "unable to allocate frame\n");
+ 			err = -ENOMEM;
+ 			goto exit;
+ 		}
+@@ -4892,7 +4935,7 @@ brcmf_cfg80211_cancel_remain_on_channel(
+ 
+ 	vif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+ 	if (vif == NULL) {
+-		brcmf_err("No p2p device available for probe response\n");
++		bphy_err(wiphy, "No p2p device available for probe response\n");
+ 		err = -ENODEV;
+ 		goto exit;
+ 	}
+@@ -4920,7 +4963,7 @@ static int brcmf_cfg80211_get_channel(st
+ 
+ 	err = brcmf_fil_iovar_int_get(ifp, "chanspec", &chanspec);
+ 	if (err) {
+-		brcmf_err("chanspec failed (%d)\n", err);
++		bphy_err(wiphy, "chanspec failed (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -5059,7 +5102,7 @@ static int brcmf_cfg80211_tdls_oper(stru
+ 	ret = brcmf_fil_iovar_data_set(ifp, "tdls_endpoint",
+ 				       &info, sizeof(info));
+ 	if (ret < 0)
+-		brcmf_err("tdls_endpoint iovar failed: ret=%d\n", ret);
++		bphy_err(wiphy, "tdls_endpoint iovar failed: ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+@@ -5080,7 +5123,7 @@ brcmf_cfg80211_update_conn_params(struct
+ 	err = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,
+ 				    sme->ie, sme->ie_len);
+ 	if (err)
+-		brcmf_err("Set Assoc REQ IE Failed\n");
++		bphy_err(wiphy, "Set Assoc REQ IE Failed\n");
+ 	else
+ 		brcmf_dbg(TRACE, "Applied Vndr IEs for Assoc request\n");
+ 
+@@ -5106,7 +5149,7 @@ brcmf_cfg80211_set_rekey_data(struct wip
+ 	ret = brcmf_fil_iovar_data_set(ifp, "gtk_key_info", &gtk_le,
+ 				       sizeof(gtk_le));
+ 	if (ret < 0)
+-		brcmf_err("gtk_key_info iovar failed: ret=%d\n", ret);
++		bphy_err(wiphy, "gtk_key_info iovar failed: ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+@@ -5341,6 +5384,7 @@ static void brcmf_clear_assoc_ies(struct
+ static s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_info *cfg,
+ 			       struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_cfg80211_assoc_ielen_le *assoc_info;
+ 	struct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+ 	u32 req_len;
+@@ -5352,7 +5396,7 @@ static s32 brcmf_get_assoc_ies(struct br
+ 	err = brcmf_fil_iovar_data_get(ifp, "assoc_info",
+ 				       cfg->extra_buf, WL_ASSOC_INFO_MAX);
+ 	if (err) {
+-		brcmf_err("could not get assoc info (%d)\n", err);
++		bphy_err(wiphy, "could not get assoc info (%d)\n", err);
+ 		return err;
+ 	}
+ 	assoc_info =
+@@ -5364,7 +5408,7 @@ static s32 brcmf_get_assoc_ies(struct br
+ 					       cfg->extra_buf,
+ 					       WL_ASSOC_INFO_MAX);
+ 		if (err) {
+-			brcmf_err("could not get assoc req (%d)\n", err);
++			bphy_err(wiphy, "could not get assoc req (%d)\n", err);
+ 			return err;
+ 		}
+ 		conn_info->req_ie_len = req_len;
+@@ -5382,7 +5426,7 @@ static s32 brcmf_get_assoc_ies(struct br
+ 					       cfg->extra_buf,
+ 					       WL_ASSOC_INFO_MAX);
+ 		if (err) {
+-			brcmf_err("could not get assoc resp (%d)\n", err);
++			bphy_err(wiphy, "could not get assoc resp (%d)\n", err);
+ 			return err;
+ 		}
+ 		conn_info->resp_ie_len = resp_len;
+@@ -5511,6 +5555,7 @@ brcmf_notify_connect_status_ap(struct br
+ 			       struct net_device *ndev,
+ 			       const struct brcmf_event_msg *e, void *data)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	static int generation;
+ 	u32 event = e->event_code;
+ 	u32 reason = e->reason;
+@@ -5528,7 +5573,7 @@ brcmf_notify_connect_status_ap(struct br
+ 	if (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&
+ 	    (reason == BRCMF_E_STATUS_SUCCESS)) {
+ 		if (!data) {
+-			brcmf_err("No IEs present in ASSOC/REASSOC_IND");
++			bphy_err(wiphy, "No IEs present in ASSOC/REASSOC_IND\n");
+ 			return -EINVAL;
+ 		}
+ 
+@@ -5820,6 +5865,7 @@ static void init_vif_event(struct brcmf_
+ 
+ static s32 brcmf_dongle_roam(struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err;
+ 	u32 bcn_timeout;
+ 	__le32 roamtrigger[2];
+@@ -5832,7 +5878,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 		bcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_ON;
+ 	err = brcmf_fil_iovar_int_set(ifp, "bcn_timeout", bcn_timeout);
+ 	if (err) {
+-		brcmf_err("bcn_timeout error (%d)\n", err);
++		bphy_err(wiphy, "bcn_timeout error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5844,7 +5890,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	err = brcmf_fil_iovar_int_set(ifp, "roam_off",
+ 				      ifp->drvr->settings->roamoff);
+ 	if (err) {
+-		brcmf_err("roam_off error (%d)\n", err);
++		bphy_err(wiphy, "roam_off error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5853,7 +5899,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,
+ 				     (void *)roamtrigger, sizeof(roamtrigger));
+ 	if (err) {
+-		brcmf_err("WLC_SET_ROAM_TRIGGER error (%d)\n", err);
++		bphy_err(wiphy, "WLC_SET_ROAM_TRIGGER error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5862,7 +5908,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,
+ 				     (void *)roam_delta, sizeof(roam_delta));
+ 	if (err) {
+-		brcmf_err("WLC_SET_ROAM_DELTA error (%d)\n", err);
++		bphy_err(wiphy, "WLC_SET_ROAM_DELTA error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5873,25 +5919,26 @@ roam_setup_done:
+ static s32
+ brcmf_dongle_scantime(struct brcmf_if *ifp)
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	s32 err = 0;
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,
+ 				    BRCMF_SCAN_CHANNEL_TIME);
+ 	if (err) {
+-		brcmf_err("Scan assoc time error (%d)\n", err);
++		bphy_err(wiphy, "Scan assoc time error (%d)\n", err);
+ 		goto dongle_scantime_out;
+ 	}
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,
+ 				    BRCMF_SCAN_UNASSOC_TIME);
+ 	if (err) {
+-		brcmf_err("Scan unassoc time error (%d)\n", err);
++		bphy_err(wiphy, "Scan unassoc time error (%d)\n", err);
+ 		goto dongle_scantime_out;
+ 	}
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,
+ 				    BRCMF_SCAN_PASSIVE_TIME);
+ 	if (err) {
+-		brcmf_err("Scan passive time error (%d)\n", err);
++		bphy_err(wiphy, "Scan passive time error (%d)\n", err);
+ 		goto dongle_scantime_out;
+ 	}
+ 
+@@ -5923,10 +5970,10 @@ static void brcmf_update_bw40_channel_fl
+ static int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,
+ 				    u32 bw_cap[])
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
+ 	struct ieee80211_supported_band *band;
+ 	struct ieee80211_channel *channel;
+-	struct wiphy *wiphy;
+ 	struct brcmf_chanspec_list *list;
+ 	struct brcmu_chan ch;
+ 	int err;
+@@ -5945,11 +5992,10 @@ static int brcmf_construct_chaninfo(stru
+ 	err = brcmf_fil_iovar_data_get(ifp, "chanspecs", pbuf,
+ 				       BRCMF_DCMD_MEDLEN);
+ 	if (err) {
+-		brcmf_err("get chanspecs error (%d)\n", err);
++		bphy_err(wiphy, "get chanspecs error (%d)\n", err);
+ 		goto fail_pbuf;
+ 	}
+ 
+-	wiphy = cfg_to_wiphy(cfg);
+ 	band = wiphy->bands[NL80211_BAND_2GHZ];
+ 	if (band)
+ 		for (i = 0; i < band->n_channels; i++)
+@@ -5969,7 +6015,8 @@ static int brcmf_construct_chaninfo(stru
+ 		} else if (ch.band == BRCMU_CHAN_BAND_5G) {
+ 			band = wiphy->bands[NL80211_BAND_5GHZ];
+ 		} else {
+-			brcmf_err("Invalid channel Spec. 0x%x.\n", ch.chspec);
++			bphy_err(wiphy, "Invalid channel Spec. 0x%x.\n",
++				 ch.chspec);
+ 			continue;
+ 		}
+ 		if (!band)
+@@ -5992,8 +6039,8 @@ static int brcmf_construct_chaninfo(stru
+ 			/* It seems firmware supports some channel we never
+ 			 * considered. Something new in IEEE standard?
+ 			 */
+-			brcmf_err("Ignoring unexpected firmware channel %d\n",
+-				  ch.control_ch_num);
++			bphy_err(wiphy, "Ignoring unexpected firmware channel %d\n",
++				 ch.control_ch_num);
+ 			continue;
+ 		}
+ 
+@@ -6039,6 +6086,7 @@ fail_pbuf:
+ 
+ static int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
+ 	struct ieee80211_supported_band *band;
+ 	struct brcmf_fil_bwcap_le band_bwcap;
+@@ -6085,7 +6133,7 @@ static int brcmf_enable_bw40_2g(struct b
+ 		err = brcmf_fil_iovar_data_get(ifp, "chanspecs", pbuf,
+ 					       BRCMF_DCMD_MEDLEN);
+ 		if (err) {
+-			brcmf_err("get chanspecs error (%d)\n", err);
++			bphy_err(wiphy, "get chanspecs error (%d)\n", err);
+ 			kfree(pbuf);
+ 			return err;
+ 		}
+@@ -6116,6 +6164,7 @@ static int brcmf_enable_bw40_2g(struct b
+ 
+ static void brcmf_get_bwcap(struct brcmf_if *ifp, u32 bw_cap[])
+ {
++	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	u32 band, mimo_bwcap;
+ 	int err;
+ 
+@@ -6151,7 +6200,7 @@ static void brcmf_get_bwcap(struct brcmf
+ 		bw_cap[NL80211_BAND_5GHZ] |= WLC_BW_20MHZ_BIT;
+ 		break;
+ 	default:
+-		brcmf_err("invalid mimo_bw_cap value\n");
++		bphy_err(wiphy, "invalid mimo_bw_cap value\n");
+ 	}
+ }
+ 
+@@ -6227,7 +6276,7 @@ static void brcmf_update_vht_cap(struct
+ static int brcmf_setup_wiphybands(struct brcmf_cfg80211_info *cfg)
+ {
+ 	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
+-	struct wiphy *wiphy;
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	u32 nmode = 0;
+ 	u32 vhtmode = 0;
+ 	u32 bw_cap[2] = { WLC_BW_20MHZ_BIT, WLC_BW_20MHZ_BIT };
+@@ -6243,7 +6292,7 @@ static int brcmf_setup_wiphybands(struct
+ 	(void)brcmf_fil_iovar_int_get(ifp, "vhtmode", &vhtmode);
+ 	err = brcmf_fil_iovar_int_get(ifp, "nmode", &nmode);
+ 	if (err) {
+-		brcmf_err("nmode error (%d)\n", err);
++		bphy_err(wiphy, "nmode error (%d)\n", err);
+ 	} else {
+ 		brcmf_get_bwcap(ifp, bw_cap);
+ 	}
+@@ -6253,7 +6302,7 @@ static int brcmf_setup_wiphybands(struct
+ 
+ 	err = brcmf_fil_iovar_int_get(ifp, "rxchain", &rxchain);
+ 	if (err) {
+-		brcmf_err("rxchain error (%d)\n", err);
++		bphy_err(wiphy, "rxchain error (%d)\n", err);
+ 		nchain = 1;
+ 	} else {
+ 		for (nchain = 0; rxchain; nchain++)
+@@ -6263,7 +6312,7 @@ static int brcmf_setup_wiphybands(struct
+ 
+ 	err = brcmf_construct_chaninfo(cfg, bw_cap);
+ 	if (err) {
+-		brcmf_err("brcmf_construct_chaninfo failed (%d)\n", err);
++		bphy_err(wiphy, "brcmf_construct_chaninfo failed (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -6275,7 +6324,6 @@ static int brcmf_setup_wiphybands(struct
+ 					      &txbf_bfr_cap);
+ 	}
+ 
+-	wiphy = cfg_to_wiphy(cfg);
+ 	for (i = 0; i < ARRAY_SIZE(wiphy->bands); i++) {
+ 		band = wiphy->bands[i];
+ 		if (band == NULL)
+@@ -6476,7 +6524,7 @@ static void brcmf_wiphy_wowl_params(stru
+ 	wowl = kmemdup(&brcmf_wowlan_support, sizeof(brcmf_wowlan_support),
+ 		       GFP_KERNEL);
+ 	if (!wowl) {
+-		brcmf_err("only support basic wowlan features\n");
++		bphy_err(wiphy, "only support basic wowlan features\n");
+ 		wiphy->wowlan = &brcmf_wowlan_support;
+ 		return;
+ 	}
+@@ -6573,7 +6621,7 @@ static int brcmf_setup_wiphy(struct wiph
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST, &bandlist,
+ 				     sizeof(bandlist));
+ 	if (err) {
+-		brcmf_err("could not obtain band info: err=%d\n", err);
++		bphy_err(wiphy, "could not obtain band info: err=%d\n", err);
+ 		return err;
+ 	}
+ 	/* first entry in bandlist is number of bands */
+@@ -6622,6 +6670,7 @@ static int brcmf_setup_wiphy(struct wiph
+ 
+ static s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)
+ {
++	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	struct net_device *ndev;
+ 	struct wireless_dev *wdev;
+ 	struct brcmf_if *ifp;
+@@ -6659,7 +6708,7 @@ static s32 brcmf_config_dongle(struct br
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_FAKEFRAG, 1);
+ 	if (err) {
+-		brcmf_err("failed to set frameburst mode\n");
++		bphy_err(wiphy, "failed to set frameburst mode\n");
+ 		goto default_conf_out;
+ 	}
+ 
+@@ -6851,8 +6900,8 @@ static void brcmf_cfg80211_reg_notifier(
+ 	/* ignore non-ISO3166 country codes */
+ 	for (i = 0; i < 2; i++)
+ 		if (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {
+-			brcmf_err("not an ISO3166 code (0x%02x 0x%02x)\n",
+-				  req->alpha2[0], req->alpha2[1]);
++			bphy_err(wiphy, "not an ISO3166 code (0x%02x 0x%02x)\n",
++				 req->alpha2[0], req->alpha2[1]);
+ 			return;
+ 		}
+ 
+@@ -6861,7 +6910,7 @@ static void brcmf_cfg80211_reg_notifier(
+ 
+ 	err = brcmf_fil_iovar_data_get(ifp, "country", &ccreq, sizeof(ccreq));
+ 	if (err) {
+-		brcmf_err("Country code iovar returned err = %d\n", err);
++		bphy_err(wiphy, "Country code iovar returned err = %d\n", err);
+ 		return;
+ 	}
+ 
+@@ -6871,7 +6920,7 @@ static void brcmf_cfg80211_reg_notifier(
+ 
+ 	err = brcmf_fil_iovar_data_set(ifp, "country", &ccreq, sizeof(ccreq));
+ 	if (err) {
+-		brcmf_err("Firmware rejected country setting\n");
++		bphy_err(wiphy, "Firmware rejected country setting\n");
+ 		return;
+ 	}
+ 	brcmf_setup_wiphybands(cfg);
+@@ -6917,13 +6966,13 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 	u16 *cap = NULL;
+ 
+ 	if (!ndev) {
+-		brcmf_err("ndev is invalid\n");
++		bphy_err(wiphy, "ndev is invalid\n");
+ 		return NULL;
+ 	}
+ 
+ 	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
+ 	if (!cfg) {
+-		brcmf_err("Could not allocate wiphy device\n");
++		bphy_err(wiphy, "Could not allocate wiphy device\n");
+ 		return NULL;
+ 	}
+ 
+@@ -6944,7 +6993,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 
+ 	err = wl_init_priv(cfg);
+ 	if (err) {
+-		brcmf_err("Failed to init iwm_priv (%d)\n", err);
++		bphy_err(wiphy, "Failed to init iwm_priv (%d)\n", err);
+ 		brcmf_free_vif(vif);
+ 		goto wiphy_out;
+ 	}
+@@ -6953,7 +7002,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 	/* determine d11 io type before wiphy setup */
+ 	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_VERSION, &io_type);
+ 	if (err) {
+-		brcmf_err("Failed to get D11 version (%d)\n", err);
++		bphy_err(wiphy, "Failed to get D11 version (%d)\n", err);
+ 		goto priv_out;
+ 	}
+ 	cfg->d11inf.io_type = (u8)io_type;
+@@ -6987,13 +7036,13 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ #endif
+ 	err = wiphy_register(wiphy);
+ 	if (err < 0) {
+-		brcmf_err("Could not register wiphy device (%d)\n", err);
++		bphy_err(wiphy, "Could not register wiphy device (%d)\n", err);
+ 		goto priv_out;
+ 	}
+ 
+ 	err = brcmf_setup_wiphybands(cfg);
+ 	if (err) {
+-		brcmf_err("Setting wiphy bands failed (%d)\n", err);
++		bphy_err(wiphy, "Setting wiphy bands failed (%d)\n", err);
+ 		goto wiphy_unreg_out;
+ 	}
+ 
+@@ -7011,24 +7060,24 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 
+ 	err = brcmf_fweh_activate_events(ifp);
+ 	if (err) {
+-		brcmf_err("FWEH activation failed (%d)\n", err);
++		bphy_err(wiphy, "FWEH activation failed (%d)\n", err);
+ 		goto wiphy_unreg_out;
+ 	}
+ 
+ 	err = brcmf_p2p_attach(cfg, p2pdev_forced);
+ 	if (err) {
+-		brcmf_err("P2P initialisation failed (%d)\n", err);
++		bphy_err(wiphy, "P2P initialisation failed (%d)\n", err);
+ 		goto wiphy_unreg_out;
+ 	}
+ 	err = brcmf_btcoex_attach(cfg);
+ 	if (err) {
+-		brcmf_err("BT-coex initialisation failed (%d)\n", err);
++		bphy_err(wiphy, "BT-coex initialisation failed (%d)\n", err);
+ 		brcmf_p2p_detach(&cfg->p2p);
+ 		goto wiphy_unreg_out;
+ 	}
+ 	err = brcmf_pno_attach(cfg);
+ 	if (err) {
+-		brcmf_err("PNO initialisation failed (%d)\n", err);
++		bphy_err(wiphy, "PNO initialisation failed (%d)\n", err);
+ 		brcmf_btcoex_detach(cfg);
+ 		brcmf_p2p_detach(&cfg->p2p);
+ 		goto wiphy_unreg_out;
+@@ -7048,7 +7097,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 	/* (re-) activate FWEH event handling */
+ 	err = brcmf_fweh_activate_events(ifp);
+ 	if (err) {
+-		brcmf_err("FWEH activation failed (%d)\n", err);
++		bphy_err(wiphy, "FWEH activation failed (%d)\n", err);
+ 		goto detach;
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+@@ -62,6 +62,15 @@ void __brcmf_err(struct brcmf_bus *bus,
+ 	} while (0)
+ #endif
+ 
++#define bphy_err(wiphy, fmt, ...)					\
++	do {								\
++		if (IS_ENABLED(CPTCFG_BRCMDBG) ||			\
++		    IS_ENABLED(CPTCFG_BRCM_TRACING) ||			\
++		    net_ratelimit())					\
++			wiphy_err(wiphy, "%s: " fmt, __func__,		\
++				  ##__VA_ARGS__);			\
++	} while (0)
++
+ #if defined(DEBUG) || defined(CPTCFG_BRCM_TRACING)
+ 
+ /* For debug/tracing purposes treat info messages as errors */
diff -uprN a/package/kernel/mac80211/patches/brcm/347-v5.1-brcmfmac-fix-typos.patch b/package/kernel/mac80211/patches/brcm/347-v5.1-brcmfmac-fix-typos.patch
--- a/package/kernel/mac80211/patches/brcm/347-v5.1-brcmfmac-fix-typos.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/347-v5.1-brcmfmac-fix-typos.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,62 @@
+From 2359dd09f9819c7d57d81e05173541f0f9f820c7 Mon Sep 17 00:00:00 2001
+From: Matteo Croce <mcroce@redhat.com>
+Date: Tue, 29 Jan 2019 18:47:17 +0100
+Subject: [PATCH] brcmfmac: fix typos
+
+Fix spelling mistakes in brcmfmac: "lenght" -> "length".
+The typos are also in the special comment blocks which
+translates to documentation.
+
+Signed-off-by: Matteo Croce <mcroce@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h     | 2 +-
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c | 2 +-
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h     | 2 +-
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c      | 2 +-
+ 4 files changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
+@@ -36,7 +36,7 @@
+ #define BRCMF_DCMD_MEDLEN	1536
+ #define BRCMF_DCMD_MAXLEN	8192
+ 
+-/* IOCTL from host to device are limited in lenght. A device can only handle
++/* IOCTL from host to device are limited in length. A device can only handle
+  * ethernet frame size. This limitation is to be applied by protocol layer.
+  */
+ #define BRCMF_TX_IOCTL_MAX_MSG_SIZE	(ETH_FRAME_LEN+ETH_FCS_LEN)
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -47,7 +47,7 @@ enum nvram_parser_state {
+  * @state: current parser state.
+  * @data: input buffer being parsed.
+  * @nvram: output buffer with parse result.
+- * @nvram_len: lenght of parse result.
++ * @nvram_len: length of parse result.
+  * @line: current line.
+  * @column: current column in line.
+  * @pos: byte offset in input buffer.
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
+@@ -266,7 +266,7 @@ struct brcmf_event {
+  * @status: status information.
+  * @reason: reason code.
+  * @auth_type: authentication type.
+- * @datalen: lenght of event data buffer.
++ * @datalen: length of event data buffer.
+  * @addr: ether address.
+  * @ifname: interface name.
+  * @ifidx: interface index.
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -509,7 +509,7 @@ static void brcmf_usb_rx_complete(struct
+ 	skb = req->skb;
+ 	req->skb = NULL;
+ 
+-	/* zero lenght packets indicate usb "failure". Do not refill */
++	/* zero length packets indicate usb "failure". Do not refill */
+ 	if (urb->status != 0 || !urb->actual_length) {
+ 		brcmu_pkt_buf_free_skb(skb);
+ 		brcmf_usb_enq(devinfo, &devinfo->rx_freeq, req, NULL);
diff -uprN a/package/kernel/mac80211/patches/brcm/348-v5.1-brcmfmac-support-monitor-frames-with-the-hardware-uc.patch b/package/kernel/mac80211/patches/brcm/348-v5.1-brcmfmac-support-monitor-frames-with-the-hardware-uc.patch
--- a/package/kernel/mac80211/patches/brcm/348-v5.1-brcmfmac-support-monitor-frames-with-the-hardware-uc.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/348-v5.1-brcmfmac-support-monitor-frames-with-the-hardware-uc.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,143 @@
+From e665988be29ccea3584528967b432a5cfd801ca4 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 8 Feb 2019 07:42:30 +0100
+Subject: [PATCH] brcmfmac: support monitor frames with the hardware/ucode
+ header
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+So far there were two monitor frame formats:
+1) 802.11 frames (with frame (sub)type & all addresses)
+2) 802.11 frames with the radiotap header
+
+Testing the latest FullMAC firmwares for 4366b1/4366c0 resulted in
+discovering a new format being used. It seems (almost?) identical to the
+one known from ucode used in SoftMAC devices which is most likely the
+same codebase anyway.
+
+While new firmwares will /announce/ radiotap header support using the
+"rtap" fw capability string it seems no string was added for the new
+ucode header format.
+
+All above means that:
+1) We need new format support when dealing with a received frame
+2) A new feature bit & mapping quirks have to be added manually
+
+As for now only an empty radiotap is being created. Adding support for
+extracting some info (band, channel, signal, etc.) is planned for the
+future.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/core.c        | 55 +++++++++++++++++++
+ .../broadcom/brcm80211/brcmfmac/feature.c     |  4 ++
+ .../broadcom/brcm80211/brcmfmac/feature.h     |  4 +-
+ 3 files changed, 62 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -43,6 +43,36 @@
+ 
+ #define BRCMF_BSSIDX_INVALID			-1
+ 
++#define	RXS_PBPRES				BIT(2)
++
++#define	D11_PHY_HDR_LEN				6
++
++struct d11rxhdr_le {
++	__le16 RxFrameSize;
++	u16 PAD;
++	__le16 PhyRxStatus_0;
++	__le16 PhyRxStatus_1;
++	__le16 PhyRxStatus_2;
++	__le16 PhyRxStatus_3;
++	__le16 PhyRxStatus_4;
++	__le16 PhyRxStatus_5;
++	__le16 RxStatus1;
++	__le16 RxStatus2;
++	__le16 RxTSFTime;
++	__le16 RxChan;
++	u8 unknown[12];
++} __packed;
++
++struct wlc_d11rxhdr {
++	struct d11rxhdr_le rxhdr;
++	__le32 tsf_l;
++	s8 rssi;
++	s8 rxpwr0;
++	s8 rxpwr1;
++	s8 do_rssi_ma;
++	s8 rxpwr[4];
++} __packed;
++
+ char *brcmf_ifname(struct brcmf_if *ifp)
+ {
+ 	if (!ifp)
+@@ -409,6 +439,31 @@ void brcmf_netif_mon_rx(struct brcmf_if
+ {
+ 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FMT_RADIOTAP)) {
+ 		/* Do nothing */
++	} else if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FMT_HW_RX_HDR)) {
++		struct wlc_d11rxhdr *wlc_rxhdr = (struct wlc_d11rxhdr *)skb->data;
++		struct ieee80211_radiotap_header *radiotap;
++		unsigned int offset;
++		u16 RxStatus1;
++
++		RxStatus1 = le16_to_cpu(wlc_rxhdr->rxhdr.RxStatus1);
++
++		offset = sizeof(struct wlc_d11rxhdr);
++		/* MAC inserts 2 pad bytes for a4 headers or QoS or A-MSDU
++		 * subframes
++		 */
++		if (RxStatus1 & RXS_PBPRES)
++			offset += 2;
++		offset += D11_PHY_HDR_LEN;
++
++		skb_pull(skb, offset);
++
++		/* TODO: use RX header to fill some radiotap data */
++		radiotap = skb_push(skb, sizeof(*radiotap));
++		memset(radiotap, 0, sizeof(*radiotap));
++		radiotap->it_len = cpu_to_le16(sizeof(*radiotap));
++
++		/* TODO: 4 bytes with receive status? */
++		skb->len -= 4;
+ 	} else {
+ 		struct ieee80211_radiotap_header *radiotap;
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+@@ -103,6 +103,10 @@ static const struct brcmf_feat_fwfeat br
+ 	{ "01-6cb8e269", BIT(BRCMF_FEAT_MONITOR) },
+ 	/* brcmfmac4366b-pcie.bin from linux-firmware.git commit 52442afee990 */
+ 	{ "01-c47a91a4", BIT(BRCMF_FEAT_MONITOR) },
++	/* brcmfmac4366b-pcie.bin from linux-firmware.git commit 211de1679a68 */
++	{ "01-801fb449", BIT(BRCMF_FEAT_MONITOR_FMT_HW_RX_HDR) },
++	/* brcmfmac4366c-pcie.bin from linux-firmware.git commit 211de1679a68 */
++	{ "01-d2cbb8fd", BIT(BRCMF_FEAT_MONITOR_FMT_HW_RX_HDR) },
+ };
+ 
+ static void brcmf_feat_firmware_overrides(struct brcmf_pub *drv)
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
+@@ -35,6 +35,7 @@
+  * FWSUP: Firmware supplicant.
+  * MONITOR: firmware can pass monitor packets to host.
+  * MONITOR_FMT_RADIOTAP: firmware provides monitor packets with radiotap header
++ * MONITOR_FMT_HW_RX_HDR: firmware provides monitor packets with hw/ucode header
+  */
+ #define BRCMF_FEAT_LIST \
+ 	BRCMF_FEAT_DEF(MBSS) \
+@@ -52,7 +53,8 @@
+ 	BRCMF_FEAT_DEF(GSCAN) \
+ 	BRCMF_FEAT_DEF(FWSUP) \
+ 	BRCMF_FEAT_DEF(MONITOR) \
+-	BRCMF_FEAT_DEF(MONITOR_FMT_RADIOTAP)
++	BRCMF_FEAT_DEF(MONITOR_FMT_RADIOTAP) \
++	BRCMF_FEAT_DEF(MONITOR_FMT_HW_RX_HDR)
+ 
+ /*
+  * Quirks:
diff -uprN a/package/kernel/mac80211/patches/brcm/349-v5.1-0004-brcmfmac-disable-MBSS-feature-for-bcm4330-device.patch b/package/kernel/mac80211/patches/brcm/349-v5.1-0004-brcmfmac-disable-MBSS-feature-for-bcm4330-device.patch
--- a/package/kernel/mac80211/patches/brcm/349-v5.1-0004-brcmfmac-disable-MBSS-feature-for-bcm4330-device.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/349-v5.1-0004-brcmfmac-disable-MBSS-feature-for-bcm4330-device.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,41 @@
+From 92d3b88b1029c46f9bf27302c502dc0e3541805b Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 14 Feb 2019 13:43:50 +0100
+Subject: [PATCH] brcmfmac: disable MBSS feature for bcm4330 device
+
+The MBSS feature was already disabled for bcm43362 as it resulted in a
+beacon with BRCM_TEST_SSID regardless user configuration in hostapd. Now
+the same has been reported for bcm4330 so disable the feature for this
+device as well.
+
+Reported-by: Russell King <linux@armlinux.org.uk>
+Tested-by: Christopher Martin <chrsmrtn@gmail.com>
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/feature.c | 10 ++++++++--
+ 1 file changed, 8 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+@@ -272,9 +272,15 @@ void brcmf_feat_attach(struct brcmf_pub
+ 					BIT(BRCMF_FEAT_WOWL_GTK);
+ 		}
+ 	}
+-	/* MBSS does not work for 43362 */
+-	if (drvr->bus_if->chip == BRCM_CC_43362_CHIP_ID)
++	/* MBSS does not work for all chips */
++	switch (drvr->bus_if->chip) {
++	case BRCM_CC_4330_CHIP_ID:
++	case BRCM_CC_43362_CHIP_ID:
+ 		ifp->drvr->feat_flags &= ~BIT(BRCMF_FEAT_MBSS);
++		break;
++	default:
++		break;
++	}
+ 	brcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_RSDB, "rsdb_mode");
+ 	brcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_TDLS, "tdls_enable");
+ 	brcmf_feat_iovar_int_get(ifp, BRCMF_FEAT_MFP, "mfp");
diff -uprN a/package/kernel/mac80211/patches/brcm/349-v5.1-0005-brcmfmac-check-and-dump-trap-info-during-sdio-probe.patch b/package/kernel/mac80211/patches/brcm/349-v5.1-0005-brcmfmac-check-and-dump-trap-info-during-sdio-probe.patch
--- a/package/kernel/mac80211/patches/brcm/349-v5.1-0005-brcmfmac-check-and-dump-trap-info-during-sdio-probe.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/349-v5.1-0005-brcmfmac-check-and-dump-trap-info-during-sdio-probe.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,121 @@
+From 4ab2cf03da91785f2c34d79a302e53da06928bc1 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 14 Feb 2019 13:43:51 +0100
+Subject: [PATCH] brcmfmac: check and dump trap info during sdio probe
+
+When the firmware crashes during the probe sequence we provide little
+information on what really failed. This patch checks the sdpcm shared
+location and show the trap information if a firmware trap has happened.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/sdio.c        | 59 +++++++++++++------
+ 1 file changed, 40 insertions(+), 19 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -3013,21 +3013,35 @@ static int brcmf_sdio_trap_info(struct s
+ 	if (error < 0)
+ 		return error;
+ 
+-	seq_printf(seq,
+-		   "dongle trap info: type 0x%x @ epc 0x%08x\n"
+-		   "  cpsr 0x%08x spsr 0x%08x sp 0x%08x\n"
+-		   "  lr   0x%08x pc   0x%08x offset 0x%x\n"
+-		   "  r0   0x%08x r1   0x%08x r2 0x%08x r3 0x%08x\n"
+-		   "  r4   0x%08x r5   0x%08x r6 0x%08x r7 0x%08x\n",
+-		   le32_to_cpu(tr.type), le32_to_cpu(tr.epc),
+-		   le32_to_cpu(tr.cpsr), le32_to_cpu(tr.spsr),
+-		   le32_to_cpu(tr.r13), le32_to_cpu(tr.r14),
+-		   le32_to_cpu(tr.pc), sh->trap_addr,
+-		   le32_to_cpu(tr.r0), le32_to_cpu(tr.r1),
+-		   le32_to_cpu(tr.r2), le32_to_cpu(tr.r3),
+-		   le32_to_cpu(tr.r4), le32_to_cpu(tr.r5),
+-		   le32_to_cpu(tr.r6), le32_to_cpu(tr.r7));
+-
++	if (seq)
++		seq_printf(seq,
++			   "dongle trap info: type 0x%x @ epc 0x%08x\n"
++			   "  cpsr 0x%08x spsr 0x%08x sp 0x%08x\n"
++			   "  lr   0x%08x pc   0x%08x offset 0x%x\n"
++			   "  r0   0x%08x r1   0x%08x r2 0x%08x r3 0x%08x\n"
++			   "  r4   0x%08x r5   0x%08x r6 0x%08x r7 0x%08x\n",
++			   le32_to_cpu(tr.type), le32_to_cpu(tr.epc),
++			   le32_to_cpu(tr.cpsr), le32_to_cpu(tr.spsr),
++			   le32_to_cpu(tr.r13), le32_to_cpu(tr.r14),
++			   le32_to_cpu(tr.pc), sh->trap_addr,
++			   le32_to_cpu(tr.r0), le32_to_cpu(tr.r1),
++			   le32_to_cpu(tr.r2), le32_to_cpu(tr.r3),
++			   le32_to_cpu(tr.r4), le32_to_cpu(tr.r5),
++			   le32_to_cpu(tr.r6), le32_to_cpu(tr.r7));
++	else
++		pr_debug("dongle trap info: type 0x%x @ epc 0x%08x\n"
++			 "  cpsr 0x%08x spsr 0x%08x sp 0x%08x\n"
++			 "  lr   0x%08x pc   0x%08x offset 0x%x\n"
++			 "  r0   0x%08x r1   0x%08x r2 0x%08x r3 0x%08x\n"
++			 "  r4   0x%08x r5   0x%08x r6 0x%08x r7 0x%08x\n",
++			 le32_to_cpu(tr.type), le32_to_cpu(tr.epc),
++			 le32_to_cpu(tr.cpsr), le32_to_cpu(tr.spsr),
++			 le32_to_cpu(tr.r13), le32_to_cpu(tr.r14),
++			 le32_to_cpu(tr.pc), sh->trap_addr,
++			 le32_to_cpu(tr.r0), le32_to_cpu(tr.r1),
++			 le32_to_cpu(tr.r2), le32_to_cpu(tr.r3),
++			 le32_to_cpu(tr.r4), le32_to_cpu(tr.r5),
++			 le32_to_cpu(tr.r6), le32_to_cpu(tr.r7));
+ 	return 0;
+ }
+ 
+@@ -3081,8 +3095,10 @@ static int brcmf_sdio_checkdied(struct b
+ 	else if (sh.flags & SDPCM_SHARED_ASSERT)
+ 		brcmf_err("assertion in dongle\n");
+ 
+-	if (sh.flags & SDPCM_SHARED_TRAP)
++	if (sh.flags & SDPCM_SHARED_TRAP) {
+ 		brcmf_err("firmware trap in dongle\n");
++		brcmf_sdio_trap_info(NULL, bus, &sh);
++	}
+ 
+ 	return 0;
+ }
+@@ -4217,7 +4233,7 @@ static void brcmf_sdio_firmware_callback
+ 	} else {
+ 		/* Disable F2 again */
+ 		sdio_disable_func(sdiod->func2);
+-		goto release;
++		goto checkdied;
+ 	}
+ 
+ 	if (brcmf_chip_sr_capable(bus->ci)) {
+@@ -4238,8 +4254,10 @@ static void brcmf_sdio_firmware_callback
+ 	}
+ 
+ 	/* If we didn't come up, turn off backplane clock */
+-	if (err != 0)
++	if (err != 0) {
+ 		brcmf_sdio_clkctl(bus, CLK_NONE, false);
++		goto checkdied;
++	}
+ 
+ 	sdio_release_host(sdiod->func1);
+ 
+@@ -4253,12 +4271,15 @@ static void brcmf_sdio_firmware_callback
+ 	err = brcmf_attach(sdiod->dev, sdiod->settings);
+ 	if (err != 0) {
+ 		brcmf_err("brcmf_attach failed\n");
+-		goto fail;
++		sdio_claim_host(sdiod->func1);
++		goto checkdied;
+ 	}
+ 
+ 	/* ready */
+ 	return;
+ 
++checkdied:
++	brcmf_sdio_checkdied(bus);
+ release:
+ 	sdio_release_host(sdiod->func1);
+ fail:
diff -uprN a/package/kernel/mac80211/patches/brcm/349-v5.1-0006-brcmfmac-use-chipname-in-brcmf_fw_alloc_request-for-.patch b/package/kernel/mac80211/patches/brcm/349-v5.1-0006-brcmfmac-use-chipname-in-brcmf_fw_alloc_request-for-.patch
--- a/package/kernel/mac80211/patches/brcm/349-v5.1-0006-brcmfmac-use-chipname-in-brcmf_fw_alloc_request-for-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/349-v5.1-0006-brcmfmac-use-chipname-in-brcmf_fw_alloc_request-for-.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,42 @@
+From a250c91c1762e85c736e67cb4a9a95ebae72e62d Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 14 Feb 2019 13:43:52 +0100
+Subject: [PATCH] brcmfmac: use chipname in brcmf_fw_alloc_request() for error
+ path as well
+
+The local variable chipname is string representation of chip id and revision
+which is printed in the good flow of brcmf_fw_alloc_request(). Also use it
+for the error path, ie. for unknown/unsupported devices.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -719,8 +719,10 @@ brcmf_fw_alloc_request(u32 chip, u32 chi
+ 			break;
+ 	}
+ 
++	brcmf_chip_name(chip, chiprev, chipname, sizeof(chipname));
++
+ 	if (i == table_size) {
+-		brcmf_err("Unknown chipid %d [%d]\n", chip, chiprev);
++		brcmf_err("Unknown chip %s\n", chipname);
+ 		return NULL;
+ 	}
+ 
+@@ -729,8 +731,6 @@ brcmf_fw_alloc_request(u32 chip, u32 chi
+ 	if (!fwreq)
+ 		return NULL;
+ 
+-	brcmf_chip_name(chip, chiprev, chipname, sizeof(chipname));
+-
+ 	brcmf_info("using %s for chip %s\n",
+ 		   mapping_table[i].fw_base, chipname);
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/350-v5.1-brcmfmac-print-firmware-reported-ring-status-errors.patch b/package/kernel/mac80211/patches/brcm/350-v5.1-brcmfmac-print-firmware-reported-ring-status-errors.patch
--- a/package/kernel/mac80211/patches/brcm/350-v5.1-brcmfmac-print-firmware-reported-ring-status-errors.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/350-v5.1-brcmfmac-print-firmware-reported-ring-status-errors.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,67 @@
+From c988b78244df8216902e20de536434e2f474a37e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 8 Feb 2019 15:24:39 +0100
+Subject: [PATCH] brcmfmac: print firmware reported ring status errors
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Firmware is capable of reporting ring status. It's used e.g. to signal
+some problem with a specific ring setup. This patch adds support for
+printing ring & error number which may be useful for debugging setup
+issues.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/msgbuf.c      | 25 +++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -134,6 +134,14 @@ struct msgbuf_completion_hdr {
+ 	__le16				flow_ring_id;
+ };
+ 
++/* Data struct for the MSGBUF_TYPE_RING_STATUS */
++struct msgbuf_ring_status {
++	struct msgbuf_common_hdr	msg;
++	struct msgbuf_completion_hdr	compl_hdr;
++	__le16				write_idx;
++	__le32				rsvd0[5];
++};
++
+ struct msgbuf_rx_event {
+ 	struct msgbuf_common_hdr	msg;
+ 	struct msgbuf_completion_hdr	compl_hdr;
+@@ -1180,6 +1188,19 @@ brcmf_msgbuf_process_rx_complete(struct
+ 	brcmf_netif_rx(ifp, skb);
+ }
+ 
++static void brcmf_msgbuf_process_ring_status(struct brcmf_msgbuf *msgbuf,
++					     void *buf)
++{
++	struct msgbuf_ring_status *ring_status = buf;
++	int err;
++
++	err = le16_to_cpu(ring_status->compl_hdr.status);
++	if (err) {
++		int ring = le16_to_cpu(ring_status->compl_hdr.flow_ring_id);
++
++		brcmf_err("Firmware reported ring %d error: %d\n", ring, err);
++	}
++}
+ 
+ static void
+ brcmf_msgbuf_process_flow_ring_create_response(struct brcmf_msgbuf *msgbuf,
+@@ -1241,6 +1262,10 @@ static void brcmf_msgbuf_process_msgtype
+ 
+ 	msg = (struct msgbuf_common_hdr *)buf;
+ 	switch (msg->msgtype) {
++	case MSGBUF_TYPE_RING_STATUS:
++		brcmf_dbg(MSGBUF, "MSGBUF_TYPE_RING_STATUS\n");
++		brcmf_msgbuf_process_ring_status(msgbuf, buf);
++		break;
+ 	case MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT:
+ 		brcmf_dbg(MSGBUF, "MSGBUF_TYPE_FLOW_RING_CREATE_CMPLT\n");
+ 		brcmf_msgbuf_process_flow_ring_create_response(msgbuf, buf);
diff -uprN a/package/kernel/mac80211/patches/brcm/351-v5.1-0001-brcmfmac-improve-code-handling-bandwidth-of-firmware.patch b/package/kernel/mac80211/patches/brcm/351-v5.1-0001-brcmfmac-improve-code-handling-bandwidth-of-firmware.patch
--- a/package/kernel/mac80211/patches/brcm/351-v5.1-0001-brcmfmac-improve-code-handling-bandwidth-of-firmware.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/351-v5.1-0001-brcmfmac-improve-code-handling-bandwidth-of-firmware.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,42 @@
+From f4e183293b871c96c0220dcc549d5ca4c72628ad Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 11 Feb 2019 23:04:53 +0100
+Subject: [PATCH] brcmfmac: improve code handling bandwidth of firmware
+ reported channels
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+1) Use switch to simplify/improve the code & avoid some duplication
+2) Add warning for unsupported values
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 13 ++++++++++---
+ 1 file changed, 10 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -6050,11 +6050,18 @@ static int brcmf_construct_chaninfo(stru
+ 		/* assuming the chanspecs order is HT20,
+ 		 * HT40 upper, HT40 lower, and VHT80.
+ 		 */
+-		if (ch.bw == BRCMU_CHAN_BW_80) {
++		switch (ch.bw) {
++		case BRCMU_CHAN_BW_80:
+ 			channel->flags &= ~IEEE80211_CHAN_NO_80MHZ;
+-		} else if (ch.bw == BRCMU_CHAN_BW_40) {
++			break;
++		case BRCMU_CHAN_BW_40:
+ 			brcmf_update_bw40_channel_flag(channel, &ch);
+-		} else {
++			break;
++		default:
++			wiphy_warn(wiphy, "Firmware reported unsupported bandwidth %d\n",
++				   ch.bw);
++			/* fall through */
++		case BRCMU_CHAN_BW_20:
+ 			/* enable the channel and disable other bandwidths
+ 			 * for now as mentioned order assure they are enabled
+ 			 * for subsequent chanspecs.
diff -uprN a/package/kernel/mac80211/patches/brcm/351-v5.1-0002-brcmfmac-support-firmware-reporting-160-MHz-channels.patch b/package/kernel/mac80211/patches/brcm/351-v5.1-0002-brcmfmac-support-firmware-reporting-160-MHz-channels.patch
--- a/package/kernel/mac80211/patches/brcm/351-v5.1-0002-brcmfmac-support-firmware-reporting-160-MHz-channels.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/351-v5.1-0002-brcmfmac-support-firmware-reporting-160-MHz-channels.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,30 @@
+From 30519cbe339a45bd11a57ca8ece07f4f6a1cda2e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 11 Feb 2019 23:04:54 +0100
+Subject: [PATCH] brcmfmac: support firmware reporting 160 MHz channels
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+So far 160 MHz channels were treated as 20 MHz ones which was breaking
+support for 40/80 MHz due to the brcmf_construct_chaninfo() logic and
+its assumptions.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 3 +++
+ 1 file changed, 3 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -6051,6 +6051,9 @@ static int brcmf_construct_chaninfo(stru
+ 		 * HT40 upper, HT40 lower, and VHT80.
+ 		 */
+ 		switch (ch.bw) {
++		case BRCMU_CHAN_BW_160:
++			channel->flags &= ~IEEE80211_CHAN_NO_160MHZ;
++			break;
+ 		case BRCMU_CHAN_BW_80:
+ 			channel->flags &= ~IEEE80211_CHAN_NO_80MHZ;
+ 			break;
diff -uprN a/package/kernel/mac80211/patches/brcm/352-v5.1-brcmfmac-rework-bphy_err-to-take-struct-brcmf_pub-ar.patch b/package/kernel/mac80211/patches/brcm/352-v5.1-brcmfmac-rework-bphy_err-to-take-struct-brcmf_pub-ar.patch
--- a/package/kernel/mac80211/patches/brcm/352-v5.1-brcmfmac-rework-bphy_err-to-take-struct-brcmf_pub-ar.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/352-v5.1-brcmfmac-rework-bphy_err-to-take-struct-brcmf_pub-ar.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,2290 @@
+From 16e646768396339b3d354985b99bcd3f1f195a7d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 15 Feb 2019 15:45:54 +0100
+Subject: [PATCH] brcmfmac: rework bphy_err() to take struct brcmf_pub argument
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This macro will be used in more places not just the cfg80211.c. It makes
+sense to pass some common struct to it as "struct wiphy" is mostly
+referenced in cfg80211 code only.
+
+A very common one (used above the bus abstraction layer) is struct
+brcmf_pub. Many functions already keep reference to it which will make
+using bphy_err() simpler. It should also allow extending that macro's
+logic if it's ever needed.
+
+This improves code recently added in the commit 3ef005b82e2a ("brcmfmac:
+add bphy_err() and use it in the cfg80211.c").
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 510 ++++++++++--------
+ .../broadcom/brcm80211/brcmfmac/debug.h       |   4 +-
+ 2 files changed, 281 insertions(+), 233 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -457,7 +457,7 @@ static void convert_key_from_CPU(struct
+ static int
+ send_key_to_dongle(struct brcmf_if *ifp, struct brcmf_wsec_key *key)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int err;
+ 	struct brcmf_wsec_key_le key_le;
+ 
+@@ -469,7 +469,7 @@ send_key_to_dongle(struct brcmf_if *ifp,
+ 					sizeof(key_le));
+ 
+ 	if (err)
+-		bphy_err(wiphy, "wsec_key error (%d)\n", err);
++		bphy_err(drvr, "wsec_key error (%d)\n", err);
+ 	return err;
+ }
+ 
+@@ -509,7 +509,7 @@ static int brcmf_get_first_free_bsscfgid
+ 
+ static int brcmf_cfg80211_request_ap_if(struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_mbss_ssid_le mbss_ssid_le;
+ 	int bsscfgidx;
+ 	int err;
+@@ -526,7 +526,7 @@ static int brcmf_cfg80211_request_ap_if(
+ 	err = brcmf_fil_bsscfg_data_set(ifp, "bsscfg:ssid", &mbss_ssid_le,
+ 					sizeof(mbss_ssid_le));
+ 	if (err < 0)
+-		bphy_err(wiphy, "setting ssid failed %d\n", err);
++		bphy_err(drvr, "setting ssid failed %d\n", err);
+ 
+ 	return err;
+ }
+@@ -544,6 +544,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	int err;
+ 
+@@ -569,7 +570,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ 					    BRCMF_VIF_EVENT_TIMEOUT);
+ 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
+ 	if (!err) {
+-		bphy_err(wiphy, "timeout occurred\n");
++		bphy_err(drvr, "timeout occurred\n");
+ 		err = -EIO;
+ 		goto fail;
+ 	}
+@@ -577,7 +578,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ 	/* interface created in firmware */
+ 	ifp = vif->ifp;
+ 	if (!ifp) {
+-		bphy_err(wiphy, "no if pointer provided\n");
++		bphy_err(drvr, "no if pointer provided\n");
+ 		err = -ENOENT;
+ 		goto fail;
+ 	}
+@@ -585,7 +586,7 @@ struct wireless_dev *brcmf_ap_add_vif(st
+ 	strncpy(ifp->ndev->name, name, sizeof(ifp->ndev->name) - 1);
+ 	err = brcmf_net_attach(ifp, true);
+ 	if (err) {
+-		bphy_err(wiphy, "Registering netdevice failed\n");
++		bphy_err(drvr, "Registering netdevice failed\n");
+ 		free_netdev(ifp->ndev);
+ 		goto fail;
+ 	}
+@@ -616,13 +617,15 @@ static struct wireless_dev *brcmf_cfg802
+ 						     enum nl80211_iftype type,
+ 						     struct vif_params *params)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct wireless_dev *wdev;
+ 	int err;
+ 
+ 	brcmf_dbg(TRACE, "enter: %s type %d\n", name, type);
+ 	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
+ 	if (err) {
+-		bphy_err(wiphy, "iface validation failed: err=%d\n", err);
++		bphy_err(drvr, "iface validation failed: err=%d\n", err);
+ 		return ERR_PTR(err);
+ 	}
+ 	switch (type) {
+@@ -647,7 +650,7 @@ static struct wireless_dev *brcmf_cfg802
+ 	}
+ 
+ 	if (IS_ERR(wdev))
+-		bphy_err(wiphy, "add iface %s type %d failed: err=%d\n", name,
++		bphy_err(drvr, "add iface %s type %d failed: err=%d\n", name,
+ 			 type, (int)PTR_ERR(wdev));
+ 	else
+ 		brcmf_cfg80211_update_proto_addr_mode(wdev);
+@@ -663,13 +666,13 @@ static void brcmf_scan_config_mpc(struct
+ 
+ void brcmf_set_mpc(struct brcmf_if *ifp, int mpc)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err = 0;
+ 
+ 	if (check_vif_up(ifp->vif)) {
+ 		err = brcmf_fil_iovar_int_set(ifp, "mpc", mpc);
+ 		if (err) {
+-			bphy_err(wiphy, "fail to set mpc\n");
++			bphy_err(drvr, "fail to set mpc\n");
+ 			return;
+ 		}
+ 		brcmf_dbg(INFO, "MPC : %d\n", mpc);
+@@ -680,7 +683,7 @@ s32 brcmf_notify_escan_complete(struct b
+ 				struct brcmf_if *ifp, bool aborted,
+ 				bool fw_abort)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_scan_params_le params_le;
+ 	struct cfg80211_scan_request *scan_request;
+ 	u64 reqid;
+@@ -715,7 +718,7 @@ s32 brcmf_notify_escan_complete(struct b
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,
+ 					     &params_le, sizeof(params_le));
+ 		if (err)
+-			bphy_err(wiphy, "Scan abort failed\n");
++			bphy_err(drvr, "Scan abort failed\n");
+ 	}
+ 
+ 	brcmf_scan_config_mpc(ifp, 1);
+@@ -760,6 +763,7 @@ static int brcmf_cfg80211_del_ap_iface(s
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct net_device *ndev = wdev->netdev;
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	int ret;
+ 	int err;
+ 
+@@ -767,7 +771,7 @@ static int brcmf_cfg80211_del_ap_iface(s
+ 
+ 	err = brcmf_fil_bsscfg_data_set(ifp, "interface_remove", NULL, 0);
+ 	if (err) {
+-		bphy_err(wiphy, "interface_remove failed %d\n", err);
++		bphy_err(drvr, "interface_remove failed %d\n", err);
+ 		goto err_unarm;
+ 	}
+ 
+@@ -775,7 +779,7 @@ static int brcmf_cfg80211_del_ap_iface(s
+ 	ret = brcmf_cfg80211_wait_vif_event(cfg, BRCMF_E_IF_DEL,
+ 					    BRCMF_VIF_EVENT_TIMEOUT);
+ 	if (!ret) {
+-		bphy_err(wiphy, "timeout occurred\n");
++		bphy_err(drvr, "timeout occurred\n");
+ 		err = -EIO;
+ 		goto err_unarm;
+ 	}
+@@ -838,6 +842,7 @@ brcmf_cfg80211_change_iface(struct wiphy
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_cfg80211_vif *vif = ifp->vif;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 infra = 0;
+ 	s32 ap = 0;
+ 	s32 err = 0;
+@@ -877,13 +882,13 @@ brcmf_cfg80211_change_iface(struct wiphy
+ 	}
+ 	err = brcmf_vif_change_validate(wiphy_to_cfg(wiphy), vif, type);
+ 	if (err) {
+-		bphy_err(wiphy, "iface validation failed: err=%d\n", err);
++		bphy_err(drvr, "iface validation failed: err=%d\n", err);
+ 		return err;
+ 	}
+ 	switch (type) {
+ 	case NL80211_IFTYPE_MONITOR:
+ 	case NL80211_IFTYPE_WDS:
+-		bphy_err(wiphy, "type (%d) : currently we do not support this type\n",
++		bphy_err(drvr, "type (%d) : currently we do not support this type\n",
+ 			 type);
+ 		return -EOPNOTSUPP;
+ 	case NL80211_IFTYPE_ADHOC:
+@@ -912,7 +917,7 @@ brcmf_cfg80211_change_iface(struct wiphy
+ 	} else {
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, infra);
+ 		if (err) {
+-			bphy_err(wiphy, "WLC_SET_INFRA error (%d)\n", err);
++			bphy_err(drvr, "WLC_SET_INFRA error (%d)\n", err);
+ 			err = -EAGAIN;
+ 			goto done;
+ 		}
+@@ -1003,7 +1008,7 @@ static s32
+ brcmf_run_escan(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp,
+ 		struct cfg80211_scan_request *request)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +
+ 			  offsetof(struct brcmf_escan_params_le, params_le);
+ 	struct brcmf_escan_params_le *params;
+@@ -1035,7 +1040,7 @@ brcmf_run_escan(struct brcmf_cfg80211_in
+ 		if (err == -EBUSY)
+ 			brcmf_dbg(INFO, "system busy : escan canceled\n");
+ 		else
+-			bphy_err(wiphy, "error (%d)\n", err);
++			bphy_err(drvr, "error (%d)\n", err);
+ 	}
+ 
+ 	kfree(params);
+@@ -1072,6 +1077,7 @@ static s32
+ brcmf_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	s32 err = 0;
+ 
+@@ -1081,22 +1087,22 @@ brcmf_cfg80211_scan(struct wiphy *wiphy,
+ 		return -EIO;
+ 
+ 	if (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {
+-		bphy_err(wiphy, "Scanning already: status (%lu)\n",
++		bphy_err(drvr, "Scanning already: status (%lu)\n",
+ 			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 	if (test_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status)) {
+-		bphy_err(wiphy, "Scanning being aborted: status (%lu)\n",
++		bphy_err(drvr, "Scanning being aborted: status (%lu)\n",
+ 			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 	if (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {
+-		bphy_err(wiphy, "Scanning suppressed: status (%lu)\n",
++		bphy_err(drvr, "Scanning suppressed: status (%lu)\n",
+ 			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+ 	if (test_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state)) {
+-		bphy_err(wiphy, "Connecting: status (%lu)\n", vif->sme_state);
++		bphy_err(drvr, "Connecting: status (%lu)\n", vif->sme_state);
+ 		return -EAGAIN;
+ 	}
+ 
+@@ -1130,7 +1136,7 @@ brcmf_cfg80211_scan(struct wiphy *wiphy,
+ 	return 0;
+ 
+ scan_out:
+-	bphy_err(wiphy, "scan error (%d)\n", err);
++	bphy_err(drvr, "scan error (%d)\n", err);
+ 	clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);
+ 	cfg->scan_request = NULL;
+ 	return err;
+@@ -1139,12 +1145,12 @@ scan_out:
+ static s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err = 0;
+ 
+ 	err = brcmf_fil_iovar_int_set(ifp, "rtsthresh", rts_threshold);
+ 	if (err)
+-		bphy_err(wiphy, "Error (%d)\n", err);
++		bphy_err(drvr, "Error (%d)\n", err);
+ 
+ 	return err;
+ }
+@@ -1152,13 +1158,13 @@ static s32 brcmf_set_rts(struct net_devi
+ static s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err = 0;
+ 
+ 	err = brcmf_fil_iovar_int_set(ifp, "fragthresh",
+ 				      frag_threshold);
+ 	if (err)
+-		bphy_err(wiphy, "Error (%d)\n", err);
++		bphy_err(drvr, "Error (%d)\n", err);
+ 
+ 	return err;
+ }
+@@ -1166,13 +1172,13 @@ static s32 brcmf_set_frag(struct net_dev
+ static s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err = 0;
+ 	u32 cmd = (l ? BRCMF_C_SET_LRL : BRCMF_C_SET_SRL);
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, cmd, retry);
+ 	if (err) {
+-		bphy_err(wiphy, "cmd (%d) , error (%d)\n", cmd, err);
++		bphy_err(drvr, "cmd (%d) , error (%d)\n", cmd, err);
+ 		return err;
+ 	}
+ 	return err;
+@@ -1248,7 +1254,7 @@ static u16 brcmf_map_fw_linkdown_reason(
+ 
+ static int brcmf_set_pmk(struct brcmf_if *ifp, const u8 *pmk_data, u16 pmk_len)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_wsec_pmk_le pmk;
+ 	int i, err;
+ 
+@@ -1262,7 +1268,7 @@ static int brcmf_set_pmk(struct brcmf_if
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_WSEC_PMK,
+ 				     &pmk, sizeof(pmk));
+ 	if (err < 0)
+-		bphy_err(wiphy, "failed to change PSK in firmware (len=%u)\n",
++		bphy_err(drvr, "failed to change PSK in firmware (len=%u)\n",
+ 			 pmk_len);
+ 
+ 	return err;
+@@ -1271,7 +1277,7 @@ static int brcmf_set_pmk(struct brcmf_if
+ static void brcmf_link_down(struct brcmf_cfg80211_vif *vif, u16 reason)
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err = 0;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+@@ -1281,7 +1287,7 @@ static void brcmf_link_down(struct brcmf
+ 		err = brcmf_fil_cmd_data_set(vif->ifp,
+ 					     BRCMF_C_DISASSOC, NULL, 0);
+ 		if (err) {
+-			bphy_err(wiphy, "WLC_DISASSOC failed (%d)\n", err);
++			bphy_err(drvr, "WLC_DISASSOC failed (%d)\n", err);
+ 		}
+ 		if ((vif->wdev.iftype == NL80211_IFTYPE_STATION) ||
+ 		    (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))
+@@ -1305,6 +1311,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_join_params join_params;
+ 	size_t join_params_size = 0;
+ 	s32 err = 0;
+@@ -1369,7 +1376,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 
+ 	err = brcmf_fil_iovar_int_set(ifp, "wsec", wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "wsec failed (%d)\n", err);
++		bphy_err(drvr, "wsec failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1381,7 +1388,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_SET_BCNPRD failed (%d)\n", err);
++		bphy_err(drvr, "WLC_SET_BCNPRD failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1426,7 +1433,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,
+ 					    target_channel);
+ 		if (err) {
+-			bphy_err(wiphy, "WLC_SET_CHANNEL failed (%d)\n", err);
++			bphy_err(drvr, "WLC_SET_CHANNEL failed (%d)\n", err);
+ 			goto done;
+ 		}
+ 	} else
+@@ -1438,7 +1445,7 @@ brcmf_cfg80211_join_ibss(struct wiphy *w
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 				     &join_params, join_params_size);
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_SET_SSID failed (%d)\n", err);
++		bphy_err(drvr, "WLC_SET_SSID failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1475,8 +1482,8 @@ static s32 brcmf_set_wpa_version(struct
+ 				 struct cfg80211_connect_params *sme)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 val = 0;
+ 	s32 err = 0;
+@@ -1490,7 +1497,7 @@ static s32 brcmf_set_wpa_version(struct
+ 	brcmf_dbg(CONN, "setting wpa_auth to 0x%0x\n", val);
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", val);
+ 	if (err) {
+-		bphy_err(wiphy, "set wpa_auth failed (%d)\n", err);
++		bphy_err(drvr, "set wpa_auth failed (%d)\n", err);
+ 		return err;
+ 	}
+ 	sec = &profile->sec;
+@@ -1502,8 +1509,8 @@ static s32 brcmf_set_auth_type(struct ne
+ 			       struct cfg80211_connect_params *sme)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 val = 0;
+ 	s32 err = 0;
+@@ -1525,7 +1532,7 @@ static s32 brcmf_set_auth_type(struct ne
+ 
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "auth", val);
+ 	if (err) {
+-		bphy_err(wiphy, "set auth failed (%d)\n", err);
++		bphy_err(drvr, "set auth failed (%d)\n", err);
+ 		return err;
+ 	}
+ 	sec = &profile->sec;
+@@ -1538,8 +1545,8 @@ brcmf_set_wsec_mode(struct net_device *n
+ 		    struct cfg80211_connect_params *sme)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 pval = 0;
+ 	s32 gval = 0;
+@@ -1562,7 +1569,7 @@ brcmf_set_wsec_mode(struct net_device *n
+ 			pval = AES_ENABLED;
+ 			break;
+ 		default:
+-			bphy_err(wiphy, "invalid cipher pairwise (%d)\n",
++			bphy_err(drvr, "invalid cipher pairwise (%d)\n",
+ 				 sme->crypto.ciphers_pairwise[0]);
+ 			return -EINVAL;
+ 		}
+@@ -1583,7 +1590,7 @@ brcmf_set_wsec_mode(struct net_device *n
+ 			gval = AES_ENABLED;
+ 			break;
+ 		default:
+-			bphy_err(wiphy, "invalid cipher group (%d)\n",
++			bphy_err(drvr, "invalid cipher group (%d)\n",
+ 				 sme->crypto.cipher_group);
+ 			return -EINVAL;
+ 		}
+@@ -1599,7 +1606,7 @@ brcmf_set_wsec_mode(struct net_device *n
+ 	wsec = pval | gval;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "error (%d)\n", err);
++		bphy_err(drvr, "error (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -1614,8 +1621,8 @@ static s32
+ brcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
+ 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 val;
+ 	s32 err;
+ 	const struct brcmf_tlv *rsn_ie;
+@@ -1633,7 +1640,7 @@ brcmf_set_key_mgmt(struct net_device *nd
+ 
+ 	err = brcmf_fil_bsscfg_int_get(netdev_priv(ndev), "wpa_auth", &val);
+ 	if (err) {
+-		bphy_err(wiphy, "could not get wpa_auth (%d)\n", err);
++		bphy_err(drvr, "could not get wpa_auth (%d)\n", err);
+ 		return err;
+ 	}
+ 	if (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {
+@@ -1647,7 +1654,7 @@ brcmf_set_key_mgmt(struct net_device *nd
+ 			val = WPA_AUTH_PSK;
+ 			break;
+ 		default:
+-			bphy_err(wiphy, "invalid cipher group (%d)\n",
++			bphy_err(drvr, "invalid cipher group (%d)\n",
+ 				 sme->crypto.cipher_group);
+ 			return -EINVAL;
+ 		}
+@@ -1670,7 +1677,7 @@ brcmf_set_key_mgmt(struct net_device *nd
+ 			val = WPA2_AUTH_PSK;
+ 			break;
+ 		default:
+-			bphy_err(wiphy, "invalid cipher group (%d)\n",
++			bphy_err(drvr, "invalid cipher group (%d)\n",
+ 				 sme->crypto.cipher_group);
+ 			return -EINVAL;
+ 		}
+@@ -1717,7 +1724,7 @@ skip_mfp_config:
+ 	brcmf_dbg(CONN, "setting wpa_auth to %d\n", val);
+ 	err = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "wpa_auth", val);
+ 	if (err) {
+-		bphy_err(wiphy, "could not set wpa_auth (%d)\n", err);
++		bphy_err(drvr, "could not set wpa_auth (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -1729,7 +1736,7 @@ brcmf_set_sharedkey(struct net_device *n
+ 		    struct cfg80211_connect_params *sme)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);
+ 	struct brcmf_cfg80211_security *sec;
+ 	struct brcmf_wsec_key key;
+@@ -1756,7 +1763,7 @@ brcmf_set_sharedkey(struct net_device *n
+ 	key.len = (u32) sme->key_len;
+ 	key.index = (u32) sme->key_idx;
+ 	if (key.len > sizeof(key.data)) {
+-		bphy_err(wiphy, "Too long key length (%u)\n", key.len);
++		bphy_err(drvr, "Too long key length (%u)\n", key.len);
+ 		return -EINVAL;
+ 	}
+ 	memcpy(key.data, sme->key, key.len);
+@@ -1769,7 +1776,7 @@ brcmf_set_sharedkey(struct net_device *n
+ 		key.algo = CRYPTO_ALGO_WEP128;
+ 		break;
+ 	default:
+-		bphy_err(wiphy, "Invalid algorithm (%d)\n",
++		bphy_err(drvr, "Invalid algorithm (%d)\n",
+ 			 sme->crypto.ciphers_pairwise[0]);
+ 		return -EINVAL;
+ 	}
+@@ -1786,7 +1793,7 @@ brcmf_set_sharedkey(struct net_device *n
+ 		val = WL_AUTH_SHARED_KEY;	/* shared key */
+ 		err = brcmf_fil_bsscfg_int_set(ifp, "auth", val);
+ 		if (err)
+-			bphy_err(wiphy, "set auth failed (%d)\n", err);
++			bphy_err(drvr, "set auth failed (%d)\n", err);
+ 	}
+ 	return err;
+ }
+@@ -1806,7 +1813,7 @@ enum nl80211_auth_type brcmf_war_auth_ty
+ static void brcmf_set_join_pref(struct brcmf_if *ifp,
+ 				struct cfg80211_bss_selection *bss_select)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_join_pref_params join_pref_params[2];
+ 	enum nl80211_band band;
+ 	int err, i = 0;
+@@ -1845,7 +1852,7 @@ static void brcmf_set_join_pref(struct b
+ 	err = brcmf_fil_iovar_data_set(ifp, "join_pref", join_pref_params,
+ 				       sizeof(join_pref_params));
+ 	if (err)
+-		bphy_err(wiphy, "Set join_pref error (%d)\n", err);
++		bphy_err(drvr, "Set join_pref error (%d)\n", err);
+ }
+ 
+ static s32
+@@ -1856,6 +1863,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
+ 	struct ieee80211_channel *chan = sme->channel;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_join_params join_params;
+ 	size_t join_params_size;
+ 	const struct brcmf_tlv *rsn_ie;
+@@ -1872,7 +1880,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 		return -EIO;
+ 
+ 	if (!sme->ssid) {
+-		bphy_err(wiphy, "Invalid ssid\n");
++		bphy_err(drvr, "Invalid ssid\n");
+ 		return -EOPNOTSUPP;
+ 	}
+ 
+@@ -1901,7 +1909,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 	err = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,
+ 				    sme->ie, sme->ie_len);
+ 	if (err)
+-		bphy_err(wiphy, "Set Assoc REQ IE Failed\n");
++		bphy_err(drvr, "Set Assoc REQ IE Failed\n");
+ 	else
+ 		brcmf_dbg(TRACE, "Applied Vndr IEs for Assoc request\n");
+ 
+@@ -1922,32 +1930,32 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 
+ 	err = brcmf_set_wpa_version(ndev, sme);
+ 	if (err) {
+-		bphy_err(wiphy, "wl_set_wpa_version failed (%d)\n", err);
++		bphy_err(drvr, "wl_set_wpa_version failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	sme->auth_type = brcmf_war_auth_type(ifp, sme->auth_type);
+ 	err = brcmf_set_auth_type(ndev, sme);
+ 	if (err) {
+-		bphy_err(wiphy, "wl_set_auth_type failed (%d)\n", err);
++		bphy_err(drvr, "wl_set_auth_type failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = brcmf_set_wsec_mode(ndev, sme);
+ 	if (err) {
+-		bphy_err(wiphy, "wl_set_set_cipher failed (%d)\n", err);
++		bphy_err(drvr, "wl_set_set_cipher failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = brcmf_set_key_mgmt(ndev, sme);
+ 	if (err) {
+-		bphy_err(wiphy, "wl_set_key_mgmt failed (%d)\n", err);
++		bphy_err(drvr, "wl_set_key_mgmt failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+ 	err = brcmf_set_sharedkey(ndev, sme);
+ 	if (err) {
+-		bphy_err(wiphy, "brcmf_set_sharedkey failed (%d)\n", err);
++		bphy_err(drvr, "brcmf_set_sharedkey failed (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -1964,7 +1972,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 		/* enable firmware supplicant for this interface */
+ 		err = brcmf_fil_iovar_int_set(ifp, "sup_wpa", 1);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "failed to enable fw supplicant\n");
++			bphy_err(drvr, "failed to enable fw supplicant\n");
+ 			goto done;
+ 		}
+ 	}
+@@ -2059,7 +2067,7 @@ brcmf_cfg80211_connect(struct wiphy *wip
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 				     &join_params, join_params_size);
+ 	if (err)
+-		bphy_err(wiphy, "BRCMF_C_SET_SSID failed (%d)\n", err);
++		bphy_err(drvr, "BRCMF_C_SET_SSID failed (%d)\n", err);
+ 
+ done:
+ 	if (err)
+@@ -2072,8 +2080,10 @@ static s32
+ brcmf_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,
+ 		       u16 reason_code)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_scb_val_le scbval;
+ 	s32 err = 0;
+ 
+@@ -2090,7 +2100,7 @@ brcmf_cfg80211_disconnect(struct wiphy *
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_DISASSOC,
+ 				     &scbval, sizeof(scbval));
+ 	if (err)
+-		bphy_err(wiphy, "error (%d)\n", err);
++		bphy_err(drvr, "error (%d)\n", err);
+ 
+ 	brcmf_dbg(TRACE, "Exit\n");
+ 	return err;
+@@ -2103,6 +2113,7 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct net_device *ndev = cfg_to_ndev(cfg);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err;
+ 	s32 disable;
+ 	u32 qdbm = 127;
+@@ -2117,7 +2128,7 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 	case NL80211_TX_POWER_LIMITED:
+ 	case NL80211_TX_POWER_FIXED:
+ 		if (mbm < 0) {
+-			bphy_err(wiphy, "TX_POWER_FIXED - dbm is negative\n");
++			bphy_err(drvr, "TX_POWER_FIXED - dbm is negative\n");
+ 			err = -EINVAL;
+ 			goto done;
+ 		}
+@@ -2127,7 +2138,7 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 		qdbm |= WL_TXPWR_OVERRIDE;
+ 		break;
+ 	default:
+-		bphy_err(wiphy, "Unsupported type %d\n", type);
++		bphy_err(drvr, "Unsupported type %d\n", type);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+@@ -2135,11 +2146,11 @@ brcmf_cfg80211_set_tx_power(struct wiphy
+ 	disable = WL_RADIO_SW_DISABLE << 16;
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_RADIO, disable);
+ 	if (err)
+-		bphy_err(wiphy, "WLC_SET_RADIO error (%d)\n", err);
++		bphy_err(drvr, "WLC_SET_RADIO error (%d)\n", err);
+ 
+ 	err = brcmf_fil_iovar_int_set(ifp, "qtxpower", qdbm);
+ 	if (err)
+-		bphy_err(wiphy, "qtxpower error (%d)\n", err);
++		bphy_err(drvr, "qtxpower error (%d)\n", err);
+ 
+ done:
+ 	brcmf_dbg(TRACE, "Exit %d (qdbm)\n", qdbm & ~WL_TXPWR_OVERRIDE);
+@@ -2150,7 +2161,9 @@ static s32
+ brcmf_cfg80211_get_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,
+ 			    s32 *dbm)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_cfg80211_vif *vif = wdev_to_vif(wdev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 qdbm = 0;
+ 	s32 err;
+ 
+@@ -2160,7 +2173,7 @@ brcmf_cfg80211_get_tx_power(struct wiphy
+ 
+ 	err = brcmf_fil_iovar_int_get(vif->ifp, "qtxpower", &qdbm);
+ 	if (err) {
+-		bphy_err(wiphy, "error (%d)\n", err);
++		bphy_err(drvr, "error (%d)\n", err);
+ 		goto done;
+ 	}
+ 	*dbm = (qdbm & ~WL_TXPWR_OVERRIDE) / 4;
+@@ -2175,6 +2188,7 @@ brcmf_cfg80211_config_default_key(struct
+ 				  u8 key_idx, bool unicast, bool multicast)
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	u32 index;
+ 	u32 wsec;
+ 	s32 err = 0;
+@@ -2186,7 +2200,7 @@ brcmf_cfg80211_config_default_key(struct
+ 
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_GET_WSEC error (%d)\n", err);
++		bphy_err(drvr, "WLC_GET_WSEC error (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -2196,7 +2210,7 @@ brcmf_cfg80211_config_default_key(struct
+ 		err = brcmf_fil_cmd_int_set(ifp,
+ 					    BRCMF_C_SET_KEY_PRIMARY, index);
+ 		if (err)
+-			bphy_err(wiphy, "error (%d)\n", err);
++			bphy_err(drvr, "error (%d)\n", err);
+ 	}
+ done:
+ 	brcmf_dbg(TRACE, "Exit\n");
+@@ -2245,7 +2259,9 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 		       u8 key_idx, bool pairwise, const u8 *mac_addr,
+ 		       struct key_params *params)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_wsec_key *key;
+ 	s32 val;
+ 	s32 wsec;
+@@ -2260,7 +2276,7 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 
+ 	if (key_idx >= BRCMF_MAX_DEFAULT_KEYS) {
+ 		/* we ignore this key index in this case */
+-		bphy_err(wiphy, "invalid key index (%d)\n", key_idx);
++		bphy_err(drvr, "invalid key index (%d)\n", key_idx);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -2269,7 +2285,7 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 					      mac_addr);
+ 
+ 	if (params->key_len > sizeof(key->data)) {
+-		bphy_err(wiphy, "Too long key length (%u)\n", params->key_len);
++		bphy_err(drvr, "Too long key length (%u)\n", params->key_len);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -2323,7 +2339,7 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 		brcmf_dbg(CONN, "WLAN_CIPHER_SUITE_CCMP\n");
+ 		break;
+ 	default:
+-		bphy_err(wiphy, "Invalid cipher (0x%x)\n", params->cipher);
++		bphy_err(drvr, "Invalid cipher (0x%x)\n", params->cipher);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+@@ -2334,13 +2350,13 @@ brcmf_cfg80211_add_key(struct wiphy *wip
+ 
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "get wsec error (%d)\n", err);
++		bphy_err(drvr, "get wsec error (%d)\n", err);
+ 		goto done;
+ 	}
+ 	wsec |= val;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "set wsec error (%d)\n", err);
++		bphy_err(drvr, "set wsec error (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -2355,9 +2371,11 @@ brcmf_cfg80211_get_key(struct wiphy *wip
+ 		       void (*callback)(void *cookie,
+ 					struct key_params *params))
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct key_params params;
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_cfg80211_profile *profile = &ifp->vif->profile;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_security *sec;
+ 	s32 wsec;
+ 	s32 err = 0;
+@@ -2371,7 +2389,7 @@ brcmf_cfg80211_get_key(struct wiphy *wip
+ 
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_GET_WSEC error (%d)\n", err);
++		bphy_err(drvr, "WLC_GET_WSEC error (%d)\n", err);
+ 		/* Ignore this error, may happen during DISASSOC */
+ 		err = -EAGAIN;
+ 		goto done;
+@@ -2392,7 +2410,7 @@ brcmf_cfg80211_get_key(struct wiphy *wip
+ 		params.cipher = WLAN_CIPHER_SUITE_AES_CMAC;
+ 		brcmf_dbg(CONN, "WLAN_CIPHER_SUITE_AES_CMAC\n");
+ 	} else  {
+-		bphy_err(wiphy, "Invalid algo (0x%x)\n", wsec);
++		bphy_err(drvr, "Invalid algo (0x%x)\n", wsec);
+ 		err = -EINVAL;
+ 		goto done;
+ 	}
+@@ -2422,7 +2440,7 @@ brcmf_cfg80211_config_default_mgmt_key(s
+ static void
+ brcmf_cfg80211_reconfigure_wep(struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err;
+ 	u8 key_idx;
+ 	struct brcmf_wsec_key *key;
+@@ -2439,18 +2457,18 @@ brcmf_cfg80211_reconfigure_wep(struct br
+ 
+ 	err = send_key_to_dongle(ifp, key);
+ 	if (err) {
+-		bphy_err(wiphy, "Setting WEP key failed (%d)\n", err);
++		bphy_err(drvr, "Setting WEP key failed (%d)\n", err);
+ 		return;
+ 	}
+ 	err = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);
+ 	if (err) {
+-		bphy_err(wiphy, "get wsec error (%d)\n", err);
++		bphy_err(drvr, "get wsec error (%d)\n", err);
+ 		return;
+ 	}
+ 	wsec |= WEP_ENABLED;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err)
+-		bphy_err(wiphy, "set wsec error (%d)\n", err);
++		bphy_err(drvr, "set wsec error (%d)\n", err);
+ }
+ 
+ static void brcmf_convert_sta_flags(u32 fw_sta_flags, struct station_info *si)
+@@ -2476,7 +2494,7 @@ static void brcmf_convert_sta_flags(u32
+ 
+ static void brcmf_fill_bss_param(struct brcmf_if *ifp, struct station_info *si)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct {
+ 		__le32 len;
+ 		struct brcmf_bss_info_le bss_le;
+@@ -2492,7 +2510,7 @@ static void brcmf_fill_bss_param(struct
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO, buf,
+ 				     WL_BSS_INFO_MAX);
+ 	if (err) {
+-		bphy_err(wiphy, "Failed to get bss info (%d)\n", err);
++		bphy_err(drvr, "Failed to get bss info (%d)\n", err);
+ 		goto out_kfree;
+ 	}
+ 	si->filled |= BIT_ULL(NL80211_STA_INFO_BSS_PARAM);
+@@ -2514,7 +2532,7 @@ static s32
+ brcmf_cfg80211_get_station_ibss(struct brcmf_if *ifp,
+ 				struct station_info *sinfo)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_scb_val_le scbval;
+ 	struct brcmf_pktcnt_le pktcnt;
+ 	s32 err;
+@@ -2524,7 +2542,7 @@ brcmf_cfg80211_get_station_ibss(struct b
+ 	/* Get the current tx rate */
+ 	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "BRCMF_C_GET_RATE error (%d)\n", err);
++		bphy_err(drvr, "BRCMF_C_GET_RATE error (%d)\n", err);
+ 		return err;
+ 	}
+ 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);
+@@ -2534,7 +2552,7 @@ brcmf_cfg80211_get_station_ibss(struct b
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI, &scbval,
+ 				     sizeof(scbval));
+ 	if (err) {
+-		bphy_err(wiphy, "BRCMF_C_GET_RSSI error (%d)\n", err);
++		bphy_err(drvr, "BRCMF_C_GET_RSSI error (%d)\n", err);
+ 		return err;
+ 	}
+ 	rssi = le32_to_cpu(scbval.val);
+@@ -2544,7 +2562,7 @@ brcmf_cfg80211_get_station_ibss(struct b
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_GET_PKTCNTS, &pktcnt,
+ 				     sizeof(pktcnt));
+ 	if (err) {
+-		bphy_err(wiphy, "BRCMF_C_GET_GET_PKTCNTS error (%d)\n", err);
++		bphy_err(drvr, "BRCMF_C_GET_GET_PKTCNTS error (%d)\n", err);
+ 		return err;
+ 	}
+ 	sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS) |
+@@ -2563,7 +2581,9 @@ static s32
+ brcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,
+ 			   const u8 *mac, struct station_info *sinfo)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_scb_val_le scb_val;
+ 	s32 err = 0;
+ 	struct brcmf_sta_info_le sta_info_le;
+@@ -2592,7 +2612,7 @@ brcmf_cfg80211_get_station(struct wiphy
+ 					       &sta_info_le,
+ 					       sizeof(sta_info_le));
+ 		if (err < 0) {
+-			bphy_err(wiphy, "GET STA INFO failed, %d\n", err);
++			bphy_err(drvr, "GET STA INFO failed, %d\n", err);
+ 			goto done;
+ 		}
+ 	}
+@@ -2661,7 +2681,7 @@ brcmf_cfg80211_get_station(struct wiphy
+ 			err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,
+ 						     &scb_val, sizeof(scb_val));
+ 			if (err) {
+-				bphy_err(wiphy, "Could not get rssi (%d)\n",
++				bphy_err(drvr, "Could not get rssi (%d)\n",
+ 					 err);
+ 				goto done;
+ 			} else {
+@@ -2683,6 +2703,7 @@ brcmf_cfg80211_dump_station(struct wiphy
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err;
+ 
+ 	brcmf_dbg(TRACE, "Enter, idx %d\n", idx);
+@@ -2693,7 +2714,7 @@ brcmf_cfg80211_dump_station(struct wiphy
+ 					     &cfg->assoclist,
+ 					     sizeof(cfg->assoclist));
+ 		if (err) {
+-			bphy_err(wiphy, "BRCMF_C_GET_ASSOCLIST unsupported, err=%d\n",
++			bphy_err(drvr, "BRCMF_C_GET_ASSOCLIST unsupported, err=%d\n",
+ 				 err);
+ 			cfg->assoclist.count = 0;
+ 			return -EOPNOTSUPP;
+@@ -2714,6 +2735,7 @@ brcmf_cfg80211_set_power_mgmt(struct wip
+ 	s32 err = 0;
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+ 
+@@ -2742,9 +2764,9 @@ brcmf_cfg80211_set_power_mgmt(struct wip
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, pm);
+ 	if (err) {
+ 		if (err == -ENODEV)
+-			bphy_err(wiphy, "net_device is not ready yet\n");
++			bphy_err(drvr, "net_device is not ready yet\n");
+ 		else
+-			bphy_err(wiphy, "error (%d)\n", err);
++			bphy_err(drvr, "error (%d)\n", err);
+ 	}
+ done:
+ 	brcmf_dbg(TRACE, "Exit\n");
+@@ -2755,6 +2777,7 @@ static s32 brcmf_inform_single_bss(struc
+ 				   struct brcmf_bss_info_le *bi)
+ {
+ 	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct cfg80211_bss *bss;
+ 	enum nl80211_band band;
+ 	struct brcmu_chan ch;
+@@ -2767,7 +2790,7 @@ static s32 brcmf_inform_single_bss(struc
+ 	struct cfg80211_inform_bss bss_data = {};
+ 
+ 	if (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {
+-		bphy_err(wiphy, "Bss info is larger than buffer. Discarding\n");
++		bphy_err(drvr, "Bss info is larger than buffer. Discarding\n");
+ 		return 0;
+ 	}
+ 
+@@ -2826,7 +2849,7 @@ next_bss_le(struct brcmf_scan_results *l
+ 
+ static s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_scan_results *bss_list;
+ 	struct brcmf_bss_info_le *bi = NULL;	/* must be initialized */
+ 	s32 err = 0;
+@@ -2835,7 +2858,7 @@ static s32 brcmf_inform_bss(struct brcmf
+ 	bss_list = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;
+ 	if (bss_list->count != 0 &&
+ 	    bss_list->version != BRCMF_BSS_INFO_VERSION) {
+-		bphy_err(wiphy, "Version %d != WL_BSS_INFO_VERSION\n",
++		bphy_err(drvr, "Version %d != WL_BSS_INFO_VERSION\n",
+ 			 bss_list->version);
+ 		return -EOPNOTSUPP;
+ 	}
+@@ -2853,6 +2876,7 @@ static s32 brcmf_inform_ibss(struct brcm
+ 			     struct net_device *ndev, const u8 *bssid)
+ {
+ 	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct ieee80211_channel *notify_channel;
+ 	struct brcmf_bss_info_le *bi = NULL;
+ 	struct ieee80211_supported_band *band;
+@@ -2880,7 +2904,7 @@ static s32 brcmf_inform_ibss(struct brcm
+ 	err = brcmf_fil_cmd_data_get(netdev_priv(ndev), BRCMF_C_GET_BSS_INFO,
+ 				     buf, WL_BSS_INFO_MAX);
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_GET_BSS_INFO failed: %d\n", err);
++		bphy_err(drvr, "WLC_GET_BSS_INFO failed: %d\n", err);
+ 		goto CleanUp;
+ 	}
+ 
+@@ -2934,7 +2958,7 @@ CleanUp:
+ static s32 brcmf_update_bss_info(struct brcmf_cfg80211_info *cfg,
+ 				 struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_bss_info_le *bi;
+ 	const struct brcmf_tlv *tim;
+ 	u16 beacon_interval;
+@@ -2951,7 +2975,7 @@ static s32 brcmf_update_bss_info(struct
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,
+ 				     cfg->extra_buf, WL_EXTRA_BUF_MAX);
+ 	if (err) {
+-		bphy_err(wiphy, "Could not get bss info %d\n", err);
++		bphy_err(drvr, "Could not get bss info %d\n", err);
+ 		goto update_bss_info_out;
+ 	}
+ 
+@@ -2976,7 +3000,7 @@ static s32 brcmf_update_bss_info(struct
+ 		u32 var;
+ 		err = brcmf_fil_iovar_int_get(ifp, "dtim_assoc", &var);
+ 		if (err) {
+-			bphy_err(wiphy, "wl dtim_assoc failed (%d)\n", err);
++			bphy_err(drvr, "wl dtim_assoc failed (%d)\n", err);
+ 			goto update_bss_info_out;
+ 		}
+ 		dtim_period = (u8)var;
+@@ -3014,10 +3038,10 @@ static void brcmf_escan_timeout(struct t
+ {
+ 	struct brcmf_cfg80211_info *cfg =
+ 			from_timer(cfg, t, escan_timeout);
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 
+ 	if (cfg->int_escan_map || cfg->scan_request) {
+-		bphy_err(wiphy, "timer expired\n");
++		bphy_err(drvr, "timer expired\n");
+ 		schedule_work(&cfg->escan_timeout_work);
+ 	}
+ }
+@@ -3065,8 +3089,8 @@ static s32
+ brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,
+ 			     const struct brcmf_event_msg *e, void *data)
+ {
+-	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_cfg80211_info *cfg = drvr->config;
+ 	s32 status;
+ 	struct brcmf_escan_result_le *escan_result_le;
+ 	u32 escan_buflen;
+@@ -3083,7 +3107,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 		goto exit;
+ 
+ 	if (!test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {
+-		bphy_err(wiphy, "scan not ready, bsscfgidx=%d\n",
++		bphy_err(drvr, "scan not ready, bsscfgidx=%d\n",
+ 			 ifp->bsscfgidx);
+ 		return -EPERM;
+ 	}
+@@ -3091,24 +3115,24 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 	if (status == BRCMF_E_STATUS_PARTIAL) {
+ 		brcmf_dbg(SCAN, "ESCAN Partial result\n");
+ 		if (e->datalen < sizeof(*escan_result_le)) {
+-			bphy_err(wiphy, "invalid event data length\n");
++			bphy_err(drvr, "invalid event data length\n");
+ 			goto exit;
+ 		}
+ 		escan_result_le = (struct brcmf_escan_result_le *) data;
+ 		if (!escan_result_le) {
+-			bphy_err(wiphy, "Invalid escan result (NULL pointer)\n");
++			bphy_err(drvr, "Invalid escan result (NULL pointer)\n");
+ 			goto exit;
+ 		}
+ 		escan_buflen = le32_to_cpu(escan_result_le->buflen);
+ 		if (escan_buflen > BRCMF_ESCAN_BUF_SIZE ||
+ 		    escan_buflen > e->datalen ||
+ 		    escan_buflen < sizeof(*escan_result_le)) {
+-			bphy_err(wiphy, "Invalid escan buffer length: %d\n",
++			bphy_err(drvr, "Invalid escan buffer length: %d\n",
+ 				 escan_buflen);
+ 			goto exit;
+ 		}
+ 		if (le16_to_cpu(escan_result_le->bss_count) != 1) {
+-			bphy_err(wiphy, "Invalid bss_count %d: ignoring\n",
++			bphy_err(drvr, "Invalid bss_count %d: ignoring\n",
+ 				 escan_result_le->bss_count);
+ 			goto exit;
+ 		}
+@@ -3124,7 +3148,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 
+ 		bi_length = le32_to_cpu(bss_info_le->length);
+ 		if (bi_length != escan_buflen -	WL_ESCAN_RESULTS_FIXED_SIZE) {
+-			bphy_err(wiphy, "Ignoring invalid bss_info length: %d\n",
++			bphy_err(drvr, "Ignoring invalid bss_info length: %d\n",
+ 				 bi_length);
+ 			goto exit;
+ 		}
+@@ -3133,7 +3157,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 					BIT(NL80211_IFTYPE_ADHOC))) {
+ 			if (le16_to_cpu(bss_info_le->capability) &
+ 						WLAN_CAPABILITY_IBSS) {
+-				bphy_err(wiphy, "Ignoring IBSS result\n");
++				bphy_err(drvr, "Ignoring IBSS result\n");
+ 				goto exit;
+ 			}
+ 		}
+@@ -3141,7 +3165,7 @@ brcmf_cfg80211_escan_handler(struct brcm
+ 		list = (struct brcmf_scan_results *)
+ 				cfg->escan_info.escan_buf;
+ 		if (bi_length > BRCMF_ESCAN_BUF_SIZE - list->buflen) {
+-			bphy_err(wiphy, "Buffer is too small: ignoring\n");
++			bphy_err(drvr, "Buffer is too small: ignoring\n");
+ 			goto exit;
+ 		}
+ 
+@@ -3300,7 +3324,8 @@ static s32
+ brcmf_notify_sched_scan_results(struct brcmf_if *ifp,
+ 				const struct brcmf_event_msg *e, void *data)
+ {
+-	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_cfg80211_info *cfg = drvr->config;
+ 	struct brcmf_pno_net_info_le *netinfo, *netinfo_start;
+ 	struct cfg80211_scan_request *request = NULL;
+ 	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+@@ -3333,14 +3358,14 @@ brcmf_notify_sched_scan_results(struct b
+ 	WARN_ON(status != BRCMF_PNO_SCAN_COMPLETE);
+ 	brcmf_dbg(SCAN, "PFN NET FOUND event. count: %d\n", result_count);
+ 	if (!result_count) {
+-		bphy_err(wiphy, "FALSE PNO Event. (pfn_count == 0)\n");
++		bphy_err(drvr, "FALSE PNO Event. (pfn_count == 0)\n");
+ 		goto out_err;
+ 	}
+ 
+ 	netinfo_start = brcmf_get_netinfo_array(pfn_result);
+ 	datalen = e->datalen - ((void *)netinfo_start - (void *)pfn_result);
+ 	if (datalen < result_count * sizeof(*netinfo)) {
+-		bphy_err(wiphy, "insufficient event data\n");
++		bphy_err(drvr, "insufficient event data\n");
+ 		goto out_err;
+ 	}
+ 
+@@ -3387,14 +3412,15 @@ brcmf_cfg80211_sched_scan_start(struct w
+ 				struct net_device *ndev,
+ 				struct cfg80211_sched_scan_request *req)
+ {
+-	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 
+ 	brcmf_dbg(SCAN, "Enter: n_match_sets=%d n_ssids=%d\n",
+ 		  req->n_match_sets, req->n_ssids);
+ 
+ 	if (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {
+-		bphy_err(wiphy, "Scanning suppressed: status=%lu\n",
++		bphy_err(drvr, "Scanning suppressed: status=%lu\n",
+ 			 cfg->scan_status);
+ 		return -EAGAIN;
+ 	}
+@@ -3473,8 +3499,8 @@ static s32
+ brcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,
+ 		      void *data)
+ {
+-	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_cfg80211_info *cfg = drvr->config;
+ 	struct brcmf_pno_scanresults_le *pfn_result;
+ 	struct brcmf_pno_net_info_le *netinfo;
+ 
+@@ -3493,7 +3519,7 @@ brcmf_wowl_nd_results(struct brcmf_if *i
+ 	}
+ 
+ 	if (le32_to_cpu(pfn_result->count) < 1) {
+-		bphy_err(wiphy, "Invalid result count, expected 1 (%d)\n",
++		bphy_err(drvr, "Invalid result count, expected 1 (%d)\n",
+ 			 le32_to_cpu(pfn_result->count));
+ 		return -EINVAL;
+ 	}
+@@ -3523,6 +3549,7 @@ brcmf_wowl_nd_results(struct brcmf_if *i
+ static void brcmf_report_wowl_wakeind(struct wiphy *wiphy, struct brcmf_if *ifp)
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_wowl_wakeind_le wake_ind_le;
+ 	struct cfg80211_wowlan_wakeup wakeup_data;
+ 	struct cfg80211_wowlan_wakeup *wakeup;
+@@ -3533,7 +3560,7 @@ static void brcmf_report_wowl_wakeind(st
+ 	err = brcmf_fil_iovar_data_get(ifp, "wowl_wakeind", &wake_ind_le,
+ 				       sizeof(wake_ind_le));
+ 	if (err) {
+-		bphy_err(wiphy, "Get wowl_wakeind failed, err = %d\n", err);
++		bphy_err(drvr, "Get wowl_wakeind failed, err = %d\n", err);
+ 		return;
+ 	}
+ 
+@@ -3574,7 +3601,7 @@ static void brcmf_report_wowl_wakeind(st
+ 				cfg->wowl.nd_data_completed,
+ 				BRCMF_ND_INFO_TIMEOUT);
+ 			if (!timeout)
+-				bphy_err(wiphy, "No result for wowl net detect\n");
++				bphy_err(drvr, "No result for wowl net detect\n");
+ 			else
+ 				wakeup_data.net_detect = cfg->wowl.nd_info;
+ 		}
+@@ -3763,6 +3790,7 @@ brcmf_cfg80211_set_pmksa(struct wiphy *w
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err;
+ 	u32 npmk, i;
+ 
+@@ -3782,7 +3810,7 @@ brcmf_cfg80211_set_pmksa(struct wiphy *w
+ 			cfg->pmk_list.npmk = cpu_to_le32(npmk);
+ 		}
+ 	} else {
+-		bphy_err(wiphy, "Too many PMKSA entries cached %d\n", npmk);
++		bphy_err(drvr, "Too many PMKSA entries cached %d\n", npmk);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -3805,6 +3833,7 @@ brcmf_cfg80211_del_pmksa(struct wiphy *w
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_pmksa *pmk = &cfg->pmk_list.pmk[0];
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err;
+ 	u32 npmk, i;
+ 
+@@ -3828,7 +3857,7 @@ brcmf_cfg80211_del_pmksa(struct wiphy *w
+ 		memset(&pmk[i], 0, sizeof(*pmk));
+ 		cfg->pmk_list.npmk = cpu_to_le32(npmk - 1);
+ 	} else {
+-		bphy_err(wiphy, "Cache entry not found\n");
++		bphy_err(drvr, "Cache entry not found\n");
+ 		return -EINVAL;
+ 	}
+ 
+@@ -3860,20 +3889,20 @@ brcmf_cfg80211_flush_pmksa(struct wiphy
+ 
+ static s32 brcmf_configure_opensecurity(struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err;
+ 	s32 wpa_val;
+ 
+ 	/* set auth */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "auth", 0);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "auth error %d\n", err);
++		bphy_err(drvr, "auth error %d\n", err);
+ 		return err;
+ 	}
+ 	/* set wsec */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", 0);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "wsec error %d\n", err);
++		bphy_err(drvr, "wsec error %d\n", err);
+ 		return err;
+ 	}
+ 	/* set upper-layer auth */
+@@ -3883,7 +3912,7 @@ static s32 brcmf_configure_opensecurity(
+ 		wpa_val = WPA_AUTH_DISABLED;
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", wpa_val);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "wpa_auth error %d\n", err);
++		bphy_err(drvr, "wpa_auth error %d\n", err);
+ 		return err;
+ 	}
+ 
+@@ -3903,7 +3932,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 		      const struct brcmf_vs_tlv *wpa_ie,
+ 		      bool is_rsn_ie)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	u32 auth = 0; /* d11 open authentication */
+ 	u16 count;
+ 	s32 err = 0;
+@@ -3934,13 +3963,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* check for multicast cipher suite */
+ 	if (offset + WPA_IE_MIN_OUI_LEN > len) {
+ 		err = -EINVAL;
+-		bphy_err(wiphy, "no multicast cipher suite\n");
++		bphy_err(drvr, "no multicast cipher suite\n");
+ 		goto exit;
+ 	}
+ 
+ 	if (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+ 		err = -EINVAL;
+-		bphy_err(wiphy, "ivalid OUI\n");
++		bphy_err(drvr, "ivalid OUI\n");
+ 		goto exit;
+ 	}
+ 	offset += TLV_OUI_LEN;
+@@ -3962,7 +3991,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 		break;
+ 	default:
+ 		err = -EINVAL;
+-		bphy_err(wiphy, "Invalid multi cast cipher info\n");
++		bphy_err(drvr, "Invalid multi cast cipher info\n");
+ 		goto exit;
+ 	}
+ 
+@@ -3973,13 +4002,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* Check for unicast suite(s) */
+ 	if (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {
+ 		err = -EINVAL;
+-		bphy_err(wiphy, "no unicast cipher suite\n");
++		bphy_err(drvr, "no unicast cipher suite\n");
+ 		goto exit;
+ 	}
+ 	for (i = 0; i < count; i++) {
+ 		if (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+ 			err = -EINVAL;
+-			bphy_err(wiphy, "ivalid OUI\n");
++			bphy_err(drvr, "ivalid OUI\n");
+ 			goto exit;
+ 		}
+ 		offset += TLV_OUI_LEN;
+@@ -3997,7 +4026,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 			pval |= AES_ENABLED;
+ 			break;
+ 		default:
+-			bphy_err(wiphy, "Invalid unicast security info\n");
++			bphy_err(drvr, "Invalid unicast security info\n");
+ 		}
+ 		offset++;
+ 	}
+@@ -4007,13 +4036,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* Check for auth key management suite(s) */
+ 	if (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {
+ 		err = -EINVAL;
+-		bphy_err(wiphy, "no auth key mgmt suite\n");
++		bphy_err(drvr, "no auth key mgmt suite\n");
+ 		goto exit;
+ 	}
+ 	for (i = 0; i < count; i++) {
+ 		if (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {
+ 			err = -EINVAL;
+-			bphy_err(wiphy, "ivalid OUI\n");
++			bphy_err(drvr, "ivalid OUI\n");
+ 			goto exit;
+ 		}
+ 		offset += TLV_OUI_LEN;
+@@ -4041,7 +4070,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 			wpa_auth |= WPA2_AUTH_1X_SHA256;
+ 			break;
+ 		default:
+-			bphy_err(wiphy, "Invalid key mgmt info\n");
++			bphy_err(drvr, "Invalid key mgmt info\n");
+ 		}
+ 		offset++;
+ 	}
+@@ -4083,7 +4112,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 		err = brcmf_fil_bsscfg_int_set(ifp, "wme_bss_disable",
+ 					       wme_bss_disable);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "wme_bss_disable error %d\n", err);
++			bphy_err(drvr, "wme_bss_disable error %d\n", err);
+ 			goto exit;
+ 		}
+ 
+@@ -4097,7 +4126,7 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 							&data[offset],
+ 							WPA_IE_MIN_OUI_LEN);
+ 			if (err < 0) {
+-				bphy_err(wiphy, "bip error %d\n", err);
++				bphy_err(drvr, "bip error %d\n", err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4108,13 +4137,13 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	/* set auth */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "auth", auth);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "auth error %d\n", err);
++		bphy_err(drvr, "auth error %d\n", err);
+ 		goto exit;
+ 	}
+ 	/* set wsec */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "wsec error %d\n", err);
++		bphy_err(drvr, "wsec error %d\n", err);
+ 		goto exit;
+ 	}
+ 	/* Configure MFP, this needs to go after wsec otherwise the wsec command
+@@ -4123,14 +4152,14 @@ brcmf_configure_wpaie(struct brcmf_if *i
+ 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MFP)) {
+ 		err = brcmf_fil_bsscfg_int_set(ifp, "mfp", mfp);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "mfp error %d\n", err);
++			bphy_err(drvr, "mfp error %d\n", err);
+ 			goto exit;
+ 		}
+ 	}
+ 	/* set upper-layer auth */
+ 	err = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", wpa_auth);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "wpa_auth error %d\n", err);
++		bphy_err(drvr, "wpa_auth error %d\n", err);
+ 		goto exit;
+ 	}
+ 
+@@ -4216,8 +4245,8 @@ brcmf_vndr_ie(u8 *iebuf, s32 pktflag, u8
+ s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,
+ 			  const u8 *vndr_ie_buf, u32 vndr_ie_len)
+ {
++	struct brcmf_pub *drvr;
+ 	struct brcmf_if *ifp;
+-	struct wiphy *wiphy;
+ 	struct vif_saved_ie *saved_ie;
+ 	s32 err = 0;
+ 	u8  *iovar_ie_buf;
+@@ -4238,7 +4267,7 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 	if (!vif)
+ 		return -ENODEV;
+ 	ifp = vif->ifp;
+-	wiphy = ifp->drvr->wiphy;
++	drvr = ifp->drvr;
+ 	saved_ie = &vif->saved_ie;
+ 
+ 	brcmf_dbg(TRACE, "bsscfgidx %d, pktflag : 0x%02X\n", ifp->bsscfgidx,
+@@ -4270,13 +4299,13 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 		break;
+ 	default:
+ 		err = -EPERM;
+-		bphy_err(wiphy, "not suitable type\n");
++		bphy_err(drvr, "not suitable type\n");
+ 		goto exit;
+ 	}
+ 
+ 	if (vndr_ie_len > mgmt_ie_buf_len) {
+ 		err = -ENOMEM;
+-		bphy_err(wiphy, "extra IE size too big\n");
++		bphy_err(drvr, "extra IE size too big\n");
+ 		goto exit;
+ 	}
+ 
+@@ -4337,7 +4366,7 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 			/* verify remained buf size before copy data */
+ 			if (remained_buf_len < (vndrie_info->vndrie.len +
+ 							VNDR_IE_VSIE_OFFSET)) {
+-				bphy_err(wiphy, "no space in mgmt_ie_buf: len left %d",
++				bphy_err(drvr, "no space in mgmt_ie_buf: len left %d",
+ 					 remained_buf_len);
+ 				break;
+ 			}
+@@ -4369,7 +4398,7 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 		err  = brcmf_fil_bsscfg_data_set(ifp, "vndr_ie", iovar_ie_buf,
+ 						 total_ie_buf_len);
+ 		if (err)
+-			bphy_err(wiphy, "vndr ie set error : %d\n", err);
++			bphy_err(drvr, "vndr ie set error : %d\n", err);
+ 	}
+ 
+ exit:
+@@ -4397,14 +4426,14 @@ static s32
+ brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,
+ 			struct cfg80211_beacon_data *beacon)
+ {
+-	struct wiphy *wiphy = vif->ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = vif->ifp->drvr;
+ 	s32 err;
+ 
+ 	/* Set Beacon IEs to FW */
+ 	err = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_BEACON_FLAG,
+ 				    beacon->tail, beacon->tail_len);
+ 	if (err) {
+-		bphy_err(wiphy, "Set Beacon IE Failed\n");
++		bphy_err(drvr, "Set Beacon IE Failed\n");
+ 		return err;
+ 	}
+ 	brcmf_dbg(TRACE, "Applied Vndr IEs for Beacon\n");
+@@ -4414,7 +4443,7 @@ brcmf_config_ap_mgmt_ie(struct brcmf_cfg
+ 				    beacon->proberesp_ies,
+ 				    beacon->proberesp_ies_len);
+ 	if (err)
+-		bphy_err(wiphy, "Set Probe Resp IE Failed\n");
++		bphy_err(drvr, "Set Probe Resp IE Failed\n");
+ 	else
+ 		brcmf_dbg(TRACE, "Applied Vndr IEs for Probe Resp\n");
+ 
+@@ -4428,6 +4457,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 	s32 ie_offset;
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	const struct brcmf_tlv *ssid_ie;
+ 	const struct brcmf_tlv *country_ie;
+ 	struct brcmf_ssid_le ssid_le;
+@@ -4523,7 +4553,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
+ 						    is_11d);
+ 			if (err < 0) {
+-				bphy_err(wiphy, "Regulatory Set Error, %d\n",
++				bphy_err(drvr, "Regulatory Set Error, %d\n",
+ 					 err);
+ 				goto exit;
+ 			}
+@@ -4532,7 +4562,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,
+ 						    settings->beacon_interval);
+ 			if (err < 0) {
+-				bphy_err(wiphy, "Beacon Interval Set Error, %d\n",
++				bphy_err(drvr, "Beacon Interval Set Error, %d\n",
+ 					 err);
+ 				goto exit;
+ 			}
+@@ -4541,7 +4571,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,
+ 						    settings->dtim_period);
+ 			if (err < 0) {
+-				bphy_err(wiphy, "DTIM Interval Set Error, %d\n",
++				bphy_err(drvr, "DTIM Interval Set Error, %d\n",
+ 					 err);
+ 				goto exit;
+ 			}
+@@ -4552,7 +4582,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 		     !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) {
+ 			err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
+ 			if (err < 0) {
+-				bphy_err(wiphy, "BRCMF_C_DOWN error %d\n",
++				bphy_err(drvr, "BRCMF_C_DOWN error %d\n",
+ 					 err);
+ 				goto exit;
+ 			}
+@@ -4561,7 +4591,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "SET INFRA error %d\n", err);
++			bphy_err(drvr, "SET INFRA error %d\n", err);
+ 			goto exit;
+ 		}
+ 	} else if (WARN_ON(supports_11d && (is_11d != ifp->vif->is_11d))) {
+@@ -4577,7 +4607,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "setting AP mode failed %d\n",
++			bphy_err(drvr, "setting AP mode failed %d\n",
+ 				 err);
+ 			goto exit;
+ 		}
+@@ -4587,14 +4617,14 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 			 */
+ 			err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
+ 			if (err < 0) {
+-				bphy_err(wiphy, "Set Channel failed: chspec=%d, %d\n",
++				bphy_err(drvr, "Set Channel failed: chspec=%d, %d\n",
+ 					 chanspec, err);
+ 				goto exit;
+ 			}
+ 		}
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "BRCMF_C_UP error (%d)\n", err);
++			bphy_err(drvr, "BRCMF_C_UP error (%d)\n", err);
+ 			goto exit;
+ 		}
+ 		/* On DOWN the firmware removes the WEP keys, reconfigure
+@@ -4609,14 +4639,14 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 					     &join_params, sizeof(join_params));
+ 		if (err < 0) {
+-			bphy_err(wiphy, "SET SSID error (%d)\n", err);
++			bphy_err(drvr, "SET SSID error (%d)\n", err);
+ 			goto exit;
+ 		}
+ 
+ 		if (settings->hidden_ssid) {
+ 			err = brcmf_fil_iovar_int_set(ifp, "closednet", 1);
+ 			if (err) {
+-				bphy_err(wiphy, "closednet error (%d)\n", err);
++				bphy_err(drvr, "closednet error (%d)\n", err);
+ 				goto exit;
+ 			}
+ 		}
+@@ -4625,14 +4655,14 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 	} else if (dev_role == NL80211_IFTYPE_P2P_GO) {
+ 		err = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);
+ 		if (err < 0) {
+-			bphy_err(wiphy, "Set Channel failed: chspec=%d, %d\n",
++			bphy_err(drvr, "Set Channel failed: chspec=%d, %d\n",
+ 				 chanspec, err);
+ 			goto exit;
+ 		}
+ 		err = brcmf_fil_bsscfg_data_set(ifp, "ssid", &ssid_le,
+ 						sizeof(ssid_le));
+ 		if (err < 0) {
+-			bphy_err(wiphy, "setting ssid failed %d\n", err);
++			bphy_err(drvr, "setting ssid failed %d\n", err);
+ 			goto exit;
+ 		}
+ 		bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx);
+@@ -4640,7 +4670,7 @@ brcmf_cfg80211_start_ap(struct wiphy *wi
+ 		err = brcmf_fil_iovar_data_set(ifp, "bss", &bss_enable,
+ 					       sizeof(bss_enable));
+ 		if (err < 0) {
+-			bphy_err(wiphy, "bss_enable config failed %d\n", err);
++			bphy_err(drvr, "bss_enable config failed %d\n", err);
+ 			goto exit;
+ 		}
+ 
+@@ -4663,7 +4693,9 @@ exit:
+ 
+ static int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err;
+ 	struct brcmf_fil_bss_enable_le bss_enable;
+ 	struct brcmf_join_params join_params;
+@@ -4688,13 +4720,13 @@ static int brcmf_cfg80211_stop_ap(struct
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,
+ 					     &join_params, sizeof(join_params));
+ 		if (err < 0)
+-			bphy_err(wiphy, "SET SSID error (%d)\n", err);
++			bphy_err(drvr, "SET SSID error (%d)\n", err);
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
+ 		if (err < 0)
+-			bphy_err(wiphy, "BRCMF_C_DOWN error %d\n", err);
++			bphy_err(drvr, "BRCMF_C_DOWN error %d\n", err);
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);
+ 		if (err < 0)
+-			bphy_err(wiphy, "setting AP mode failed %d\n", err);
++			bphy_err(drvr, "setting AP mode failed %d\n", err);
+ 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS))
+ 			brcmf_fil_iovar_int_set(ifp, "mbss", 0);
+ 		brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY,
+@@ -4702,7 +4734,7 @@ static int brcmf_cfg80211_stop_ap(struct
+ 		/* Bring device back up so it can be used again */
+ 		err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);
+ 		if (err < 0)
+-			bphy_err(wiphy, "BRCMF_C_UP error %d\n", err);
++			bphy_err(drvr, "BRCMF_C_UP error %d\n", err);
+ 
+ 		brcmf_vif_clear_mgmt_ies(ifp->vif);
+ 	} else {
+@@ -4711,7 +4743,7 @@ static int brcmf_cfg80211_stop_ap(struct
+ 		err = brcmf_fil_iovar_data_set(ifp, "bss", &bss_enable,
+ 					       sizeof(bss_enable));
+ 		if (err < 0)
+-			bphy_err(wiphy, "bss_enable config failed %d\n", err);
++			bphy_err(drvr, "bss_enable config failed %d\n", err);
+ 	}
+ 	brcmf_set_mpc(ifp, 1);
+ 	brcmf_configure_arp_nd_offload(ifp, true);
+@@ -4740,6 +4772,7 @@ brcmf_cfg80211_del_station(struct wiphy
+ 			   struct station_del_parameters *params)
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_scb_val_le scbval;
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	s32 err;
+@@ -4759,7 +4792,7 @@ brcmf_cfg80211_del_station(struct wiphy
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON,
+ 				     &scbval, sizeof(scbval));
+ 	if (err)
+-		bphy_err(wiphy, "SCB_DEAUTHENTICATE_FOR_REASON failed %d\n",
++		bphy_err(drvr, "SCB_DEAUTHENTICATE_FOR_REASON failed %d\n",
+ 			 err);
+ 
+ 	brcmf_dbg(TRACE, "Exit\n");
+@@ -4770,6 +4803,8 @@ static int
+ brcmf_cfg80211_change_station(struct wiphy *wiphy, struct net_device *ndev,
+ 			      const u8 *mac, struct station_parameters *params)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	s32 err;
+ 
+@@ -4790,7 +4825,7 @@ brcmf_cfg80211_change_station(struct wip
+ 		err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SCB_DEAUTHORIZE,
+ 					     (void *)mac, ETH_ALEN);
+ 	if (err < 0)
+-		bphy_err(wiphy, "Setting SCB (de-)authorize failed, %d\n", err);
++		bphy_err(drvr, "Setting SCB (de-)authorize failed, %d\n", err);
+ 
+ 	return err;
+ }
+@@ -4820,6 +4855,7 @@ brcmf_cfg80211_mgmt_tx(struct wiphy *wip
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct ieee80211_channel *chan = params->chan;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	const u8 *buf = params->buf;
+ 	size_t len = params->len;
+ 	const struct ieee80211_mgmt *mgmt;
+@@ -4840,7 +4876,7 @@ brcmf_cfg80211_mgmt_tx(struct wiphy *wip
+ 	mgmt = (const struct ieee80211_mgmt *)buf;
+ 
+ 	if (!ieee80211_is_mgmt(mgmt->frame_control)) {
+-		bphy_err(wiphy, "Driver only allows MGMT packet type\n");
++		bphy_err(drvr, "Driver only allows MGMT packet type\n");
+ 		return -EPERM;
+ 	}
+ 
+@@ -4871,13 +4907,13 @@ brcmf_cfg80211_mgmt_tx(struct wiphy *wip
+ 					GFP_KERNEL);
+ 	} else if (ieee80211_is_action(mgmt->frame_control)) {
+ 		if (len > BRCMF_FIL_ACTION_FRAME_SIZE + DOT11_MGMT_HDR_LEN) {
+-			bphy_err(wiphy, "invalid action frame length\n");
++			bphy_err(drvr, "invalid action frame length\n");
+ 			err = -EINVAL;
+ 			goto exit;
+ 		}
+ 		af_params = kzalloc(sizeof(*af_params), GFP_KERNEL);
+ 		if (af_params == NULL) {
+-			bphy_err(wiphy, "unable to allocate frame\n");
++			bphy_err(drvr, "unable to allocate frame\n");
+ 			err = -ENOMEM;
+ 			goto exit;
+ 		}
+@@ -4928,6 +4964,7 @@ brcmf_cfg80211_cancel_remain_on_channel(
+ 					u64 cookie)
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	int err = 0;
+ 
+@@ -4935,7 +4972,7 @@ brcmf_cfg80211_cancel_remain_on_channel(
+ 
+ 	vif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+ 	if (vif == NULL) {
+-		bphy_err(wiphy, "No p2p device available for probe response\n");
++		bphy_err(drvr, "No p2p device available for probe response\n");
+ 		err = -ENODEV;
+ 		goto exit;
+ 	}
+@@ -4950,6 +4987,7 @@ static int brcmf_cfg80211_get_channel(st
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct net_device *ndev = wdev->netdev;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_if *ifp;
+ 	struct brcmu_chan ch;
+ 	enum nl80211_band band = 0;
+@@ -4963,7 +5001,7 @@ static int brcmf_cfg80211_get_channel(st
+ 
+ 	err = brcmf_fil_iovar_int_get(ifp, "chanspec", &chanspec);
+ 	if (err) {
+-		bphy_err(wiphy, "chanspec failed (%d)\n", err);
++		bphy_err(drvr, "chanspec failed (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -5085,6 +5123,8 @@ static int brcmf_cfg80211_tdls_oper(stru
+ 				    struct net_device *ndev, const u8 *peer,
+ 				    enum nl80211_tdls_operation oper)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_if *ifp;
+ 	struct brcmf_tdls_iovar_le info;
+ 	int ret = 0;
+@@ -5102,7 +5142,7 @@ static int brcmf_cfg80211_tdls_oper(stru
+ 	ret = brcmf_fil_iovar_data_set(ifp, "tdls_endpoint",
+ 				       &info, sizeof(info));
+ 	if (ret < 0)
+-		bphy_err(wiphy, "tdls_endpoint iovar failed: ret=%d\n", ret);
++		bphy_err(drvr, "tdls_endpoint iovar failed: ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+@@ -5113,6 +5153,8 @@ brcmf_cfg80211_update_conn_params(struct
+ 				  struct cfg80211_connect_params *sme,
+ 				  u32 changed)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_if *ifp;
+ 	int err;
+ 
+@@ -5123,7 +5165,7 @@ brcmf_cfg80211_update_conn_params(struct
+ 	err = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,
+ 				    sme->ie, sme->ie_len);
+ 	if (err)
+-		bphy_err(wiphy, "Set Assoc REQ IE Failed\n");
++		bphy_err(drvr, "Set Assoc REQ IE Failed\n");
+ 	else
+ 		brcmf_dbg(TRACE, "Applied Vndr IEs for Assoc request\n");
+ 
+@@ -5135,6 +5177,8 @@ static int
+ brcmf_cfg80211_set_rekey_data(struct wiphy *wiphy, struct net_device *ndev,
+ 			      struct cfg80211_gtk_rekey_data *gtk)
+ {
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct brcmf_gtk_keyinfo_le gtk_le;
+ 	int ret;
+@@ -5149,7 +5193,7 @@ brcmf_cfg80211_set_rekey_data(struct wip
+ 	ret = brcmf_fil_iovar_data_set(ifp, "gtk_key_info", &gtk_le,
+ 				       sizeof(gtk_le));
+ 	if (ret < 0)
+-		bphy_err(wiphy, "gtk_key_info iovar failed: ret=%d\n", ret);
++		bphy_err(drvr, "gtk_key_info iovar failed: ret=%d\n", ret);
+ 
+ 	return ret;
+ }
+@@ -5384,7 +5428,7 @@ static void brcmf_clear_assoc_ies(struct
+ static s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_info *cfg,
+ 			       struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_assoc_ielen_le *assoc_info;
+ 	struct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);
+ 	u32 req_len;
+@@ -5396,7 +5440,7 @@ static s32 brcmf_get_assoc_ies(struct br
+ 	err = brcmf_fil_iovar_data_get(ifp, "assoc_info",
+ 				       cfg->extra_buf, WL_ASSOC_INFO_MAX);
+ 	if (err) {
+-		bphy_err(wiphy, "could not get assoc info (%d)\n", err);
++		bphy_err(drvr, "could not get assoc info (%d)\n", err);
+ 		return err;
+ 	}
+ 	assoc_info =
+@@ -5408,7 +5452,7 @@ static s32 brcmf_get_assoc_ies(struct br
+ 					       cfg->extra_buf,
+ 					       WL_ASSOC_INFO_MAX);
+ 		if (err) {
+-			bphy_err(wiphy, "could not get assoc req (%d)\n", err);
++			bphy_err(drvr, "could not get assoc req (%d)\n", err);
+ 			return err;
+ 		}
+ 		conn_info->req_ie_len = req_len;
+@@ -5426,7 +5470,7 @@ static s32 brcmf_get_assoc_ies(struct br
+ 					       cfg->extra_buf,
+ 					       WL_ASSOC_INFO_MAX);
+ 		if (err) {
+-			bphy_err(wiphy, "could not get assoc resp (%d)\n", err);
++			bphy_err(drvr, "could not get assoc resp (%d)\n", err);
+ 			return err;
+ 		}
+ 		conn_info->resp_ie_len = resp_len;
+@@ -5555,7 +5599,7 @@ brcmf_notify_connect_status_ap(struct br
+ 			       struct net_device *ndev,
+ 			       const struct brcmf_event_msg *e, void *data)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	static int generation;
+ 	u32 event = e->event_code;
+ 	u32 reason = e->reason;
+@@ -5573,7 +5617,7 @@ brcmf_notify_connect_status_ap(struct br
+ 	if (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&
+ 	    (reason == BRCMF_E_STATUS_SUCCESS)) {
+ 		if (!data) {
+-			bphy_err(wiphy, "No IEs present in ASSOC/REASSOC_IND\n");
++			bphy_err(drvr, "No IEs present in ASSOC/REASSOC_IND\n");
+ 			return -EINVAL;
+ 		}
+ 
+@@ -5865,7 +5909,7 @@ static void init_vif_event(struct brcmf_
+ 
+ static s32 brcmf_dongle_roam(struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err;
+ 	u32 bcn_timeout;
+ 	__le32 roamtrigger[2];
+@@ -5878,7 +5922,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 		bcn_timeout = BRCMF_DEFAULT_BCN_TIMEOUT_ROAM_ON;
+ 	err = brcmf_fil_iovar_int_set(ifp, "bcn_timeout", bcn_timeout);
+ 	if (err) {
+-		bphy_err(wiphy, "bcn_timeout error (%d)\n", err);
++		bphy_err(drvr, "bcn_timeout error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5890,7 +5934,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	err = brcmf_fil_iovar_int_set(ifp, "roam_off",
+ 				      ifp->drvr->settings->roamoff);
+ 	if (err) {
+-		bphy_err(wiphy, "roam_off error (%d)\n", err);
++		bphy_err(drvr, "roam_off error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5899,7 +5943,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,
+ 				     (void *)roamtrigger, sizeof(roamtrigger));
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_SET_ROAM_TRIGGER error (%d)\n", err);
++		bphy_err(drvr, "WLC_SET_ROAM_TRIGGER error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5908,7 +5952,7 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,
+ 				     (void *)roam_delta, sizeof(roam_delta));
+ 	if (err) {
+-		bphy_err(wiphy, "WLC_SET_ROAM_DELTA error (%d)\n", err);
++		bphy_err(drvr, "WLC_SET_ROAM_DELTA error (%d)\n", err);
+ 		goto roam_setup_done;
+ 	}
+ 
+@@ -5919,26 +5963,26 @@ roam_setup_done:
+ static s32
+ brcmf_dongle_scantime(struct brcmf_if *ifp)
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 err = 0;
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,
+ 				    BRCMF_SCAN_CHANNEL_TIME);
+ 	if (err) {
+-		bphy_err(wiphy, "Scan assoc time error (%d)\n", err);
++		bphy_err(drvr, "Scan assoc time error (%d)\n", err);
+ 		goto dongle_scantime_out;
+ 	}
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,
+ 				    BRCMF_SCAN_UNASSOC_TIME);
+ 	if (err) {
+-		bphy_err(wiphy, "Scan unassoc time error (%d)\n", err);
++		bphy_err(drvr, "Scan unassoc time error (%d)\n", err);
+ 		goto dongle_scantime_out;
+ 	}
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,
+ 				    BRCMF_SCAN_PASSIVE_TIME);
+ 	if (err) {
+-		bphy_err(wiphy, "Scan passive time error (%d)\n", err);
++		bphy_err(drvr, "Scan passive time error (%d)\n", err);
+ 		goto dongle_scantime_out;
+ 	}
+ 
+@@ -5971,7 +6015,8 @@ static int brcmf_construct_chaninfo(stru
+ 				    u32 bw_cap[])
+ {
+ 	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+-	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
++	struct brcmf_pub *drvr = cfg->pub;
++	struct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);
+ 	struct ieee80211_supported_band *band;
+ 	struct ieee80211_channel *channel;
+ 	struct brcmf_chanspec_list *list;
+@@ -5992,7 +6037,7 @@ static int brcmf_construct_chaninfo(stru
+ 	err = brcmf_fil_iovar_data_get(ifp, "chanspecs", pbuf,
+ 				       BRCMF_DCMD_MEDLEN);
+ 	if (err) {
+-		bphy_err(wiphy, "get chanspecs error (%d)\n", err);
++		bphy_err(drvr, "get chanspecs error (%d)\n", err);
+ 		goto fail_pbuf;
+ 	}
+ 
+@@ -6015,7 +6060,7 @@ static int brcmf_construct_chaninfo(stru
+ 		} else if (ch.band == BRCMU_CHAN_BAND_5G) {
+ 			band = wiphy->bands[NL80211_BAND_5GHZ];
+ 		} else {
+-			bphy_err(wiphy, "Invalid channel Spec. 0x%x.\n",
++			bphy_err(drvr, "Invalid channel Spec. 0x%x.\n",
+ 				 ch.chspec);
+ 			continue;
+ 		}
+@@ -6039,7 +6084,7 @@ static int brcmf_construct_chaninfo(stru
+ 			/* It seems firmware supports some channel we never
+ 			 * considered. Something new in IEEE standard?
+ 			 */
+-			bphy_err(wiphy, "Ignoring unexpected firmware channel %d\n",
++			bphy_err(drvr, "Ignoring unexpected firmware channel %d\n",
+ 				 ch.control_ch_num);
+ 			continue;
+ 		}
+@@ -6096,8 +6141,8 @@ fail_pbuf:
+ 
+ static int brcmf_enable_bw40_2g(struct brcmf_cfg80211_info *cfg)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+-	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
++	struct brcmf_pub *drvr = cfg->pub;
++	struct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);
+ 	struct ieee80211_supported_band *band;
+ 	struct brcmf_fil_bwcap_le band_bwcap;
+ 	struct brcmf_chanspec_list *list;
+@@ -6143,7 +6188,7 @@ static int brcmf_enable_bw40_2g(struct b
+ 		err = brcmf_fil_iovar_data_get(ifp, "chanspecs", pbuf,
+ 					       BRCMF_DCMD_MEDLEN);
+ 		if (err) {
+-			bphy_err(wiphy, "get chanspecs error (%d)\n", err);
++			bphy_err(drvr, "get chanspecs error (%d)\n", err);
+ 			kfree(pbuf);
+ 			return err;
+ 		}
+@@ -6174,7 +6219,7 @@ static int brcmf_enable_bw40_2g(struct b
+ 
+ static void brcmf_get_bwcap(struct brcmf_if *ifp, u32 bw_cap[])
+ {
+-	struct wiphy *wiphy = ifp->drvr->wiphy;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	u32 band, mimo_bwcap;
+ 	int err;
+ 
+@@ -6210,7 +6255,7 @@ static void brcmf_get_bwcap(struct brcmf
+ 		bw_cap[NL80211_BAND_5GHZ] |= WLC_BW_20MHZ_BIT;
+ 		break;
+ 	default:
+-		bphy_err(wiphy, "invalid mimo_bw_cap value\n");
++		bphy_err(drvr, "invalid mimo_bw_cap value\n");
+ 	}
+ }
+ 
+@@ -6285,7 +6330,8 @@ static void brcmf_update_vht_cap(struct
+ 
+ static int brcmf_setup_wiphybands(struct brcmf_cfg80211_info *cfg)
+ {
+-	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
++	struct brcmf_pub *drvr = cfg->pub;
++	struct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);
+ 	struct wiphy *wiphy = cfg_to_wiphy(cfg);
+ 	u32 nmode = 0;
+ 	u32 vhtmode = 0;
+@@ -6302,7 +6348,7 @@ static int brcmf_setup_wiphybands(struct
+ 	(void)brcmf_fil_iovar_int_get(ifp, "vhtmode", &vhtmode);
+ 	err = brcmf_fil_iovar_int_get(ifp, "nmode", &nmode);
+ 	if (err) {
+-		bphy_err(wiphy, "nmode error (%d)\n", err);
++		bphy_err(drvr, "nmode error (%d)\n", err);
+ 	} else {
+ 		brcmf_get_bwcap(ifp, bw_cap);
+ 	}
+@@ -6312,7 +6358,7 @@ static int brcmf_setup_wiphybands(struct
+ 
+ 	err = brcmf_fil_iovar_int_get(ifp, "rxchain", &rxchain);
+ 	if (err) {
+-		bphy_err(wiphy, "rxchain error (%d)\n", err);
++		bphy_err(drvr, "rxchain error (%d)\n", err);
+ 		nchain = 1;
+ 	} else {
+ 		for (nchain = 0; rxchain; nchain++)
+@@ -6322,7 +6368,7 @@ static int brcmf_setup_wiphybands(struct
+ 
+ 	err = brcmf_construct_chaninfo(cfg, bw_cap);
+ 	if (err) {
+-		bphy_err(wiphy, "brcmf_construct_chaninfo failed (%d)\n", err);
++		bphy_err(drvr, "brcmf_construct_chaninfo failed (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -6529,12 +6575,13 @@ static void brcmf_wiphy_wowl_params(stru
+ {
+ #ifdef CONFIG_PM
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct wiphy_wowlan_support *wowl;
+ 
+ 	wowl = kmemdup(&brcmf_wowlan_support, sizeof(brcmf_wowlan_support),
+ 		       GFP_KERNEL);
+ 	if (!wowl) {
+-		bphy_err(wiphy, "only support basic wowlan features\n");
++		bphy_err(drvr, "only support basic wowlan features\n");
+ 		wiphy->wowlan = &brcmf_wowlan_support;
+ 		return;
+ 	}
+@@ -6631,7 +6678,7 @@ static int brcmf_setup_wiphy(struct wiph
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST, &bandlist,
+ 				     sizeof(bandlist));
+ 	if (err) {
+-		bphy_err(wiphy, "could not obtain band info: err=%d\n", err);
++		bphy_err(drvr, "could not obtain band info: err=%d\n", err);
+ 		return err;
+ 	}
+ 	/* first entry in bandlist is number of bands */
+@@ -6680,7 +6727,7 @@ static int brcmf_setup_wiphy(struct wiph
+ 
+ static s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)
+ {
+-	struct wiphy *wiphy = cfg_to_wiphy(cfg);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct net_device *ndev;
+ 	struct wireless_dev *wdev;
+ 	struct brcmf_if *ifp;
+@@ -6718,7 +6765,7 @@ static s32 brcmf_config_dongle(struct br
+ 
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_FAKEFRAG, 1);
+ 	if (err) {
+-		bphy_err(wiphy, "failed to set frameburst mode\n");
++		bphy_err(drvr, "failed to set frameburst mode\n");
+ 		goto default_conf_out;
+ 	}
+ 
+@@ -6899,6 +6946,7 @@ static void brcmf_cfg80211_reg_notifier(
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_fil_country_le ccreq;
+ 	s32 err;
+ 	int i;
+@@ -6910,7 +6958,7 @@ static void brcmf_cfg80211_reg_notifier(
+ 	/* ignore non-ISO3166 country codes */
+ 	for (i = 0; i < 2; i++)
+ 		if (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {
+-			bphy_err(wiphy, "not an ISO3166 code (0x%02x 0x%02x)\n",
++			bphy_err(drvr, "not an ISO3166 code (0x%02x 0x%02x)\n",
+ 				 req->alpha2[0], req->alpha2[1]);
+ 			return;
+ 		}
+@@ -6920,7 +6968,7 @@ static void brcmf_cfg80211_reg_notifier(
+ 
+ 	err = brcmf_fil_iovar_data_get(ifp, "country", &ccreq, sizeof(ccreq));
+ 	if (err) {
+-		bphy_err(wiphy, "Country code iovar returned err = %d\n", err);
++		bphy_err(drvr, "Country code iovar returned err = %d\n", err);
+ 		return;
+ 	}
+ 
+@@ -6930,7 +6978,7 @@ static void brcmf_cfg80211_reg_notifier(
+ 
+ 	err = brcmf_fil_iovar_data_set(ifp, "country", &ccreq, sizeof(ccreq));
+ 	if (err) {
+-		bphy_err(wiphy, "Firmware rejected country setting\n");
++		bphy_err(drvr, "Firmware rejected country setting\n");
+ 		return;
+ 	}
+ 	brcmf_setup_wiphybands(cfg);
+@@ -6976,13 +7024,13 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 	u16 *cap = NULL;
+ 
+ 	if (!ndev) {
+-		bphy_err(wiphy, "ndev is invalid\n");
++		bphy_err(drvr, "ndev is invalid\n");
+ 		return NULL;
+ 	}
+ 
+ 	cfg = kzalloc(sizeof(*cfg), GFP_KERNEL);
+ 	if (!cfg) {
+-		bphy_err(wiphy, "Could not allocate wiphy device\n");
++		bphy_err(drvr, "Could not allocate wiphy device\n");
+ 		return NULL;
+ 	}
+ 
+@@ -7003,7 +7051,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 
+ 	err = wl_init_priv(cfg);
+ 	if (err) {
+-		bphy_err(wiphy, "Failed to init iwm_priv (%d)\n", err);
++		bphy_err(drvr, "Failed to init iwm_priv (%d)\n", err);
+ 		brcmf_free_vif(vif);
+ 		goto wiphy_out;
+ 	}
+@@ -7012,7 +7060,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 	/* determine d11 io type before wiphy setup */
+ 	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_VERSION, &io_type);
+ 	if (err) {
+-		bphy_err(wiphy, "Failed to get D11 version (%d)\n", err);
++		bphy_err(drvr, "Failed to get D11 version (%d)\n", err);
+ 		goto priv_out;
+ 	}
+ 	cfg->d11inf.io_type = (u8)io_type;
+@@ -7046,13 +7094,13 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ #endif
+ 	err = wiphy_register(wiphy);
+ 	if (err < 0) {
+-		bphy_err(wiphy, "Could not register wiphy device (%d)\n", err);
++		bphy_err(drvr, "Could not register wiphy device (%d)\n", err);
+ 		goto priv_out;
+ 	}
+ 
+ 	err = brcmf_setup_wiphybands(cfg);
+ 	if (err) {
+-		bphy_err(wiphy, "Setting wiphy bands failed (%d)\n", err);
++		bphy_err(drvr, "Setting wiphy bands failed (%d)\n", err);
+ 		goto wiphy_unreg_out;
+ 	}
+ 
+@@ -7070,24 +7118,24 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 
+ 	err = brcmf_fweh_activate_events(ifp);
+ 	if (err) {
+-		bphy_err(wiphy, "FWEH activation failed (%d)\n", err);
++		bphy_err(drvr, "FWEH activation failed (%d)\n", err);
+ 		goto wiphy_unreg_out;
+ 	}
+ 
+ 	err = brcmf_p2p_attach(cfg, p2pdev_forced);
+ 	if (err) {
+-		bphy_err(wiphy, "P2P initialisation failed (%d)\n", err);
++		bphy_err(drvr, "P2P initialisation failed (%d)\n", err);
+ 		goto wiphy_unreg_out;
+ 	}
+ 	err = brcmf_btcoex_attach(cfg);
+ 	if (err) {
+-		bphy_err(wiphy, "BT-coex initialisation failed (%d)\n", err);
++		bphy_err(drvr, "BT-coex initialisation failed (%d)\n", err);
+ 		brcmf_p2p_detach(&cfg->p2p);
+ 		goto wiphy_unreg_out;
+ 	}
+ 	err = brcmf_pno_attach(cfg);
+ 	if (err) {
+-		bphy_err(wiphy, "PNO initialisation failed (%d)\n", err);
++		bphy_err(drvr, "PNO initialisation failed (%d)\n", err);
+ 		brcmf_btcoex_detach(cfg);
+ 		brcmf_p2p_detach(&cfg->p2p);
+ 		goto wiphy_unreg_out;
+@@ -7107,7 +7155,7 @@ struct brcmf_cfg80211_info *brcmf_cfg802
+ 	/* (re-) activate FWEH event handling */
+ 	err = brcmf_fweh_activate_events(ifp);
+ 	if (err) {
+-		bphy_err(wiphy, "FWEH activation failed (%d)\n", err);
++		bphy_err(drvr, "FWEH activation failed (%d)\n", err);
+ 		goto detach;
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+@@ -62,12 +62,12 @@ void __brcmf_err(struct brcmf_bus *bus,
+ 	} while (0)
+ #endif
+ 
+-#define bphy_err(wiphy, fmt, ...)					\
++#define bphy_err(drvr, fmt, ...)					\
+ 	do {								\
+ 		if (IS_ENABLED(CPTCFG_BRCMDBG) ||			\
+ 		    IS_ENABLED(CPTCFG_BRCM_TRACING) ||			\
+ 		    net_ratelimit())					\
+-			wiphy_err(wiphy, "%s: " fmt, __func__,		\
++			wiphy_err((drvr)->wiphy, "%s: " fmt, __func__,	\
+ 				  ##__VA_ARGS__);			\
+ 	} while (0)
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/353-v5.1-brcmfmac-remove-set-but-not-used-variable-old_state.patch b/package/kernel/mac80211/patches/brcm/353-v5.1-brcmfmac-remove-set-but-not-used-variable-old_state.patch
--- a/package/kernel/mac80211/patches/brcm/353-v5.1-brcmfmac-remove-set-but-not-used-variable-old_state.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/353-v5.1-brcmfmac-remove-set-but-not-used-variable-old_state.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,38 @@
+From e4d1b2716b8859199c28f2ac5f984bd05a146a6b Mon Sep 17 00:00:00 2001
+From: YueHaibing <yuehaibing@huawei.com>
+Date: Mon, 18 Feb 2019 08:08:46 +0000
+Subject: [PATCH] brcmfmac: remove set but not used variable 'old_state'
+
+Fixes gcc '-Wunused-but-set-variable' warning:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c: In function 'brcmf_usb_state_change':
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c:578:6: warning:
+ variable 'old_state' set but not used [-Wunused-but-set-variable]
+
+It's never used and can be removed.
+
+Signed-off-by: YueHaibing <yuehaibing@huawei.com>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -576,7 +576,6 @@ static void
+ brcmf_usb_state_change(struct brcmf_usbdev_info *devinfo, int state)
+ {
+ 	struct brcmf_bus *bcmf_bus = devinfo->bus_pub.bus;
+-	int old_state;
+ 
+ 	brcmf_dbg(USB, "Enter, current state=%d, new state=%d\n",
+ 		  devinfo->bus_pub.state, state);
+@@ -584,7 +583,6 @@ brcmf_usb_state_change(struct brcmf_usbd
+ 	if (devinfo->bus_pub.state == state)
+ 		return;
+ 
+-	old_state = devinfo->bus_pub.state;
+ 	devinfo->bus_pub.state = state;
+ 
+ 	/* update state of upper layer */
diff -uprN a/package/kernel/mac80211/patches/brcm/354-v5.1-brcmfmac-use-bphy_err-in-all-wiphy-related-code.patch b/package/kernel/mac80211/patches/brcm/354-v5.1-brcmfmac-use-bphy_err-in-all-wiphy-related-code.patch
--- a/package/kernel/mac80211/patches/brcm/354-v5.1-brcmfmac-use-bphy_err-in-all-wiphy-related-code.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/354-v5.1-brcmfmac-use-bphy_err-in-all-wiphy-related-code.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,1707 @@
+From dcb1471bc6d0541d636c7ecd9239573304842884 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 19 Feb 2019 23:42:19 +0100
+Subject: [PATCH] brcmfmac: use bphy_err() in all wiphy-related code
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This recently added macro provides more meaningful error messages thanks
+to identifying a specific wiphy. It's especially important on systems
+with few cards supported by the same (brcmfmac) driver.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/bcdc.c        | 22 ++---
+ .../broadcom/brcm80211/brcmfmac/common.c      | 39 ++++----
+ .../broadcom/brcm80211/brcmfmac/core.c        | 74 ++++++++--------
+ .../broadcom/brcm80211/brcmfmac/feature.c     |  8 +-
+ .../broadcom/brcm80211/brcmfmac/fweh.c        | 25 +++---
+ .../broadcom/brcm80211/brcmfmac/fwil.c        | 10 +--
+ .../broadcom/brcm80211/brcmfmac/fwsignal.c    | 38 ++++----
+ .../broadcom/brcm80211/brcmfmac/msgbuf.c      | 65 ++++++++------
+ .../broadcom/brcm80211/brcmfmac/p2p.c         | 88 +++++++++++--------
+ .../broadcom/brcm80211/brcmfmac/pno.c         | 22 +++--
+ .../broadcom/brcm80211/brcmfmac/proto.c       |  6 +-
+ 11 files changed, 224 insertions(+), 173 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c
+@@ -178,8 +178,8 @@ brcmf_proto_bcdc_query_dcmd(struct brcmf
+ 	*fwerr = 0;
+ 	ret = brcmf_proto_bcdc_msg(drvr, ifidx, cmd, buf, len, false);
+ 	if (ret < 0) {
+-		brcmf_err("brcmf_proto_bcdc_msg failed w/status %d\n",
+-			  ret);
++		bphy_err(drvr, "brcmf_proto_bcdc_msg failed w/status %d\n",
++			 ret);
+ 		goto done;
+ 	}
+ 
+@@ -195,9 +195,9 @@ retry:
+ 	if ((id < bcdc->reqid) && (++retries < RETRIES))
+ 		goto retry;
+ 	if (id != bcdc->reqid) {
+-		brcmf_err("%s: unexpected request id %d (expected %d)\n",
+-			  brcmf_ifname(brcmf_get_ifp(drvr, ifidx)), id,
+-			  bcdc->reqid);
++		bphy_err(drvr, "%s: unexpected request id %d (expected %d)\n",
++			 brcmf_ifname(brcmf_get_ifp(drvr, ifidx)), id,
++			 bcdc->reqid);
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+@@ -245,9 +245,9 @@ brcmf_proto_bcdc_set_dcmd(struct brcmf_p
+ 	id = (flags & BCDC_DCMD_ID_MASK) >> BCDC_DCMD_ID_SHIFT;
+ 
+ 	if (id != bcdc->reqid) {
+-		brcmf_err("%s: unexpected request id %d (expected %d)\n",
+-			  brcmf_ifname(brcmf_get_ifp(drvr, ifidx)), id,
+-			  bcdc->reqid);
++		bphy_err(drvr, "%s: unexpected request id %d (expected %d)\n",
++			 brcmf_ifname(brcmf_get_ifp(drvr, ifidx)), id,
++			 bcdc->reqid);
+ 		ret = -EINVAL;
+ 		goto done;
+ 	}
+@@ -312,8 +312,8 @@ brcmf_proto_bcdc_hdrpull(struct brcmf_pu
+ 	}
+ 	if (((h->flags & BCDC_FLAG_VER_MASK) >> BCDC_FLAG_VER_SHIFT) !=
+ 	    BCDC_PROTO_VER) {
+-		brcmf_err("%s: non-BCDC packet received, flags 0x%x\n",
+-			  brcmf_ifname(tmp_if), h->flags);
++		bphy_err(drvr, "%s: non-BCDC packet received, flags 0x%x\n",
++			 brcmf_ifname(tmp_if), h->flags);
+ 		return -EBADE;
+ 	}
+ 
+@@ -460,7 +460,7 @@ int brcmf_proto_bcdc_attach(struct brcmf
+ 
+ 	/* ensure that the msg buf directly follows the cdc msg struct */
+ 	if ((unsigned long)(&bcdc->msg + 1) != (unsigned long)bcdc->buf) {
+-		brcmf_err("struct brcmf_proto_bcdc is not correctly defined\n");
++		bphy_err(drvr, "struct brcmf_proto_bcdc is not correctly defined\n");
+ 		goto fail;
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -90,6 +90,7 @@ struct brcmf_mp_global_t brcmf_mp_global
+ 
+ void brcmf_c_set_joinpref_default(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_join_pref_params join_pref_params[2];
+ 	int err;
+ 
+@@ -106,7 +107,7 @@ void brcmf_c_set_joinpref_default(struct
+ 	err = brcmf_fil_iovar_data_set(ifp, "join_pref", join_pref_params,
+ 				       sizeof(join_pref_params));
+ 	if (err)
+-		brcmf_err("Set join_pref error (%d)\n", err);
++		bphy_err(drvr, "Set join_pref error (%d)\n", err);
+ }
+ 
+ static int brcmf_c_download(struct brcmf_if *ifp, u16 flag,
+@@ -129,7 +130,8 @@ static int brcmf_c_download(struct brcmf
+ 
+ static int brcmf_c_process_clm_blob(struct brcmf_if *ifp)
+ {
+-	struct brcmf_bus *bus = ifp->drvr->bus_if;
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_bus *bus = drvr->bus_if;
+ 	struct brcmf_dload_data_le *chunk_buf;
+ 	const struct firmware *clm = NULL;
+ 	u8 clm_name[BRCMF_FW_NAME_LEN];
+@@ -145,7 +147,7 @@ static int brcmf_c_process_clm_blob(stru
+ 	memset(clm_name, 0, sizeof(clm_name));
+ 	err = brcmf_bus_get_fwname(bus, ".clm_blob", clm_name);
+ 	if (err) {
+-		brcmf_err("get CLM blob file name failed (%d)\n", err);
++		bphy_err(drvr, "get CLM blob file name failed (%d)\n", err);
+ 		return err;
+ 	}
+ 
+@@ -182,12 +184,12 @@ static int brcmf_c_process_clm_blob(stru
+ 	} while ((datalen > 0) && (err == 0));
+ 
+ 	if (err) {
+-		brcmf_err("clmload (%zu byte file) failed (%d); ",
+-			  clm->size, err);
++		bphy_err(drvr, "clmload (%zu byte file) failed (%d)\n",
++			 clm->size, err);
+ 		/* Retrieve clmload_status and print */
+ 		err = brcmf_fil_iovar_int_get(ifp, "clmload_status", &status);
+ 		if (err)
+-			brcmf_err("get clmload_status failed (%d)\n", err);
++			bphy_err(drvr, "get clmload_status failed (%d)\n", err);
+ 		else
+ 			brcmf_dbg(INFO, "clmload_status=%d\n", status);
+ 		err = -EIO;
+@@ -201,6 +203,7 @@ done:
+ 
+ int brcmf_c_preinit_dcmds(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s8 eventmask[BRCMF_EVENTING_MASK_LEN];
+ 	u8 buf[BRCMF_DCMD_SMLEN];
+ 	struct brcmf_bus *bus;
+@@ -214,7 +217,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	err = brcmf_fil_iovar_data_get(ifp, "cur_etheraddr", ifp->mac_addr,
+ 				       sizeof(ifp->mac_addr));
+ 	if (err < 0) {
+-		brcmf_err("Retrieving cur_etheraddr failed, %d\n", err);
++		bphy_err(drvr, "Retrieving cur_etheraddr failed, %d\n", err);
+ 		goto done;
+ 	}
+ 	memcpy(ifp->drvr->wiphy->perm_addr, ifp->drvr->mac, ETH_ALEN);
+@@ -226,7 +229,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	err = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_REVINFO,
+ 				     &revinfo, sizeof(revinfo));
+ 	if (err < 0) {
+-		brcmf_err("retrieving revision info failed, %d\n", err);
++		bphy_err(drvr, "retrieving revision info failed, %d\n", err);
+ 		strlcpy(ri->chipname, "UNKNOWN", sizeof(ri->chipname));
+ 	} else {
+ 		ri->vendorid = le32_to_cpu(revinfo.vendorid);
+@@ -260,7 +263,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	/* Do any CLM downloading */
+ 	err = brcmf_c_process_clm_blob(ifp);
+ 	if (err < 0) {
+-		brcmf_err("download CLM blob file failed, %d\n", err);
++		bphy_err(drvr, "download CLM blob file failed, %d\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -269,8 +272,8 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	strcpy(buf, "ver");
+ 	err = brcmf_fil_iovar_data_get(ifp, "ver", buf, sizeof(buf));
+ 	if (err < 0) {
+-		brcmf_err("Retrieving version information failed, %d\n",
+-			  err);
++		bphy_err(drvr, "Retrieving version information failed, %d\n",
++			 err);
+ 		goto done;
+ 	}
+ 	ptr = (char *)buf;
+@@ -304,7 +307,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	/* set mpc */
+ 	err = brcmf_fil_iovar_int_set(ifp, "mpc", 1);
+ 	if (err) {
+-		brcmf_err("failed setting mpc\n");
++		bphy_err(drvr, "failed setting mpc\n");
+ 		goto done;
+ 	}
+ 
+@@ -314,14 +317,14 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	err = brcmf_fil_iovar_data_get(ifp, "event_msgs", eventmask,
+ 				       BRCMF_EVENTING_MASK_LEN);
+ 	if (err) {
+-		brcmf_err("Get event_msgs error (%d)\n", err);
++		bphy_err(drvr, "Get event_msgs error (%d)\n", err);
+ 		goto done;
+ 	}
+ 	setbit(eventmask, BRCMF_E_IF);
+ 	err = brcmf_fil_iovar_data_set(ifp, "event_msgs", eventmask,
+ 				       BRCMF_EVENTING_MASK_LEN);
+ 	if (err) {
+-		brcmf_err("Set event_msgs error (%d)\n", err);
++		bphy_err(drvr, "Set event_msgs error (%d)\n", err);
+ 		goto done;
+ 	}
+ 
+@@ -329,8 +332,8 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,
+ 				    BRCMF_DEFAULT_SCAN_CHANNEL_TIME);
+ 	if (err) {
+-		brcmf_err("BRCMF_C_SET_SCAN_CHANNEL_TIME error (%d)\n",
+-			  err);
++		bphy_err(drvr, "BRCMF_C_SET_SCAN_CHANNEL_TIME error (%d)\n",
++			 err);
+ 		goto done;
+ 	}
+ 
+@@ -338,8 +341,8 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,
+ 				    BRCMF_DEFAULT_SCAN_UNASSOC_TIME);
+ 	if (err) {
+-		brcmf_err("BRCMF_C_SET_SCAN_UNASSOC_TIME error (%d)\n",
+-			  err);
++		bphy_err(drvr, "BRCMF_C_SET_SCAN_UNASSOC_TIME error (%d)\n",
++			 err);
+ 		goto done;
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -90,7 +90,7 @@ struct brcmf_if *brcmf_get_ifp(struct br
+ 	s32 bsscfgidx;
+ 
+ 	if (ifidx < 0 || ifidx >= BRCMF_MAX_IFS) {
+-		brcmf_err("ifidx %d out of range\n", ifidx);
++		bphy_err(drvr, "ifidx %d out of range\n", ifidx);
+ 		return NULL;
+ 	}
+ 
+@@ -141,7 +141,9 @@ void brcmf_configure_arp_nd_offload(stru
+ 
+ static void _brcmf_set_multicast_list(struct work_struct *work)
+ {
+-	struct brcmf_if *ifp;
++	struct brcmf_if *ifp = container_of(work, struct brcmf_if,
++					    multicast_work);
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct net_device *ndev;
+ 	struct netdev_hw_addr *ha;
+ 	u32 cmd_value, cnt;
+@@ -150,8 +152,6 @@ static void _brcmf_set_multicast_list(st
+ 	u32 buflen;
+ 	s32 err;
+ 
+-	ifp = container_of(work, struct brcmf_if, multicast_work);
+-
+ 	brcmf_dbg(TRACE, "Enter, bsscfgidx=%d\n", ifp->bsscfgidx);
+ 
+ 	ndev = ifp->ndev;
+@@ -181,7 +181,7 @@ static void _brcmf_set_multicast_list(st
+ 
+ 	err = brcmf_fil_iovar_data_set(ifp, "mcast_list", buf, buflen);
+ 	if (err < 0) {
+-		brcmf_err("Setting mcast_list failed, %d\n", err);
++		bphy_err(drvr, "Setting mcast_list failed, %d\n", err);
+ 		cmd_value = cnt ? true : cmd_value;
+ 	}
+ 
+@@ -194,25 +194,25 @@ static void _brcmf_set_multicast_list(st
+ 	 */
+ 	err = brcmf_fil_iovar_int_set(ifp, "allmulti", cmd_value);
+ 	if (err < 0)
+-		brcmf_err("Setting allmulti failed, %d\n", err);
++		bphy_err(drvr, "Setting allmulti failed, %d\n", err);
+ 
+ 	/*Finally, pick up the PROMISC flag */
+ 	cmd_value = (ndev->flags & IFF_PROMISC) ? true : false;
+ 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PROMISC, cmd_value);
+ 	if (err < 0)
+-		brcmf_err("Setting BRCMF_C_SET_PROMISC failed, %d\n",
+-			  err);
++		bphy_err(drvr, "Setting BRCMF_C_SET_PROMISC failed, %d\n",
++			 err);
+ 	brcmf_configure_arp_nd_offload(ifp, !cmd_value);
+ }
+ 
+ #if IS_ENABLED(CONFIG_IPV6)
+ static void _brcmf_update_ndtable(struct work_struct *work)
+ {
+-	struct brcmf_if *ifp;
++	struct brcmf_if *ifp = container_of(work, struct brcmf_if,
++					    ndoffload_work);
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int i, ret;
+ 
+-	ifp = container_of(work, struct brcmf_if, ndoffload_work);
+-
+ 	/* clear the table in firmware */
+ 	ret = brcmf_fil_iovar_data_set(ifp, "nd_hostip_clear", NULL, 0);
+ 	if (ret) {
+@@ -225,7 +225,7 @@ static void _brcmf_update_ndtable(struct
+ 					       &ifp->ipv6_addr_tbl[i],
+ 					       sizeof(struct in6_addr));
+ 		if (ret)
+-			brcmf_err("add nd ip err %d\n", ret);
++			bphy_err(drvr, "add nd ip err %d\n", ret);
+ 	}
+ }
+ #else
+@@ -238,6 +238,7 @@ static int brcmf_netdev_set_mac_address(
+ {
+ 	struct brcmf_if *ifp = netdev_priv(ndev);
+ 	struct sockaddr *sa = (struct sockaddr *)addr;
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int err;
+ 
+ 	brcmf_dbg(TRACE, "Enter, bsscfgidx=%d\n", ifp->bsscfgidx);
+@@ -245,7 +246,7 @@ static int brcmf_netdev_set_mac_address(
+ 	err = brcmf_fil_iovar_data_set(ifp, "cur_etheraddr", sa->sa_data,
+ 				       ETH_ALEN);
+ 	if (err < 0) {
+-		brcmf_err("Setting cur_etheraddr failed, %d\n", err);
++		bphy_err(drvr, "Setting cur_etheraddr failed, %d\n", err);
+ 	} else {
+ 		brcmf_dbg(TRACE, "updated to %pM\n", sa->sa_data);
+ 		memcpy(ifp->mac_addr, sa->sa_data, ETH_ALEN);
+@@ -305,7 +306,7 @@ static netdev_tx_t brcmf_netdev_start_xm
+ 
+ 	/* Can the device send data? */
+ 	if (drvr->bus_if->state != BRCMF_BUS_UP) {
+-		brcmf_err("xmit rejected state=%d\n", drvr->bus_if->state);
++		bphy_err(drvr, "xmit rejected state=%d\n", drvr->bus_if->state);
+ 		netif_stop_queue(ndev);
+ 		dev_kfree_skb(skb);
+ 		ret = -ENODEV;
+@@ -339,8 +340,8 @@ static netdev_tx_t brcmf_netdev_start_xm
+ 		ret = pskb_expand_head(skb, ALIGN(head_delta, NET_SKB_PAD), 0,
+ 				       GFP_ATOMIC);
+ 		if (ret < 0) {
+-			brcmf_err("%s: failed to expand headroom\n",
+-				  brcmf_ifname(ifp));
++			bphy_err(drvr, "%s: failed to expand headroom\n",
++				 brcmf_ifname(ifp));
+ 			atomic_inc(&drvr->bus_if->stats.pktcow_failed);
+ 			goto done;
+ 		}
+@@ -607,7 +608,7 @@ static int brcmf_netdev_open(struct net_
+ 
+ 	/* If bus is not ready, can't continue */
+ 	if (bus_if->state != BRCMF_BUS_UP) {
+-		brcmf_err("failed bus is not ready\n");
++		bphy_err(drvr, "failed bus is not ready\n");
+ 		return -EAGAIN;
+ 	}
+ 
+@@ -621,7 +622,7 @@ static int brcmf_netdev_open(struct net_
+ 		ndev->features &= ~NETIF_F_IP_CSUM;
+ 
+ 	if (brcmf_cfg80211_up(ndev)) {
+-		brcmf_err("failed to bring up cfg80211\n");
++		bphy_err(drvr, "failed to bring up cfg80211\n");
+ 		return -EIO;
+ 	}
+ 
+@@ -683,7 +684,7 @@ int brcmf_net_attach(struct brcmf_if *if
+ 	else
+ 		err = register_netdev(ndev);
+ 	if (err != 0) {
+-		brcmf_err("couldn't register the net device\n");
++		bphy_err(drvr, "couldn't register the net device\n");
+ 		goto fail;
+ 	}
+ 
+@@ -760,6 +761,7 @@ static const struct net_device_ops brcmf
+ 
+ static int brcmf_net_p2p_attach(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct net_device *ndev;
+ 
+ 	brcmf_dbg(TRACE, "Enter, bsscfgidx=%d mac=%pM\n", ifp->bsscfgidx,
+@@ -772,7 +774,7 @@ static int brcmf_net_p2p_attach(struct b
+ 	memcpy(ndev->dev_addr, ifp->mac_addr, ETH_ALEN);
+ 
+ 	if (register_netdev(ndev) != 0) {
+-		brcmf_err("couldn't register the p2p net device\n");
++		bphy_err(drvr, "couldn't register the p2p net device\n");
+ 		goto fail;
+ 	}
+ 
+@@ -801,8 +803,8 @@ struct brcmf_if *brcmf_add_if(struct brc
+ 	 */
+ 	if (ifp) {
+ 		if (ifidx) {
+-			brcmf_err("ERROR: netdev:%s already exists\n",
+-				  ifp->ndev->name);
++			bphy_err(drvr, "ERROR: netdev:%s already exists\n",
++				 ifp->ndev->name);
+ 			netif_stop_queue(ifp->ndev);
+ 			brcmf_net_detach(ifp->ndev, false);
+ 			drvr->iflist[bsscfgidx] = NULL;
+@@ -864,7 +866,7 @@ static void brcmf_del_if(struct brcmf_pu
+ 
+ 	ifp = drvr->iflist[bsscfgidx];
+ 	if (!ifp) {
+-		brcmf_err("Null interface, bsscfgidx=%d\n", bsscfgidx);
++		bphy_err(drvr, "Null interface, bsscfgidx=%d\n", bsscfgidx);
+ 		return;
+ 	}
+ 	brcmf_dbg(TRACE, "Enter, bsscfgidx=%d, ifidx=%d\n", bsscfgidx,
+@@ -918,16 +920,17 @@ static int brcmf_psm_watchdog_notify(str
+ 				     const struct brcmf_event_msg *evtmsg,
+ 				     void *data)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int err;
+ 
+ 	brcmf_dbg(TRACE, "enter: bsscfgidx=%d\n", ifp->bsscfgidx);
+ 
+-	brcmf_err("PSM's watchdog has fired!\n");
++	bphy_err(drvr, "PSM's watchdog has fired!\n");
+ 
+ 	err = brcmf_debug_create_memdump(ifp->drvr->bus_if, data,
+ 					 evtmsg->datalen);
+ 	if (err)
+-		brcmf_err("Failed to get memory dump, %d\n", err);
++		bphy_err(drvr, "Failed to get memory dump, %d\n", err);
+ 
+ 	return err;
+ }
+@@ -971,7 +974,7 @@ static int brcmf_inetaddr_changed(struct
+ 	ret = brcmf_fil_iovar_data_get(ifp, "arp_hostip", addr_table,
+ 				       sizeof(addr_table));
+ 	if (ret) {
+-		brcmf_err("fail to get arp ip table err:%d\n", ret);
++		bphy_err(drvr, "fail to get arp ip table err:%d\n", ret);
+ 		return NOTIFY_OK;
+ 	}
+ 
+@@ -988,7 +991,7 @@ static int brcmf_inetaddr_changed(struct
+ 			ret = brcmf_fil_iovar_data_set(ifp, "arp_hostip",
+ 				&ifa->ifa_address, sizeof(ifa->ifa_address));
+ 			if (ret)
+-				brcmf_err("add arp ip err %d\n", ret);
++				bphy_err(drvr, "add arp ip err %d\n", ret);
+ 		}
+ 		break;
+ 	case NETDEV_DOWN:
+@@ -1000,8 +1003,8 @@ static int brcmf_inetaddr_changed(struct
+ 			ret = brcmf_fil_iovar_data_set(ifp, "arp_hostip_clear",
+ 						       NULL, 0);
+ 			if (ret) {
+-				brcmf_err("fail to clear arp ip table err:%d\n",
+-					  ret);
++				bphy_err(drvr, "fail to clear arp ip table err:%d\n",
++					 ret);
+ 				return NOTIFY_OK;
+ 			}
+ 			for (i = 0; i < ARPOL_MAX_ENTRIES; i++) {
+@@ -1011,8 +1014,8 @@ static int brcmf_inetaddr_changed(struct
+ 							       &addr_table[i],
+ 							       sizeof(addr_table[i]));
+ 				if (ret)
+-					brcmf_err("add arp ip err %d\n",
+-						  ret);
++					bphy_err(drvr, "add arp ip err %d\n",
++						 ret);
+ 			}
+ 		}
+ 		break;
+@@ -1186,7 +1189,7 @@ static int brcmf_bus_started(struct brcm
+ 	return 0;
+ 
+ fail:
+-	brcmf_err("failed: %d\n", ret);
++	bphy_err(drvr, "failed: %d\n", ret);
+ 	if (drvr->config) {
+ 		brcmf_cfg80211_detach(drvr->config);
+ 		drvr->config = NULL;
+@@ -1238,7 +1241,7 @@ int brcmf_attach(struct device *dev, str
+ 	/* Attach and link in the protocol */
+ 	ret = brcmf_proto_attach(drvr);
+ 	if (ret != 0) {
+-		brcmf_err("brcmf_prot_attach failed\n");
++		bphy_err(drvr, "brcmf_prot_attach failed\n");
+ 		goto fail;
+ 	}
+ 
+@@ -1251,7 +1254,7 @@ int brcmf_attach(struct device *dev, str
+ 
+ 	ret = brcmf_bus_started(drvr, ops);
+ 	if (ret != 0) {
+-		brcmf_err("dongle is not responding: err=%d\n", ret);
++		bphy_err(drvr, "dongle is not responding: err=%d\n", ret);
+ 		goto fail;
+ 	}
+ 
+@@ -1358,6 +1361,7 @@ static int brcmf_get_pend_8021x_cnt(stru
+ 
+ int brcmf_netdev_wait_pend8021x(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int err;
+ 
+ 	err = wait_event_timeout(ifp->pend_8021x_wait,
+@@ -1365,7 +1369,7 @@ int brcmf_netdev_wait_pend8021x(struct b
+ 				 MAX_WAIT_FOR_8021X_TX);
+ 
+ 	if (!err)
+-		brcmf_err("Timed out waiting for no pending 802.1x packets\n");
++		bphy_err(drvr, "Timed out waiting for no pending 802.1x packets\n");
+ 
+ 	return !err;
+ }
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+@@ -185,13 +185,14 @@ static void brcmf_feat_iovar_data_set(st
+ #define MAX_CAPS_BUFFER_SIZE	768
+ static void brcmf_feat_firmware_capabilities(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	char caps[MAX_CAPS_BUFFER_SIZE];
+ 	enum brcmf_feat_id id;
+ 	int i, err;
+ 
+ 	err = brcmf_fil_iovar_data_get(ifp, "cap", caps, sizeof(caps));
+ 	if (err) {
+-		brcmf_err("could not get firmware cap (%d)\n", err);
++		bphy_err(drvr, "could not get firmware cap (%d)\n", err);
+ 		return;
+ 	}
+ 
+@@ -216,14 +217,15 @@ static void brcmf_feat_firmware_capabili
+ static int brcmf_feat_fwcap_debugfs_read(struct seq_file *seq, void *data)
+ {
+ 	struct brcmf_bus *bus_if = dev_get_drvdata(seq->private);
+-	struct brcmf_if *ifp = brcmf_get_ifp(bus_if->drvr, 0);
++	struct brcmf_pub *drvr = bus_if->drvr;
++	struct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);
+ 	char caps[MAX_CAPS_BUFFER_SIZE + 1] = { };
+ 	char *tmp;
+ 	int err;
+ 
+ 	err = brcmf_fil_iovar_data_get(ifp, "cap", caps, sizeof(caps));
+ 	if (err) {
+-		brcmf_err("could not get firmware cap (%d)\n", err);
++		bphy_err(drvr, "could not get firmware cap (%d)\n", err);
+ 		return err;
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
+@@ -102,7 +102,8 @@ static void brcmf_fweh_queue_event(struc
+ 	schedule_work(&fweh->event_work);
+ }
+ 
+-static int brcmf_fweh_call_event_handler(struct brcmf_if *ifp,
++static int brcmf_fweh_call_event_handler(struct brcmf_pub *drvr,
++					 struct brcmf_if *ifp,
+ 					 enum brcmf_fweh_event_code code,
+ 					 struct brcmf_event_msg *emsg,
+ 					 void *data)
+@@ -117,9 +118,9 @@ static int brcmf_fweh_call_event_handler
+ 		if (fweh->evt_handler[code])
+ 			err = fweh->evt_handler[code](ifp, emsg, data);
+ 		else
+-			brcmf_err("unhandled event %d ignored\n", code);
++			bphy_err(drvr, "unhandled event %d ignored\n", code);
+ 	} else {
+-		brcmf_err("no interface object\n");
++		bphy_err(drvr, "no interface object\n");
+ 	}
+ 	return err;
+ }
+@@ -158,7 +159,7 @@ static void brcmf_fweh_handle_if_event(s
+ 		return;
+ 	}
+ 	if (ifevent->ifidx >= BRCMF_MAX_IFS) {
+-		brcmf_err("invalid interface index: %u\n", ifevent->ifidx);
++		bphy_err(drvr, "invalid interface index: %u\n", ifevent->ifidx);
+ 		return;
+ 	}
+ 
+@@ -181,7 +182,8 @@ static void brcmf_fweh_handle_if_event(s
+ 	if (ifp && ifevent->action == BRCMF_E_IF_CHANGE)
+ 		brcmf_proto_reset_if(drvr, ifp);
+ 
+-	err = brcmf_fweh_call_event_handler(ifp, emsg->event_code, emsg, data);
++	err = brcmf_fweh_call_event_handler(drvr, ifp, emsg->event_code, emsg,
++					    data);
+ 
+ 	if (ifp && ifevent->action == BRCMF_E_IF_DEL) {
+ 		bool armed = brcmf_cfg80211_vif_event_armed(drvr->config);
+@@ -268,11 +270,11 @@ static void brcmf_fweh_event_worker(stru
+ 			ifp = drvr->iflist[0];
+ 		else
+ 			ifp = drvr->iflist[emsg.bsscfgidx];
+-		err = brcmf_fweh_call_event_handler(ifp, event->code, &emsg,
+-						    event->data);
++		err = brcmf_fweh_call_event_handler(drvr, ifp, event->code,
++						    &emsg, event->data);
+ 		if (err) {
+-			brcmf_err("event handler failed (%d)\n",
+-				  event->code);
++			bphy_err(drvr, "event handler failed (%d)\n",
++				 event->code);
+ 			err = 0;
+ 		}
+ event_free:
+@@ -339,7 +341,7 @@ int brcmf_fweh_register(struct brcmf_pub
+ 			brcmf_fweh_handler_t handler)
+ {
+ 	if (drvr->fweh.evt_handler[code]) {
+-		brcmf_err("event code %d already registered\n", code);
++		bphy_err(drvr, "event code %d already registered\n", code);
+ 		return -ENOSPC;
+ 	}
+ 	drvr->fweh.evt_handler[code] = handler;
+@@ -369,6 +371,7 @@ void brcmf_fweh_unregister(struct brcmf_
+  */
+ int brcmf_fweh_activate_events(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int i, err;
+ 	s8 eventmask[BRCMF_EVENTING_MASK_LEN];
+ 
+@@ -388,7 +391,7 @@ int brcmf_fweh_activate_events(struct br
+ 	err = brcmf_fil_iovar_data_set(ifp, "event_msgs",
+ 				       eventmask, BRCMF_EVENTING_MASK_LEN);
+ 	if (err)
+-		brcmf_err("Set event_msgs error (%d)\n", err);
++		bphy_err(drvr, "Set event_msgs error (%d)\n", err);
+ 
+ 	return err;
+ }
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c
+@@ -110,7 +110,7 @@ brcmf_fil_cmd_data(struct brcmf_if *ifp,
+ 	s32 err, fwerr;
+ 
+ 	if (drvr->bus_if->state != BRCMF_BUS_UP) {
+-		brcmf_err("bus is down. we have nothing to do.\n");
++		bphy_err(drvr, "bus is down. we have nothing to do.\n");
+ 		return -EIO;
+ 	}
+ 
+@@ -242,7 +242,7 @@ brcmf_fil_iovar_data_set(struct brcmf_if
+ 					 buflen, true);
+ 	} else {
+ 		err = -EPERM;
+-		brcmf_err("Creating iovar failed\n");
++		bphy_err(drvr, "Creating iovar failed\n");
+ 	}
+ 
+ 	mutex_unlock(&drvr->proto_block);
+@@ -268,7 +268,7 @@ brcmf_fil_iovar_data_get(struct brcmf_if
+ 			memcpy(data, drvr->proto_buf, len);
+ 	} else {
+ 		err = -EPERM;
+-		brcmf_err("Creating iovar failed\n");
++		bphy_err(drvr, "Creating iovar failed\n");
+ 	}
+ 
+ 	brcmf_dbg(FIL, "ifidx=%d, name=%s, len=%d\n", ifp->ifidx, name, len);
+@@ -366,7 +366,7 @@ brcmf_fil_bsscfg_data_set(struct brcmf_i
+ 					 buflen, true);
+ 	} else {
+ 		err = -EPERM;
+-		brcmf_err("Creating bsscfg failed\n");
++		bphy_err(drvr, "Creating bsscfg failed\n");
+ 	}
+ 
+ 	mutex_unlock(&drvr->proto_block);
+@@ -392,7 +392,7 @@ brcmf_fil_bsscfg_data_get(struct brcmf_i
+ 			memcpy(data, drvr->proto_buf, len);
+ 	} else {
+ 		err = -EPERM;
+-		brcmf_err("Creating bsscfg failed\n");
++		bphy_err(drvr, "Creating bsscfg failed\n");
+ 	}
+ 	brcmf_dbg(FIL, "ifidx=%d, bsscfgidx=%d, name=%s, len=%d\n", ifp->ifidx,
+ 		  ifp->bsscfgidx, name, len);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+@@ -1263,6 +1263,7 @@ static int brcmf_fws_enq(struct brcmf_fw
+ 			 enum brcmf_fws_skb_state state, int fifo,
+ 			 struct sk_buff *p)
+ {
++	struct brcmf_pub *drvr = fws->drvr;
+ 	int prec = 2 * fifo;
+ 	u32 *qfull_stat = &fws->stats.delayq_full_error;
+ 	struct brcmf_fws_mac_descriptor *entry;
+@@ -1275,7 +1276,7 @@ static int brcmf_fws_enq(struct brcmf_fw
+ 
+ 	entry = brcmf_skbcb(p)->mac;
+ 	if (entry == NULL) {
+-		brcmf_err("no mac descriptor found for skb %p\n", p);
++		bphy_err(drvr, "no mac descriptor found for skb %p\n", p);
+ 		return -ENOENT;
+ 	}
+ 
+@@ -1465,6 +1466,7 @@ static int
+ brcmf_fws_txs_process(struct brcmf_fws_info *fws, u8 flags, u32 hslot,
+ 		      u32 genbit, u16 seq, u8 compcnt)
+ {
++	struct brcmf_pub *drvr = fws->drvr;
+ 	u32 fifo;
+ 	u8 cnt = 0;
+ 	int ret;
+@@ -1489,14 +1491,14 @@ brcmf_fws_txs_process(struct brcmf_fws_i
+ 	else if (flags == BRCMF_FWS_TXSTATUS_HOST_TOSSED)
+ 		fws->stats.txs_host_tossed += compcnt;
+ 	else
+-		brcmf_err("unexpected txstatus\n");
++		bphy_err(drvr, "unexpected txstatus\n");
+ 
+ 	while (cnt < compcnt) {
+ 		ret = brcmf_fws_hanger_poppkt(&fws->hanger, hslot, &skb,
+ 					      remove_from_hanger);
+ 		if (ret != 0) {
+-			brcmf_err("no packet in hanger slot: hslot=%d\n",
+-				  hslot);
++			bphy_err(drvr, "no packet in hanger slot: hslot=%d\n",
++				 hslot);
+ 			goto cont;
+ 		}
+ 
+@@ -1620,12 +1622,13 @@ static int brcmf_fws_notify_credit_map(s
+ 				       const struct brcmf_event_msg *e,
+ 				       void *data)
+ {
+-	struct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_fws_info *fws = drvr_to_fws(drvr);
+ 	int i;
+ 	u8 *credits = data;
+ 
+ 	if (e->datalen < BRCMF_FWS_FIFO_COUNT) {
+-		brcmf_err("event payload too small (%d)\n", e->datalen);
++		bphy_err(drvr, "event payload too small (%d)\n", e->datalen);
+ 		return -EINVAL;
+ 	}
+ 
+@@ -1689,6 +1692,7 @@ static void brcmf_rxreorder_get_skb_list
+ 
+ void brcmf_fws_rxreorder(struct brcmf_if *ifp, struct sk_buff *pkt)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	u8 *reorder_data;
+ 	u8 flow_id, max_idx, cur_idx, exp_idx, end_idx;
+ 	struct brcmf_ampdu_rx_reorder *rfi;
+@@ -1703,7 +1707,7 @@ void brcmf_fws_rxreorder(struct brcmf_if
+ 
+ 	/* validate flags and flow id */
+ 	if (flags == 0xFF) {
+-		brcmf_err("invalid flags...so ignore this packet\n");
++		bphy_err(drvr, "invalid flags...so ignore this packet\n");
+ 		brcmf_netif_rx(ifp, pkt);
+ 		return;
+ 	}
+@@ -1740,7 +1744,7 @@ void brcmf_fws_rxreorder(struct brcmf_if
+ 			  flow_id, max_idx);
+ 		rfi = kzalloc(buf_size, GFP_ATOMIC);
+ 		if (rfi == NULL) {
+-			brcmf_err("failed to alloc buffer\n");
++			bphy_err(drvr, "failed to alloc buffer\n");
+ 			brcmf_netif_rx(ifp, pkt);
+ 			return;
+ 		}
+@@ -2004,6 +2008,7 @@ static u8 brcmf_fws_precommit_skb(struct
+ static void brcmf_fws_rollback_toq(struct brcmf_fws_info *fws,
+ 				   struct sk_buff *skb, int fifo)
+ {
++	struct brcmf_pub *drvr = fws->drvr;
+ 	struct brcmf_fws_mac_descriptor *entry;
+ 	struct sk_buff *pktout;
+ 	int qidx, hslot;
+@@ -2017,11 +2022,11 @@ static void brcmf_fws_rollback_toq(struc
+ 
+ 		pktout = brcmu_pktq_penq_head(&entry->psq, qidx, skb);
+ 		if (pktout == NULL) {
+-			brcmf_err("%s queue %d full\n", entry->name, qidx);
++			bphy_err(drvr, "%s queue %d full\n", entry->name, qidx);
+ 			rc = -ENOSPC;
+ 		}
+ 	} else {
+-		brcmf_err("%s entry removed\n", entry->name);
++		bphy_err(drvr, "%s entry removed\n", entry->name);
+ 		rc = -ENOENT;
+ 	}
+ 
+@@ -2126,7 +2131,8 @@ static int brcmf_fws_assign_htod(struct
+ 
+ int brcmf_fws_process_skb(struct brcmf_if *ifp, struct sk_buff *skb)
+ {
+-	struct brcmf_fws_info *fws = drvr_to_fws(ifp->drvr);
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_fws_info *fws = drvr_to_fws(drvr);
+ 	struct brcmf_skbuff_cb *skcb = brcmf_skbcb(skb);
+ 	struct ethhdr *eh = (struct ethhdr *)(skb->data);
+ 	int fifo = BRCMF_FWS_FIFO_BCMC;
+@@ -2154,7 +2160,7 @@ int brcmf_fws_process_skb(struct brcmf_i
+ 		brcmf_fws_enq(fws, BRCMF_FWS_SKBSTATE_DELAYED, fifo, skb);
+ 		brcmf_fws_schedule_deq(fws);
+ 	} else {
+-		brcmf_err("drop skb: no hanger slot\n");
++		bphy_err(drvr, "drop skb: no hanger slot\n");
+ 		brcmf_txfinalize(ifp, skb, false);
+ 		rc = -ENOMEM;
+ 	}
+@@ -2375,7 +2381,7 @@ struct brcmf_fws_info *brcmf_fws_attach(
+ 
+ 	fws->fws_wq = create_singlethread_workqueue("brcmf_fws_wq");
+ 	if (fws->fws_wq == NULL) {
+-		brcmf_err("workqueue creation failed\n");
++		bphy_err(drvr, "workqueue creation failed\n");
+ 		rc = -EBADF;
+ 		goto fail;
+ 	}
+@@ -2391,13 +2397,13 @@ struct brcmf_fws_info *brcmf_fws_attach(
+ 	rc = brcmf_fweh_register(drvr, BRCMF_E_FIFO_CREDIT_MAP,
+ 				 brcmf_fws_notify_credit_map);
+ 	if (rc < 0) {
+-		brcmf_err("register credit map handler failed\n");
++		bphy_err(drvr, "register credit map handler failed\n");
+ 		goto fail;
+ 	}
+ 	rc = brcmf_fweh_register(drvr, BRCMF_E_BCMC_CREDIT_SUPPORT,
+ 				 brcmf_fws_notify_bcmc_credit_support);
+ 	if (rc < 0) {
+-		brcmf_err("register bcmc credit handler failed\n");
++		bphy_err(drvr, "register bcmc credit handler failed\n");
+ 		brcmf_fweh_unregister(drvr, BRCMF_E_FIFO_CREDIT_MAP);
+ 		goto fail;
+ 	}
+@@ -2409,7 +2415,7 @@ struct brcmf_fws_info *brcmf_fws_attach(
+ 	fws->fw_signals = true;
+ 	ifp = brcmf_get_ifp(drvr, 0);
+ 	if (brcmf_fil_iovar_int_set(ifp, "tlv", tlv)) {
+-		brcmf_err("failed to set bdcv2 tlv signaling\n");
++		bphy_err(drvr, "failed to set bdcv2 tlv signaling\n");
+ 		fws->fcmode = BRCMF_FWS_FCMODE_NONE;
+ 		fws->fw_signals = false;
+ 	}
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -439,7 +439,7 @@ static int brcmf_msgbuf_tx_ioctl(struct
+ 	brcmf_commonring_lock(commonring);
+ 	ret_ptr = brcmf_commonring_reserve_for_write(commonring);
+ 	if (!ret_ptr) {
+-		brcmf_err("Failed to reserve space in commonring\n");
++		bphy_err(drvr, "Failed to reserve space in commonring\n");
+ 		brcmf_commonring_unlock(commonring);
+ 		return -ENOMEM;
+ 	}
+@@ -503,7 +503,7 @@ static int brcmf_msgbuf_query_dcmd(struc
+ 
+ 	timeout = brcmf_msgbuf_ioctl_resp_wait(msgbuf);
+ 	if (!timeout) {
+-		brcmf_err("Timeout on response for query command\n");
++		bphy_err(drvr, "Timeout on response for query command\n");
+ 		return -EIO;
+ 	}
+ 
+@@ -580,6 +580,7 @@ static u32
+ brcmf_msgbuf_flowring_create_worker(struct brcmf_msgbuf *msgbuf,
+ 				    struct brcmf_msgbuf_work_item *work)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct msgbuf_tx_flowring_create_req *create;
+ 	struct brcmf_commonring *commonring;
+ 	void *ret_ptr;
+@@ -595,7 +596,7 @@ brcmf_msgbuf_flowring_create_worker(stru
+ 				     &msgbuf->flowring_dma_handle[flowid],
+ 				     GFP_KERNEL);
+ 	if (!dma_buf) {
+-		brcmf_err("dma_alloc_coherent failed\n");
++		bphy_err(drvr, "dma_alloc_coherent failed\n");
+ 		brcmf_flowring_delete(msgbuf->flow, flowid);
+ 		return BRCMF_FLOWRING_INVALID_ID;
+ 	}
+@@ -608,7 +609,7 @@ brcmf_msgbuf_flowring_create_worker(stru
+ 	brcmf_commonring_lock(commonring);
+ 	ret_ptr = brcmf_commonring_reserve_for_write(commonring);
+ 	if (!ret_ptr) {
+-		brcmf_err("Failed to reserve space in commonring\n");
++		bphy_err(drvr, "Failed to reserve space in commonring\n");
+ 		brcmf_commonring_unlock(commonring);
+ 		brcmf_msgbuf_remove_flowring(msgbuf, flowid);
+ 		return BRCMF_FLOWRING_INVALID_ID;
+@@ -635,7 +636,7 @@ brcmf_msgbuf_flowring_create_worker(stru
+ 	err = brcmf_commonring_write_complete(commonring);
+ 	brcmf_commonring_unlock(commonring);
+ 	if (err) {
+-		brcmf_err("Failed to write commonring\n");
++		bphy_err(drvr, "Failed to write commonring\n");
+ 		brcmf_msgbuf_remove_flowring(msgbuf, flowid);
+ 		return BRCMF_FLOWRING_INVALID_ID;
+ 	}
+@@ -694,6 +695,7 @@ static u32 brcmf_msgbuf_flowring_create(
+ static void brcmf_msgbuf_txflow(struct brcmf_msgbuf *msgbuf, u16 flowid)
+ {
+ 	struct brcmf_flowring *flow = msgbuf->flow;
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct brcmf_commonring *commonring;
+ 	void *ret_ptr;
+ 	u32 count;
+@@ -713,8 +715,8 @@ static void brcmf_msgbuf_txflow(struct b
+ 	while (brcmf_flowring_qlen(flow, flowid)) {
+ 		skb = brcmf_flowring_dequeue(flow, flowid);
+ 		if (skb == NULL) {
+-			brcmf_err("No SKB, but qlen %d\n",
+-				  brcmf_flowring_qlen(flow, flowid));
++			bphy_err(drvr, "No SKB, but qlen %d\n",
++				 brcmf_flowring_qlen(flow, flowid));
+ 			break;
+ 		}
+ 		skb_orphan(skb);
+@@ -722,7 +724,7 @@ static void brcmf_msgbuf_txflow(struct b
+ 					     msgbuf->tx_pktids, skb, ETH_HLEN,
+ 					     &physaddr, &pktid)) {
+ 			brcmf_flowring_reinsert(flow, flowid, skb);
+-			brcmf_err("No PKTID available !!\n");
++			bphy_err(drvr, "No PKTID available !!\n");
+ 			break;
+ 		}
+ 		ret_ptr = brcmf_commonring_reserve_for_write(commonring);
+@@ -893,6 +895,7 @@ brcmf_msgbuf_process_txstatus(struct brc
+ 
+ static u32 brcmf_msgbuf_rxbuf_data_post(struct brcmf_msgbuf *msgbuf, u32 count)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct brcmf_commonring *commonring;
+ 	void *ret_ptr;
+ 	struct sk_buff *skb;
+@@ -920,7 +923,7 @@ static u32 brcmf_msgbuf_rxbuf_data_post(
+ 		skb = brcmu_pkt_buf_get_skb(BRCMF_MSGBUF_MAX_PKT_SIZE);
+ 
+ 		if (skb == NULL) {
+-			brcmf_err("Failed to alloc SKB\n");
++			bphy_err(drvr, "Failed to alloc SKB\n");
+ 			brcmf_commonring_write_cancel(commonring, alloced - i);
+ 			break;
+ 		}
+@@ -930,7 +933,7 @@ static u32 brcmf_msgbuf_rxbuf_data_post(
+ 					     msgbuf->rx_pktids, skb, 0,
+ 					     &physaddr, &pktid)) {
+ 			dev_kfree_skb_any(skb);
+-			brcmf_err("No PKTID available !!\n");
++			bphy_err(drvr, "No PKTID available !!\n");
+ 			brcmf_commonring_write_cancel(commonring, alloced - i);
+ 			break;
+ 		}
+@@ -1000,6 +1003,7 @@ static u32
+ brcmf_msgbuf_rxbuf_ctrl_post(struct brcmf_msgbuf *msgbuf, bool event_buf,
+ 			     u32 count)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct brcmf_commonring *commonring;
+ 	void *ret_ptr;
+ 	struct sk_buff *skb;
+@@ -1017,7 +1021,7 @@ brcmf_msgbuf_rxbuf_ctrl_post(struct brcm
+ 							      count,
+ 							      &alloced);
+ 	if (!ret_ptr) {
+-		brcmf_err("Failed to reserve space in commonring\n");
++		bphy_err(drvr, "Failed to reserve space in commonring\n");
+ 		brcmf_commonring_unlock(commonring);
+ 		return 0;
+ 	}
+@@ -1029,7 +1033,7 @@ brcmf_msgbuf_rxbuf_ctrl_post(struct brcm
+ 		skb = brcmu_pkt_buf_get_skb(BRCMF_MSGBUF_MAX_PKT_SIZE);
+ 
+ 		if (skb == NULL) {
+-			brcmf_err("Failed to alloc SKB\n");
++			bphy_err(drvr, "Failed to alloc SKB\n");
+ 			brcmf_commonring_write_cancel(commonring, alloced - i);
+ 			break;
+ 		}
+@@ -1039,7 +1043,7 @@ brcmf_msgbuf_rxbuf_ctrl_post(struct brcm
+ 					     msgbuf->rx_pktids, skb, 0,
+ 					     &physaddr, &pktid)) {
+ 			dev_kfree_skb_any(skb);
+-			brcmf_err("No PKTID available !!\n");
++			bphy_err(drvr, "No PKTID available !!\n");
+ 			brcmf_commonring_write_cancel(commonring, alloced - i);
+ 			break;
+ 		}
+@@ -1091,6 +1095,7 @@ static void brcmf_msgbuf_rxbuf_event_pos
+ 
+ static void brcmf_msgbuf_process_event(struct brcmf_msgbuf *msgbuf, void *buf)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct msgbuf_rx_event *event;
+ 	u32 idx;
+ 	u16 buflen;
+@@ -1117,8 +1122,8 @@ static void brcmf_msgbuf_process_event(s
+ 
+ 	ifp = brcmf_get_ifp(msgbuf->drvr, event->msg.ifidx);
+ 	if (!ifp || !ifp->ndev) {
+-		brcmf_err("Received pkt for invalid ifidx %d\n",
+-			  event->msg.ifidx);
++		bphy_err(drvr, "Received pkt for invalid ifidx %d\n",
++			 event->msg.ifidx);
+ 		goto exit;
+ 	}
+ 
+@@ -1134,6 +1139,7 @@ exit:
+ static void
+ brcmf_msgbuf_process_rx_complete(struct brcmf_msgbuf *msgbuf, void *buf)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct msgbuf_rx_complete *rx_complete;
+ 	struct sk_buff *skb;
+ 	u16 data_offset;
+@@ -1167,7 +1173,7 @@ brcmf_msgbuf_process_rx_complete(struct
+ 		ifp = msgbuf->drvr->mon_if;
+ 
+ 		if (!ifp) {
+-			brcmf_err("Received unexpected monitor pkt\n");
++			bphy_err(drvr, "Received unexpected monitor pkt\n");
+ 			brcmu_pkt_buf_free_skb(skb);
+ 			return;
+ 		}
+@@ -1178,8 +1184,8 @@ brcmf_msgbuf_process_rx_complete(struct
+ 
+ 	ifp = brcmf_get_ifp(msgbuf->drvr, rx_complete->msg.ifidx);
+ 	if (!ifp || !ifp->ndev) {
+-		brcmf_err("Received pkt for invalid ifidx %d\n",
+-			  rx_complete->msg.ifidx);
++		bphy_err(drvr, "Received pkt for invalid ifidx %d\n",
++			 rx_complete->msg.ifidx);
+ 		brcmu_pkt_buf_free_skb(skb);
+ 		return;
+ 	}
+@@ -1192,13 +1198,15 @@ static void brcmf_msgbuf_process_ring_st
+ 					     void *buf)
+ {
+ 	struct msgbuf_ring_status *ring_status = buf;
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	int err;
+ 
+ 	err = le16_to_cpu(ring_status->compl_hdr.status);
+ 	if (err) {
+ 		int ring = le16_to_cpu(ring_status->compl_hdr.flow_ring_id);
+ 
+-		brcmf_err("Firmware reported ring %d error: %d\n", ring, err);
++		bphy_err(drvr, "Firmware reported ring %d error: %d\n", ring,
++			 err);
+ 	}
+ }
+ 
+@@ -1206,6 +1214,7 @@ static void
+ brcmf_msgbuf_process_flow_ring_create_response(struct brcmf_msgbuf *msgbuf,
+ 					       void *buf)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct msgbuf_flowring_create_resp *flowring_create_resp;
+ 	u16 status;
+ 	u16 flowid;
+@@ -1217,7 +1226,7 @@ brcmf_msgbuf_process_flow_ring_create_re
+ 	status =  le16_to_cpu(flowring_create_resp->compl_hdr.status);
+ 
+ 	if (status) {
+-		brcmf_err("Flowring creation failed, code %d\n", status);
++		bphy_err(drvr, "Flowring creation failed, code %d\n", status);
+ 		brcmf_msgbuf_remove_flowring(msgbuf, flowid);
+ 		return;
+ 	}
+@@ -1234,6 +1243,7 @@ static void
+ brcmf_msgbuf_process_flow_ring_delete_response(struct brcmf_msgbuf *msgbuf,
+ 					       void *buf)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct msgbuf_flowring_delete_resp *flowring_delete_resp;
+ 	u16 status;
+ 	u16 flowid;
+@@ -1245,7 +1255,7 @@ brcmf_msgbuf_process_flow_ring_delete_re
+ 	status =  le16_to_cpu(flowring_delete_resp->compl_hdr.status);
+ 
+ 	if (status) {
+-		brcmf_err("Flowring deletion failed, code %d\n", status);
++		bphy_err(drvr, "Flowring deletion failed, code %d\n", status);
+ 		brcmf_flowring_delete(msgbuf->flow, flowid);
+ 		return;
+ 	}
+@@ -1258,6 +1268,7 @@ brcmf_msgbuf_process_flow_ring_delete_re
+ 
+ static void brcmf_msgbuf_process_msgtype(struct brcmf_msgbuf *msgbuf, void *buf)
+ {
++	struct brcmf_pub *drvr = msgbuf->drvr;
+ 	struct msgbuf_common_hdr *msg;
+ 
+ 	msg = (struct msgbuf_common_hdr *)buf;
+@@ -1294,7 +1305,7 @@ static void brcmf_msgbuf_process_msgtype
+ 		brcmf_msgbuf_process_rx_complete(msgbuf, buf);
+ 		break;
+ 	default:
+-		brcmf_err("Unsupported msgtype %d\n", msg->msgtype);
++		bphy_err(drvr, "Unsupported msgtype %d\n", msg->msgtype);
+ 		break;
+ 	}
+ }
+@@ -1377,7 +1388,7 @@ void brcmf_msgbuf_delete_flowring(struct
+ 	brcmf_commonring_lock(commonring);
+ 	ret_ptr = brcmf_commonring_reserve_for_write(commonring);
+ 	if (!ret_ptr) {
+-		brcmf_err("FW unaware, flowring will be removed !!\n");
++		bphy_err(drvr, "FW unaware, flowring will be removed !!\n");
+ 		brcmf_commonring_unlock(commonring);
+ 		brcmf_msgbuf_remove_flowring(msgbuf, flowid);
+ 		return;
+@@ -1401,7 +1412,7 @@ void brcmf_msgbuf_delete_flowring(struct
+ 	err = brcmf_commonring_write_complete(commonring);
+ 	brcmf_commonring_unlock(commonring);
+ 	if (err) {
+-		brcmf_err("Failed to submit RING_DELETE, flowring will be removed\n");
++		bphy_err(drvr, "Failed to submit RING_DELETE, flowring will be removed\n");
+ 		brcmf_msgbuf_remove_flowring(msgbuf, flowid);
+ 	}
+ }
+@@ -1476,8 +1487,8 @@ int brcmf_proto_msgbuf_attach(struct brc
+ 	if_msgbuf = drvr->bus_if->msgbuf;
+ 
+ 	if (if_msgbuf->max_flowrings >= BRCMF_FLOWRING_HASHSIZE) {
+-		brcmf_err("driver not configured for this many flowrings %d\n",
+-			  if_msgbuf->max_flowrings);
++		bphy_err(drvr, "driver not configured for this many flowrings %d\n",
++			 if_msgbuf->max_flowrings);
+ 		if_msgbuf->max_flowrings = BRCMF_FLOWRING_HASHSIZE - 1;
+ 	}
+ 
+@@ -1487,7 +1498,7 @@ int brcmf_proto_msgbuf_attach(struct brc
+ 
+ 	msgbuf->txflow_wq = create_singlethread_workqueue("msgbuf_txflow");
+ 	if (msgbuf->txflow_wq == NULL) {
+-		brcmf_err("workqueue creation failed\n");
++		bphy_err(drvr, "workqueue creation failed\n");
+ 		goto fail;
+ 	}
+ 	INIT_WORK(&msgbuf->txflow_work, brcmf_msgbuf_txflow_worker);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
+@@ -434,6 +434,7 @@ static void brcmf_p2p_print_actframe(boo
+  */
+ static int brcmf_p2p_set_firmware(struct brcmf_if *ifp, u8 *p2p_mac)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	s32 ret = 0;
+ 
+ 	brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);
+@@ -450,7 +451,7 @@ static int brcmf_p2p_set_firmware(struct
+ 	ret = brcmf_fil_iovar_data_set(ifp, "p2p_da_override", p2p_mac,
+ 				       ETH_ALEN);
+ 	if (ret)
+-		brcmf_err("failed to update device address ret %d\n", ret);
++		bphy_err(drvr, "failed to update device address ret %d\n", ret);
+ 
+ 	return ret;
+ }
+@@ -570,13 +571,14 @@ static s32 brcmf_p2p_deinit_discovery(st
+  */
+ static int brcmf_p2p_enable_discovery(struct brcmf_p2p_info *p2p)
+ {
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	s32 ret = 0;
+ 
+ 	brcmf_dbg(TRACE, "enter\n");
+ 	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+ 	if (!vif) {
+-		brcmf_err("P2P config device not available\n");
++		bphy_err(drvr, "P2P config device not available\n");
+ 		ret = -EPERM;
+ 		goto exit;
+ 	}
+@@ -590,13 +592,13 @@ static int brcmf_p2p_enable_discovery(st
+ 	vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+ 	ret = brcmf_fil_iovar_int_set(vif->ifp, "p2p_disc", 1);
+ 	if (ret < 0) {
+-		brcmf_err("set p2p_disc error\n");
++		bphy_err(drvr, "set p2p_disc error\n");
+ 		goto exit;
+ 	}
+ 	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+ 	ret = brcmf_p2p_set_discover_state(vif->ifp, WL_P2P_DISC_ST_SCAN, 0, 0);
+ 	if (ret < 0) {
+-		brcmf_err("unable to set WL_P2P_DISC_ST_SCAN\n");
++		bphy_err(drvr, "unable to set WL_P2P_DISC_ST_SCAN\n");
+ 		goto exit;
+ 	}
+ 
+@@ -608,7 +610,7 @@ static int brcmf_p2p_enable_discovery(st
+ 	 */
+ 	ret = brcmf_fil_bsscfg_int_set(vif->ifp, "wsec", AES_ENABLED);
+ 	if (ret < 0) {
+-		brcmf_err("wsec error %d\n", ret);
++		bphy_err(drvr, "wsec error %d\n", ret);
+ 		goto exit;
+ 	}
+ 
+@@ -630,6 +632,7 @@ static s32 brcmf_p2p_escan(struct brcmf_
+ 			   u16 chanspecs[], s32 search_state,
+ 			   enum p2p_bss_type bss_type)
+ {
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	s32 ret = 0;
+ 	s32 memsize = offsetof(struct brcmf_p2p_scan_le,
+ 			       eparams.params_le.channel_list);
+@@ -648,7 +651,7 @@ static s32 brcmf_p2p_escan(struct brcmf_
+ 
+ 	vif = p2p->bss_idx[bss_type].vif;
+ 	if (vif == NULL) {
+-		brcmf_err("no vif for bss type %d\n", bss_type);
++		bphy_err(drvr, "no vif for bss type %d\n", bss_type);
+ 		ret = -EINVAL;
+ 		goto exit;
+ 	}
+@@ -676,7 +679,7 @@ static s32 brcmf_p2p_escan(struct brcmf_
+ 		       BRCMF_P2P_WILDCARD_SSID_LEN);
+ 		break;
+ 	default:
+-		brcmf_err(" invalid search state %d\n", search_state);
++		bphy_err(drvr, " invalid search state %d\n", search_state);
+ 		ret = -EINVAL;
+ 		goto exit;
+ 	}
+@@ -760,6 +763,7 @@ static s32 brcmf_p2p_run_escan(struct br
+ 			       struct cfg80211_scan_request *request)
+ {
+ 	struct brcmf_p2p_info *p2p = &cfg->p2p;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	s32 err = 0;
+ 	s32 search_state = WL_P2P_DISC_ST_SCAN;
+ 	struct brcmf_cfg80211_vif *vif;
+@@ -822,7 +826,7 @@ static s32 brcmf_p2p_run_escan(struct br
+ 	}
+ exit:
+ 	if (err)
+-		brcmf_err("error (%d)\n", err);
++		bphy_err(drvr, "error (%d)\n", err);
+ 	return err;
+ }
+ 
+@@ -917,19 +921,20 @@ int brcmf_p2p_scan_prep(struct wiphy *wi
+ static s32
+ brcmf_p2p_discover_listen(struct brcmf_p2p_info *p2p, u16 channel, u32 duration)
+ {
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	struct brcmu_chan ch;
+ 	s32 err = 0;
+ 
+ 	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+ 	if (!vif) {
+-		brcmf_err("Discovery is not set, so we have nothing to do\n");
++		bphy_err(drvr, "Discovery is not set, so we have nothing to do\n");
+ 		err = -EPERM;
+ 		goto exit;
+ 	}
+ 
+ 	if (test_bit(BRCMF_P2P_STATUS_DISCOVER_LISTEN, &p2p->status)) {
+-		brcmf_err("Previous LISTEN is not completed yet\n");
++		bphy_err(drvr, "Previous LISTEN is not completed yet\n");
+ 		/* WAR: prevent cookie mismatch in wpa_supplicant return OK */
+ 		goto exit;
+ 	}
+@@ -1046,6 +1051,7 @@ void brcmf_p2p_cancel_remain_on_channel(
+  */
+ static s32 brcmf_p2p_act_frm_search(struct brcmf_p2p_info *p2p, u16 channel)
+ {
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	s32 err;
+ 	u32 channel_cnt;
+ 	u16 *default_chan_list;
+@@ -1061,7 +1067,7 @@ static s32 brcmf_p2p_act_frm_search(stru
+ 	default_chan_list = kcalloc(channel_cnt, sizeof(*default_chan_list),
+ 				    GFP_KERNEL);
+ 	if (default_chan_list == NULL) {
+-		brcmf_err("channel list allocation failed\n");
++		bphy_err(drvr, "channel list allocation failed\n");
+ 		err = -ENOMEM;
+ 		goto exit;
+ 	}
+@@ -1103,6 +1109,7 @@ static void brcmf_p2p_afx_handler(struct
+ 	struct brcmf_p2p_info *p2p = container_of(afx_hdl,
+ 						  struct brcmf_p2p_info,
+ 						  afx_hdl);
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	s32 err;
+ 
+ 	if (!afx_hdl->is_active)
+@@ -1116,7 +1123,7 @@ static void brcmf_p2p_afx_handler(struct
+ 		err = brcmf_p2p_act_frm_search(p2p, afx_hdl->peer_listen_chan);
+ 
+ 	if (err) {
+-		brcmf_err("ERROR occurred! value is (%d)\n", err);
++		bphy_err(drvr, "ERROR occurred! value is (%d)\n", err);
+ 		if (test_bit(BRCMF_P2P_STATUS_FINDING_COMMON_CHANNEL,
+ 			     &p2p->status))
+ 			complete(&afx_hdl->act_frm_scan);
+@@ -1338,7 +1345,8 @@ int brcmf_p2p_notify_action_frame_rx(str
+ 				     const struct brcmf_event_msg *e,
+ 				     void *data)
+ {
+-	struct brcmf_cfg80211_info *cfg = ifp->drvr->config;
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct brcmf_cfg80211_info *cfg = drvr->config;
+ 	struct brcmf_p2p_info *p2p = &cfg->p2p;
+ 	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
+ 	struct wireless_dev *wdev;
+@@ -1409,7 +1417,7 @@ int brcmf_p2p_notify_action_frame_rx(str
+ 	mgmt_frame = kzalloc(offsetof(struct ieee80211_mgmt, u) +
+ 			     mgmt_frame_len, GFP_KERNEL);
+ 	if (!mgmt_frame) {
+-		brcmf_err("No memory available for action frame\n");
++		bphy_err(drvr, "No memory available for action frame\n");
+ 		return -ENOMEM;
+ 	}
+ 	memcpy(mgmt_frame->da, ifp->mac_addr, ETH_ALEN);
+@@ -1492,6 +1500,7 @@ int brcmf_p2p_notify_action_tx_complete(
+ static s32 brcmf_p2p_tx_action_frame(struct brcmf_p2p_info *p2p,
+ 				     struct brcmf_fil_af_params_le *af_params)
+ {
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	s32 err = 0;
+ 	s32 timeout = 0;
+@@ -1506,7 +1515,7 @@ static s32 brcmf_p2p_tx_action_frame(str
+ 	err = brcmf_fil_bsscfg_data_set(vif->ifp, "actframe", af_params,
+ 					sizeof(*af_params));
+ 	if (err) {
+-		brcmf_err(" sending action frame has failed\n");
++		bphy_err(drvr, " sending action frame has failed\n");
+ 		goto exit;
+ 	}
+ 
+@@ -1556,6 +1565,7 @@ static s32 brcmf_p2p_pub_af_tx(struct br
+ 			       struct brcmf_config_af_params *config_af_params)
+ {
+ 	struct brcmf_p2p_info *p2p = &cfg->p2p;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_fil_action_frame_le *action_frame;
+ 	struct brcmf_p2p_pub_act_frame *act_frm;
+ 	s32 err = 0;
+@@ -1634,8 +1644,8 @@ static s32 brcmf_p2p_pub_af_tx(struct br
+ 		config_af_params->extra_listen = false;
+ 		break;
+ 	default:
+-		brcmf_err("Unknown p2p pub act frame subtype: %d\n",
+-			  act_frm->subtype);
++		bphy_err(drvr, "Unknown p2p pub act frame subtype: %d\n",
++			 act_frm->subtype);
+ 		err = -EINVAL;
+ 	}
+ 	return err;
+@@ -1657,6 +1667,7 @@ bool brcmf_p2p_send_action_frame(struct
+ 	struct brcmf_fil_action_frame_le *action_frame;
+ 	struct brcmf_config_af_params config_af_params;
+ 	struct afx_hdl *afx_hdl = &p2p->afx_hdl;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	u16 action_frame_len;
+ 	bool ack = false;
+ 	u8 category;
+@@ -1692,7 +1703,7 @@ bool brcmf_p2p_send_action_frame(struct
+ 		if (brcmf_p2p_pub_af_tx(cfg, af_params, &config_af_params)) {
+ 			/* Just send unknown subtype frame with */
+ 			/* default parameters.                  */
+-			brcmf_err("P2P Public action frame, unknown subtype.\n");
++			bphy_err(drvr, "P2P Public action frame, unknown subtype.\n");
+ 		}
+ 	} else if (brcmf_p2p_is_gas_action(action_frame->data,
+ 					   action_frame_len)) {
+@@ -1714,7 +1725,7 @@ bool brcmf_p2p_send_action_frame(struct
+ 			af_params->dwell_time =
+ 				cpu_to_le32(P2P_AF_MIN_DWELL_TIME);
+ 		} else {
+-			brcmf_err("Unknown action type: %d\n", action);
++			bphy_err(drvr, "Unknown action type: %d\n", action);
+ 			goto exit;
+ 		}
+ 	} else if (brcmf_p2p_is_p2p_action(action_frame->data,
+@@ -1722,8 +1733,8 @@ bool brcmf_p2p_send_action_frame(struct
+ 		/* do not configure anything. it will be */
+ 		/* sent with a default configuration     */
+ 	} else {
+-		brcmf_err("Unknown Frame: category 0x%x, action 0x%x\n",
+-			  category, action);
++		bphy_err(drvr, "Unknown Frame: category 0x%x, action 0x%x\n",
++			 category, action);
+ 		return false;
+ 	}
+ 
+@@ -1761,7 +1772,7 @@ bool brcmf_p2p_send_action_frame(struct
+ 
+ 		if (brcmf_p2p_af_searching_channel(p2p) ==
+ 							P2P_INVALID_CHANNEL) {
+-			brcmf_err("Couldn't find peer's channel.\n");
++			bphy_err(drvr, "Couldn't find peer's channel.\n");
+ 			goto exit;
+ 		}
+ 
+@@ -1783,7 +1794,8 @@ bool brcmf_p2p_send_action_frame(struct
+ 		tx_retry++;
+ 	}
+ 	if (ack == false) {
+-		brcmf_err("Failed to send Action Frame(retry %d)\n", tx_retry);
++		bphy_err(drvr, "Failed to send Action Frame(retry %d)\n",
++			 tx_retry);
+ 		clear_bit(BRCMF_P2P_STATUS_GO_NEG_PHASE, &p2p->status);
+ 	}
+ 
+@@ -1965,6 +1977,7 @@ int brcmf_p2p_ifchange(struct brcmf_cfg8
+ 		       enum brcmf_fil_p2p_if_types if_type)
+ {
+ 	struct brcmf_p2p_info *p2p = &cfg->p2p;
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	struct brcmf_fil_p2p_if_le if_request;
+ 	s32 err;
+@@ -1974,13 +1987,13 @@ int brcmf_p2p_ifchange(struct brcmf_cfg8
+ 
+ 	vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+ 	if (!vif) {
+-		brcmf_err("vif for P2PAPI_BSSCFG_PRIMARY does not exist\n");
++		bphy_err(drvr, "vif for P2PAPI_BSSCFG_PRIMARY does not exist\n");
+ 		return -EPERM;
+ 	}
+ 	brcmf_notify_escan_complete(cfg, vif->ifp, true, true);
+ 	vif = p2p->bss_idx[P2PAPI_BSSCFG_CONNECTION].vif;
+ 	if (!vif) {
+-		brcmf_err("vif for P2PAPI_BSSCFG_CONNECTION does not exist\n");
++		bphy_err(drvr, "vif for P2PAPI_BSSCFG_CONNECTION does not exist\n");
+ 		return -EPERM;
+ 	}
+ 	brcmf_set_mpc(vif->ifp, 0);
+@@ -1998,7 +2011,7 @@ int brcmf_p2p_ifchange(struct brcmf_cfg8
+ 	err = brcmf_fil_iovar_data_set(vif->ifp, "p2p_ifupd", &if_request,
+ 				       sizeof(if_request));
+ 	if (err) {
+-		brcmf_err("p2p_ifupd FAILED, err=%d\n", err);
++		bphy_err(drvr, "p2p_ifupd FAILED, err=%d\n", err);
+ 		brcmf_cfg80211_arm_vif_event(cfg, NULL);
+ 		return err;
+ 	}
+@@ -2006,7 +2019,7 @@ int brcmf_p2p_ifchange(struct brcmf_cfg8
+ 					    BRCMF_VIF_EVENT_TIMEOUT);
+ 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
+ 	if (!err)  {
+-		brcmf_err("No BRCMF_E_IF_CHANGE event received\n");
++		bphy_err(drvr, "No BRCMF_E_IF_CHANGE event received\n");
+ 		return -EIO;
+ 	}
+ 
+@@ -2069,6 +2082,7 @@ static struct wireless_dev *brcmf_p2p_cr
+ 						    struct wiphy *wiphy,
+ 						    u8 *addr)
+ {
++	struct brcmf_pub *drvr = p2p->cfg->pub;
+ 	struct brcmf_cfg80211_vif *p2p_vif;
+ 	struct brcmf_if *p2p_ifp;
+ 	struct brcmf_if *pri_ifp;
+@@ -2080,7 +2094,7 @@ static struct wireless_dev *brcmf_p2p_cr
+ 
+ 	p2p_vif = brcmf_alloc_vif(p2p->cfg, NL80211_IFTYPE_P2P_DEVICE);
+ 	if (IS_ERR(p2p_vif)) {
+-		brcmf_err("could not create discovery vif\n");
++		bphy_err(drvr, "could not create discovery vif\n");
+ 		return (struct wireless_dev *)p2p_vif;
+ 	}
+ 
+@@ -2088,7 +2102,7 @@ static struct wireless_dev *brcmf_p2p_cr
+ 
+ 	/* firmware requires unique mac address for p2pdev interface */
+ 	if (addr && ether_addr_equal(addr, pri_ifp->mac_addr)) {
+-		brcmf_err("discovery vif must be different from primary interface\n");
++		bphy_err(drvr, "discovery vif must be different from primary interface\n");
+ 		return ERR_PTR(-EINVAL);
+ 	}
+ 
+@@ -2101,7 +2115,7 @@ static struct wireless_dev *brcmf_p2p_cr
+ 	/* Initialize P2P Discovery in the firmware */
+ 	err = brcmf_fil_iovar_int_set(pri_ifp, "p2p_disc", 1);
+ 	if (err < 0) {
+-		brcmf_err("set p2p_disc error\n");
++		bphy_err(drvr, "set p2p_disc error\n");
+ 		brcmf_fweh_p2pdev_setup(pri_ifp, false);
+ 		brcmf_cfg80211_arm_vif_event(p2p->cfg, NULL);
+ 		goto fail;
+@@ -2113,7 +2127,7 @@ static struct wireless_dev *brcmf_p2p_cr
+ 	brcmf_cfg80211_arm_vif_event(p2p->cfg, NULL);
+ 	brcmf_fweh_p2pdev_setup(pri_ifp, false);
+ 	if (!err) {
+-		brcmf_err("timeout occurred\n");
++		bphy_err(drvr, "timeout occurred\n");
+ 		err = -EIO;
+ 		goto fail;
+ 	}
+@@ -2127,7 +2141,7 @@ static struct wireless_dev *brcmf_p2p_cr
+ 	/* verify bsscfg index for P2P discovery */
+ 	err = brcmf_fil_iovar_int_get(pri_ifp, "p2p_dev", &bsscfgidx);
+ 	if (err < 0) {
+-		brcmf_err("retrieving discover bsscfg index failed\n");
++		bphy_err(drvr, "retrieving discover bsscfg index failed\n");
+ 		goto fail;
+ 	}
+ 
+@@ -2161,6 +2175,7 @@ struct wireless_dev *brcmf_p2p_add_vif(s
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	enum brcmf_fil_p2p_if_types iftype;
+ 	int err;
+@@ -2201,7 +2216,7 @@ struct wireless_dev *brcmf_p2p_add_vif(s
+ 					    BRCMF_VIF_EVENT_TIMEOUT);
+ 	brcmf_cfg80211_arm_vif_event(cfg, NULL);
+ 	if (!err) {
+-		brcmf_err("timeout occurred\n");
++		bphy_err(drvr, "timeout occurred\n");
+ 		err = -EIO;
+ 		goto fail;
+ 	}
+@@ -2209,7 +2224,7 @@ struct wireless_dev *brcmf_p2p_add_vif(s
+ 	/* interface created in firmware */
+ 	ifp = vif->ifp;
+ 	if (!ifp) {
+-		brcmf_err("no if pointer provided\n");
++		bphy_err(drvr, "no if pointer provided\n");
+ 		err = -ENOENT;
+ 		goto fail;
+ 	}
+@@ -2220,7 +2235,7 @@ struct wireless_dev *brcmf_p2p_add_vif(s
+ #endif /* >= 3.17.0 */
+ 	err = brcmf_net_attach(ifp, true);
+ 	if (err) {
+-		brcmf_err("Registering netdevice failed\n");
++		bphy_err(drvr, "Registering netdevice failed\n");
+ 		free_netdev(ifp->ndev);
+ 		goto fail;
+ 	}
+@@ -2375,6 +2390,7 @@ void brcmf_p2p_stop_device(struct wiphy
+  */
+ s32 brcmf_p2p_attach(struct brcmf_cfg80211_info *cfg, bool p2pdev_forced)
+ {
++	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_p2p_info *p2p;
+ 	struct brcmf_if *pri_ifp;
+ 	s32 err = 0;
+@@ -2389,7 +2405,7 @@ s32 brcmf_p2p_attach(struct brcmf_cfg802
+ 	if (p2pdev_forced) {
+ 		err_ptr = brcmf_p2p_create_p2pdev(p2p, NULL, NULL);
+ 		if (IS_ERR(err_ptr)) {
+-			brcmf_err("P2P device creation failed.\n");
++			bphy_err(drvr, "P2P device creation failed.\n");
+ 			err = PTR_ERR(err_ptr);
+ 		}
+ 	} else {
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
+@@ -109,6 +109,7 @@ static int brcmf_pno_channel_config(stru
+ static int brcmf_pno_config(struct brcmf_if *ifp, u32 scan_freq,
+ 			    u32 mscan, u32 bestn)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_pno_param_le pfn_param;
+ 	u16 flags;
+ 	u32 pfnmem;
+@@ -132,13 +133,13 @@ static int brcmf_pno_config(struct brcmf
+ 		/* set bestn in firmware */
+ 		err = brcmf_fil_iovar_int_set(ifp, "pfnmem", pfnmem);
+ 		if (err < 0) {
+-			brcmf_err("failed to set pfnmem\n");
++			bphy_err(drvr, "failed to set pfnmem\n");
+ 			goto exit;
+ 		}
+ 		/* get max mscan which the firmware supports */
+ 		err = brcmf_fil_iovar_int_get(ifp, "pfnmem", &pfnmem);
+ 		if (err < 0) {
+-			brcmf_err("failed to get pfnmem\n");
++			bphy_err(drvr, "failed to get pfnmem\n");
+ 			goto exit;
+ 		}
+ 		mscan = min_t(u32, mscan, pfnmem);
+@@ -152,7 +153,7 @@ static int brcmf_pno_config(struct brcmf
+ 	err = brcmf_fil_iovar_data_set(ifp, "pfn_set", &pfn_param,
+ 				       sizeof(pfn_param));
+ 	if (err)
+-		brcmf_err("pfn_set failed, err=%d\n", err);
++		bphy_err(drvr, "pfn_set failed, err=%d\n", err);
+ 
+ exit:
+ 	return err;
+@@ -160,6 +161,7 @@ exit:
+ 
+ static int brcmf_pno_set_random(struct brcmf_if *ifp, struct brcmf_pno_info *pi)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_pno_macaddr_le pfn_mac;
+ 	u8 *mac_addr = NULL;
+ 	u8 *mac_mask = NULL;
+@@ -194,7 +196,7 @@ static int brcmf_pno_set_random(struct b
+ 	err = brcmf_fil_iovar_data_set(ifp, "pfn_macaddr", &pfn_mac,
+ 				       sizeof(pfn_mac));
+ 	if (err)
+-		brcmf_err("pfn_macaddr failed, err=%d\n", err);
++		bphy_err(drvr, "pfn_macaddr failed, err=%d\n", err);
+ 
+ 	return err;
+ }
+@@ -202,6 +204,7 @@ static int brcmf_pno_set_random(struct b
+ static int brcmf_pno_add_ssid(struct brcmf_if *ifp, struct cfg80211_ssid *ssid,
+ 			      bool active)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_pno_net_param_le pfn;
+ 	int err;
+ 
+@@ -218,12 +221,13 @@ static int brcmf_pno_add_ssid(struct brc
+ 	brcmf_dbg(SCAN, "adding ssid=%.32s (active=%d)\n", ssid->ssid, active);
+ 	err = brcmf_fil_iovar_data_set(ifp, "pfn_add", &pfn, sizeof(pfn));
+ 	if (err < 0)
+-		brcmf_err("adding failed: err=%d\n", err);
++		bphy_err(drvr, "adding failed: err=%d\n", err);
+ 	return err;
+ }
+ 
+ static int brcmf_pno_add_bssid(struct brcmf_if *ifp, const u8 *bssid)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_pno_bssid_le bssid_cfg;
+ 	int err;
+ 
+@@ -234,7 +238,7 @@ static int brcmf_pno_add_bssid(struct br
+ 	err = brcmf_fil_iovar_data_set(ifp, "pfn_add_bssid", &bssid_cfg,
+ 				       sizeof(bssid_cfg));
+ 	if (err < 0)
+-		brcmf_err("adding failed: err=%d\n", err);
++		bphy_err(drvr, "adding failed: err=%d\n", err);
+ 	return err;
+ }
+ 
+@@ -258,6 +262,7 @@ static bool brcmf_is_ssid_active(struct
+ 
+ static int brcmf_pno_clean(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	int ret;
+ 
+ 	/* Disable pfn */
+@@ -267,7 +272,7 @@ static int brcmf_pno_clean(struct brcmf_
+ 		ret = brcmf_fil_iovar_data_set(ifp, "pfnclear", NULL, 0);
+ 	}
+ 	if (ret < 0)
+-		brcmf_err("failed code %d\n", ret);
++		bphy_err(drvr, "failed code %d\n", ret);
+ 
+ 	return ret;
+ }
+@@ -392,6 +397,7 @@ static int brcmf_pno_config_networks(str
+ 
+ static int brcmf_pno_config_sched_scans(struct brcmf_if *ifp)
+ {
++	struct brcmf_pub *drvr = ifp->drvr;
+ 	struct brcmf_pno_info *pi;
+ 	struct brcmf_gscan_config *gscan_cfg;
+ 	struct brcmf_gscan_bucket_config *buckets;
+@@ -416,7 +422,7 @@ static int brcmf_pno_config_sched_scans(
+ 	/* clean up everything */
+ 	err = brcmf_pno_clean(ifp);
+ 	if  (err < 0) {
+-		brcmf_err("failed error=%d\n", err);
++		bphy_err(drvr, "failed error=%d\n", err);
+ 		goto free_gscan;
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.c
+@@ -47,8 +47,8 @@ int brcmf_proto_attach(struct brcmf_pub
+ 		if (brcmf_proto_msgbuf_attach(drvr))
+ 			goto fail;
+ 	} else {
+-		brcmf_err("Unsupported proto type %d\n",
+-			  drvr->bus_if->proto_type);
++		bphy_err(drvr, "Unsupported proto type %d\n",
++			 drvr->bus_if->proto_type);
+ 		goto fail;
+ 	}
+ 	if (!proto->tx_queue_data || (proto->hdrpull == NULL) ||
+@@ -56,7 +56,7 @@ int brcmf_proto_attach(struct brcmf_pub
+ 	    (proto->configure_addr_mode == NULL) ||
+ 	    (proto->delete_peer == NULL) || (proto->add_tdls_peer == NULL) ||
+ 	    (proto->debugfs_create == NULL)) {
+-		brcmf_err("Not all proto handlers have been installed\n");
++		bphy_err(drvr, "Not all proto handlers have been installed\n");
+ 		goto fail;
+ 	}
+ 	return 0;
diff -uprN a/package/kernel/mac80211/patches/brcm/355-v5.1-brcmfmac-add-basic-validation-of-shared-RAM-address.patch b/package/kernel/mac80211/patches/brcm/355-v5.1-brcmfmac-add-basic-validation-of-shared-RAM-address.patch
--- a/package/kernel/mac80211/patches/brcm/355-v5.1-brcmfmac-add-basic-validation-of-shared-RAM-address.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/355-v5.1-brcmfmac-add-basic-validation-of-shared-RAM-address.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,38 @@
+From e0a8ef4d7b4315bc4c1641fb3f3a7dfdfa6627b8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Wed, 20 Feb 2019 11:30:47 +0100
+Subject: [PATCH] brcmfmac: add basic validation of shared RAM address
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+While experimenting with firmware loading I ended up in a state of
+firmware reporting shared RAM address 0x04000001. It was causing:
+[   94.448015] Unable to handle kernel paging request at virtual address cd680001
+due to reading out of the mapped memory.
+
+This patch adds some basic validation to avoid kernel crashes due to the
+unexpected firmware behavior.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 6 ++++++
+ 1 file changed, 6 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1560,6 +1560,12 @@ static int brcmf_pcie_download_fw_nvram(
+ 		brcmf_err(bus, "FW failed to initialize\n");
+ 		return -ENODEV;
+ 	}
++	if (sharedram_addr < devinfo->ci->rambase ||
++	    sharedram_addr >= devinfo->ci->rambase + devinfo->ci->ramsize) {
++		brcmf_err(bus, "Invalid shared RAM address 0x%08x\n",
++			  sharedram_addr);
++		return -ENODEV;
++	}
+ 	brcmf_dbg(PCIE, "Shared RAM addr: 0x%08x\n", sharedram_addr);
+ 
+ 	return (brcmf_pcie_init_share_ram_info(devinfo, sharedram_addr));
diff -uprN a/package/kernel/mac80211/patches/brcm/356-v5.1-0001-brcmfmac-fix-size-of-the-struct-msgbuf_ring_status.patch b/package/kernel/mac80211/patches/brcm/356-v5.1-0001-brcmfmac-fix-size-of-the-struct-msgbuf_ring_status.patch
--- a/package/kernel/mac80211/patches/brcm/356-v5.1-0001-brcmfmac-fix-size-of-the-struct-msgbuf_ring_status.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/356-v5.1-0001-brcmfmac-fix-size-of-the-struct-msgbuf_ring_status.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,29 @@
+From 0c7051610c577b60b01b3b5aec14d6765e177b0d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 21 Feb 2019 11:33:24 +0100
+Subject: [PATCH] brcmfmac: fix size of the struct msgbuf_ring_status
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This updates host struct to match the in-firmawre definition. It's a
+cosmetic change as it only applies to the reserved struct space.
+
+Fixes: c988b78244df ("brcmfmac: print firmware reported ring status errors")
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -139,7 +139,7 @@ struct msgbuf_ring_status {
+ 	struct msgbuf_common_hdr	msg;
+ 	struct msgbuf_completion_hdr	compl_hdr;
+ 	__le16				write_idx;
+-	__le32				rsvd0[5];
++	__le16				rsvd0[5];
+ };
+ 
+ struct msgbuf_rx_event {
diff -uprN a/package/kernel/mac80211/patches/brcm/356-v5.1-0002-brcmfmac-print-firmware-reported-general-status-erro.patch b/package/kernel/mac80211/patches/brcm/356-v5.1-0002-brcmfmac-print-firmware-reported-general-status-erro.patch
--- a/package/kernel/mac80211/patches/brcm/356-v5.1-0002-brcmfmac-print-firmware-reported-general-status-erro.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/356-v5.1-0002-brcmfmac-print-firmware-reported-general-status-erro.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,69 @@
+From c91377495192cda096e52dc09c266b0d05f16d86 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 21 Feb 2019 11:33:25 +0100
+Subject: [PATCH] brcmfmac: print firmware reported general status errors
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Firmware may report general errors using a special message type. Add
+basic support for it by simply decoding & printing an error number.
+
+A sample situation in which firmware reports a buf error:
+CONSOLE: 027084.733 no host response IOCTL buffer available..so fail the request
+will now produce a "Firmware reported general error: 9" on the host.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/msgbuf.c      | 24 +++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -134,6 +134,14 @@ struct msgbuf_completion_hdr {
+ 	__le16				flow_ring_id;
+ };
+ 
++/* Data struct for the MSGBUF_TYPE_GEN_STATUS */
++struct msgbuf_gen_status {
++	struct msgbuf_common_hdr	msg;
++	struct msgbuf_completion_hdr	compl_hdr;
++	__le16				write_idx;
++	__le32				rsvd0[3];
++};
++
+ /* Data struct for the MSGBUF_TYPE_RING_STATUS */
+ struct msgbuf_ring_status {
+ 	struct msgbuf_common_hdr	msg;
+@@ -1194,6 +1202,18 @@ brcmf_msgbuf_process_rx_complete(struct
+ 	brcmf_netif_rx(ifp, skb);
+ }
+ 
++static void brcmf_msgbuf_process_gen_status(struct brcmf_msgbuf *msgbuf,
++					    void *buf)
++{
++	struct msgbuf_gen_status *gen_status = buf;
++	struct brcmf_pub *drvr = msgbuf->drvr;
++	int err;
++
++	err = le16_to_cpu(gen_status->compl_hdr.status);
++	if (err)
++		bphy_err(drvr, "Firmware reported general error: %d\n", err);
++}
++
+ static void brcmf_msgbuf_process_ring_status(struct brcmf_msgbuf *msgbuf,
+ 					     void *buf)
+ {
+@@ -1273,6 +1293,10 @@ static void brcmf_msgbuf_process_msgtype
+ 
+ 	msg = (struct msgbuf_common_hdr *)buf;
+ 	switch (msg->msgtype) {
++	case MSGBUF_TYPE_GEN_STATUS:
++		brcmf_dbg(MSGBUF, "MSGBUF_TYPE_GEN_STATUS\n");
++		brcmf_msgbuf_process_gen_status(msgbuf, buf);
++		break;
+ 	case MSGBUF_TYPE_RING_STATUS:
+ 		brcmf_dbg(MSGBUF, "MSGBUF_TYPE_RING_STATUS\n");
+ 		brcmf_msgbuf_process_ring_status(msgbuf, buf);
diff -uprN a/package/kernel/mac80211/patches/brcm/360-v5.2-0001-brcmfmac-support-repeated-brcmf_fw_alloc_request-cal.patch b/package/kernel/mac80211/patches/brcm/360-v5.2-0001-brcmfmac-support-repeated-brcmf_fw_alloc_request-cal.patch
--- a/package/kernel/mac80211/patches/brcm/360-v5.2-0001-brcmfmac-support-repeated-brcmf_fw_alloc_request-cal.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/360-v5.2-0001-brcmfmac-support-repeated-brcmf_fw_alloc_request-cal.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,32 @@
+From c9692820710f57c826b2e43a6fb1e4cd307508b0 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 26 Feb 2019 14:11:16 +0100
+Subject: [PATCH] brcmfmac: support repeated brcmf_fw_alloc_request() calls
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+During a normal brcmfmac lifetime brcmf_fw_alloc_request() is called
+once only during the probe. It's safe to assume provided array is clear.
+
+Further brcmfmac improvements may require calling it multiple times
+though. This patch allows it by fixing invalid firmware paths like:
+brcm/brcmfmac4366c-pcie.binbrcm/brcmfmac4366c-pcie.bin
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -743,6 +743,7 @@ brcmf_fw_alloc_request(u32 chip, u32 chi
+ 
+ 	for (j = 0; j < n_fwnames; j++) {
+ 		fwreq->items[j].path = fwnames[j].path;
++		fwnames[j].path[0] = '\0';
+ 		/* check if firmware path is provided by module parameter */
+ 		if (brcmf_mp_global.firmware_path[0] != '\0') {
+ 			strlcpy(fwnames[j].path, mp_path,
diff -uprN a/package/kernel/mac80211/patches/brcm/360-v5.2-0002-brcmfmac-add-a-function-designated-for-handling-firm.patch b/package/kernel/mac80211/patches/brcm/360-v5.2-0002-brcmfmac-add-a-function-designated-for-handling-firm.patch
--- a/package/kernel/mac80211/patches/brcm/360-v5.2-0002-brcmfmac-add-a-function-designated-for-handling-firm.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/360-v5.2-0002-brcmfmac-add-a-function-designated-for-handling-firm.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,79 @@
+From a2ec87ddbf1637f854ffcfff9d12d392fa30758b Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 26 Feb 2019 14:11:18 +0100
+Subject: [PATCH] brcmfmac: add a function designated for handling firmware
+ fails
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This improves handling PCIe firmware halts by printing a clear error
+message and replaces a similar code in the SDIO bus support.
+
+It will also allow further improvements like trying to recover from a
+firmware crash.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h |  2 ++
+ .../net/wireless/broadcom/brcm80211/brcmfmac/core.c    | 10 ++++++++++
+ .../net/wireless/broadcom/brcm80211/brcmfmac/pcie.c    |  2 +-
+ .../net/wireless/broadcom/brcm80211/brcmfmac/sdio.c    |  4 ++--
+ 4 files changed, 15 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
+@@ -262,6 +262,8 @@ void brcmf_detach(struct device *dev);
+ void brcmf_dev_reset(struct device *dev);
+ /* Request from bus module to initiate a coredump */
+ void brcmf_dev_coredump(struct device *dev);
++/* Indication that firmware has halted or crashed */
++void brcmf_fw_crashed(struct device *dev);
+ 
+ /* Configure the "global" bus state used by upper layers */
+ void brcmf_bus_change_state(struct brcmf_bus *bus, enum brcmf_bus_state state);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1298,6 +1298,16 @@ void brcmf_dev_coredump(struct device *d
+ 		brcmf_dbg(TRACE, "failed to create coredump\n");
+ }
+ 
++void brcmf_fw_crashed(struct device *dev)
++{
++	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
++	struct brcmf_pub *drvr = bus_if->drvr;
++
++	bphy_err(drvr, "Firmware has halted or crashed\n");
++
++	brcmf_dev_coredump(dev);
++}
++
+ void brcmf_detach(struct device *dev)
+ {
+ 	s32 i;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -730,7 +730,7 @@ static void brcmf_pcie_handle_mb_data(st
+ 	}
+ 	if (dtoh_mb_data & BRCMF_D2H_DEV_FWHALT) {
+ 		brcmf_dbg(PCIE, "D2H_MB_DATA: FW HALT\n");
+-		brcmf_dev_coredump(&devinfo->pdev->dev);
++		brcmf_fw_crashed(&devinfo->pdev->dev);
+ 	}
+ }
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -1101,8 +1101,8 @@ static u32 brcmf_sdio_hostmail(struct br
+ 
+ 	/* dongle indicates the firmware has halted/crashed */
+ 	if (hmb_data & HMB_DATA_FWHALT) {
+-		brcmf_err("mailbox indicates firmware halted\n");
+-		brcmf_dev_coredump(&sdiod->func1->dev);
++		brcmf_dbg(SDIO, "mailbox indicates firmware halted\n");
++		brcmf_fw_crashed(&sdiod->func1->dev);
+ 	}
+ 
+ 	/* Dongle recomposed rx frames, accept them again */
diff -uprN a/package/kernel/mac80211/patches/brcm/360-v5.2-0003-brcmfmac-reset-PCIe-bus-on-a-firmware-crash.patch b/package/kernel/mac80211/patches/brcm/360-v5.2-0003-brcmfmac-reset-PCIe-bus-on-a-firmware-crash.patch
--- a/package/kernel/mac80211/patches/brcm/360-v5.2-0003-brcmfmac-reset-PCIe-bus-on-a-firmware-crash.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/360-v5.2-0003-brcmfmac-reset-PCIe-bus-on-a-firmware-crash.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,153 @@
+From 4684997d9eea29380000e062755aa6d368d789a3 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 26 Feb 2019 14:11:19 +0100
+Subject: [PATCH] brcmfmac: reset PCIe bus on a firmware crash
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This includes bus reset & reloading a firmware. It should be sufficient
+for a user space to (setup and) use a wireless device again.
+
+Support for reset on USB & SDIO can be added later.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/bus.h         | 10 ++++++
+ .../broadcom/brcm80211/brcmfmac/core.c        | 12 +++++++
+ .../broadcom/brcm80211/brcmfmac/core.h        |  2 ++
+ .../broadcom/brcm80211/brcmfmac/pcie.c        | 35 +++++++++++++++++++
+ 4 files changed, 59 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
+@@ -91,6 +91,7 @@ struct brcmf_bus_ops {
+ 	int (*get_fwname)(struct device *dev, const char *ext,
+ 			  unsigned char *fw_name);
+ 	void (*debugfs_create)(struct device *dev);
++	int (*reset)(struct device *dev);
+ };
+ 
+ 
+@@ -245,6 +246,15 @@ void brcmf_bus_debugfs_create(struct brc
+ 	return bus->ops->debugfs_create(bus->dev);
+ }
+ 
++static inline
++int brcmf_bus_reset(struct brcmf_bus *bus)
++{
++	if (!bus->ops->reset)
++		return -EOPNOTSUPP;
++
++	return bus->ops->reset(bus->dev);
++}
++
+ /*
+  * interface functions from common layer
+  */
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1109,6 +1109,14 @@ static int brcmf_revinfo_read(struct seq
+ 	return 0;
+ }
+ 
++static void brcmf_core_bus_reset(struct work_struct *work)
++{
++	struct brcmf_pub *drvr = container_of(work, struct brcmf_pub,
++					      bus_reset);
++
++	brcmf_bus_reset(drvr->bus_if);
++}
++
+ static int brcmf_bus_started(struct brcmf_pub *drvr, struct cfg80211_ops *ops)
+ {
+ 	int ret = -1;
+@@ -1180,6 +1188,8 @@ static int brcmf_bus_started(struct brcm
+ #endif
+ #endif /* CONFIG_INET */
+ 
++	INIT_WORK(&drvr->bus_reset, brcmf_core_bus_reset);
++
+ 	/* populate debugfs */
+ 	brcmf_debugfs_add_entry(drvr, "revinfo", brcmf_revinfo_read);
+ 	brcmf_feat_debugfs_create(drvr);
+@@ -1306,6 +1316,8 @@ void brcmf_fw_crashed(struct device *dev
+ 	bphy_err(drvr, "Firmware has halted or crashed\n");
+ 
+ 	brcmf_dev_coredump(dev);
++
++	schedule_work(&drvr->bus_reset);
+ }
+ 
+ void brcmf_detach(struct device *dev)
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
+@@ -143,6 +143,8 @@ struct brcmf_pub {
+ 	struct notifier_block inet6addr_notifier;
+ 	struct brcmf_mp_device *settings;
+ 
++	struct work_struct bus_reset;
++
+ 	u8 clmver[BRCMF_DCMD_SMLEN];
+ };
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -345,6 +345,10 @@ static const u32 brcmf_ring_itemsize[BRC
+ 	BRCMF_D2H_MSGRING_RX_COMPLETE_ITEMSIZE
+ };
+ 
++static void brcmf_pcie_setup(struct device *dev, int ret,
++			     struct brcmf_fw_request *fwreq);
++static struct brcmf_fw_request *
++brcmf_pcie_prepare_fw_request(struct brcmf_pciedev_info *devinfo);
+ 
+ static u32
+ brcmf_pcie_read_reg32(struct brcmf_pciedev_info *devinfo, u32 reg_offset)
+@@ -1409,6 +1413,36 @@ int brcmf_pcie_get_fwname(struct device
+ 	return 0;
+ }
+ 
++static int brcmf_pcie_reset(struct device *dev)
++{
++	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
++	struct brcmf_pciedev *buspub = bus_if->bus_priv.pcie;
++	struct brcmf_pciedev_info *devinfo = buspub->devinfo;
++	struct brcmf_fw_request *fwreq;
++	int err;
++
++	brcmf_detach(dev);
++
++	brcmf_pcie_release_irq(devinfo);
++	brcmf_pcie_release_scratchbuffers(devinfo);
++	brcmf_pcie_release_ringbuffers(devinfo);
++	brcmf_pcie_reset_device(devinfo);
++
++	fwreq = brcmf_pcie_prepare_fw_request(devinfo);
++	if (!fwreq) {
++		dev_err(dev, "Failed to prepare FW request\n");
++		return -ENOMEM;
++	}
++
++	err = brcmf_fw_get_firmwares(dev, fwreq, brcmf_pcie_setup);
++	if (err) {
++		dev_err(dev, "Failed to prepare FW request\n");
++		kfree(fwreq);
++	}
++
++	return err;
++}
++
+ static const struct brcmf_bus_ops brcmf_pcie_bus_ops = {
+ 	.txdata = brcmf_pcie_tx,
+ 	.stop = brcmf_pcie_down,
+@@ -1418,6 +1452,7 @@ static const struct brcmf_bus_ops brcmf_
+ 	.get_ramsize = brcmf_pcie_get_ramsize,
+ 	.get_memdump = brcmf_pcie_get_memdump,
+ 	.get_fwname = brcmf_pcie_get_fwname,
++	.reset = brcmf_pcie_reset,
+ };
+ 
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/362-v5.2-0002-brcmfmac-remove-pending-parameter-from-brcmf_usb_fre.patch b/package/kernel/mac80211/patches/brcm/362-v5.2-0002-brcmfmac-remove-pending-parameter-from-brcmf_usb_fre.patch
--- a/package/kernel/mac80211/patches/brcm/362-v5.2-0002-brcmfmac-remove-pending-parameter-from-brcmf_usb_fre.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/362-v5.2-0002-brcmfmac-remove-pending-parameter-from-brcmf_usb_fre.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,54 @@
+From 2b78e5f5223666d403d4fdb30af4ad65c8da3cdb Mon Sep 17 00:00:00 2001
+From: Piotr Figiel <p.figiel@camlintechnologies.com>
+Date: Fri, 8 Mar 2019 15:25:06 +0000
+Subject: [PATCH] brcmfmac: remove pending parameter from brcmf_usb_free_q
+
+brcmf_usb_free_q is no longer called with pending=true thus this boolean
+parameter is no longer needed.
+
+Signed-off-by: Piotr Figiel <p.figiel@camlintechnologies.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/usb.c    | 15 ++++++---------
+ 1 file changed, 6 insertions(+), 9 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -446,9 +446,10 @@ fail:
+ 
+ }
+ 
+-static void brcmf_usb_free_q(struct list_head *q, bool pending)
++static void brcmf_usb_free_q(struct list_head *q)
+ {
+ 	struct brcmf_usbreq *req, *next;
++
+ 	int i = 0;
+ 	list_for_each_entry_safe(req, next, q, list) {
+ 		if (!req->urb) {
+@@ -456,12 +457,8 @@ static void brcmf_usb_free_q(struct list
+ 			break;
+ 		}
+ 		i++;
+-		if (pending) {
+-			usb_kill_urb(req->urb);
+-		} else {
+-			usb_free_urb(req->urb);
+-			list_del_init(&req->list);
+-		}
++		usb_free_urb(req->urb);
++		list_del_init(&req->list);
+ 	}
+ }
+ 
+@@ -1030,8 +1027,8 @@ static void brcmf_usb_detach(struct brcm
+ 	brcmf_dbg(USB, "Enter, devinfo %p\n", devinfo);
+ 
+ 	/* free the URBS */
+-	brcmf_usb_free_q(&devinfo->rx_freeq, false);
+-	brcmf_usb_free_q(&devinfo->tx_freeq, false);
++	brcmf_usb_free_q(&devinfo->rx_freeq);
++	brcmf_usb_free_q(&devinfo->tx_freeq);
+ 
+ 	usb_free_urb(devinfo->ctl_urb);
+ 	usb_free_urb(devinfo->bulk_urb);
diff -uprN a/package/kernel/mac80211/patches/brcm/362-v5.2-0003-brcmfmac-remove-unused-variable-i-from-brcmf_usb_fre.patch b/package/kernel/mac80211/patches/brcm/362-v5.2-0003-brcmfmac-remove-unused-variable-i-from-brcmf_usb_fre.patch
--- a/package/kernel/mac80211/patches/brcm/362-v5.2-0003-brcmfmac-remove-unused-variable-i-from-brcmf_usb_fre.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/362-v5.2-0003-brcmfmac-remove-unused-variable-i-from-brcmf_usb_fre.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,29 @@
+From 504f06725d015954a0fcafdf1d90a6795ca8f769 Mon Sep 17 00:00:00 2001
+From: Piotr Figiel <p.figiel@camlintechnologies.com>
+Date: Fri, 8 Mar 2019 15:25:09 +0000
+Subject: [PATCH] brcmfmac: remove unused variable i from brcmf_usb_free_q
+
+Variable i is not used so remove it.
+
+Signed-off-by: Piotr Figiel <p.figiel@camlintechnologies.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -450,13 +450,11 @@ static void brcmf_usb_free_q(struct list
+ {
+ 	struct brcmf_usbreq *req, *next;
+ 
+-	int i = 0;
+ 	list_for_each_entry_safe(req, next, q, list) {
+ 		if (!req->urb) {
+ 			brcmf_err("bad req\n");
+ 			break;
+ 		}
+-		i++;
+ 		usb_free_urb(req->urb);
+ 		list_del_init(&req->list);
+ 	}
diff -uprN a/package/kernel/mac80211/patches/brcm/366-v5.2-brcmfmac-Use-struct_size-in-kzalloc.patch b/package/kernel/mac80211/patches/brcm/366-v5.2-brcmfmac-Use-struct_size-in-kzalloc.patch
--- a/package/kernel/mac80211/patches/brcm/366-v5.2-brcmfmac-Use-struct_size-in-kzalloc.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/366-v5.2-brcmfmac-Use-struct_size-in-kzalloc.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,53 @@
+From 0cf83903aad03dc7f444a47990def48c4a9d3276 Mon Sep 17 00:00:00 2001
+From: "Gustavo A. R. Silva" <gustavo@embeddedor.com>
+Date: Wed, 3 Apr 2019 11:46:11 -0500
+Subject: [PATCH] brcmfmac: Use struct_size() in kzalloc()
+
+One of the more common cases of allocation size calculations is finding
+the size of a structure that has a zero-sized array at the end, along
+with memory for some number of elements for that array. For example:
+
+struct foo {
+    int stuff;
+    struct boo entry[];
+};
+
+size = sizeof(struct foo) + count * sizeof(struct boo);
+instance = kzalloc(size, GFP_KERNEL)
+
+Instead of leaving these open-coded and prone to type mistakes, we can
+now use the new struct_size() helper:
+
+instance = kzalloc(struct_size(instance, entry, count), GFP_KERNEL)
+
+Notice that, in this case, variable reqsz is not necessary,
+hence it is removed.
+
+This code was detected with the help of Coccinelle.
+
+Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -711,7 +711,6 @@ brcmf_fw_alloc_request(u32 chip, u32 chi
+ 	size_t mp_path_len;
+ 	u32 i, j;
+ 	char end = '\0';
+-	size_t reqsz;
+ 
+ 	for (i = 0; i < table_size; i++) {
+ 		if (mapping_table[i].chipid == chip &&
+@@ -726,8 +725,7 @@ brcmf_fw_alloc_request(u32 chip, u32 chi
+ 		return NULL;
+ 	}
+ 
+-	reqsz = sizeof(*fwreq) + n_fwnames * sizeof(struct brcmf_fw_item);
+-	fwreq = kzalloc(reqsz, GFP_KERNEL);
++	fwreq = kzalloc(struct_size(fwreq, items, n_fwnames), GFP_KERNEL);
+ 	if (!fwreq)
+ 		return NULL;
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/367-v5.2-brcmfmac-Loading-the-correct-firmware-for-brcm43456.patch b/package/kernel/mac80211/patches/brcm/367-v5.2-brcmfmac-Loading-the-correct-firmware-for-brcm43456.patch
--- a/package/kernel/mac80211/patches/brcm/367-v5.2-brcmfmac-Loading-the-correct-firmware-for-brcm43456.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/367-v5.2-brcmfmac-Loading-the-correct-firmware-for-brcm43456.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,35 @@
+From e3062e05e1cfe378bb9b3fa0bef46711372bcf13 Mon Sep 17 00:00:00 2001
+From: Ondrej Jirman <megous@megous.com>
+Date: Sat, 6 Apr 2019 01:45:13 +0200
+Subject: [PATCH] brcmfmac: Loading the correct firmware for brcm43456
+
+SDIO based brcm43456 is currently misdetected as brcm43455 and the wrong
+firmware name is used. Correct the detection and load the correct
+firmware file. Chiprev for brcm43456 is "9".
+
+Signed-off-by: Ondrej Jirman <megous@megous.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -622,6 +622,7 @@ BRCMF_FW_DEF(43430A0, "brcmfmac43430a0-s
+ /* Note the names are not postfixed with a1 for backward compatibility */
+ BRCMF_FW_DEF(43430A1, "brcmfmac43430-sdio");
+ BRCMF_FW_DEF(43455, "brcmfmac43455-sdio");
++BRCMF_FW_DEF(43456, "brcmfmac43456-sdio");
+ BRCMF_FW_DEF(4354, "brcmfmac4354-sdio");
+ BRCMF_FW_DEF(4356, "brcmfmac4356-sdio");
+ BRCMF_FW_DEF(4373, "brcmfmac4373-sdio");
+@@ -642,7 +643,8 @@ static const struct brcmf_firmware_mappi
+ 	BRCMF_FW_ENTRY(BRCM_CC_4339_CHIP_ID, 0xFFFFFFFF, 4339),
+ 	BRCMF_FW_ENTRY(BRCM_CC_43430_CHIP_ID, 0x00000001, 43430A0),
+ 	BRCMF_FW_ENTRY(BRCM_CC_43430_CHIP_ID, 0xFFFFFFFE, 43430A1),
+-	BRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFFC0, 43455),
++	BRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0x00000200, 43456),
++	BRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFDC0, 43455),
+ 	BRCMF_FW_ENTRY(BRCM_CC_4354_CHIP_ID, 0xFFFFFFFF, 4354),
+ 	BRCMF_FW_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),
+ 	BRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373),
diff -uprN a/package/kernel/mac80211/patches/brcm/369-v5.2-brcmfmac-Add-DMI-nvram-filename-quirk-for-ACEPC-T8-a.patch b/package/kernel/mac80211/patches/brcm/369-v5.2-brcmfmac-Add-DMI-nvram-filename-quirk-for-ACEPC-T8-a.patch
--- a/package/kernel/mac80211/patches/brcm/369-v5.2-brcmfmac-Add-DMI-nvram-filename-quirk-for-ACEPC-T8-a.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/369-v5.2-brcmfmac-Add-DMI-nvram-filename-quirk-for-ACEPC-T8-a.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,70 @@
+From b1a0ba8f772d7a6dcb5aa3e856f5bd8274989ebe Mon Sep 17 00:00:00 2001
+From: Hans de Goede <hdegoede@redhat.com>
+Date: Mon, 22 Apr 2019 22:41:23 +0200
+Subject: [PATCH] brcmfmac: Add DMI nvram filename quirk for ACEPC T8 and T11
+ mini PCs
+
+The ACEPC T8 and T11 mini PCs contain quite generic names in the sys_vendor
+and product_name DMI strings, without this patch brcmfmac will try to load:
+"brcmfmac43455-sdio.Default string-Default string.txt" as nvram file which
+is way too generic.
+
+The DMI strings on which we are matching are somewhat generic too, but
+"To be filled by O.E.M." is less common then "Default string" and the
+system-sku and bios-version strings are pretty unique. Beside the DMI
+strings we also check the wifi-module chip-id and revision. I'm confident
+that the combination of all this is unique.
+
+Both the T8 and T11 use the same wifi-module, this commit adds DMI
+quirks for both mini PCs pointing to brcmfmac43455-sdio.acepc-t8.txt .
+
+BugLink: https://bugzilla.redhat.com/show_bug.cgi?id=1690852
+Cc: stable@vger.kernel.org
+Signed-off-by: Hans de Goede <hdegoede@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/dmi.c         | 26 +++++++++++++++++++
+ 1 file changed, 26 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
+@@ -31,6 +31,10 @@ struct brcmf_dmi_data {
+ 
+ /* NOTE: Please keep all entries sorted alphabetically */
+ 
++static const struct brcmf_dmi_data acepc_t8_data = {
++	BRCM_CC_4345_CHIP_ID, 6, "acepc-t8"
++};
++
+ static const struct brcmf_dmi_data gpd_win_pocket_data = {
+ 	BRCM_CC_4356_CHIP_ID, 2, "gpd-win-pocket"
+ };
+@@ -49,6 +53,28 @@ static const struct brcmf_dmi_data pov_t
+ 
+ static const struct dmi_system_id dmi_platform_data[] = {
+ 	{
++		/* ACEPC T8 Cherry Trail Z8350 mini PC */
++		.matches = {
++			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "To be filled by O.E.M."),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "Cherry Trail CR"),
++			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "T8"),
++			/* also match on somewhat unique bios-version */
++			DMI_EXACT_MATCH(DMI_BIOS_VERSION, "1.000"),
++		},
++		.driver_data = (void *)&acepc_t8_data,
++	},
++	{
++		/* ACEPC T11 Cherry Trail Z8350 mini PC, same wifi as the T8 */
++		.matches = {
++			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "To be filled by O.E.M."),
++			DMI_EXACT_MATCH(DMI_BOARD_NAME, "Cherry Trail CR"),
++			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "T11"),
++			/* also match on somewhat unique bios-version */
++			DMI_EXACT_MATCH(DMI_BIOS_VERSION, "1.000"),
++		},
++		.driver_data = (void *)&acepc_t8_data,
++	},
++	{
+ 		/* Match for the GPDwin which unfortunately uses somewhat
+ 		 * generic dmi strings, which is why we test for 4 strings.
+ 		 * Comparing against 23 other byt/cht boards, board_vendor
diff -uprN a/package/kernel/mac80211/patches/brcm/370-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch b/package/kernel/mac80211/patches/brcm/370-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch
--- a/package/kernel/mac80211/patches/brcm/370-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/370-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,32 @@
+From 99d94ef367af67f630b38c93ff46c5819b7d06b6 Mon Sep 17 00:00:00 2001
+From: Wright Feng <Wright.Feng@cypress.com>
+Date: Thu, 25 Apr 2019 07:05:46 +0000
+Subject: [PATCH] brcmfmac: send mailbox interrupt twice for specific hardware
+ device
+
+For PCIE wireless device with core revision less than 14, device may miss
+PCIE to System Backplane Interrupt via PCIEtoSBMailbox. So add sending
+mail box interrupt twice as a hardware workaround.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 6 +++++-
+ 1 file changed, 5 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -698,7 +698,11 @@ brcmf_pcie_send_mb_data(struct brcmf_pci
+ 
+ 	brcmf_pcie_write_tcm32(devinfo, addr, htod_mb_data);
+ 	pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
+-	pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
++
++	/* Send mailbox interrupt twice as a hardware workaround */
++	core = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_PCIE2);
++	if (core->rev <= 13)
++		pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
+ 
+ 	return 0;
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/371-v5.2-Revert-brcmfmac-send-mailbox-interrupt-twice-for-spe.patch b/package/kernel/mac80211/patches/brcm/371-v5.2-Revert-brcmfmac-send-mailbox-interrupt-twice-for-spe.patch
--- a/package/kernel/mac80211/patches/brcm/371-v5.2-Revert-brcmfmac-send-mailbox-interrupt-twice-for-spe.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/371-v5.2-Revert-brcmfmac-send-mailbox-interrupt-twice-for-spe.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,30 @@
+From 324f1feb960c79a07df3acde89a119a5aa80cb10 Mon Sep 17 00:00:00 2001
+From: Kalle Valo <kvalo@codeaurora.org>
+Date: Thu, 25 Apr 2019 20:08:31 +0300
+Subject: [PATCH] Revert "brcmfmac: send mailbox interrupt twice for specific
+ hardware device"
+
+This reverts commit 99d94ef367af67f630b38c93ff46c5819b7d06b6. I accidentally
+applied this broken (failed to compile) patch due to a bug in my patchwork
+script.
+
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 6 +-----
+ 1 file changed, 1 insertion(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -698,11 +698,7 @@ brcmf_pcie_send_mb_data(struct brcmf_pci
+ 
+ 	brcmf_pcie_write_tcm32(devinfo, addr, htod_mb_data);
+ 	pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
+-
+-	/* Send mailbox interrupt twice as a hardware workaround */
+-	core = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_PCIE2);
+-	if (core->rev <= 13)
+-		pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
++	pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
+ 
+ 	return 0;
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/372-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch b/package/kernel/mac80211/patches/brcm/372-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch
--- a/package/kernel/mac80211/patches/brcm/372-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/372-v5.2-brcmfmac-send-mailbox-interrupt-twice-for-specific-h.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,39 @@
+From 9ef77fbedad9ea8895cd5d7fb7aee16071f527dc Mon Sep 17 00:00:00 2001
+From: Wright Feng <Wright.Feng@cypress.com>
+Date: Fri, 26 Apr 2019 03:12:32 +0000
+Subject: [PATCH] brcmfmac: send mailbox interrupt twice for specific hardware
+ device
+
+For PCIE wireless device with core revision less than 14, device may miss
+PCIE to System Backplane Interrupt via PCIEtoSBMailbox. So add sending
+mail box interrupt twice as a hardware workaround.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 7 ++++++-
+ 1 file changed, 6 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -675,6 +675,7 @@ static int
+ brcmf_pcie_send_mb_data(struct brcmf_pciedev_info *devinfo, u32 htod_mb_data)
+ {
+ 	struct brcmf_pcie_shared_info *shared;
++	struct brcmf_core *core;
+ 	u32 addr;
+ 	u32 cur_htod_mb_data;
+ 	u32 i;
+@@ -698,7 +699,11 @@ brcmf_pcie_send_mb_data(struct brcmf_pci
+ 
+ 	brcmf_pcie_write_tcm32(devinfo, addr, htod_mb_data);
+ 	pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
+-	pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
++
++	/* Send mailbox interrupt twice as a hardware workaround */
++	core = brcmf_chip_get_core(devinfo->ci, BCMA_CORE_PCIE2);
++	if (core->rev <= 13)
++		pci_write_config_dword(devinfo->pdev, BRCMF_PCIE_REG_SBMBX, 1);
+ 
+ 	return 0;
+ }
diff -uprN a/package/kernel/mac80211/patches/brcm/374-v5.2-brcmfmac-set-txflow-request-id-from-1-to-pktids-arra.patch b/package/kernel/mac80211/patches/brcm/374-v5.2-brcmfmac-set-txflow-request-id-from-1-to-pktids-arra.patch
--- a/package/kernel/mac80211/patches/brcm/374-v5.2-brcmfmac-set-txflow-request-id-from-1-to-pktids-arra.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/374-v5.2-brcmfmac-set-txflow-request-id-from-1-to-pktids-arra.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,49 @@
+From 2d91c8ad068a5cad4d9e7ece8dc811a697c7176a Mon Sep 17 00:00:00 2001
+From: Wright Feng <Wright.Feng@cypress.com>
+Date: Fri, 26 Apr 2019 03:41:46 +0000
+Subject: [PATCH] brcmfmac: set txflow request id from 1 to pktids array size
+
+Some PCIE firmwares drop txstatus if pktid is 0 and make packet held in
+host side and never be released. If that packet type is 802.1x, the
+pend_8021x_cnt value will be always greater than 0 and show "Timed out
+waiting for no pending 802.1x packets" error message when sending key to
+dongle every time.
+
+To be compatible with all firmwares, host should set txflow request id
+from 1 instead of from 0.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -375,7 +375,7 @@ brcmf_msgbuf_get_pktid(struct device *de
+ 	struct brcmf_msgbuf_pktid *pktid;
+ 	struct sk_buff *skb;
+ 
+-	if (idx >= pktids->array_size) {
++	if (idx < 0 || idx >= pktids->array_size) {
+ 		brcmf_err("Invalid packet id %d (max %d)\n", idx,
+ 			  pktids->array_size);
+ 		return NULL;
+@@ -747,7 +747,7 @@ static void brcmf_msgbuf_txflow(struct b
+ 		tx_msghdr = (struct msgbuf_tx_msghdr *)ret_ptr;
+ 
+ 		tx_msghdr->msg.msgtype = MSGBUF_TYPE_TX_POST;
+-		tx_msghdr->msg.request_id = cpu_to_le32(pktid);
++		tx_msghdr->msg.request_id = cpu_to_le32(pktid + 1);
+ 		tx_msghdr->msg.ifidx = brcmf_flowring_ifidx_get(flow, flowid);
+ 		tx_msghdr->flags = BRCMF_MSGBUF_PKT_FLAGS_FRAME_802_3;
+ 		tx_msghdr->flags |= (skb->priority & 0x07) <<
+@@ -884,7 +884,7 @@ brcmf_msgbuf_process_txstatus(struct brc
+ 	u16 flowid;
+ 
+ 	tx_status = (struct msgbuf_tx_status *)buf;
+-	idx = le32_to_cpu(tx_status->msg.request_id);
++	idx = le32_to_cpu(tx_status->msg.request_id) - 1;
+ 	flowid = le16_to_cpu(tx_status->compl_hdr.flow_ring_id);
+ 	flowid -= BRCMF_H2D_MSGRING_FLOWRING_IDSTART;
+ 	skb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,
diff -uprN a/package/kernel/mac80211/patches/brcm/375-v5.2-brcmfmac-print-firmware-messages-after-a-firmware-cr.patch b/package/kernel/mac80211/patches/brcm/375-v5.2-brcmfmac-print-firmware-messages-after-a-firmware-cr.patch
--- a/package/kernel/mac80211/patches/brcm/375-v5.2-brcmfmac-print-firmware-messages-after-a-firmware-cr.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/375-v5.2-brcmfmac-print-firmware-messages-after-a-firmware-cr.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,90 @@
+From 47dd82e3d25e85a7c7c4e4b0eac9d297d1e5e2d4 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Sun, 28 Apr 2019 23:38:26 +0200
+Subject: [PATCH] brcmfmac: print firmware messages after a firmware crash
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Normally firmware messages are printed with debugging enabled only. It's
+a good idea as firmware may print a lot of messages that normal users
+don't need to care about.
+
+However, on firmware crash, it may be very helpful to log all recent
+messages. There is almost always a backtrace available as well as rought
+info on the latest actions/state.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/pcie.c        | 24 ++++++++++++++-----
+ 1 file changed, 18 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -764,15 +764,22 @@ static void brcmf_pcie_bus_console_init(
+ 		  console->base_addr, console->buf_addr, console->bufsize);
+ }
+ 
+-
+-static void brcmf_pcie_bus_console_read(struct brcmf_pciedev_info *devinfo)
++/**
++ * brcmf_pcie_bus_console_read - reads firmware messages
++ *
++ * @error: specifies if error has occurred (prints messages unconditionally)
++ */
++static void brcmf_pcie_bus_console_read(struct brcmf_pciedev_info *devinfo,
++					bool error)
+ {
++	struct pci_dev *pdev = devinfo->pdev;
++	struct brcmf_bus *bus = dev_get_drvdata(&pdev->dev);
+ 	struct brcmf_pcie_console *console;
+ 	u32 addr;
+ 	u8 ch;
+ 	u32 newidx;
+ 
+-	if (!BRCMF_FWCON_ON())
++	if (!error && !BRCMF_FWCON_ON())
+ 		return;
+ 
+ 	console = &devinfo->shared.console;
+@@ -796,7 +803,10 @@ static void brcmf_pcie_bus_console_read(
+ 		}
+ 		if (ch == '\n') {
+ 			console->log_str[console->log_idx] = 0;
+-			pr_debug("CONSOLE: %s", console->log_str);
++			if (error)
++				brcmf_err(bus, "CONSOLE: %s", console->log_str);
++			else
++				pr_debug("CONSOLE: %s", console->log_str);
+ 			console->log_idx = 0;
+ 		}
+ 	}
+@@ -857,7 +867,7 @@ static irqreturn_t brcmf_pcie_isr_thread
+ 							&devinfo->pdev->dev);
+ 		}
+ 	}
+-	brcmf_pcie_bus_console_read(devinfo);
++	brcmf_pcie_bus_console_read(devinfo, false);
+ 	if (devinfo->state == BRCMFMAC_PCIE_STATE_UP)
+ 		brcmf_pcie_intr_enable(devinfo);
+ 	devinfo->in_irq = false;
+@@ -1426,6 +1436,8 @@ static int brcmf_pcie_reset(struct devic
+ 	struct brcmf_fw_request *fwreq;
+ 	int err;
+ 
++	brcmf_pcie_bus_console_read(devinfo, true);
++
+ 	brcmf_detach(dev);
+ 
+ 	brcmf_pcie_release_irq(devinfo);
+@@ -1818,7 +1830,7 @@ static void brcmf_pcie_setup(struct devi
+ 	if (brcmf_attach(&devinfo->pdev->dev, devinfo->settings) == 0)
+ 		return;
+ 
+-	brcmf_pcie_bus_console_read(devinfo);
++	brcmf_pcie_bus_console_read(devinfo, false);
+ 
+ fail:
+ 	device_release_driver(dev);
diff -uprN a/package/kernel/mac80211/patches/brcm/380-v5.4-0001-brcmfmac-switch-source-files-to-using-SPDX-license-i.patch b/package/kernel/mac80211/patches/brcm/380-v5.4-0001-brcmfmac-switch-source-files-to-using-SPDX-license-i.patch
--- a/package/kernel/mac80211/patches/brcm/380-v5.4-0001-brcmfmac-switch-source-files-to-using-SPDX-license-i.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/380-v5.4-0001-brcmfmac-switch-source-files-to-using-SPDX-license-i.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,1223 @@
+From daeccac2d5e7a6179ffff63e40b4a59bc3376a05 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 16 May 2019 14:04:09 +0200
+Subject: [PATCH] brcmfmac: switch source files to using SPDX license
+ identifier
+
+With ISC license text in place under the LICENSES folder switch
+to using the SPDX license identifier to refer to the ISC license.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/Makefile | 14 ++------------
+ .../broadcom/brcm80211/brcmfmac/Makefile         | 14 ++------------
+ .../wireless/broadcom/brcm80211/brcmfmac/bcdc.c  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/bcdc.h  | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/bcmsdh.c         | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/btcoex.c         | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/btcoex.h         | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/bus.h   | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c       | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/cfg80211.h       | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/chip.c  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/chip.h  | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/common.c         | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/common.h         | 16 +++-------------
+ .../broadcom/brcm80211/brcmfmac/commonring.c     | 16 +++-------------
+ .../broadcom/brcm80211/brcmfmac/commonring.h     | 16 +++-------------
+ .../wireless/broadcom/brcm80211/brcmfmac/core.c  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/core.h  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/debug.c | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/debug.h | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/dmi.c   | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/feature.c        | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/feature.h        | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/firmware.c       | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/firmware.h       | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/flowring.c       | 16 +++-------------
+ .../broadcom/brcm80211/brcmfmac/flowring.h       | 16 +++-------------
+ .../wireless/broadcom/brcm80211/brcmfmac/fweh.c  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/fweh.h  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/fwil.c  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/fwil.h  | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/fwil_types.h     | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/fwsignal.c       | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/fwsignal.h       | 14 +-------------
+ .../broadcom/brcm80211/brcmfmac/msgbuf.c         | 16 +++-------------
+ .../broadcom/brcm80211/brcmfmac/msgbuf.h         | 16 +++-------------
+ .../wireless/broadcom/brcm80211/brcmfmac/of.c    | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/of.h    | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/p2p.c   | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/p2p.h   | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/pcie.c  | 16 +++-------------
+ .../wireless/broadcom/brcm80211/brcmfmac/pcie.h  | 16 +++-------------
+ .../wireless/broadcom/brcm80211/brcmfmac/pno.c   | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/pno.h   | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/proto.c | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/proto.h | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/sdio.c  | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/sdio.h  | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/tracepoint.c     | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/tracepoint.h     | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/usb.c   | 13 +------------
+ .../wireless/broadcom/brcm80211/brcmfmac/usb.h   | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/vendor.c         | 13 +------------
+ .../broadcom/brcm80211/brcmfmac/vendor.h         | 13 +------------
+ 54 files changed, 74 insertions(+), 658 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/Makefile
++++ b/drivers/net/wireless/broadcom/brcm80211/Makefile
+@@ -1,19 +1,9 @@
++# SPDX-License-Identifier: ISC
+ #
+-# Makefile fragment for Broadcom 802.11n Networking Device Driver
++# Makefile fragment for Broadcom 802.11 Networking Device Driver
+ #
+ # Copyright (c) 2010 Broadcom Corporation
+ #
+-# Permission to use, copy, modify, and/or distribute this software for any
+-# purpose with or without fee is hereby granted, provided that the above
+-# copyright notice and this permission notice appear in all copies.
+-#
+-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+-# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+-# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+-# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ # common flags
+ subdir-ccflags-$(CPTCFG_BRCMDBG)	+= -DDEBUG
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/Makefile
+@@ -1,19 +1,9 @@
++# SPDX-License-Identifier: ISC
+ #
+-# Makefile fragment for Broadcom 802.11n Networking Device Driver
++# Makefile fragment for Broadcom 802.11 Networking Device Driver
+ #
+ # Copyright (c) 2010 Broadcom Corporation
+ #
+-# Permission to use, copy, modify, and/or distribute this software for any
+-# purpose with or without fee is hereby granted, provided that the above
+-# copyright notice and this permission notice appear in all copies.
+-#
+-# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+-# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+-# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+-# SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+-# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+-# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+-# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ 
+ ccflags-y += \
+ 	-I$(backport_srctree)/drivers/net/wireless/broadcom/brcm80211/brcmfmac	\
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ /*******************************************************************************
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef BRCMFMAC_BCDC_H
+ #define BRCMFMAC_BCDC_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ /* ****************** SDIO CARD Interface Functions **************************/
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/slab.h>
+ #include <linux/netdevice.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/btcoex.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef WL_BTCOEX_H_
+ #define WL_BTCOEX_H_
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #ifndef BRCMFMAC_BUS_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ /* Toplevel file. Relies on dhd_linux.c to send commands to the dongle. */
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #ifndef BRCMFMAC_CFG80211_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/kernel.h>
+ #include <linux/delay.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef BRCMF_CHIP_H
+ #define BRCMF_CHIP_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/kernel.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.h
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ #ifndef BRCMFMAC_COMMON_H
+ #define BRCMFMAC_COMMON_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/commonring.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/commonring.c
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ 
+ #include <linux/types.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/commonring.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/commonring.h
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ #ifndef BRCMFMAC_COMMONRING_H
+ #define BRCMFMAC_COMMONRING_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/kernel.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ /****************
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/debugfs.h>
+ #include <linux/netdevice.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #ifndef BRCMFMAC_DEBUG_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/dmi.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright 2018 Hans de Goede <hdegoede@redhat.com>
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/dmi.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/netdevice.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef _BRCMF_FEATURE_H
+ #define _BRCMF_FEATURE_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/efi.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef BRCMFMAC_FIRMWARE_H
+ #define BRCMFMAC_FIRMWARE_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.c
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ 
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/flowring.h
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ #ifndef BRCMFMAC_FLOWRING_H
+ #define BRCMFMAC_FLOWRING_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/netdevice.h>
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ /* FWIL is the Firmware Interface Layer. In this module the support functions
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #ifndef _fwil_h_
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil_types.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/types.h>
+ #include <linux/module.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.h
+@@ -1,20 +1,8 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+-
+ #ifndef FWSIGNAL_H_
+ #define FWSIGNAL_H_
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ 
+ /*******************************************************************************
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.h
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ #ifndef BRCMFMAC_MSGBUF_H
+ #define BRCMFMAC_MSGBUF_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/init.h>
+ #include <linux/of.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifdef CONFIG_OF
+ void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/slab.h>
+ #include <linux/netdevice.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef WL_CFGP2P_H_
+ #define WL_CFGP2P_H_
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ 
+ #include <linux/kernel.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.h
+@@ -1,16 +1,6 @@
+-/* Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++// SPDX-License-Identifier: ISC
++/*
++ * Copyright (c) 2014 Broadcom Corporation
+  */
+ #ifndef BRCMFMAC_PCIE_H
+ #define BRCMFMAC_PCIE_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2016 Broadcom
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #include <linux/netdevice.h>
+ #include <linux/gcd.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2016 Broadcom
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef _BRCMF_PNO_H
+ #define _BRCMF_PNO_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef BRCMFMAC_PROTO_H
+ #define BRCMFMAC_PROTO_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/types.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2010 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #ifndef	BRCMFMAC_SDIO_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2012 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/device.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2013 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #if !defined(BRCMF_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ)
+ #define BRCMF_TRACEPOINT_H_
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2011 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/kernel.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2011 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ #ifndef BRCMFMAC_USB_H
+ #define BRCMFMAC_USB_H
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor.c
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #include <linux/vmalloc.h>
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/vendor.h
+@@ -1,17 +1,6 @@
++// SPDX-License-Identifier: ISC
+ /*
+  * Copyright (c) 2014 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
+ #ifndef _vendor_h_
diff -uprN a/package/kernel/mac80211/patches/brcm/381-v5.4-brcmfmac-fix-typos-in-code-comments.patch b/package/kernel/mac80211/patches/brcm/381-v5.4-brcmfmac-fix-typos-in-code-comments.patch
--- a/package/kernel/mac80211/patches/brcm/381-v5.4-brcmfmac-fix-typos-in-code-comments.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/381-v5.4-brcmfmac-fix-typos-in-code-comments.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,24 @@
+From b07e1ae2ce53a60af67009ef199603a588003e07 Mon Sep 17 00:00:00 2001
+From: Weitao Hou <houweitaoo@gmail.com>
+Date: Mon, 20 May 2019 20:28:25 +0800
+Subject: [PATCH] brcmfmac: fix typos in code comments
+
+fix lengh to length
+
+Signed-off-by: Weitao Hou <houweitaoo@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.c
+@@ -303,7 +303,7 @@ brcmf_create_bsscfg(s32 bsscfgidx, char
+ 		return brcmf_create_iovar(name, data, datalen, buf, buflen);
+ 
+ 	prefixlen = strlen(prefix);
+-	namelen = strlen(name) + 1; /* lengh of iovar  name + null */
++	namelen = strlen(name) + 1; /* length of iovar  name + null */
+ 	iolen = prefixlen + namelen + sizeof(bsscfgidx_le) + datalen;
+ 
+ 	if (buflen < iolen) {
diff -uprN a/package/kernel/mac80211/patches/brcm/382-v5.4-brcmfmac-use-strlcpy-instead-of-strcpy.patch b/package/kernel/mac80211/patches/brcm/382-v5.4-brcmfmac-use-strlcpy-instead-of-strcpy.patch
--- a/package/kernel/mac80211/patches/brcm/382-v5.4-brcmfmac-use-strlcpy-instead-of-strcpy.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/382-v5.4-brcmfmac-use-strlcpy-instead-of-strcpy.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,26 @@
+From bbfab331e3abd9fa8767eea6bf5c4684cdd4b934 Mon Sep 17 00:00:00 2001
+From: Neo Jou <neojou@gmail.com>
+Date: Tue, 21 May 2019 17:12:20 +0800
+Subject: [PATCH] brcmfmac: use strlcpy() instead of strcpy()
+
+The function strcpy() is inherently not safe. Though the function
+works without problems here, it would be better to use other safer
+function, e.g. strlcpy(), to replace strcpy() still.
+
+Signed-off-by: Neo Jou <neojou@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -258,7 +258,7 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 
+ 	/* query for 'ver' to get version info from firmware */
+ 	memset(buf, 0, sizeof(buf));
+-	strcpy(buf, "ver");
++	strlcpy(buf, "ver", sizeof(buf));
+ 	err = brcmf_fil_iovar_data_get(ifp, "ver", buf, sizeof(buf));
+ 	if (err < 0) {
+ 		bphy_err(drvr, "Retrieving version information failed, %d\n",
diff -uprN a/package/kernel/mac80211/patches/brcm/383-v5.4-0001-brcmfmac-add-160MHz-in-chandef_to_chanspec.patch b/package/kernel/mac80211/patches/brcm/383-v5.4-0001-brcmfmac-add-160MHz-in-chandef_to_chanspec.patch
--- a/package/kernel/mac80211/patches/brcm/383-v5.4-0001-brcmfmac-add-160MHz-in-chandef_to_chanspec.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/383-v5.4-0001-brcmfmac-add-160MHz-in-chandef_to_chanspec.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,56 @@
+From f491645f039420fb7e14283e21b90772571c807c Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 10:45:30 +0200
+Subject: [PATCH] brcmfmac: add 160MHz in chandef_to_chanspec()
+
+The function chandef_to_chanspec() was not handling 160MHz bandwidth
+resulting in wrong encoding of the channel. That resulting in firmware
+rejecting the provided channel specification.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 21 ++++++++++++++++++-
+ 1 file changed, 20 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -276,8 +276,26 @@ static u16 chandef_to_chanspec(struct br
+ 		else
+ 			ch_inf.sb = BRCMU_CHAN_SB_UU;
+ 		break;
+-	case NL80211_CHAN_WIDTH_80P80:
+ 	case NL80211_CHAN_WIDTH_160:
++		ch_inf.bw = BRCMU_CHAN_BW_160;
++		if (primary_offset == -70)
++			ch_inf.sb = BRCMU_CHAN_SB_LLL;
++		else if (primary_offset == -50)
++			ch_inf.sb = BRCMU_CHAN_SB_LLU;
++		else if (primary_offset == -30)
++			ch_inf.sb = BRCMU_CHAN_SB_LUL;
++		else if (primary_offset == -10)
++			ch_inf.sb = BRCMU_CHAN_SB_LUU;
++		else if (primary_offset == 10)
++			ch_inf.sb = BRCMU_CHAN_SB_ULL;
++		else if (primary_offset == 30)
++			ch_inf.sb = BRCMU_CHAN_SB_ULU;
++		else if (primary_offset == 50)
++			ch_inf.sb = BRCMU_CHAN_SB_UUL;
++		else
++			ch_inf.sb = BRCMU_CHAN_SB_UUU;
++		break;
++	case NL80211_CHAN_WIDTH_80P80:
+ 	case NL80211_CHAN_WIDTH_5:
+ 	case NL80211_CHAN_WIDTH_10:
+ 	default:
+@@ -296,6 +314,7 @@ static u16 chandef_to_chanspec(struct br
+ 	}
+ 	d11inf->encchspec(&ch_inf);
+ 
++	brcmf_dbg(TRACE, "chanspec: 0x%x\n", ch_inf.chspec);
+ 	return ch_inf.chspec;
+ }
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/383-v5.4-0002-brcmfmac-enable-DFS_OFFLOAD-extended-feature-if-supp.patch b/package/kernel/mac80211/patches/brcm/383-v5.4-0002-brcmfmac-enable-DFS_OFFLOAD-extended-feature-if-supp.patch
--- a/package/kernel/mac80211/patches/brcm/383-v5.4-0002-brcmfmac-enable-DFS_OFFLOAD-extended-feature-if-supp.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/383-v5.4-0002-brcmfmac-enable-DFS_OFFLOAD-extended-feature-if-supp.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,63 @@
+From 011a56a3336a5de9c3152c169cd52ff79b8c3f89 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 10:45:31 +0200
+Subject: [PATCH] brcmfmac: enable DFS_OFFLOAD extended feature if supported
+
+If the firmware supports 802.11h and the device can operate in 5GHz
+band we can enable DFS_OFFLOAD extended feature.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 5 +++++
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c  | 1 +
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h  | 4 +++-
+ 3 files changed, 9 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -6728,6 +6728,11 @@ static int brcmf_setup_wiphy(struct wiph
+ 		}
+ 	}
+ 
++	if (wiphy->bands[NL80211_BAND_5GHZ] &&
++	    brcmf_feat_is_enabled(ifp, BRCMF_FEAT_DOT11H))
++		wiphy_ext_feature_set(wiphy,
++				      NL80211_EXT_FEATURE_DFS_OFFLOAD);
++
+ 	wiphy_read_of_freq_limits(wiphy);
+ 
+ 	return 0;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+@@ -39,6 +39,7 @@ static const struct brcmf_feat_fwcap brc
+ 	{ BRCMF_FEAT_P2P, "p2p" },
+ 	{ BRCMF_FEAT_MONITOR, "monitor" },
+ 	{ BRCMF_FEAT_MONITOR_FMT_RADIOTAP, "rtap" },
++	{ BRCMF_FEAT_DOT11H, "802.11h" }
+ };
+ 
+ #ifdef DEBUG
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
+@@ -25,6 +25,7 @@
+  * MONITOR: firmware can pass monitor packets to host.
+  * MONITOR_FMT_RADIOTAP: firmware provides monitor packets with radiotap header
+  * MONITOR_FMT_HW_RX_HDR: firmware provides monitor packets with hw/ucode header
++ * DOT11H: firmware supports 802.11h
+  */
+ #define BRCMF_FEAT_LIST \
+ 	BRCMF_FEAT_DEF(MBSS) \
+@@ -43,7 +44,8 @@
+ 	BRCMF_FEAT_DEF(FWSUP) \
+ 	BRCMF_FEAT_DEF(MONITOR) \
+ 	BRCMF_FEAT_DEF(MONITOR_FMT_RADIOTAP) \
+-	BRCMF_FEAT_DEF(MONITOR_FMT_HW_RX_HDR)
++	BRCMF_FEAT_DEF(MONITOR_FMT_HW_RX_HDR) \
++	BRCMF_FEAT_DEF(DOT11H)
+ 
+ /*
+  * Quirks:
diff -uprN a/package/kernel/mac80211/patches/brcm/383-v5.4-0003-brcmfmac-allow-160MHz-in-custom-regulatory-rules.patch b/package/kernel/mac80211/patches/brcm/383-v5.4-0003-brcmfmac-allow-160MHz-in-custom-regulatory-rules.patch
--- a/package/kernel/mac80211/patches/brcm/383-v5.4-0003-brcmfmac-allow-160MHz-in-custom-regulatory-rules.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/383-v5.4-0003-brcmfmac-allow-160MHz-in-custom-regulatory-rules.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,34 @@
+From fa9050927fa885410055ee03c948c2252693d296 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 10:45:32 +0200
+Subject: [PATCH] brcmfmac: allow 160MHz in custom regulatory rules
+
+The driver has custom regulatory rules which had maximum bandwidth
+for 5GHz channels set to 80MHz. As a consequence the driver can
+not use 160MHz in AP mode even when the device supports it. So
+relax the rules allowing 160MHz. After wiphy_register() the channel
+flags are updated according what the device actually supports.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -189,9 +189,9 @@ static const struct ieee80211_regdomain
+ 		 */
+ 		REG_RULE(2484-10, 2484+10, 20, 6, 20, 0),
+ 		/* IEEE 802.11a, channel 36..64 */
+-		REG_RULE(5150-10, 5350+10, 80, 6, 20, 0),
++		REG_RULE(5150-10, 5350+10, 160, 6, 20, 0),
+ 		/* IEEE 802.11a, channel 100..165 */
+-		REG_RULE(5470-10, 5850+10, 80, 6, 20, 0), }
++		REG_RULE(5470-10, 5850+10, 160, 6, 20, 0), }
+ };
+ 
+ /* Note: brcmf_cipher_suites is an array of int defining which cipher suites
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0001-Revert-brcmfmac-fix-NULL-pointer-derefence-during-US.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0001-Revert-brcmfmac-fix-NULL-pointer-derefence-during-US.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0001-Revert-brcmfmac-fix-NULL-pointer-derefence-during-US.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0001-Revert-brcmfmac-fix-NULL-pointer-derefence-during-US.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,168 @@
+From a84a60ccdd65278485fb495f468a5ab91a75c649 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:06 +0200
+Subject: [PATCH] Revert "brcmfmac: fix NULL pointer derefence during USB
+ disconnect"
+
+This reverts commit 5cdb0ef6144f47440850553579aa923c20a63f23. Subsequent
+changes make rework the driver code fixing the issue differently.
+
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/bcdc.c  | 11 ++---------
+ .../wireless/broadcom/brcm80211/brcmfmac/bcdc.h  |  6 ++----
+ .../wireless/broadcom/brcm80211/brcmfmac/core.c  |  4 +---
+ .../broadcom/brcm80211/brcmfmac/fwsignal.c       | 16 ++++------------
+ .../broadcom/brcm80211/brcmfmac/fwsignal.h       |  3 +--
+ .../wireless/broadcom/brcm80211/brcmfmac/proto.c | 10 ++--------
+ .../wireless/broadcom/brcm80211/brcmfmac/proto.h |  3 +--
+ 7 files changed, 13 insertions(+), 40 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.c
+@@ -479,18 +479,11 @@ fail:
+ 	return -ENOMEM;
+ }
+ 
+-void brcmf_proto_bcdc_detach_pre_delif(struct brcmf_pub *drvr)
+-{
+-	struct brcmf_bcdc *bcdc = drvr->proto->pd;
+-
+-	brcmf_fws_detach_pre_delif(bcdc->fws);
+-}
+-
+-void brcmf_proto_bcdc_detach_post_delif(struct brcmf_pub *drvr)
++void brcmf_proto_bcdc_detach(struct brcmf_pub *drvr)
+ {
+ 	struct brcmf_bcdc *bcdc = drvr->proto->pd;
+ 
+ 	drvr->proto->pd = NULL;
+-	brcmf_fws_detach_post_delif(bcdc->fws);
++	brcmf_fws_detach(bcdc->fws);
+ 	kfree(bcdc);
+ }
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcdc.h
+@@ -7,16 +7,14 @@
+ 
+ #ifdef CPTCFG_BRCMFMAC_PROTO_BCDC
+ int brcmf_proto_bcdc_attach(struct brcmf_pub *drvr);
+-void brcmf_proto_bcdc_detach_pre_delif(struct brcmf_pub *drvr);
+-void brcmf_proto_bcdc_detach_post_delif(struct brcmf_pub *drvr);
++void brcmf_proto_bcdc_detach(struct brcmf_pub *drvr);
+ void brcmf_proto_bcdc_txflowblock(struct device *dev, bool state);
+ void brcmf_proto_bcdc_txcomplete(struct device *dev, struct sk_buff *txp,
+ 				 bool success);
+ struct brcmf_fws_info *drvr_to_fws(struct brcmf_pub *drvr);
+ #else
+ static inline int brcmf_proto_bcdc_attach(struct brcmf_pub *drvr) { return 0; }
+-static void brcmf_proto_bcdc_detach_pre_delif(struct brcmf_pub *drvr) {};
+-static inline void brcmf_proto_bcdc_detach_post_delif(struct brcmf_pub *drvr) {}
++static inline void brcmf_proto_bcdc_detach(struct brcmf_pub *drvr) {}
+ #endif
+ 
+ #endif /* BRCMFMAC_BCDC_H */
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1335,8 +1335,6 @@ void brcmf_detach(struct device *dev)
+ 
+ 	brcmf_bus_change_state(bus_if, BRCMF_BUS_DOWN);
+ 
+-	brcmf_proto_detach_pre_delif(drvr);
+-
+ 	if (drvr->mon_if) {
+ 		brcmf_net_detach(drvr->mon_if->ndev, false);
+ 		drvr->mon_if = NULL;
+@@ -1351,7 +1349,7 @@ void brcmf_detach(struct device *dev)
+ 
+ 	brcmf_bus_stop(drvr->bus_if);
+ 
+-	brcmf_proto_detach_post_delif(drvr);
++	brcmf_proto_detach(drvr);
+ 
+ 	bus_if->drvr = NULL;
+ 	wiphy_free(drvr->wiphy);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+@@ -2436,25 +2436,17 @@ struct brcmf_fws_info *brcmf_fws_attach(
+ 	return fws;
+ 
+ fail:
+-	brcmf_fws_detach_pre_delif(fws);
+-	brcmf_fws_detach_post_delif(fws);
++	brcmf_fws_detach(fws);
+ 	return ERR_PTR(rc);
+ }
+ 
+-void brcmf_fws_detach_pre_delif(struct brcmf_fws_info *fws)
++void brcmf_fws_detach(struct brcmf_fws_info *fws)
+ {
+ 	if (!fws)
+ 		return;
+-	if (fws->fws_wq) {
+-		destroy_workqueue(fws->fws_wq);
+-		fws->fws_wq = NULL;
+-	}
+-}
+ 
+-void brcmf_fws_detach_post_delif(struct brcmf_fws_info *fws)
+-{
+-	if (!fws)
+-		return;
++	if (fws->fws_wq)
++		destroy_workqueue(fws->fws_wq);
+ 
+ 	/* cleanup */
+ 	brcmf_fws_lock(fws);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.h
+@@ -7,8 +7,7 @@
+ #define FWSIGNAL_H_
+ 
+ struct brcmf_fws_info *brcmf_fws_attach(struct brcmf_pub *drvr);
+-void brcmf_fws_detach_pre_delif(struct brcmf_fws_info *fws);
+-void brcmf_fws_detach_post_delif(struct brcmf_fws_info *fws);
++void brcmf_fws_detach(struct brcmf_fws_info *fws);
+ void brcmf_fws_debugfs_create(struct brcmf_pub *drvr);
+ bool brcmf_fws_queue_skbs(struct brcmf_fws_info *fws);
+ bool brcmf_fws_fc_active(struct brcmf_fws_info *fws);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.c
+@@ -56,22 +56,16 @@ fail:
+ 	return -ENOMEM;
+ }
+ 
+-void brcmf_proto_detach_post_delif(struct brcmf_pub *drvr)
++void brcmf_proto_detach(struct brcmf_pub *drvr)
+ {
+ 	brcmf_dbg(TRACE, "Enter\n");
+ 
+ 	if (drvr->proto) {
+ 		if (drvr->bus_if->proto_type == BRCMF_PROTO_BCDC)
+-			brcmf_proto_bcdc_detach_post_delif(drvr);
++			brcmf_proto_bcdc_detach(drvr);
+ 		else if (drvr->bus_if->proto_type == BRCMF_PROTO_MSGBUF)
+ 			brcmf_proto_msgbuf_detach(drvr);
+ 		kfree(drvr->proto);
+ 		drvr->proto = NULL;
+ 	}
+ }
+-
+-void brcmf_proto_detach_pre_delif(struct brcmf_pub *drvr)
+-{
+-	if (drvr->proto && drvr->bus_if->proto_type == BRCMF_PROTO_BCDC)
+-		brcmf_proto_bcdc_detach_pre_delif(drvr);
+-}
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/proto.h
+@@ -43,8 +43,7 @@ struct brcmf_proto {
+ 
+ 
+ int brcmf_proto_attach(struct brcmf_pub *drvr);
+-void brcmf_proto_detach_pre_delif(struct brcmf_pub *drvr);
+-void brcmf_proto_detach_post_delif(struct brcmf_pub *drvr);
++void brcmf_proto_detach(struct brcmf_pub *drvr);
+ 
+ static inline int brcmf_proto_hdrpull(struct brcmf_pub *drvr, bool do_fws,
+ 				      struct sk_buff *skb,
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0002-brcmfmac-change-the-order-of-things-in-brcmf_detach.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0002-brcmfmac-change-the-order-of-things-in-brcmf_detach.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0002-brcmfmac-change-the-order-of-things-in-brcmf_detach.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0002-brcmfmac-change-the-order-of-things-in-brcmf_detach.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,72 @@
+From 14fcfd1cc0c05ea58f47dd693fdd13f25dfe995e Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:07 +0200
+Subject: [PATCH] brcmfmac: change the order of things in brcmf_detach()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+When brcmf_detach() from the bus layer upon rmmod we can no longer
+communicate. Hence we will set the bus state to DOWN and cleanup
+the event and protocol layer. The network interfaces need to be
+deleted before brcmf_cfg80211_detach() because the latter does the
+wiphy_unregister() which issues a warning if there are still network
+devices linked to the wiphy instance.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Tested-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/core.c        | 27 ++++++++++---------
+ 1 file changed, 14 insertions(+), 13 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1328,12 +1328,11 @@ void brcmf_detach(struct device *dev)
+ 	unregister_inet6addr_notifier(&drvr->inet6addr_notifier);
+ #endif
+ 
+-	/* stop firmware event handling */
+-	brcmf_fweh_detach(drvr);
+-	if (drvr->config)
+-		brcmf_p2p_detach(&drvr->config->p2p);
+-
+ 	brcmf_bus_change_state(bus_if, BRCMF_BUS_DOWN);
++	brcmf_bus_stop(drvr->bus_if);
++
++	brcmf_fweh_detach(drvr);
++	brcmf_proto_detach(drvr);
+ 
+ 	if (drvr->mon_if) {
+ 		brcmf_net_detach(drvr->mon_if->ndev, false);
+@@ -1341,17 +1340,19 @@ void brcmf_detach(struct device *dev)
+ 	}
+ 
+ 	/* make sure primary interface removed last */
+-	for (i = BRCMF_MAX_IFS-1; i > -1; i--)
+-		brcmf_remove_interface(drvr->iflist[i], false);
+-
+-	brcmf_cfg80211_detach(drvr->config);
+-	drvr->config = NULL;
+-
+-	brcmf_bus_stop(drvr->bus_if);
++	for (i = BRCMF_MAX_IFS - 1; i > -1; i--) {
++		if (drvr->iflist[i])
++			brcmf_del_if(drvr, drvr->iflist[i]->bsscfgidx, false);
++	}
+ 
+-	brcmf_proto_detach(drvr);
++	if (drvr->config) {
++		brcmf_p2p_detach(&drvr->config->p2p);
++		brcmf_cfg80211_detach(drvr->config);
++		drvr->config = NULL;
++	}
+ 
+ 	bus_if->drvr = NULL;
++
+ 	wiphy_free(drvr->wiphy);
+ }
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0003-brcmfmac-avoid-firmware-command-in-brcmf_netdev_open.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0003-brcmfmac-avoid-firmware-command-in-brcmf_netdev_open.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0003-brcmfmac-avoid-firmware-command-in-brcmf_netdev_open.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0003-brcmfmac-avoid-firmware-command-in-brcmf_netdev_open.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,30 @@
+From c613085b74941024194e41b200601b9aa6ee388f Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:08 +0200
+Subject: [PATCH] brcmfmac: avoid firmware command in brcmf_netdev_open() when
+ bus is down
+
+No point in sending a firmware command when bus is down so make it
+conditional checking the state.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -579,7 +579,8 @@ static int brcmf_netdev_stop(struct net_
+ 
+ 	brcmf_cfg80211_down(ndev);
+ 
+-	brcmf_fil_iovar_data_set(ifp, "arp_hostip_clear", NULL, 0);
++	if (ifp->drvr->bus_if->state == BRCMF_BUS_UP)
++		brcmf_fil_iovar_data_set(ifp, "arp_hostip_clear", NULL, 0);
+ 
+ 	brcmf_net_setcarrier(ifp, false);
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0004-brcmfmac-clear-events-in-brcmf_fweh_detach-will-alwa.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0004-brcmfmac-clear-events-in-brcmf_fweh_detach-will-alwa.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0004-brcmfmac-clear-events-in-brcmf_fweh_detach-will-alwa.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0004-brcmfmac-clear-events-in-brcmf_fweh_detach-will-alwa.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,38 @@
+From c33330ac06fe863289643e7a13ecdb6a2502dad7 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:09 +0200
+Subject: [PATCH] brcmfmac: clear events in brcmf_fweh_detach() will always
+ fail
+
+Clearing firmware events in brcmf_fweh_detach() is always failing
+because it is called only upon driver remove and communication
+with firmware is no longer possible.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c | 9 ---------
+ 1 file changed, 9 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.c
+@@ -303,16 +303,7 @@ void brcmf_fweh_attach(struct brcmf_pub
+ void brcmf_fweh_detach(struct brcmf_pub *drvr)
+ {
+ 	struct brcmf_fweh_info *fweh = &drvr->fweh;
+-	struct brcmf_if *ifp = brcmf_get_ifp(drvr, 0);
+-	s8 eventmask[BRCMF_EVENTING_MASK_LEN];
+ 
+-	if (ifp) {
+-		/* clear all events */
+-		memset(eventmask, 0, BRCMF_EVENTING_MASK_LEN);
+-		(void)brcmf_fil_iovar_data_set(ifp, "event_msgs",
+-					       eventmask,
+-					       BRCMF_EVENTING_MASK_LEN);
+-	}
+ 	/* cancel the worker */
+ 	cancel_work_sync(&fweh->event_work);
+ 	WARN_ON(!list_empty(&fweh->event_q));
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0005-brcmfmac-avoid-firmware-commands-when-bus-is-down.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0005-brcmfmac-avoid-firmware-commands-when-bus-is-down.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0005-brcmfmac-avoid-firmware-commands-when-bus-is-down.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0005-brcmfmac-avoid-firmware-commands-when-bus-is-down.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,79 @@
+From 1ac11ae949dd883854f4523ef8e3a32aabfd6256 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:10 +0200
+Subject: [PATCH] brcmfmac: avoid firmware commands when bus is down
+
+Upon rmmod a few attempts are made to inform firmware, but there is
+no point as the bus is down and these will fail. Avoid them to keep
+the logs clean.
+
+Reported-by: Stefan Wahren <stefan.wahren@i2se.com>
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 23 +++++++++++--------
+ 1 file changed, 13 insertions(+), 10 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -1286,17 +1286,21 @@ static void brcmf_link_down(struct brcmf
+ {
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);
+ 	struct brcmf_pub *drvr = cfg->pub;
++	bool bus_up = drvr->bus_if->state == BRCMF_BUS_UP;
+ 	s32 err = 0;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+ 
+ 	if (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state)) {
+-		brcmf_dbg(INFO, "Call WLC_DISASSOC to stop excess roaming\n");
+-		err = brcmf_fil_cmd_data_set(vif->ifp,
+-					     BRCMF_C_DISASSOC, NULL, 0);
+-		if (err) {
+-			bphy_err(drvr, "WLC_DISASSOC failed (%d)\n", err);
++		if (bus_up) {
++			brcmf_dbg(INFO, "Call WLC_DISASSOC to stop excess roaming\n");
++			err = brcmf_fil_cmd_data_set(vif->ifp,
++						     BRCMF_C_DISASSOC, NULL, 0);
++			if (err)
++				bphy_err(drvr, "WLC_DISASSOC failed (%d)\n",
++					 err);
+ 		}
++
+ 		if ((vif->wdev.iftype == NL80211_IFTYPE_STATION) ||
+ 		    (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT))
+ 			cfg80211_disconnected(vif->wdev.netdev, reason, NULL, 0,
+@@ -1306,7 +1310,8 @@ static void brcmf_link_down(struct brcmf
+ 	clear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);
+ 	brcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);
+ 	if (vif->profile.use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {
+-		brcmf_set_pmk(vif->ifp, NULL, 0);
++		if (bus_up)
++			brcmf_set_pmk(vif->ifp, NULL, 0);
+ 		vif->profile.use_fwsup = BRCMF_PROFILE_FWSUP_NONE;
+ 	}
+ 	brcmf_dbg(TRACE, "Exit\n");
+@@ -4996,18 +5001,16 @@ static int brcmf_cfg80211_get_channel(st
+ 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
+ 	struct net_device *ndev = wdev->netdev;
+ 	struct brcmf_pub *drvr = cfg->pub;
+-	struct brcmf_if *ifp;
+ 	struct brcmu_chan ch;
+ 	enum nl80211_band band = 0;
+ 	enum nl80211_chan_width width = 0;
+ 	u32 chanspec;
+ 	int freq, err;
+ 
+-	if (!ndev)
++	if (!ndev || drvr->bus_if->state != BRCMF_BUS_UP)
+ 		return -ENODEV;
+-	ifp = netdev_priv(ndev);
+ 
+-	err = brcmf_fil_iovar_int_get(ifp, "chanspec", &chanspec);
++	err = brcmf_fil_iovar_int_get(netdev_priv(ndev), "chanspec", &chanspec);
+ 	if (err) {
+ 		bphy_err(drvr, "chanspec failed (%d)\n", err);
+ 		return err;
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0006-brcmfmac-simply-remove-flowring-if-bus-is-down.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0006-brcmfmac-simply-remove-flowring-if-bus-is-down.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0006-brcmfmac-simply-remove-flowring-if-bus-is-down.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0006-brcmfmac-simply-remove-flowring-if-bus-is-down.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,33 @@
+From e0bfb9601d4812719167cc4124a0d6db1e2f55e4 Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:11 +0200
+Subject: [PATCH] brcmfmac: simply remove flowring if bus is down
+
+When the bus is down, eg. due to rmmod, there is no need to
+attempt to inform firmware about it.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c | 7 +++++++
+ 1 file changed, 7 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -1398,6 +1398,13 @@ void brcmf_msgbuf_delete_flowring(struct
+ 	u8 ifidx;
+ 	int err;
+ 
++	/* no need to submit if firmware can not be reached */
++	if (drvr->bus_if->state != BRCMF_BUS_UP) {
++		brcmf_dbg(MSGBUF, "bus down, flowring will be removed\n");
++		brcmf_msgbuf_remove_flowring(msgbuf, flowid);
++		return;
++	}
++
+ 	commonring = msgbuf->commonrings[BRCMF_H2D_MSGRING_CONTROL_SUBMIT];
+ 	brcmf_commonring_lock(commonring);
+ 	ret_ptr = brcmf_commonring_reserve_for_write(commonring);
diff -uprN a/package/kernel/mac80211/patches/brcm/384-v5.4-0007-brcmfmac-remove-unnecessary-strlcpy-upon-obtaining-v.patch b/package/kernel/mac80211/patches/brcm/384-v5.4-0007-brcmfmac-remove-unnecessary-strlcpy-upon-obtaining-v.patch
--- a/package/kernel/mac80211/patches/brcm/384-v5.4-0007-brcmfmac-remove-unnecessary-strlcpy-upon-obtaining-v.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/384-v5.4-0007-brcmfmac-remove-unnecessary-strlcpy-upon-obtaining-v.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,28 @@
+From 4b11c915f00caeef3292ed0429acc579b9da762a Mon Sep 17 00:00:00 2001
+From: Arend van Spriel <arend.vanspriel@broadcom.com>
+Date: Thu, 11 Jul 2019 11:05:12 +0200
+Subject: [PATCH] brcmfmac: remove unnecessary strlcpy() upon obtaining "ver"
+ iovar
+
+Recently a strcpy() was replaced by strlcpy(). However, the strcpy()
+was not needed in the first place. So removing that line of code.
+
+Reviewed-by: Hante Meuleman <hante.meuleman@broadcom.com>
+Reviewed-by: Pieter-Paul Giesberts <pieter-paul.giesberts@broadcom.com>
+Reviewed-by: Franky Lin <franky.lin@broadcom.com>
+Signed-off-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+@@ -258,7 +258,6 @@ int brcmf_c_preinit_dcmds(struct brcmf_i
+ 
+ 	/* query for 'ver' to get version info from firmware */
+ 	memset(buf, 0, sizeof(buf));
+-	strlcpy(buf, "ver", sizeof(buf));
+ 	err = brcmf_fil_iovar_data_get(ifp, "ver", buf, sizeof(buf));
+ 	if (err < 0) {
+ 		bphy_err(drvr, "Retrieving version information failed, %d\n",
diff -uprN a/package/kernel/mac80211/patches/brcm/385-v5.4-brcmfmac-don-t-net_ratelimit-CONSOLE-messages-on-fir.patch b/package/kernel/mac80211/patches/brcm/385-v5.4-brcmfmac-don-t-net_ratelimit-CONSOLE-messages-on-fir.patch
--- a/package/kernel/mac80211/patches/brcm/385-v5.4-brcmfmac-don-t-net_ratelimit-CONSOLE-messages-on-fir.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/385-v5.4-brcmfmac-don-t-net_ratelimit-CONSOLE-messages-on-fir.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,38 @@
+From e3b1d879ccda9ffd5332777bb1beeb2cc913faa8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Sun, 21 Jul 2019 21:52:17 +0200
+Subject: [PATCH] brcmfmac: don't net_ratelimit() CONSOLE messages on firmware
+ crash
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Firmware crash is a pretty rare event and can't happen too frequently as
+it has to be followed by a hardware reinitialization and config reload.
+It should be safe to don't use net_ratelimit() when it happens.
+
+For reporting & debugging purposes it's important to provide a complete
+log as the last lines are actually the most important. This change
+modifies brcmfmac to print all messages in an unlimited way in that
+specific case. With this change there should be finally a backtrace of
+firmware finally visible after a crash.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -794,7 +794,8 @@ static void brcmf_pcie_bus_console_read(
+ 		if (ch == '\n') {
+ 			console->log_str[console->log_idx] = 0;
+ 			if (error)
+-				brcmf_err(bus, "CONSOLE: %s", console->log_str);
++				__brcmf_err(bus, __func__, "CONSOLE: %s",
++					    console->log_str);
+ 			else
+ 				pr_debug("CONSOLE: %s", console->log_str);
+ 			console->log_idx = 0;
diff -uprN a/package/kernel/mac80211/patches/brcm/386-v5.4-brcmfmac-remove-set-but-not-used-variable-dtim_perio.patch b/package/kernel/mac80211/patches/brcm/386-v5.4-brcmfmac-remove-set-but-not-used-variable-dtim_perio.patch
--- a/package/kernel/mac80211/patches/brcm/386-v5.4-brcmfmac-remove-set-but-not-used-variable-dtim_perio.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/386-v5.4-brcmfmac-remove-set-but-not-used-variable-dtim_perio.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,54 @@
+From cddecd92d1ec2fd05ed1123455e7c6cf6906b5a5 Mon Sep 17 00:00:00 2001
+From: YueHaibing <yuehaibing@huawei.com>
+Date: Wed, 24 Jul 2019 22:12:01 +0800
+Subject: [PATCH] brcmfmac: remove set but not used variable 'dtim_period'
+
+Fixes gcc '-Wunused-but-set-variable' warning:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c: In function brcmf_update_bss_info:
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:2962:5: warning: variable dtim_period set but not used [-Wunused-but-set-variable]
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c: In function brcmf_update_bss_info:
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:2961:6: warning: variable beacon_interval set but not used [-Wunused-but-set-variable]
+
+They are never used so can be removed.
+
+Reported-by: Hulk Robot <hulkci@huawei.com>
+Signed-off-by: YueHaibing <yuehaibing@huawei.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c   | 8 +-------
+ 1 file changed, 1 insertion(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -2974,8 +2974,6 @@ static s32 brcmf_update_bss_info(struct
+ 	struct brcmf_pub *drvr = cfg->pub;
+ 	struct brcmf_bss_info_le *bi;
+ 	const struct brcmf_tlv *tim;
+-	u16 beacon_interval;
+-	u8 dtim_period;
+ 	size_t ie_len;
+ 	u8 *ie;
+ 	s32 err = 0;
+@@ -2999,12 +2997,9 @@ static s32 brcmf_update_bss_info(struct
+ 
+ 	ie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);
+ 	ie_len = le32_to_cpu(bi->ie_length);
+-	beacon_interval = le16_to_cpu(bi->beacon_period);
+ 
+ 	tim = brcmf_parse_tlvs(ie, ie_len, WLAN_EID_TIM);
+-	if (tim)
+-		dtim_period = tim->data[1];
+-	else {
++	if (!tim) {
+ 		/*
+ 		* active scan was done so we could not get dtim
+ 		* information out of probe response.
+@@ -3016,7 +3011,6 @@ static s32 brcmf_update_bss_info(struct
+ 			bphy_err(drvr, "wl dtim_assoc failed (%d)\n", err);
+ 			goto update_bss_info_out;
+ 		}
+-		dtim_period = (u8)var;
+ 	}
+ 
+ update_bss_info_out:
diff -uprN a/package/kernel/mac80211/patches/brcm/387-v5.4-brcmfmac-remove-redundant-assignment-to-pointer-hash.patch b/package/kernel/mac80211/patches/brcm/387-v5.4-brcmfmac-remove-redundant-assignment-to-pointer-hash.patch
--- a/package/kernel/mac80211/patches/brcm/387-v5.4-brcmfmac-remove-redundant-assignment-to-pointer-hash.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/387-v5.4-brcmfmac-remove-redundant-assignment-to-pointer-hash.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,26 @@
+From 73c742bb9c9ba30871fdd5c730d5ca8b6712833a Mon Sep 17 00:00:00 2001
+From: Colin Ian King <colin.king@canonical.com>
+Date: Fri, 9 Aug 2019 18:22:17 +0100
+Subject: [PATCH] brcmfmac: remove redundant assignment to pointer hash
+
+The pointer hash is being initialized with a value that is never read
+and is being re-assigned a little later on. The assignment is
+redundant and hence can be removed.
+
+Addresses-Coverity: ("Unused value")
+Signed-off-by: Colin Ian King <colin.king@canonical.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c | 1 -
+ 1 file changed, 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -1468,7 +1468,6 @@ static int brcmf_msgbuf_stats_read(struc
+ 	seq_printf(seq, "\nh2d_flowrings: depth %u\n",
+ 		   BRCMF_H2D_TXFLOWRING_MAX_ITEM);
+ 	seq_puts(seq, "Active flowrings:\n");
+-	hash = msgbuf->flow->hash;
+ 	for (i = 0; i < msgbuf->flow->nrofrings; i++) {
+ 		if (!msgbuf->flow->rings[i])
+ 			continue;
diff -uprN a/package/kernel/mac80211/patches/brcm/388-v5.4-brcmfmac-replace-strncpy-by-strscpy.patch b/package/kernel/mac80211/patches/brcm/388-v5.4-brcmfmac-replace-strncpy-by-strscpy.patch
--- a/package/kernel/mac80211/patches/brcm/388-v5.4-brcmfmac-replace-strncpy-by-strscpy.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/388-v5.4-brcmfmac-replace-strncpy-by-strscpy.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,36 @@
+From 5f42b382ead278c1f6c3854765c97eb20491aa2a Mon Sep 17 00:00:00 2001
+From: Xulin Sun <xulin.sun@windriver.com>
+Date: Fri, 23 Aug 2019 15:47:08 +0800
+Subject: [PATCH] brcmfmac: replace strncpy() by strscpy()
+
+The strncpy() may truncate the copied string,
+replace it by the safer strscpy().
+
+To avoid below compile warning with gcc 8.2:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:In function 'brcmf_vndr_ie':
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c:4227:2:
+warning: 'strncpy' output truncated before terminating nul copying 3 bytes from a string of the same length [-Wstringop-truncation]
+  strncpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN - 1);
+  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 4 +---
+ 1 file changed, 1 insertion(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -4236,9 +4236,7 @@ next:
+ static u32
+ brcmf_vndr_ie(u8 *iebuf, s32 pktflag, u8 *ie_ptr, u32 ie_len, s8 *add_del_cmd)
+ {
+-
+-	strncpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN - 1);
+-	iebuf[VNDR_IE_CMD_LEN - 1] = '\0';
++	strscpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN);
+ 
+ 	put_unaligned_le32(1, &iebuf[VNDR_IE_COUNT_OFFSET]);
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/389-v5.4-brcmfmac-get-chip-s-default-RAM-info-during-PCIe-set.patch b/package/kernel/mac80211/patches/brcm/389-v5.4-brcmfmac-get-chip-s-default-RAM-info-during-PCIe-set.patch
--- a/package/kernel/mac80211/patches/brcm/389-v5.4-brcmfmac-get-chip-s-default-RAM-info-during-PCIe-set.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/389-v5.4-brcmfmac-get-chip-s-default-RAM-info-during-PCIe-set.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,80 @@
+From 82f93cf46d6007ffa003b2d4a2834563b6b84d21 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 29 Aug 2019 10:27:01 +0200
+Subject: [PATCH] brcmfmac: get chip's default RAM info during PCIe setup
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Getting RAM info just once per driver's lifetime (during chip
+recognition) is not enough as it may get adjusted later (depending on
+the used firmware). Subsequent inits may load different firmwares so a
+full RAM recognition is required on every PCIe setup. This is especially
+important since implementing hardware reset on a firmware crash.
+
+Moreover calling brcmf_chip_get_raminfo() makes sure that RAM core is
+up. It's important as having BCMA_CORE_SYS_MEM down on BCM4366 was
+resulting in firmware failing to initialize and following error:
+[   65.657546] brcmfmac 0000:01:00.0: brcmf_pcie_download_fw_nvram: Invalid shared RAM address 0x04000001
+
+This change makes brcmf_chip_get_raminfo() call during chip recognition
+redundant for PCIe devices but SDIO and USB still need it and it's a
+very small overhead anyway.
+
+Fixes: 4684997d9eea ("brcmfmac: reset PCIe bus on a firmware crash")
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c | 6 ++++--
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h | 1 +
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 6 ++++++
+ 3 files changed, 11 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -696,8 +696,10 @@ static u32 brcmf_chip_tcm_rambase(struct
+ 	return 0;
+ }
+ 
+-static int brcmf_chip_get_raminfo(struct brcmf_chip_priv *ci)
++int brcmf_chip_get_raminfo(struct brcmf_chip *pub)
+ {
++	struct brcmf_chip_priv *ci = container_of(pub, struct brcmf_chip_priv,
++						  pub);
+ 	struct brcmf_core_priv *mem_core;
+ 	struct brcmf_core *mem;
+ 
+@@ -979,7 +981,7 @@ static int brcmf_chip_recognition(struct
+ 		brcmf_chip_set_passive(&ci->pub);
+ 	}
+ 
+-	return brcmf_chip_get_raminfo(ci);
++	return brcmf_chip_get_raminfo(&ci->pub);
+ }
+ 
+ static void brcmf_chip_disable_arm(struct brcmf_chip_priv *chip, u16 id)
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
+@@ -69,6 +69,7 @@ struct brcmf_buscore_ops {
+ 	void (*activate)(void *ctx, struct brcmf_chip *chip, u32 rstvec);
+ };
+ 
++int brcmf_chip_get_raminfo(struct brcmf_chip *pub);
+ struct brcmf_chip *brcmf_chip_attach(void *ctx,
+ 				     const struct brcmf_buscore_ops *ops);
+ void brcmf_chip_detach(struct brcmf_chip *chip);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1770,6 +1770,12 @@ static void brcmf_pcie_setup(struct devi
+ 	nvram_len = fwreq->items[BRCMF_PCIE_FW_NVRAM].nv_data.len;
+ 	kfree(fwreq);
+ 
++	ret = brcmf_chip_get_raminfo(devinfo->ci);
++	if (ret) {
++		brcmf_err(bus, "Failed to get RAM info\n");
++		goto fail;
++	}
++
+ 	/* Some of the firmwares have the size of the memory of the device
+ 	 * defined inside the firmware. This is because part of the memory in
+ 	 * the device is shared and the devision is determined by FW. Parse
diff -uprN a/package/kernel/mac80211/patches/brcm/390-v5.4-0001-brcmfmac-add-stub-version-of-brcmf_debugfs_get_devdi.patch b/package/kernel/mac80211/patches/brcm/390-v5.4-0001-brcmfmac-add-stub-version-of-brcmf_debugfs_get_devdi.patch
--- a/package/kernel/mac80211/patches/brcm/390-v5.4-0001-brcmfmac-add-stub-version-of-brcmf_debugfs_get_devdi.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/390-v5.4-0001-brcmfmac-add-stub-version-of-brcmf_debugfs_get_devdi.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,31 @@
+From cb34212b1c25f7656a315f956d72696777e88340 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Sun, 1 Sep 2019 13:34:35 +0200
+Subject: [PATCH] brcmfmac: add stub version of brcmf_debugfs_get_devdir()
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+In case of compiling driver without DEBUG expose a stub function to make
+writing debug code much simpler (no extra conditions). This will allow
+e.g. using debugfs_create_file() without any magic if or #ifdef.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+@@ -121,6 +121,10 @@ int brcmf_debugfs_add_entry(struct brcmf
+ int brcmf_debug_create_memdump(struct brcmf_bus *bus, const void *data,
+ 			       size_t len);
+ #else
++static inline struct dentry *brcmf_debugfs_get_devdir(struct brcmf_pub *drvr)
++{
++	return ERR_PTR(-ENOENT);
++}
+ static inline
+ int brcmf_debugfs_add_entry(struct brcmf_pub *drvr, const char *fn,
+ 			    int (*read_fn)(struct seq_file *seq, void *data))
diff -uprN a/package/kernel/mac80211/patches/brcm/390-v5.4-0002-brcmfmac-add-reset-debugfs-entry-for-testing-reset.patch b/package/kernel/mac80211/patches/brcm/390-v5.4-0002-brcmfmac-add-reset-debugfs-entry-for-testing-reset.patch
--- a/package/kernel/mac80211/patches/brcm/390-v5.4-0002-brcmfmac-add-reset-debugfs-entry-for-testing-reset.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/390-v5.4-0002-brcmfmac-add-reset-debugfs-entry-for-testing-reset.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,59 @@
+From 2f8c8e62cd50d72ac68de884a09c6f5a969a269c Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Sun, 1 Sep 2019 13:34:36 +0200
+Subject: [PATCH] brcmfmac: add "reset" debugfs entry for testing reset
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This is a trivial debugfs entry for triggering reset just like in case
+of firmware crash. It works by writing 1 to it:
+echo 1 > reset
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/core.c        | 25 +++++++++++++++++++
+ 1 file changed, 25 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1107,6 +1107,29 @@ static void brcmf_core_bus_reset(struct
+ 	brcmf_bus_reset(drvr->bus_if);
+ }
+ 
++static ssize_t bus_reset_write(struct file *file, const char __user *user_buf,
++			       size_t count, loff_t *ppos)
++{
++	struct brcmf_pub *drvr = file->private_data;
++	u8 value;
++
++	if (kstrtou8_from_user(user_buf, count, 0, &value))
++		return -EINVAL;
++
++	if (value != 1)
++		return -EINVAL;
++
++	schedule_work(&drvr->bus_reset);
++
++	return count;
++}
++
++static const struct file_operations bus_reset_fops = {
++	.open	= simple_open,
++	.llseek	= no_llseek,
++	.write	= bus_reset_write,
++};
++
+ static int brcmf_bus_started(struct brcmf_pub *drvr, struct cfg80211_ops *ops)
+ {
+ 	int ret = -1;
+@@ -1182,6 +1205,8 @@ static int brcmf_bus_started(struct brcm
+ 
+ 	/* populate debugfs */
+ 	brcmf_debugfs_add_entry(drvr, "revinfo", brcmf_revinfo_read);
++	debugfs_create_file("reset", 0600, brcmf_debugfs_get_devdir(drvr), drvr,
++			    &bus_reset_fops);
+ 	brcmf_feat_debugfs_create(drvr);
+ 	brcmf_proto_debugfs_create(drvr);
+ 	brcmf_bus_debugfs_create(bus_if);
diff -uprN a/package/kernel/mac80211/patches/brcm/391-v5.4-brcmfmac-use-ph-to-print-small-buffer.patch b/package/kernel/mac80211/patches/brcm/391-v5.4-brcmfmac-use-ph-to-print-small-buffer.patch
--- a/package/kernel/mac80211/patches/brcm/391-v5.4-brcmfmac-use-ph-to-print-small-buffer.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/391-v5.4-brcmfmac-use-ph-to-print-small-buffer.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,58 @@
+From 0e48b86d9a8f5c695bb02c9c02f6dc7d2ec8f2e2 Mon Sep 17 00:00:00 2001
+From: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
+Date: Wed, 4 Sep 2019 20:50:52 +0300
+Subject: [PATCH] brcmfmac: use %*ph to print small buffer
+
+Use %*ph format to print small buffer as hex string.
+
+Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c     | 18 ++++++------------
+ 1 file changed, 6 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -4214,10 +4214,8 @@ brcmf_parse_vndr_ies(const u8 *vndr_ie_b
+ 
+ 		vndr_ies->count++;
+ 
+-		brcmf_dbg(TRACE, "** OUI %02x %02x %02x, type 0x%02x\n",
+-			  parsed_info->vndrie.oui[0],
+-			  parsed_info->vndrie.oui[1],
+-			  parsed_info->vndrie.oui[2],
++		brcmf_dbg(TRACE, "** OUI %3ph, type 0x%02x\n",
++			  parsed_info->vndrie.oui,
+ 			  parsed_info->vndrie.oui_type);
+ 
+ 		if (vndr_ies->count >= VNDR_IE_PARSE_LIMIT)
+@@ -4341,12 +4339,10 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 		for (i = 0; i < old_vndr_ies.count; i++) {
+ 			vndrie_info = &old_vndr_ies.ie_info[i];
+ 
+-			brcmf_dbg(TRACE, "DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\n",
++			brcmf_dbg(TRACE, "DEL ID : %d, Len: %d , OUI:%3ph\n",
+ 				  vndrie_info->vndrie.id,
+ 				  vndrie_info->vndrie.len,
+-				  vndrie_info->vndrie.oui[0],
+-				  vndrie_info->vndrie.oui[1],
+-				  vndrie_info->vndrie.oui[2]);
++				  vndrie_info->vndrie.oui);
+ 
+ 			del_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,
+ 							   vndrie_info->ie_ptr,
+@@ -4378,12 +4374,10 @@ s32 brcmf_vif_set_mgmt_ie(struct brcmf_c
+ 			remained_buf_len -= (vndrie_info->ie_len +
+ 					     VNDR_IE_VSIE_OFFSET);
+ 
+-			brcmf_dbg(TRACE, "ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\n",
++			brcmf_dbg(TRACE, "ADDED ID : %d, Len: %d, OUI:%3ph\n",
+ 				  vndrie_info->vndrie.id,
+ 				  vndrie_info->vndrie.len,
+-				  vndrie_info->vndrie.oui[0],
+-				  vndrie_info->vndrie.oui[1],
+-				  vndrie_info->vndrie.oui[2]);
++				  vndrie_info->vndrie.oui);
+ 
+ 			del_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,
+ 							   vndrie_info->ie_ptr,
diff -uprN a/package/kernel/mac80211/patches/brcm/392-v5.4-0001-brcmfmac-move-cfg80211_ops-pointer-to-another-struct.patch b/package/kernel/mac80211/patches/brcm/392-v5.4-0001-brcmfmac-move-cfg80211_ops-pointer-to-another-struct.patch
--- a/package/kernel/mac80211/patches/brcm/392-v5.4-0001-brcmfmac-move-cfg80211_ops-pointer-to-another-struct.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/392-v5.4-0001-brcmfmac-move-cfg80211_ops-pointer-to-another-struct.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,95 @@
+From ba76ff25ee64d5cfc86209d1fbb3c294b2c04412 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 3 Sep 2019 06:29:26 +0200
+Subject: [PATCH 1/3] brcmfmac: move "cfg80211_ops" pointer to another struct
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This moves "ops" pointer from "struct brcmf_cfg80211_info" to the
+"struct brcmf_pub". This movement makes it possible to allocate wiphy
+without attaching cfg80211 (brcmf_cfg80211_attach()). It's required for
+later separation of wiphy allocation and driver initialization.
+
+While at it fix also an unlikely memory leak in the brcmf_attach().
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c  | 1 -
+ .../net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h  | 1 -
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c  | 9 ++++++---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h  | 1 +
+ 4 files changed, 7 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -7197,7 +7197,6 @@ void brcmf_cfg80211_detach(struct brcmf_
+ 	brcmf_pno_detach(cfg);
+ 	brcmf_btcoex_detach(cfg);
+ 	wiphy_unregister(cfg->wiphy);
+-	kfree(cfg->ops);
+ 	wl_deinit_priv(cfg);
+ 	brcmf_free_wiphy(cfg->wiphy);
+ 	kfree(cfg);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.h
+@@ -292,7 +292,6 @@ struct brcmf_cfg80211_wowl {
+  */
+ struct brcmf_cfg80211_info {
+ 	struct wiphy *wiphy;
+-	struct cfg80211_ops *ops;
+ 	struct brcmf_cfg80211_conf *conf;
+ 	struct brcmf_p2p_info p2p;
+ 	struct brcmf_btcoex_info *btcoex;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1245,12 +1245,15 @@ int brcmf_attach(struct device *dev, str
+ 		return -ENOMEM;
+ 
+ 	wiphy = wiphy_new(ops, sizeof(*drvr));
+-	if (!wiphy)
++	if (!wiphy) {
++		kfree(ops);
+ 		return -ENOMEM;
++	}
+ 
+ 	set_wiphy_dev(wiphy, dev);
+ 	drvr = wiphy_priv(wiphy);
+ 	drvr->wiphy = wiphy;
++	drvr->ops = ops;
+ 
+ 	for (i = 0; i < ARRAY_SIZE(drvr->if2bss); i++)
+ 		drvr->if2bss[i] = BRCMF_BSSIDX_INVALID;
+@@ -1283,12 +1286,10 @@ int brcmf_attach(struct device *dev, str
+ 		goto fail;
+ 	}
+ 
+-	drvr->config->ops = ops;
+ 	return 0;
+ 
+ fail:
+ 	brcmf_detach(dev);
+-	kfree(ops);
+ 
+ 	return ret;
+ }
+@@ -1379,6 +1380,8 @@ void brcmf_detach(struct device *dev)
+ 
+ 	bus_if->drvr = NULL;
+ 
++	kfree(drvr->ops);
++
+ 	wiphy_free(drvr->wiphy);
+ }
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
+@@ -97,6 +97,7 @@ struct brcmf_pub {
+ 	struct brcmf_bus *bus_if;
+ 	struct brcmf_proto *proto;
+ 	struct wiphy *wiphy;
++	struct cfg80211_ops *ops;
+ 	struct brcmf_cfg80211_info *config;
+ 
+ 	/* Internal brcmf items */
diff -uprN a/package/kernel/mac80211/patches/brcm/392-v5.4-0002-brcmfmac-split-brcmf_attach-and-brcmf_detach-functio.patch b/package/kernel/mac80211/patches/brcm/392-v5.4-0002-brcmfmac-split-brcmf_attach-and-brcmf_detach-functio.patch
--- a/package/kernel/mac80211/patches/brcm/392-v5.4-0002-brcmfmac-split-brcmf_attach-and-brcmf_detach-functio.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/392-v5.4-0002-brcmfmac-split-brcmf_attach-and-brcmf_detach-functio.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,266 @@
+From 450914c39f88d1adada26256360dea7050ff4e83 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 3 Sep 2019 06:29:27 +0200
+Subject: [PATCH 2/3] brcmfmac: split brcmf_attach() and brcmf_detach()
+ functions
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Move code allocating/freeing wiphy out of above functions. This will
+allow reinitializing the driver (e.g. on some error) without allocating
+a new wiphy.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/bus.h         |  4 ++-
+ .../broadcom/brcm80211/brcmfmac/core.c        | 33 ++++++++++++++----
+ .../broadcom/brcm80211/brcmfmac/pcie.c        | 13 +++++--
+ .../broadcom/brcm80211/brcmfmac/sdio.c        | 15 ++++++--
+ .../broadcom/brcm80211/brcmfmac/usb.c         | 34 +++++++++++++++----
+ 5 files changed, 80 insertions(+), 19 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
+@@ -253,10 +253,12 @@ void brcmf_rx_frame(struct device *dev,
+ /* Receive async event packet from firmware. Callee disposes of rxp. */
+ void brcmf_rx_event(struct device *dev, struct sk_buff *rxp);
+ 
++int brcmf_alloc(struct device *dev, struct brcmf_mp_device *settings);
+ /* Indication from bus module regarding presence/insertion of dongle. */
+-int brcmf_attach(struct device *dev, struct brcmf_mp_device *settings);
++int brcmf_attach(struct device *dev);
+ /* Indication from bus module regarding removal/absence of dongle */
+ void brcmf_detach(struct device *dev);
++void brcmf_free(struct device *dev);
+ /* Indication from bus module that dongle should be reset */
+ void brcmf_dev_reset(struct device *dev);
+ /* Request from bus module to initiate a coredump */
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -1230,13 +1230,11 @@ fail:
+ 	return ret;
+ }
+ 
+-int brcmf_attach(struct device *dev, struct brcmf_mp_device *settings)
++int brcmf_alloc(struct device *dev, struct brcmf_mp_device *settings)
+ {
+ 	struct wiphy *wiphy;
+ 	struct cfg80211_ops *ops;
+ 	struct brcmf_pub *drvr = NULL;
+-	int ret = 0;
+-	int i;
+ 
+ 	brcmf_dbg(TRACE, "Enter\n");
+ 
+@@ -1254,6 +1252,21 @@ int brcmf_attach(struct device *dev, str
+ 	drvr = wiphy_priv(wiphy);
+ 	drvr->wiphy = wiphy;
+ 	drvr->ops = ops;
++	drvr->bus_if = dev_get_drvdata(dev);
++	drvr->bus_if->drvr = drvr;
++	drvr->settings = settings;
++
++	return 0;
++}
++
++int brcmf_attach(struct device *dev)
++{
++	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
++	struct brcmf_pub *drvr = bus_if->drvr;
++	int ret = 0;
++	int i;
++
++	brcmf_dbg(TRACE, "Enter\n");
+ 
+ 	for (i = 0; i < ARRAY_SIZE(drvr->if2bss); i++)
+ 		drvr->if2bss[i] = BRCMF_BSSIDX_INVALID;
+@@ -1262,9 +1275,6 @@ int brcmf_attach(struct device *dev, str
+ 
+ 	/* Link to bus module */
+ 	drvr->hdrlen = 0;
+-	drvr->bus_if = dev_get_drvdata(dev);
+-	drvr->bus_if->drvr = drvr;
+-	drvr->settings = settings;
+ 
+ 	/* Attach and link in the protocol */
+ 	ret = brcmf_proto_attach(drvr);
+@@ -1280,7 +1290,7 @@ int brcmf_attach(struct device *dev, str
+ 	/* attach firmware event handler */
+ 	brcmf_fweh_attach(drvr);
+ 
+-	ret = brcmf_bus_started(drvr, ops);
++	ret = brcmf_bus_started(drvr, drvr->ops);
+ 	if (ret != 0) {
+ 		bphy_err(drvr, "dongle is not responding: err=%d\n", ret);
+ 		goto fail;
+@@ -1377,6 +1387,15 @@ void brcmf_detach(struct device *dev)
+ 		brcmf_cfg80211_detach(drvr->config);
+ 		drvr->config = NULL;
+ 	}
++}
++
++void brcmf_free(struct device *dev)
++{
++	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
++	struct brcmf_pub *drvr = bus_if->drvr;
++
++	if (!drvr)
++		return;
+ 
+ 	bus_if->drvr = NULL;
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1430,6 +1430,7 @@ static int brcmf_pcie_reset(struct devic
+ 	brcmf_pcie_bus_console_read(devinfo, true);
+ 
+ 	brcmf_detach(dev);
++	brcmf_free(dev);
+ 
+ 	brcmf_pcie_release_irq(devinfo);
+ 	brcmf_pcie_release_scratchbuffers(devinfo);
+@@ -1824,11 +1825,18 @@ static void brcmf_pcie_setup(struct devi
+ 
+ 	brcmf_pcie_intr_enable(devinfo);
+ 	brcmf_pcie_hostready(devinfo);
+-	if (brcmf_attach(&devinfo->pdev->dev, devinfo->settings) == 0)
+-		return;
++
++	ret = brcmf_alloc(&devinfo->pdev->dev, devinfo->settings);
++	if (ret)
++		goto fail;
++	ret = brcmf_attach(&devinfo->pdev->dev);
++	if (ret)
++		goto fail;
+ 
+ 	brcmf_pcie_bus_console_read(devinfo, false);
+ 
++	return;
++
+ fail:
+ 	device_release_driver(dev);
+ }
+@@ -1971,6 +1979,7 @@ brcmf_pcie_remove(struct pci_dev *pdev)
+ 		brcmf_pcie_intr_disable(devinfo);
+ 
+ 	brcmf_detach(&pdev->dev);
++	brcmf_free(&pdev->dev);
+ 
+ 	kfree(bus->bus_priv.pcie);
+ 	kfree(bus->msgbuf->flowrings);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -4258,17 +4258,26 @@ static void brcmf_sdio_firmware_callback
+ 	sdiod->bus_if->chip = bus->ci->chip;
+ 	sdiod->bus_if->chiprev = bus->ci->chiprev;
+ 
++	err = brcmf_alloc(sdiod->dev, sdiod->settings);
++	if (err) {
++		brcmf_err("brcmf_alloc failed\n");
++		goto claim;
++	}
++
+ 	/* Attach to the common layer, reserve hdr space */
+-	err = brcmf_attach(sdiod->dev, sdiod->settings);
++	err = brcmf_attach(sdiod->dev);
+ 	if (err != 0) {
+ 		brcmf_err("brcmf_attach failed\n");
+-		sdio_claim_host(sdiod->func1);
+-		goto checkdied;
++		goto free;
+ 	}
+ 
+ 	/* ready */
+ 	return;
+ 
++free:
++	brcmf_free(sdiod->dev);
++claim:
++	sdio_claim_host(sdiod->func1);
+ checkdied:
+ 	brcmf_sdio_checkdied(bus);
+ release:
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+@@ -1179,8 +1179,12 @@ static void brcmf_usb_probe_phase2(struc
+ 	if (ret)
+ 		goto error;
+ 
++	ret = brcmf_alloc(devinfo->dev, devinfo->settings);
++	if (ret)
++		goto error;
++
+ 	/* Attach to the common driver interface */
+-	ret = brcmf_attach(devinfo->dev, devinfo->settings);
++	ret = brcmf_attach(devinfo->dev);
+ 	if (ret)
+ 		goto error;
+ 
+@@ -1252,7 +1256,10 @@ static int brcmf_usb_probe_cb(struct brc
+ 	}
+ 
+ 	if (!brcmf_usb_dlneeded(devinfo)) {
+-		ret = brcmf_attach(devinfo->dev, devinfo->settings);
++		ret = brcmf_alloc(devinfo->dev, devinfo->settings);
++		if (ret)
++			goto fail;
++		ret = brcmf_attach(devinfo->dev);
+ 		if (ret)
+ 			goto fail;
+ 		/* we are done */
+@@ -1280,6 +1287,7 @@ static int brcmf_usb_probe_cb(struct brc
+ 
+ fail:
+ 	/* Release resources in reverse order */
++	brcmf_free(devinfo->dev);
+ 	kfree(bus);
+ 	brcmf_usb_detach(devinfo);
+ 	return ret;
+@@ -1293,6 +1301,7 @@ brcmf_usb_disconnect_cb(struct brcmf_usb
+ 	brcmf_dbg(USB, "Enter, bus_pub %p\n", devinfo);
+ 
+ 	brcmf_detach(devinfo->dev);
++	brcmf_free(devinfo->dev);
+ 	kfree(devinfo->bus_pub.bus);
+ 	brcmf_usb_detach(devinfo);
+ }
+@@ -1436,10 +1445,12 @@ static int brcmf_usb_suspend(struct usb_
+ 
+ 	brcmf_dbg(USB, "Enter\n");
+ 	devinfo->bus_pub.state = BRCMFMAC_USB_STATE_SLEEP;
+-	if (devinfo->wowl_enabled)
++	if (devinfo->wowl_enabled) {
+ 		brcmf_cancel_all_urbs(devinfo);
+-	else
++	} else {
+ 		brcmf_detach(&usb->dev);
++		brcmf_free(&usb->dev);
++	}
+ 	return 0;
+ }
+ 
+@@ -1452,8 +1463,19 @@ static int brcmf_usb_resume(struct usb_i
+ 	struct brcmf_usbdev_info *devinfo = brcmf_usb_get_businfo(&usb->dev);
+ 
+ 	brcmf_dbg(USB, "Enter\n");
+-	if (!devinfo->wowl_enabled)
+-		return brcmf_attach(devinfo->dev, devinfo->settings);
++	if (!devinfo->wowl_enabled) {
++		int err;
++
++		err = brcmf_alloc(&usb->dev, devinfo->settings);
++		if (err)
++			return err;
++
++		err = brcmf_attach(devinfo->dev);
++		if (err) {
++			brcmf_free(devinfo->dev);
++			return err;
++		}
++	}
+ 
+ 	devinfo->bus_pub.state = BRCMFMAC_USB_STATE_UP;
+ 	brcmf_usb_rx_fill_all(devinfo);
diff -uprN a/package/kernel/mac80211/patches/brcm/392-v5.4-0003-brcmfmac-don-t-realloc-wiphy-during-PCIe-reset.patch b/package/kernel/mac80211/patches/brcm/392-v5.4-0003-brcmfmac-don-t-realloc-wiphy-during-PCIe-reset.patch
--- a/package/kernel/mac80211/patches/brcm/392-v5.4-0003-brcmfmac-don-t-realloc-wiphy-during-PCIe-reset.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/392-v5.4-0003-brcmfmac-don-t-realloc-wiphy-during-PCIe-reset.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,51 @@
+From a1f5aac1765afbeace9581afa27da34085f68e1d Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 3 Sep 2019 06:29:28 +0200
+Subject: [PATCH 3/3] brcmfmac: don't realloc wiphy during PCIe reset
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Providing a new wiphy on every PCIe reset was confusing and was causing
+configuration problems for some users (supplicant and authenticators).
+Sticking to the existing wiphy should make error recovery much simpler
+and more reliable.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Acked-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1430,7 +1430,6 @@ static int brcmf_pcie_reset(struct devic
+ 	brcmf_pcie_bus_console_read(devinfo, true);
+ 
+ 	brcmf_detach(dev);
+-	brcmf_free(dev);
+ 
+ 	brcmf_pcie_release_irq(devinfo);
+ 	brcmf_pcie_release_scratchbuffers(devinfo);
+@@ -1826,9 +1825,6 @@ static void brcmf_pcie_setup(struct devi
+ 	brcmf_pcie_intr_enable(devinfo);
+ 	brcmf_pcie_hostready(devinfo);
+ 
+-	ret = brcmf_alloc(&devinfo->pdev->dev, devinfo->settings);
+-	if (ret)
+-		goto fail;
+ 	ret = brcmf_attach(&devinfo->pdev->dev);
+ 	if (ret)
+ 		goto fail;
+@@ -1931,6 +1927,10 @@ brcmf_pcie_probe(struct pci_dev *pdev, c
+ 	bus->wowl_supported = pci_pme_capable(pdev, PCI_D3hot);
+ 	dev_set_drvdata(&pdev->dev, bus);
+ 
++	ret = brcmf_alloc(&devinfo->pdev->dev, devinfo->settings);
++	if (ret)
++		goto fail_bus;
++
+ 	fwreq = brcmf_pcie_prepare_fw_request(devinfo);
+ 	if (!fwreq) {
+ 		ret = -ENOMEM;
diff -uprN a/package/kernel/mac80211/patches/brcm/401-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch b/package/kernel/mac80211/patches/brcm/401-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch
--- a/package/kernel/mac80211/patches/brcm/401-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/401-v5.5-0001-brcmfmac-don-t-WARN-when-there-are-no-requests.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,28 @@
+From 1524cbf3621576c639405e7aabeac415f9617c8d Mon Sep 17 00:00:00 2001
+From: Adrian Ratiu <adrian.ratiu@collabora.com>
+Date: Wed, 25 Sep 2019 16:44:57 +0300
+Subject: [PATCH] brcmfmac: don't WARN when there are no requests
+
+When n_reqs == 0 there is nothing to do so it doesn't make sense to
+search for requests and issue a warning because none is found.
+
+Signed-off-by: Martyn Welch <martyn.welch@collabora.com>
+Signed-off-by: Adrian Ratiu <adrian.ratiu@collabora.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pno.c
+@@ -57,6 +57,10 @@ static int brcmf_pno_remove_request(stru
+ 
+ 	mutex_lock(&pi->req_lock);
+ 
++	/* Nothing to do if we have no requests */
++	if (pi->n_reqs == 0)
++		goto done;
++
+ 	/* find request */
+ 	for (i = 0; i < pi->n_reqs; i++) {
+ 		if (pi->reqs[i]->reqid == reqid)
diff -uprN a/package/kernel/mac80211/patches/brcm/401-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch b/package/kernel/mac80211/patches/brcm/401-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch
--- a/package/kernel/mac80211/patches/brcm/401-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/401-v5.5-0002-brcmfmac-fix-suspend-resume-when-power-is-cut-off.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,109 @@
+From e0ae4bac22effbd644add326f658a3aeeb8d45ee Mon Sep 17 00:00:00 2001
+From: Adrian Ratiu <adrian.ratiu@collabora.com>
+Date: Wed, 25 Sep 2019 16:44:58 +0300
+Subject: [PATCH] brcmfmac: fix suspend/resume when power is cut off
+
+brcmfmac assumed the wifi device always remains powered on and thus
+hardcoded the MMC_PM_KEEP_POWER flag expecting the wifi device to
+remain on even during suspend/resume cycles.
+
+This is not always the case, some appliances cut power to everything
+connected via SDIO for efficiency reasons and this leads to wifi not
+being usable after coming out of suspend because the device was not
+correctly reinitialized.
+
+So we check for the keep_power capability and if it's not present then
+we remove the device and probe it again during resume to mirror what's
+happening in hardware and ensure correct reinitialization in the case
+when MMC_PM_KEEP_POWER is not supported.
+
+Suggested-by: Gustavo Padovan <gustavo.padovan@collabora.com>
+Signed-off-by: Adrian Ratiu <adrian.ratiu@collabora.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/bcmsdh.c      | 53 ++++++++++++++-----
+ 1 file changed, 39 insertions(+), 14 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+@@ -1097,7 +1097,8 @@ static int brcmf_ops_sdio_suspend(struct
+ 	struct sdio_func *func;
+ 	struct brcmf_bus *bus_if;
+ 	struct brcmf_sdio_dev *sdiodev;
+-	mmc_pm_flag_t sdio_flags;
++	mmc_pm_flag_t pm_caps, sdio_flags;
++	int ret = 0;
+ 
+ 	func = container_of(dev, struct sdio_func, dev);
+ 	brcmf_dbg(SDIO, "Enter: F%d\n", func->num);
+@@ -1108,19 +1109,33 @@ static int brcmf_ops_sdio_suspend(struct
+ 	bus_if = dev_get_drvdata(dev);
+ 	sdiodev = bus_if->bus_priv.sdio;
+ 
+-	brcmf_sdiod_freezer_on(sdiodev);
+-	brcmf_sdio_wd_timer(sdiodev->bus, 0);
++	pm_caps = sdio_get_host_pm_caps(func);
+ 
+-	sdio_flags = MMC_PM_KEEP_POWER;
+-	if (sdiodev->wowl_enabled) {
+-		if (sdiodev->settings->bus.sdio.oob_irq_supported)
+-			enable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
+-		else
+-			sdio_flags |= MMC_PM_WAKE_SDIO_IRQ;
++	if (pm_caps & MMC_PM_KEEP_POWER) {
++		/* preserve card power during suspend */
++		brcmf_sdiod_freezer_on(sdiodev);
++		brcmf_sdio_wd_timer(sdiodev->bus, 0);
++
++		sdio_flags = MMC_PM_KEEP_POWER;
++		if (sdiodev->wowl_enabled) {
++			if (sdiodev->settings->bus.sdio.oob_irq_supported)
++				enable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
++			else
++				sdio_flags |= MMC_PM_WAKE_SDIO_IRQ;
++		}
++
++		if (sdio_set_host_pm_flags(sdiodev->func1, sdio_flags))
++			brcmf_err("Failed to set pm_flags %x\n", sdio_flags);
++
++	} else {
++		/* power will be cut so remove device, probe again in resume */
++		brcmf_sdiod_intr_unregister(sdiodev);
++		ret = brcmf_sdiod_remove(sdiodev);
++		if (ret)
++			brcmf_err("Failed to remove device on suspend\n");
+ 	}
+-	if (sdio_set_host_pm_flags(sdiodev->func1, sdio_flags))
+-		brcmf_err("Failed to set pm_flags %x\n", sdio_flags);
+-	return 0;
++
++	return ret;
+ }
+ 
+ static int brcmf_ops_sdio_resume(struct device *dev)
+@@ -1128,13 +1143,23 @@ static int brcmf_ops_sdio_resume(struct
+ 	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
+ 	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+ 	struct sdio_func *func = container_of(dev, struct sdio_func, dev);
++	mmc_pm_flag_t pm_caps = sdio_get_host_pm_caps(func);
++	int ret = 0;
+ 
+ 	brcmf_dbg(SDIO, "Enter: F%d\n", func->num);
+ 	if (func->num != 2)
+ 		return 0;
+ 
+-	brcmf_sdiod_freezer_off(sdiodev);
+-	return 0;
++	if (!(pm_caps & MMC_PM_KEEP_POWER)) {
++		/* bus was powered off and device removed, probe again */
++		ret = brcmf_sdiod_probe(sdiodev);
++		if (ret)
++			brcmf_err("Failed to probe device on resume\n");
++	} else {
++		brcmf_sdiod_freezer_off(sdiodev);
++	}
++
++	return ret;
+ }
+ 
+ static const struct dev_pm_ops brcmf_sdio_pm_ops = {
diff -uprN a/package/kernel/mac80211/patches/brcm/403-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch b/package/kernel/mac80211/patches/brcm/403-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch
--- a/package/kernel/mac80211/patches/brcm/403-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/403-v5.5-brcmfmac-remove-set-but-not-used-variable-mpnum-nsp-.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,58 @@
+From 7af496b9eb0433bc4cb478c9a46f85509cdb5541 Mon Sep 17 00:00:00 2001
+From: zhengbin <zhengbin13@huawei.com>
+Date: Sat, 16 Nov 2019 15:22:47 +0800
+Subject: [PATCH] brcmfmac: remove set but not used variable
+ 'mpnum','nsp','nmp'
+
+Fixes gcc '-Wunused-but-set-variable' warning:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c: In function brcmf_chip_dmp_get_regaddr:
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:790:5: warning: variable mpnum set but not used [-Wunused-but-set-variable]
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c: In function brcmf_chip_dmp_erom_scan:
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:866:10: warning: variable nsp set but not used [-Wunused-but-set-variable]
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c: In function brcmf_chip_dmp_erom_scan:
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c:866:5: warning: variable nmp set but not used [-Wunused-but-set-variable]
+
+Reported-by: Hulk Robot <hulkci@huawei.com>
+Signed-off-by: zhengbin <zhengbin13@huawei.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c | 6 +-----
+ 1 file changed, 1 insertion(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -778,7 +778,6 @@ static int brcmf_chip_dmp_get_regaddr(st
+ {
+ 	u8 desc;
+ 	u32 val, szdesc;
+-	u8 mpnum = 0;
+ 	u8 stype, sztype, wraptype;
+ 
+ 	*regbase = 0;
+@@ -786,7 +785,6 @@ static int brcmf_chip_dmp_get_regaddr(st
+ 
+ 	val = brcmf_chip_dmp_get_desc(ci, eromaddr, &desc);
+ 	if (desc == DMP_DESC_MASTER_PORT) {
+-		mpnum = (val & DMP_MASTER_PORT_NUM) >> DMP_MASTER_PORT_NUM_S;
+ 		wraptype = DMP_SLAVE_TYPE_MWRAP;
+ 	} else if (desc == DMP_DESC_ADDRESS) {
+ 		/* revert erom address */
+@@ -854,7 +852,7 @@ int brcmf_chip_dmp_erom_scan(struct brcm
+ 	u8 desc_type = 0;
+ 	u32 val;
+ 	u16 id;
+-	u8 nmp, nsp, nmw, nsw, rev;
++	u8 nmw, nsw, rev;
+ 	u32 base, wrap;
+ 	int err;
+ 
+@@ -880,8 +878,6 @@ int brcmf_chip_dmp_erom_scan(struct brcm
+ 			return -EFAULT;
+ 
+ 		/* only look at cores with master port(s) */
+-		nmp = (val & DMP_COMP_NUM_MPORT) >> DMP_COMP_NUM_MPORT_S;
+-		nsp = (val & DMP_COMP_NUM_SPORT) >> DMP_COMP_NUM_SPORT_S;
+ 		nmw = (val & DMP_COMP_NUM_MWRAP) >> DMP_COMP_NUM_MWRAP_S;
+ 		nsw = (val & DMP_COMP_NUM_SWRAP) >> DMP_COMP_NUM_SWRAP_S;
+ 		rev = (val & DMP_COMP_REVISION) >> DMP_COMP_REVISION_S;
diff -uprN a/package/kernel/mac80211/patches/brcm/404-v5.5-brcmfmac-disable-PCIe-interrupts-before-bus-reset.patch b/package/kernel/mac80211/patches/brcm/404-v5.5-brcmfmac-disable-PCIe-interrupts-before-bus-reset.patch
--- a/package/kernel/mac80211/patches/brcm/404-v5.5-brcmfmac-disable-PCIe-interrupts-before-bus-reset.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/404-v5.5-brcmfmac-disable-PCIe-interrupts-before-bus-reset.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,54 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Mon, 18 Nov 2019 11:52:41 +0100
+Subject: [PATCH FIX] brcmfmac: disable PCIe interrupts before bus reset
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Keeping interrupts on could result in brcmfmac freeing some resources
+and then IRQ handlers trying to use them. That was obviously a straight
+path for crashing a kernel.
+
+Example:
+CPU0                           CPU1
+----                           ----
+brcmf_pcie_reset
+  brcmf_pcie_bus_console_read
+  brcmf_detach
+    ...
+    brcmf_fweh_detach
+    brcmf_proto_detach
+                               brcmf_pcie_isr_thread
+                                 ...
+                                 brcmf_proto_msgbuf_rx_trigger
+                                   ...
+                                   drvr->proto->pd
+    brcmf_pcie_release_irq
+
+[  363.789218] Unable to handle kernel NULL pointer dereference at virtual address 00000038
+[  363.797339] pgd = c0004000
+[  363.800050] [00000038] *pgd=00000000
+[  363.803635] Internal error: Oops: 17 [#1] SMP ARM
+(...)
+[  364.029209] Backtrace:
+[  364.031725] [<bf243838>] (brcmf_proto_msgbuf_rx_trigger [brcmfmac]) from [<bf2471dc>] (brcmf_pcie_isr_thread+0x228/0x274 [brcmfmac])
+[  364.043662]  r7:00000001 r6:c8ca0000 r5:00010000 r4:c7b4f800
+
+Fixes: 4684997d9eea ("brcmfmac: reset PCIe bus on a firmware crash")
+Cc: stable@vger.kernel.org # v5.2+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -1427,6 +1427,8 @@ static int brcmf_pcie_reset(struct devic
+ 	struct brcmf_fw_request *fwreq;
+ 	int err;
+ 
++	brcmf_pcie_intr_disable(devinfo);
++
+ 	brcmf_pcie_bus_console_read(devinfo, true);
+ 
+ 	brcmf_detach(dev);
diff -uprN a/package/kernel/mac80211/patches/brcm/410-v5.6-brcmfmac-Fix-memory-leak-in-brcmf_p2p_create_p2pdev.patch b/package/kernel/mac80211/patches/brcm/410-v5.6-brcmfmac-Fix-memory-leak-in-brcmf_p2p_create_p2pdev.patch
--- a/package/kernel/mac80211/patches/brcm/410-v5.6-brcmfmac-Fix-memory-leak-in-brcmf_p2p_create_p2pdev.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/410-v5.6-brcmfmac-Fix-memory-leak-in-brcmf_p2p_create_p2pdev.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,29 @@
+From 5cc509aa83c6acd2c5cd94f99065c39d2bd0a490 Mon Sep 17 00:00:00 2001
+From: Navid Emamdoost <navid.emamdoost@gmail.com>
+Date: Fri, 22 Nov 2019 13:19:48 -0600
+Subject: [PATCH] brcmfmac: Fix memory leak in brcmf_p2p_create_p2pdev()
+
+In the implementation of brcmf_p2p_create_p2pdev() the allocated memory
+for p2p_vif is leaked when the mac address is the same as primary
+interface. To fix this, go to error path to release p2p_vif via
+brcmf_free_vif().
+
+Fixes: cb746e47837a ("brcmfmac: check p2pdev mac address uniqueness")
+Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
+@@ -2092,7 +2092,8 @@ static struct wireless_dev *brcmf_p2p_cr
+ 	/* firmware requires unique mac address for p2pdev interface */
+ 	if (addr && ether_addr_equal(addr, pri_ifp->mac_addr)) {
+ 		bphy_err(drvr, "discovery vif must be different from primary interface\n");
+-		return ERR_PTR(-EINVAL);
++		err = -EINVAL;
++		goto fail;
+ 	}
+ 
+ 	brcmf_p2p_generate_bss_mac(p2p, addr);
diff -uprN a/package/kernel/mac80211/patches/brcm/412-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch b/package/kernel/mac80211/patches/brcm/412-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch
--- a/package/kernel/mac80211/patches/brcm/412-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/412-v5.6-brcmfmac-set-interface-carrier-to-off-by-default.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,29 @@
+From 8d9627b05b2c33e4468e65739eb7caf9c3f274d8 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Tue, 10 Dec 2019 12:35:55 +0100
+Subject: [PATCH] brcmfmac: set interface carrier to off by default
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+It's important as brcmfmac creates one main interface for each PHY and
+doesn't allow deleting it. Not setting carrier could result in other
+subsystems misbehaving (e.g. LEDs "netdev" trigger turning LED on).
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c | 2 ++
+ 1 file changed, 2 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -678,6 +678,8 @@ int brcmf_net_attach(struct brcmf_if *if
+ 		goto fail;
+ 	}
+ 
++	netif_carrier_off(ndev);
++
+ 	netdev_set_priv_destructor(ndev, brcmf_cfg80211_free_netdev);
+ 	brcmf_dbg(INFO, "%s: Broadcom Dongle Host Driver\n", ndev->name);
+ 	return 0;
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0001-brcmfmac-reset-two-D11-cores-if-chip-has-two-D11-cor.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,121 @@
+From 1b8d2e0a9e4221b99eea375c079507ce8ef655f5 Mon Sep 17 00:00:00 2001
+From: Wright Feng <wright.feng@cypress.com>
+Date: Thu, 12 Dec 2019 00:52:45 +0100
+Subject: [PATCH 1/7] brcmfmac: reset two D11 cores if chip has two D11 cores
+
+There are two D11 cores in RSDB chips like 4359. We have to reset two
+D11 cores simutaneously before firmware download, or the firmware may
+not be initialized correctly and cause "fw initialized failed" error.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Signed-off-by: Soeren Moch <smoch@web.de>
+Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/chip.c        | 50 +++++++++++++++++++
+ .../broadcom/brcm80211/brcmfmac/chip.h        |  1 +
+ .../broadcom/brcm80211/brcmfmac/pcie.c        |  2 +-
+ 3 files changed, 52 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -433,11 +433,25 @@ static void brcmf_chip_ai_resetcore(stru
+ {
+ 	struct brcmf_chip_priv *ci;
+ 	int count;
++	struct brcmf_core *d11core2 = NULL;
++	struct brcmf_core_priv *d11priv2 = NULL;
+ 
+ 	ci = core->chip;
+ 
++	/* special handle two D11 cores reset */
++	if (core->pub.id == BCMA_CORE_80211) {
++		d11core2 = brcmf_chip_get_d11core(&ci->pub, 1);
++		if (d11core2) {
++			brcmf_dbg(INFO, "found two d11 cores, reset both\n");
++			d11priv2 = container_of(d11core2,
++						struct brcmf_core_priv, pub);
++		}
++	}
++
+ 	/* must disable first to work for arbitrary current core state */
+ 	brcmf_chip_ai_coredisable(core, prereset, reset);
++	if (d11priv2)
++		brcmf_chip_ai_coredisable(d11priv2, prereset, reset);
+ 
+ 	count = 0;
+ 	while (ci->ops->read32(ci->ctx, core->wrapbase + BCMA_RESET_CTL) &
+@@ -449,9 +463,30 @@ static void brcmf_chip_ai_resetcore(stru
+ 		usleep_range(40, 60);
+ 	}
+ 
++	if (d11priv2) {
++		count = 0;
++		while (ci->ops->read32(ci->ctx,
++				       d11priv2->wrapbase + BCMA_RESET_CTL) &
++				       BCMA_RESET_CTL_RESET) {
++			ci->ops->write32(ci->ctx,
++					 d11priv2->wrapbase + BCMA_RESET_CTL,
++					 0);
++			count++;
++			if (count > 50)
++				break;
++			usleep_range(40, 60);
++		}
++	}
++
+ 	ci->ops->write32(ci->ctx, core->wrapbase + BCMA_IOCTL,
+ 			 postreset | BCMA_IOCTL_CLK);
+ 	ci->ops->read32(ci->ctx, core->wrapbase + BCMA_IOCTL);
++
++	if (d11priv2) {
++		ci->ops->write32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL,
++				 postreset | BCMA_IOCTL_CLK);
++		ci->ops->read32(ci->ctx, d11priv2->wrapbase + BCMA_IOCTL);
++	}
+ }
+ 
+ char *brcmf_chip_name(u32 id, u32 rev, char *buf, uint len)
+@@ -1109,6 +1144,21 @@ void brcmf_chip_detach(struct brcmf_chip
+ 	kfree(chip);
+ }
+ 
++struct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit)
++{
++	struct brcmf_chip_priv *chip;
++	struct brcmf_core_priv *core;
++
++	chip = container_of(pub, struct brcmf_chip_priv, pub);
++	list_for_each_entry(core, &chip->cores, list) {
++		if (core->pub.id == BCMA_CORE_80211) {
++			if (unit-- == 0)
++				return &core->pub;
++		}
++	}
++	return NULL;
++}
++
+ struct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *pub, u16 coreid)
+ {
+ 	struct brcmf_chip_priv *chip;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.h
+@@ -74,6 +74,7 @@ struct brcmf_chip *brcmf_chip_attach(voi
+ 				     const struct brcmf_buscore_ops *ops);
+ void brcmf_chip_detach(struct brcmf_chip *chip);
+ struct brcmf_core *brcmf_chip_get_core(struct brcmf_chip *chip, u16 coreid);
++struct brcmf_core *brcmf_chip_get_d11core(struct brcmf_chip *pub, u8 unit);
+ struct brcmf_core *brcmf_chip_get_chipcommon(struct brcmf_chip *chip);
+ struct brcmf_core *brcmf_chip_get_pmu(struct brcmf_chip *pub);
+ bool brcmf_chip_iscoreup(struct brcmf_core *core);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+@@ -78,7 +78,7 @@ static const struct brcmf_firmware_mappi
+ 	BRCMF_FW_ENTRY(BRCM_CC_4371_CHIP_ID, 0xFFFFFFFF, 4371),
+ };
+ 
+-#define BRCMF_PCIE_FW_UP_TIMEOUT		2000 /* msec */
++#define BRCMF_PCIE_FW_UP_TIMEOUT		5000 /* msec */
+ 
+ #define BRCMF_PCIE_REG_MAP_SIZE			(32 * 1024)
+ 
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0002-brcmfmac-set-F2-blocksize-and-watermark-for-4359.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,79 @@
+From 172f6854551d48d1c9530f84513b421db944e714 Mon Sep 17 00:00:00 2001
+From: Chung-Hsien Hsu <stanley.hsu@cypress.com>
+Date: Thu, 12 Dec 2019 00:52:46 +0100
+Subject: [PATCH 2/7] brcmfmac: set F2 blocksize and watermark for 4359
+
+Set F2 blocksize to 256 bytes and watermark to 0x40 for 4359. Also
+enable and configure F1 MesBusyCtrl. It fixes DMA error while having
+UDP bi-directional traffic.
+
+Signed-off-by: Chung-Hsien Hsu <stanley.hsu@cypress.com>
+[slightly adapted for rebase on mainline linux]
+Signed-off-by: Soeren Moch <smoch@web.de>
+Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c |  6 +++++-
+ .../wireless/broadcom/brcm80211/brcmfmac/sdio.c   | 15 +++++++++++++++
+ 2 files changed, 20 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+@@ -43,6 +43,7 @@
+ 
+ #define SDIO_FUNC1_BLOCKSIZE		64
+ #define SDIO_FUNC2_BLOCKSIZE		512
++#define SDIO_4359_FUNC2_BLOCKSIZE	256
+ /* Maximum milliseconds to wait for F2 to come up */
+ #define SDIO_WAIT_F2RDY	3000
+ 
+@@ -892,6 +893,7 @@ static void brcmf_sdiod_host_fixup(struc
+ static int brcmf_sdiod_probe(struct brcmf_sdio_dev *sdiodev)
+ {
+ 	int ret = 0;
++	unsigned int f2_blksz = SDIO_FUNC2_BLOCKSIZE;
+ 
+ 	sdio_claim_host(sdiodev->func1);
+ 
+@@ -901,7 +903,9 @@ static int brcmf_sdiod_probe(struct brcm
+ 		sdio_release_host(sdiodev->func1);
+ 		goto out;
+ 	}
+-	ret = sdio_set_block_size(sdiodev->func2, SDIO_FUNC2_BLOCKSIZE);
++	if (sdiodev->func2->device == SDIO_DEVICE_ID_BROADCOM_4359)
++		f2_blksz = SDIO_4359_FUNC2_BLOCKSIZE;
++	ret = sdio_set_block_size(sdiodev->func2, f2_blksz);
+ 	if (ret) {
+ 		brcmf_err("Failed to set F2 blocksize\n");
+ 		sdio_release_host(sdiodev->func1);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -42,6 +42,8 @@
+ #define DEFAULT_F2_WATERMARK    0x8
+ #define CY_4373_F2_WATERMARK    0x40
+ #define CY_43012_F2_WATERMARK    0x60
++#define CY_4359_F2_WATERMARK	0x40
++#define CY_4359_F1_MESBUSYCTRL	(CY_4359_F2_WATERMARK | SBSDIO_MESBUSYCTRL_ENAB)
+ 
+ #ifdef DEBUG
+ 
+@@ -4216,6 +4218,19 @@ static void brcmf_sdio_firmware_callback
+ 			brcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,
+ 					   &err);
+ 			break;
++		case SDIO_DEVICE_ID_BROADCOM_4359:
++			brcmf_dbg(INFO, "set F2 watermark to 0x%x*4 bytes\n",
++				  CY_4359_F2_WATERMARK);
++			brcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,
++					   CY_4359_F2_WATERMARK, &err);
++			devctl = brcmf_sdiod_readb(sdiod, SBSDIO_DEVICE_CTL,
++						   &err);
++			devctl |= SBSDIO_DEVCTL_F2WM_ENAB;
++			brcmf_sdiod_writeb(sdiod, SBSDIO_DEVICE_CTL, devctl,
++					   &err);
++			brcmf_sdiod_writeb(sdiod, SBSDIO_FUNC1_MESBUSYCTRL,
++					   CY_4359_F1_MESBUSYCTRL, &err);
++			break;
+ 		default:
+ 			brcmf_sdiod_writeb(sdiod, SBSDIO_WATERMARK,
+ 					   DEFAULT_F2_WATERMARK, &err);
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0003-brcmfmac-fix-rambase-for-4359-9.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,34 @@
+From 6647274ed995a172369cb04754eb5f8b85f68f6d Mon Sep 17 00:00:00 2001
+From: Soeren Moch <smoch@web.de>
+Date: Thu, 12 Dec 2019 00:52:47 +0100
+Subject: [PATCH 3/7] brcmfmac: fix rambase for 4359/9
+
+Newer 4359 chip revisions need a different rambase address.
+This fixes firmware download on such devices which fails otherwise.
+
+Signed-off-by: Soeren Moch <smoch@web.de>
+Acked-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c | 3 ++-
+ 1 file changed, 2 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -712,7 +712,6 @@ static u32 brcmf_chip_tcm_rambase(struct
+ 	case BRCM_CC_43569_CHIP_ID:
+ 	case BRCM_CC_43570_CHIP_ID:
+ 	case BRCM_CC_4358_CHIP_ID:
+-	case BRCM_CC_4359_CHIP_ID:
+ 	case BRCM_CC_43602_CHIP_ID:
+ 	case BRCM_CC_4371_CHIP_ID:
+ 		return 0x180000;
+@@ -722,6 +721,8 @@ static u32 brcmf_chip_tcm_rambase(struct
+ 	case BRCM_CC_4366_CHIP_ID:
+ 	case BRCM_CC_43664_CHIP_ID:
+ 		return 0x200000;
++	case BRCM_CC_4359_CHIP_ID:
++		return (ci->pub.chiprev < 9) ? 0x180000 : 0x160000;
+ 	case CY_CC_4373_CHIP_ID:
+ 		return 0x160000;
+ 	default:
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0004-brcmfmac-make-errors-when-setting-roaming-parameters.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,42 @@
+From c12c8913d79c49ceccb38f42714d25b783833758 Mon Sep 17 00:00:00 2001
+From: Soeren Moch <smoch@web.de>
+Date: Thu, 12 Dec 2019 00:52:48 +0100
+Subject: [PATCH 4/7] brcmfmac: make errors when setting roaming parameters
+ non-fatal
+
+4359 dongles do not support setting roaming parameters (error -52).
+Do not fail the 80211 configuration in this case.
+
+Signed-off-by: Soeren Moch <smoch@web.de>
+Acked-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../wireless/broadcom/brcm80211/brcmfmac/cfg80211.c    | 10 ++++------
+ 1 file changed, 4 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -5939,19 +5939,17 @@ static s32 brcmf_dongle_roam(struct brcm
+ 	roamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,
+ 				     (void *)roamtrigger, sizeof(roamtrigger));
+-	if (err) {
++	if (err)
+ 		bphy_err(drvr, "WLC_SET_ROAM_TRIGGER error (%d)\n", err);
+-		goto roam_setup_done;
+-	}
+ 
+ 	roam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);
+ 	roam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);
+ 	err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,
+ 				     (void *)roam_delta, sizeof(roam_delta));
+-	if (err) {
++	if (err)
+ 		bphy_err(drvr, "WLC_SET_ROAM_DELTA error (%d)\n", err);
+-		goto roam_setup_done;
+-	}
++
++	return 0;
+ 
+ roam_setup_done:
+ 	return err;
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0005-brcmfmac-add-support-for-BCM4359-SDIO-chipset.patch	2022-04-04 20:20:32.951828000 +0800
@@ -0,0 +1,75 @@
+From d4aef159394d5940bd7158ab789969dab82f7c76 Mon Sep 17 00:00:00 2001
+From: Soeren Moch <smoch@web.de>
+Date: Thu, 12 Dec 2019 00:52:49 +0100
+Subject: [PATCH 5/7] brcmfmac: add support for BCM4359 SDIO chipset
+
+BCM4359 is a 2x2 802.11 abgn+ac Dual-Band HT80 combo chip and it
+supports Real Simultaneous Dual Band feature.
+
+Based on a similar patch by: Wright Feng <wright.feng@cypress.com>
+
+Signed-off-by: Soeren Moch <smoch@web.de>
+Acked-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Acked-by: Ulf Hansson <ulf.hansson@linaro.org>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c | 2 ++
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c   | 1 +
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c   | 2 ++
+ include/linux/mmc/sdio_ids.h                              | 2 ++
+ 4 files changed, 7 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+@@ -962,8 +962,10 @@ static const struct sdio_device_id brcmf
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_43455),
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4354),
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4356),
++	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_BROADCOM_4359),
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_4373),
+ 	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_43012),
++	BRCMF_SDIO_DEVICE(SDIO_DEVICE_ID_CYPRESS_89359),
+ 	{ /* end: all zeroes */ }
+ };
+ MODULE_DEVICE_TABLE(sdio, brcmf_sdmmc_ids);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/chip.c
+@@ -1408,6 +1408,7 @@ bool brcmf_chip_sr_capable(struct brcmf_
+ 		addr = CORE_CC_REG(base, sr_control0);
+ 		reg = chip->ops->read32(chip->ctx, addr);
+ 		return (reg & CC_SR_CTL0_ENABLE_MASK) != 0;
++	case BRCM_CC_4359_CHIP_ID:
+ 	case CY_CC_43012_CHIP_ID:
+ 		addr = CORE_CC_REG(pmu->base, retention_ctl);
+ 		reg = chip->ops->read32(chip->ctx, addr);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -616,6 +616,7 @@ BRCMF_FW_DEF(43455, "brcmfmac43455-sdio"
+ BRCMF_FW_DEF(43456, "brcmfmac43456-sdio");
+ BRCMF_FW_DEF(4354, "brcmfmac4354-sdio");
+ BRCMF_FW_DEF(4356, "brcmfmac4356-sdio");
++BRCMF_FW_DEF(4359, "brcmfmac4359-sdio");
+ BRCMF_FW_DEF(4373, "brcmfmac4373-sdio");
+ BRCMF_FW_DEF(43012, "brcmfmac43012-sdio");
+ 
+@@ -638,6 +639,7 @@ static const struct brcmf_firmware_mappi
+ 	BRCMF_FW_ENTRY(BRCM_CC_4345_CHIP_ID, 0xFFFFFDC0, 43455),
+ 	BRCMF_FW_ENTRY(BRCM_CC_4354_CHIP_ID, 0xFFFFFFFF, 4354),
+ 	BRCMF_FW_ENTRY(BRCM_CC_4356_CHIP_ID, 0xFFFFFFFF, 4356),
++	BRCMF_FW_ENTRY(BRCM_CC_4359_CHIP_ID, 0xFFFFFFFF, 4359),
+ 	BRCMF_FW_ENTRY(CY_CC_4373_CHIP_ID, 0xFFFFFFFF, 4373),
+ 	BRCMF_FW_ENTRY(CY_CC_43012_CHIP_ID, 0xFFFFFFFF, 43012)
+ };
+--- a/include/linux/mmc/sdio_ids.h
++++ b/include/linux/mmc/sdio_ids.h
+@@ -41,8 +41,10 @@
+ #define SDIO_DEVICE_ID_BROADCOM_43455		0xa9bf
+ #define SDIO_DEVICE_ID_BROADCOM_4354		0x4354
+ #define SDIO_DEVICE_ID_BROADCOM_4356		0x4356
++#define SDIO_DEVICE_ID_BROADCOM_4359		0x4359
+ #define SDIO_DEVICE_ID_CYPRESS_4373		0x4373
+ #define SDIO_DEVICE_ID_CYPRESS_43012		43012
++#define SDIO_DEVICE_ID_CYPRESS_89359		0x4355
+ 
+ #define SDIO_VENDOR_ID_INTEL			0x0089
+ #define SDIO_DEVICE_ID_INTEL_IWMC3200WIMAX	0x1402
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0006-brcmfmac-add-RSDB-condition-when-setting-interface-c.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,130 @@
+From 837482e69a3f0d7cbc73922020012f83635f5ddb Mon Sep 17 00:00:00 2001
+From: Wright Feng <wright.feng@cypress.com>
+Date: Thu, 12 Dec 2019 00:52:50 +0100
+Subject: [PATCH 6/7] brcmfmac: add RSDB condition when setting interface
+ combinations
+
+With firmware RSDB feature
+1. The maximum support interface is four.
+2. The maximum difference channel is two.
+3. The maximum interfaces of {station/p2p client/AP} are two.
+4. The maximum interface of p2p device is one.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Signed-off-by: Soeren Moch <smoch@web.de>
+Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 54 ++++++++++++++++---
+ 1 file changed, 46 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -6447,6 +6447,9 @@ brcmf_txrx_stypes[NUM_NL80211_IFTYPES] =
+  *	#STA <= 1, #AP <= 1, channels = 1, 2 total
+  *	#AP <= 4, matching BI, channels = 1, 4 total
+  *
++ * no p2p and rsdb:
++ *	#STA <= 2, #AP <= 2, channels = 2, 4 total
++ *
+  * p2p, no mchan, and mbss:
+  *
+  *	#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 1, 3 total
+@@ -6458,6 +6461,10 @@ brcmf_txrx_stypes[NUM_NL80211_IFTYPES] =
+  *	#STA <= 1, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 1, channels = 2, 3 total
+  *	#STA <= 1, #P2P-DEV <= 1, #AP <= 1, #P2P-CL <= 1, channels = 1, 4 total
+  *	#AP <= 4, matching BI, channels = 1, 4 total
++ *
++ * p2p, rsdb, and no mbss:
++ *	#STA <= 2, #P2P-DEV <= 1, #{P2P-CL, P2P-GO} <= 2, AP <= 2,
++ *	 channels = 2, 4 total
+  */
+ static int brcmf_setup_ifmodes(struct wiphy *wiphy, struct brcmf_if *ifp)
+ {
+@@ -6465,13 +6472,14 @@ static int brcmf_setup_ifmodes(struct wi
+ 	struct ieee80211_iface_limit *c0_limits = NULL;
+ 	struct ieee80211_iface_limit *p2p_limits = NULL;
+ 	struct ieee80211_iface_limit *mbss_limits = NULL;
+-	bool mbss, p2p;
++	bool mbss, p2p, rsdb;
+ 	int i, c, n_combos;
+ 
+ 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
+ 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
++	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
+ 
+-	n_combos = 1 + !!p2p + !!mbss;
++	n_combos = 1 + !!(p2p && !rsdb) + !!mbss;
+ 	combo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);
+ 	if (!combo)
+ 		goto err;
+@@ -6482,16 +6490,36 @@ static int brcmf_setup_ifmodes(struct wi
+ 
+ 	c = 0;
+ 	i = 0;
+-	c0_limits = kcalloc(p2p ? 3 : 2, sizeof(*c0_limits), GFP_KERNEL);
++	if (p2p && rsdb)
++		c0_limits = kcalloc(4, sizeof(*c0_limits), GFP_KERNEL);
++	else if (p2p)
++		c0_limits = kcalloc(3, sizeof(*c0_limits), GFP_KERNEL);
++	else
++		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
+ 	if (!c0_limits)
+ 		goto err;
+-	c0_limits[i].max = 1;
+-	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+-	if (p2p) {
++	if (p2p && rsdb) {
++		combo[c].num_different_channels = 2;
++		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
++					  BIT(NL80211_IFTYPE_P2P_GO) |
++					  BIT(NL80211_IFTYPE_P2P_DEVICE);
++		c0_limits[i].max = 2;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
++		c0_limits[i].max = 1;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
++		c0_limits[i].max = 2;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
++				       BIT(NL80211_IFTYPE_P2P_GO);
++		c0_limits[i].max = 2;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
++		combo[c].max_interfaces = 5;
++	} else if (p2p) {
+ 		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))
+ 			combo[c].num_different_channels = 2;
+ 		else
+ 			combo[c].num_different_channels = 1;
++		c0_limits[i].max = 1;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+ 		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
+ 					  BIT(NL80211_IFTYPE_P2P_GO) |
+ 					  BIT(NL80211_IFTYPE_P2P_DEVICE);
+@@ -6500,16 +6528,26 @@ static int brcmf_setup_ifmodes(struct wi
+ 		c0_limits[i].max = 1;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+ 				       BIT(NL80211_IFTYPE_P2P_GO);
++		combo[c].max_interfaces = i;
++	} else if (rsdb) {
++		combo[c].num_different_channels = 2;
++		c0_limits[i].max = 2;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
++		c0_limits[i].max = 2;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
++		combo[c].max_interfaces = 3;
+ 	} else {
+ 		combo[c].num_different_channels = 1;
+ 		c0_limits[i].max = 1;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
++		c0_limits[i].max = 1;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
++		combo[c].max_interfaces = i;
+ 	}
+-	combo[c].max_interfaces = i;
+ 	combo[c].n_limits = i;
+ 	combo[c].limits = c0_limits;
+ 
+-	if (p2p) {
++	if (p2p && !rsdb) {
+ 		c++;
+ 		i = 0;
+ 		p2p_limits = kcalloc(4, sizeof(*p2p_limits), GFP_KERNEL);
diff -uprN a/package/kernel/mac80211/patches/brcm/414-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch b/package/kernel/mac80211/patches/brcm/414-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch
--- a/package/kernel/mac80211/patches/brcm/414-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/414-v5.6-0007-brcmfmac-not-set-mbss-in-vif-if-firmware-does-not-su.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,38 @@
+From 2635853ce4ab7654a77ab7080fb56de83408606b Mon Sep 17 00:00:00 2001
+From: Wright Feng <wright.feng@cypress.com>
+Date: Thu, 12 Dec 2019 00:52:51 +0100
+Subject: [PATCH 7/7] brcmfmac: not set mbss in vif if firmware does not
+ support MBSS
+
+With RSDB mode, FMAC and firmware are able to create 2 or more AP,
+so we should not set mbss in vif structure if firmware does not
+support MBSS feature.
+
+Signed-off-by: Wright Feng <wright.feng@cypress.com>
+Signed-off-by: Soeren Moch <smoch@web.de>
+Reviewed-by: Chi-Hsien Lin <chi-hsien.lin@cypress.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -5293,6 +5293,7 @@ struct brcmf_cfg80211_vif *brcmf_alloc_v
+ 	struct brcmf_cfg80211_vif *vif_walk;
+ 	struct brcmf_cfg80211_vif *vif;
+ 	bool mbss;
++	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
+ 
+ 	brcmf_dbg(TRACE, "allocating virtual interface (size=%zu)\n",
+ 		  sizeof(*vif));
+@@ -5305,7 +5306,8 @@ struct brcmf_cfg80211_vif *brcmf_alloc_v
+ 
+ 	brcmf_init_prof(&vif->profile);
+ 
+-	if (type == NL80211_IFTYPE_AP) {
++	if (type == NL80211_IFTYPE_AP &&
++	    brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) {
+ 		mbss = false;
+ 		list_for_each_entry(vif_walk, &cfg->vif_list, list) {
+ 			if (vif_walk->wdev.iftype == NL80211_IFTYPE_AP) {
diff -uprN a/package/kernel/mac80211/patches/brcm/416-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch b/package/kernel/mac80211/patches/brcm/416-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch
--- a/package/kernel/mac80211/patches/brcm/416-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/416-v5.6-brcmfmac-Keep-OOB-wake-interrupt-disabled-when-it-sh.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,66 @@
+From a32de68edab7b73ded850bcf76cdf6858e92a7e5 Mon Sep 17 00:00:00 2001
+From: Dmitry Osipenko <digetx@gmail.com>
+Date: Sun, 15 Dec 2019 21:42:24 +0300
+Subject: [PATCH] brcmfmac: Keep OOB wake-interrupt disabled when it shouldn't
+ be enabled
+
+NVIDIA Tegra SoCs do not like when OOB wake is enabled and WiFi interface
+is in DOWN state during suspend. This results in a CPU hang on programming
+OOB wake-up state of the GPIO controller during of system's suspend.
+
+The solution is trivial: don't enable wake for the OOB interrupt when it
+should be disabled.
+
+This fixes hang on Tegra20 (Acer A500) and Tegra30 (Nexus 7) devices which
+are using BCM4329 and BCM4330 WiFi chips respectively.
+
+Signed-off-by: Dmitry Osipenko <digetx@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c  | 10 +++++-----
+ .../net/wireless/broadcom/brcm80211/brcmfmac/sdio.h    |  1 -
+ 2 files changed, 5 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bcmsdh.c
+@@ -120,7 +120,7 @@ int brcmf_sdiod_intr_register(struct brc
+ 			brcmf_err("enable_irq_wake failed %d\n", ret);
+ 			return ret;
+ 		}
+-		sdiodev->irq_wake = true;
++		disable_irq_wake(pdata->oob_irq_nr);
+ 
+ 		sdio_claim_host(sdiodev->func1);
+ 
+@@ -179,10 +179,6 @@ void brcmf_sdiod_intr_unregister(struct
+ 		sdio_release_host(sdiodev->func1);
+ 
+ 		sdiodev->oob_irq_requested = false;
+-		if (sdiodev->irq_wake) {
+-			disable_irq_wake(pdata->oob_irq_nr);
+-			sdiodev->irq_wake = false;
+-		}
+ 		free_irq(pdata->oob_irq_nr, &sdiodev->func1->dev);
+ 		sdiodev->irq_en = false;
+ 		sdiodev->oob_irq_requested = false;
+@@ -1162,6 +1158,10 @@ static int brcmf_ops_sdio_resume(struct
+ 		if (ret)
+ 			brcmf_err("Failed to probe device on resume\n");
+ 	} else {
++		if (sdiodev->wowl_enabled &&
++		    sdiodev->settings->bus.sdio.oob_irq_supported)
++			disable_irq_wake(sdiodev->settings->bus.sdio.oob_irq_nr);
++
+ 		brcmf_sdiod_freezer_off(sdiodev);
+ 	}
+ 
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
+@@ -178,7 +178,6 @@ struct brcmf_sdio_dev {
+ 	bool sd_irq_requested;
+ 	bool irq_en;			/* irq enable flags */
+ 	spinlock_t irq_en_lock;
+-	bool irq_wake;			/* irq wake enable flags */
+ 	bool sg_support;
+ 	uint max_request_size;
+ 	ushort max_segment_count;
diff -uprN a/package/kernel/mac80211/patches/brcm/417-v5.6-brcmfmac-use-true-false-for-bool-variable.patch b/package/kernel/mac80211/patches/brcm/417-v5.6-brcmfmac-use-true-false-for-bool-variable.patch
--- a/package/kernel/mac80211/patches/brcm/417-v5.6-brcmfmac-use-true-false-for-bool-variable.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/417-v5.6-brcmfmac-use-true-false-for-bool-variable.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,27 @@
+From b92c017deda819e45a0f054f6df6b53e645d7fe4 Mon Sep 17 00:00:00 2001
+From: zhengbin <zhengbin13@huawei.com>
+Date: Tue, 24 Dec 2019 22:16:06 +0800
+Subject: [PATCH] brcmfmac: use true,false for bool variable
+
+Fixes coccicheck warning:
+
+drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c:911:2-24: WARNING: Assignment of 0/1 to bool variable
+
+Reported-by: Hulk Robot <hulkci@huawei.com>
+Signed-off-by: zhengbin <zhengbin13@huawei.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwsignal.c
+@@ -912,7 +912,7 @@ static u8 brcmf_fws_hdrpush(struct brcmf
+ 	wlh += wlh[1] + 2;
+ 
+ 	if (entry->send_tim_signal) {
+-		entry->send_tim_signal = 0;
++		entry->send_tim_signal = false;
+ 		wlh[0] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP;
+ 		wlh[1] = BRCMF_FWS_TYPE_PENDING_TRAFFIC_BMP_LEN;
+ 		wlh[2] = entry->mac_handle;
diff -uprN a/package/kernel/mac80211/patches/brcm/418-v5.6-brcmfmac-sdio-Fix-OOB-interrupt-initialization-on-br.patch b/package/kernel/mac80211/patches/brcm/418-v5.6-brcmfmac-sdio-Fix-OOB-interrupt-initialization-on-br.patch
--- a/package/kernel/mac80211/patches/brcm/418-v5.6-brcmfmac-sdio-Fix-OOB-interrupt-initialization-on-br.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/418-v5.6-brcmfmac-sdio-Fix-OOB-interrupt-initialization-on-br.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,57 @@
+From 8c8e60fb86a90a30721bbd797f58f96b3980dcc1 Mon Sep 17 00:00:00 2001
+From: Jean-Philippe Brucker <jean-philippe@linaro.org>
+Date: Thu, 26 Dec 2019 10:20:33 +0100
+Subject: [PATCH] brcmfmac: sdio: Fix OOB interrupt initialization on brcm43362
+
+Commit 262f2b53f679 ("brcmfmac: call brcmf_attach() just before calling
+brcmf_bus_started()") changed the initialization order of the brcmfmac
+SDIO driver. Unfortunately since brcmf_sdiod_intr_register() is now
+called before the sdiodev->bus_if initialization, it reads the wrong
+chip ID and fails to initialize the GPIO on brcm43362. Thus the chip
+cannot send interrupts and fails to probe:
+
+[   12.517023] brcmfmac: brcmf_sdio_bus_rxctl: resumed on timeout
+[   12.531214] ieee80211 phy0: brcmf_bus_started: failed: -110
+[   12.536976] ieee80211 phy0: brcmf_attach: dongle is not responding: err=-110
+[   12.566467] brcmfmac: brcmf_sdio_firmware_callback: brcmf_attach failed
+
+Initialize the bus interface earlier to ensure that
+brcmf_sdiod_intr_register() properly sets up the OOB interrupt.
+
+BugLink: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=908438
+Fixes: 262f2b53f679 ("brcmfmac: call brcmf_attach() just before calling brcmf_bus_started()")
+Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
+Reviewed-by: Arend van Spriel <arend.vanspriel@broadcom.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/broadcom/brcm80211/brcmfmac/sdio.c  | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+@@ -4253,6 +4253,12 @@ static void brcmf_sdio_firmware_callback
+ 	}
+ 
+ 	if (err == 0) {
++		/* Assign bus interface call back */
++		sdiod->bus_if->dev = sdiod->dev;
++		sdiod->bus_if->ops = &brcmf_sdio_bus_ops;
++		sdiod->bus_if->chip = bus->ci->chip;
++		sdiod->bus_if->chiprev = bus->ci->chiprev;
++
+ 		/* Allow full data communication using DPC from now on. */
+ 		brcmf_sdiod_change_state(bus->sdiodev, BRCMF_SDIOD_DATA);
+ 
+@@ -4269,12 +4275,6 @@ static void brcmf_sdio_firmware_callback
+ 
+ 	sdio_release_host(sdiod->func1);
+ 
+-	/* Assign bus interface call back */
+-	sdiod->bus_if->dev = sdiod->dev;
+-	sdiod->bus_if->ops = &brcmf_sdio_bus_ops;
+-	sdiod->bus_if->chip = bus->ci->chip;
+-	sdiod->bus_if->chiprev = bus->ci->chiprev;
+-
+ 	err = brcmf_alloc(sdiod->dev, sdiod->settings);
+ 	if (err) {
+ 		brcmf_err("brcmf_alloc failed\n");
diff -uprN a/package/kernel/mac80211/patches/brcm/419-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch b/package/kernel/mac80211/patches/brcm/419-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch
--- a/package/kernel/mac80211/patches/brcm/419-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/419-v5.6-0001-brcmfmac-simplify-building-interface-combinations.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,103 @@
+From 24332f8068ff6df7f16aefee45d514de1de4de80 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 26 Dec 2019 14:30:49 +0100
+Subject: [PATCH] brcmfmac: simplify building interface combinations
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Move similar/duplicated code out of combination specific code blocks.
+This simplifies code a bit and allows adding more combinations later.
+A list of combinations remains unchanged.
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 43 ++++++-------------
+ 1 file changed, 14 insertions(+), 29 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -6474,12 +6474,13 @@ static int brcmf_setup_ifmodes(struct wi
+ 	struct ieee80211_iface_limit *c0_limits = NULL;
+ 	struct ieee80211_iface_limit *p2p_limits = NULL;
+ 	struct ieee80211_iface_limit *mbss_limits = NULL;
+-	bool mbss, p2p, rsdb;
++	bool mbss, p2p, rsdb, mchan;
+ 	int i, c, n_combos;
+ 
+ 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
+ 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
+ 	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
++	mchan = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN);
+ 
+ 	n_combos = 1 + !!(p2p && !rsdb) + !!mbss;
+ 	combo = kcalloc(n_combos, sizeof(*combo), GFP_KERNEL);
+@@ -6489,6 +6490,10 @@ static int brcmf_setup_ifmodes(struct wi
+ 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+ 				 BIT(NL80211_IFTYPE_ADHOC) |
+ 				 BIT(NL80211_IFTYPE_AP);
++	if (p2p)
++		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
++					  BIT(NL80211_IFTYPE_P2P_GO) |
++					  BIT(NL80211_IFTYPE_P2P_DEVICE);
+ 
+ 	c = 0;
+ 	i = 0;
+@@ -6500,48 +6505,28 @@ static int brcmf_setup_ifmodes(struct wi
+ 		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
+ 	if (!c0_limits)
+ 		goto err;
+-	if (p2p && rsdb) {
+-		combo[c].num_different_channels = 2;
+-		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
+-					  BIT(NL80211_IFTYPE_P2P_GO) |
+-					  BIT(NL80211_IFTYPE_P2P_DEVICE);
+-		c0_limits[i].max = 2;
+-		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
++
++	combo[c].num_different_channels = 1 + (rsdb || (p2p && mchan));
++	c0_limits[i].max = 1 + rsdb;
++	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
++	if (p2p) {
+ 		c0_limits[i].max = 1;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
+-		c0_limits[i].max = 2;
++		c0_limits[i].max = 1 + rsdb;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+ 				       BIT(NL80211_IFTYPE_P2P_GO);
++	}
++	if (p2p && rsdb) {
+ 		c0_limits[i].max = 2;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
+ 		combo[c].max_interfaces = 5;
+ 	} else if (p2p) {
+-		if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MCHAN))
+-			combo[c].num_different_channels = 2;
+-		else
+-			combo[c].num_different_channels = 1;
+-		c0_limits[i].max = 1;
+-		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+-		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
+-					  BIT(NL80211_IFTYPE_P2P_GO) |
+-					  BIT(NL80211_IFTYPE_P2P_DEVICE);
+-		c0_limits[i].max = 1;
+-		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
+-		c0_limits[i].max = 1;
+-		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+-				       BIT(NL80211_IFTYPE_P2P_GO);
+ 		combo[c].max_interfaces = i;
+ 	} else if (rsdb) {
+-		combo[c].num_different_channels = 2;
+-		c0_limits[i].max = 2;
+-		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+ 		c0_limits[i].max = 2;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
+ 		combo[c].max_interfaces = 3;
+ 	} else {
+-		combo[c].num_different_channels = 1;
+-		c0_limits[i].max = 1;
+-		c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
+ 		c0_limits[i].max = 1;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_AP);
+ 		combo[c].max_interfaces = i;
diff -uprN a/package/kernel/mac80211/patches/brcm/419-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch b/package/kernel/mac80211/patches/brcm/419-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch
--- a/package/kernel/mac80211/patches/brcm/419-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/419-v5.6-0002-brcmfmac-add-initial-support-for-monitor-mode.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,345 @@
+From 20f2c5fa3af060401c72e444999470a4cab641cf Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Thu, 26 Dec 2019 14:30:50 +0100
+Subject: [PATCH] brcmfmac: add initial support for monitor mode
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Report monitor interface availability using cfg80211 and support it in
+the add_virtual_intf() and del_virtual_intf() callbacks. This new
+feature is conditional and depends on firmware flagging monitor packets.
+Receiving monitor frames is already handled by the brcmf_netif_mon_rx().
+
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 112 ++++++++++++++++--
+ .../broadcom/brcm80211/brcmfmac/core.c        |  68 ++++++++++-
+ .../broadcom/brcm80211/brcmfmac/core.h        |   2 +
+ .../broadcom/brcm80211/brcmfmac/feature.c     |   1 +
+ .../broadcom/brcm80211/brcmfmac/feature.h     |   2 +
+ .../broadcom/brcm80211/brcmfmac/fwil.h        |   2 +
+ 6 files changed, 174 insertions(+), 13 deletions(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+@@ -11,6 +11,7 @@
+ #include <linux/vmalloc.h>
+ #include <net/cfg80211.h>
+ #include <net/netlink.h>
++#include <uapi/linux/if_arp.h>
+ 
+ #include <brcmu_utils.h>
+ #include <defs.h>
+@@ -619,6 +620,82 @@ static bool brcmf_is_ibssmode(struct brc
+ 	return vif->wdev.iftype == NL80211_IFTYPE_ADHOC;
+ }
+ 
++/**
++ * brcmf_mon_add_vif() - create monitor mode virtual interface
++ *
++ * @wiphy: wiphy device of new interface.
++ * @name: name of the new interface.
++ */
++static struct wireless_dev *brcmf_mon_add_vif(struct wiphy *wiphy,
++					      const char *name)
++{
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct brcmf_cfg80211_vif *vif;
++	struct net_device *ndev;
++	struct brcmf_if *ifp;
++	int err;
++
++	if (cfg->pub->mon_if) {
++		err = -EEXIST;
++		goto err_out;
++	}
++
++	vif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_MONITOR);
++	if (IS_ERR(vif)) {
++		err = PTR_ERR(vif);
++		goto err_out;
++	}
++
++	ndev = alloc_netdev(sizeof(*ifp), name, NET_NAME_UNKNOWN, ether_setup);
++	if (!ndev) {
++		err = -ENOMEM;
++		goto err_free_vif;
++	}
++	ndev->type = ARPHRD_IEEE80211_RADIOTAP;
++	ndev->ieee80211_ptr = &vif->wdev;
++	ndev->needs_free_netdev = true;
++	ndev->priv_destructor = brcmf_cfg80211_free_netdev;
++	SET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));
++
++	ifp = netdev_priv(ndev);
++	ifp->vif = vif;
++	ifp->ndev = ndev;
++	ifp->drvr = cfg->pub;
++
++	vif->ifp = ifp;
++	vif->wdev.netdev = ndev;
++
++	err = brcmf_net_mon_attach(ifp);
++	if (err) {
++		brcmf_err("Failed to attach %s device\n", ndev->name);
++		free_netdev(ndev);
++		goto err_free_vif;
++	}
++
++	cfg->pub->mon_if = ifp;
++
++	return &vif->wdev;
++
++err_free_vif:
++	brcmf_free_vif(vif);
++err_out:
++	return ERR_PTR(err);
++}
++
++static int brcmf_mon_del_vif(struct wiphy *wiphy, struct wireless_dev *wdev)
++{
++	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
++	struct net_device *ndev = wdev->netdev;
++
++	ndev->netdev_ops->ndo_stop(ndev);
++
++	brcmf_net_detach(ndev, true);
++
++	cfg->pub->mon_if = NULL;
++
++	return 0;
++}
++
+ static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
+ 						     const char *name,
+ 						     unsigned char name_assign_type,
+@@ -641,9 +718,10 @@ static struct wireless_dev *brcmf_cfg802
+ 	case NL80211_IFTYPE_STATION:
+ 	case NL80211_IFTYPE_AP_VLAN:
+ 	case NL80211_IFTYPE_WDS:
+-	case NL80211_IFTYPE_MONITOR:
+ 	case NL80211_IFTYPE_MESH_POINT:
+ 		return ERR_PTR(-EOPNOTSUPP);
++	case NL80211_IFTYPE_MONITOR:
++		return brcmf_mon_add_vif(wiphy, name);
+ 	case NL80211_IFTYPE_AP:
+ 		wdev = brcmf_ap_add_vif(wiphy, name, params);
+ 		break;
+@@ -826,9 +904,10 @@ int brcmf_cfg80211_del_iface(struct wiph
+ 	case NL80211_IFTYPE_STATION:
+ 	case NL80211_IFTYPE_AP_VLAN:
+ 	case NL80211_IFTYPE_WDS:
+-	case NL80211_IFTYPE_MONITOR:
+ 	case NL80211_IFTYPE_MESH_POINT:
+ 		return -EOPNOTSUPP;
++	case NL80211_IFTYPE_MONITOR:
++		return brcmf_mon_del_vif(wiphy, wdev);
+ 	case NL80211_IFTYPE_AP:
+ 		return brcmf_cfg80211_del_ap_iface(wiphy, wdev);
+ 	case NL80211_IFTYPE_P2P_CLIENT:
+@@ -6474,9 +6553,10 @@ static int brcmf_setup_ifmodes(struct wi
+ 	struct ieee80211_iface_limit *c0_limits = NULL;
+ 	struct ieee80211_iface_limit *p2p_limits = NULL;
+ 	struct ieee80211_iface_limit *mbss_limits = NULL;
+-	bool mbss, p2p, rsdb, mchan;
+-	int i, c, n_combos;
++	bool mon_flag, mbss, p2p, rsdb, mchan;
++	int i, c, n_combos, n_limits;
+ 
++	mon_flag = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MONITOR_FLAG);
+ 	mbss = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS);
+ 	p2p = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_P2P);
+ 	rsdb = brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB);
+@@ -6490,6 +6570,8 @@ static int brcmf_setup_ifmodes(struct wi
+ 	wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+ 				 BIT(NL80211_IFTYPE_ADHOC) |
+ 				 BIT(NL80211_IFTYPE_AP);
++	if (mon_flag)
++		wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);
+ 	if (p2p)
+ 		wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_CLIENT) |
+ 					  BIT(NL80211_IFTYPE_P2P_GO) |
+@@ -6497,18 +6579,18 @@ static int brcmf_setup_ifmodes(struct wi
+ 
+ 	c = 0;
+ 	i = 0;
+-	if (p2p && rsdb)
+-		c0_limits = kcalloc(4, sizeof(*c0_limits), GFP_KERNEL);
+-	else if (p2p)
+-		c0_limits = kcalloc(3, sizeof(*c0_limits), GFP_KERNEL);
+-	else
+-		c0_limits = kcalloc(2, sizeof(*c0_limits), GFP_KERNEL);
++	n_limits = 1 + mon_flag + (p2p ? 2 : 0) + (rsdb || !p2p);
++	c0_limits = kcalloc(n_limits, sizeof(*c0_limits), GFP_KERNEL);
+ 	if (!c0_limits)
+ 		goto err;
+ 
+ 	combo[c].num_different_channels = 1 + (rsdb || (p2p && mchan));
+ 	c0_limits[i].max = 1 + rsdb;
+ 	c0_limits[i++].types = BIT(NL80211_IFTYPE_STATION);
++	if (mon_flag) {
++		c0_limits[i].max = 1;
++		c0_limits[i++].types = BIT(NL80211_IFTYPE_MONITOR);
++	}
+ 	if (p2p) {
+ 		c0_limits[i].max = 1;
+ 		c0_limits[i++].types = BIT(NL80211_IFTYPE_P2P_DEVICE);
+@@ -6557,14 +6639,20 @@ static int brcmf_setup_ifmodes(struct wi
+ 	if (mbss) {
+ 		c++;
+ 		i = 0;
+-		mbss_limits = kcalloc(1, sizeof(*mbss_limits), GFP_KERNEL);
++		n_limits = 1 + mon_flag;
++		mbss_limits = kcalloc(n_limits, sizeof(*mbss_limits),
++				      GFP_KERNEL);
+ 		if (!mbss_limits)
+ 			goto err;
+ 		mbss_limits[i].max = 4;
+ 		mbss_limits[i++].types = BIT(NL80211_IFTYPE_AP);
++		if (mon_flag) {
++			mbss_limits[i].max = 1;
++			mbss_limits[i++].types = BIT(NL80211_IFTYPE_MONITOR);
++		}
+ 		combo[c].beacon_int_infra_match = true;
+ 		combo[c].num_different_channels = 1;
+-		combo[c].max_interfaces = 4;
++		combo[c].max_interfaces = 4 + mon_flag;
+ 		combo[c].n_limits = i;
+ 		combo[c].limits = mbss_limits;
+ 	}
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -690,7 +690,7 @@ fail:
+ 	return -EBADE;
+ }
+ 
+-static void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked)
++void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked)
+ {
+ 	if (ndev->reg_state == NETREG_REGISTERED) {
+ 		if (rtnl_locked)
+@@ -703,6 +703,72 @@ static void brcmf_net_detach(struct net_
+ 	}
+ }
+ 
++static int brcmf_net_mon_open(struct net_device *ndev)
++{
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = ifp->drvr;
++	u32 monitor;
++	int err;
++
++	brcmf_dbg(TRACE, "Enter\n");
++
++	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_MONITOR, &monitor);
++	if (err) {
++		bphy_err(drvr, "BRCMF_C_GET_MONITOR error (%d)\n", err);
++		return err;
++	} else if (monitor) {
++		bphy_err(drvr, "Monitor mode is already enabled\n");
++		return -EEXIST;
++	}
++
++	monitor = 3;
++	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_MONITOR, monitor);
++	if (err)
++		bphy_err(drvr, "BRCMF_C_SET_MONITOR error (%d)\n", err);
++
++	return err;
++}
++
++static int brcmf_net_mon_stop(struct net_device *ndev)
++{
++	struct brcmf_if *ifp = netdev_priv(ndev);
++	struct brcmf_pub *drvr = ifp->drvr;
++	u32 monitor;
++	int err;
++
++	brcmf_dbg(TRACE, "Enter\n");
++
++	monitor = 0;
++	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_MONITOR, monitor);
++	if (err)
++		bphy_err(drvr, "BRCMF_C_SET_MONITOR error (%d)\n", err);
++
++	return err;
++}
++
++static const struct net_device_ops brcmf_netdev_ops_mon = {
++	.ndo_open = brcmf_net_mon_open,
++	.ndo_stop = brcmf_net_mon_stop,
++};
++
++int brcmf_net_mon_attach(struct brcmf_if *ifp)
++{
++	struct brcmf_pub *drvr = ifp->drvr;
++	struct net_device *ndev;
++	int err;
++
++	brcmf_dbg(TRACE, "Enter\n");
++
++	ndev = ifp->ndev;
++	ndev->netdev_ops = &brcmf_netdev_ops_mon;
++
++	err = register_netdevice(ndev);
++	if (err)
++		bphy_err(drvr, "Failed to register %s device\n", ndev->name);
++
++	return err;
++}
++
+ void brcmf_net_setcarrier(struct brcmf_if *ifp, bool on)
+ {
+ 	struct net_device *ndev;
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
+@@ -210,6 +210,8 @@ void brcmf_txflowblock_if(struct brcmf_i
+ void brcmf_txfinalize(struct brcmf_if *ifp, struct sk_buff *txp, bool success);
+ void brcmf_netif_rx(struct brcmf_if *ifp, struct sk_buff *skb);
+ void brcmf_netif_mon_rx(struct brcmf_if *ifp, struct sk_buff *skb);
++void brcmf_net_detach(struct net_device *ndev, bool rtnl_locked);
++int brcmf_net_mon_attach(struct brcmf_if *ifp);
+ void brcmf_net_setcarrier(struct brcmf_if *ifp, bool on);
+ int __init brcmf_core_init(void);
+ void __exit brcmf_core_exit(void);
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.c
+@@ -38,6 +38,7 @@ static const struct brcmf_feat_fwcap brc
+ 	{ BRCMF_FEAT_MCHAN, "mchan" },
+ 	{ BRCMF_FEAT_P2P, "p2p" },
+ 	{ BRCMF_FEAT_MONITOR, "monitor" },
++	{ BRCMF_FEAT_MONITOR_FLAG, "rtap" },
+ 	{ BRCMF_FEAT_MONITOR_FMT_RADIOTAP, "rtap" },
+ 	{ BRCMF_FEAT_DOT11H, "802.11h" }
+ };
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/feature.h
+@@ -23,6 +23,7 @@
+  * GSCAN: enhanced scan offload feature.
+  * FWSUP: Firmware supplicant.
+  * MONITOR: firmware can pass monitor packets to host.
++ * MONITOR_FLAG: firmware flags monitor packets.
+  * MONITOR_FMT_RADIOTAP: firmware provides monitor packets with radiotap header
+  * MONITOR_FMT_HW_RX_HDR: firmware provides monitor packets with hw/ucode header
+  * DOT11H: firmware supports 802.11h
+@@ -43,6 +44,7 @@
+ 	BRCMF_FEAT_DEF(GSCAN) \
+ 	BRCMF_FEAT_DEF(FWSUP) \
+ 	BRCMF_FEAT_DEF(MONITOR) \
++	BRCMF_FEAT_DEF(MONITOR_FLAG) \
+ 	BRCMF_FEAT_DEF(MONITOR_FMT_RADIOTAP) \
+ 	BRCMF_FEAT_DEF(MONITOR_FMT_HW_RX_HDR) \
+ 	BRCMF_FEAT_DEF(DOT11H)
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fwil.h
+@@ -49,6 +49,8 @@
+ #define BRCMF_C_GET_PM				85
+ #define BRCMF_C_SET_PM				86
+ #define BRCMF_C_GET_REVINFO			98
++#define BRCMF_C_GET_MONITOR			107
++#define BRCMF_C_SET_MONITOR			108
+ #define BRCMF_C_GET_CURR_RATESET		114
+ #define BRCMF_C_GET_AP				117
+ #define BRCMF_C_SET_AP				118
diff -uprN a/package/kernel/mac80211/patches/brcm/420-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch b/package/kernel/mac80211/patches/brcm/420-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch
--- a/package/kernel/mac80211/patches/brcm/420-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/420-v5.6-brcmfmac-Remove-always-false-idx-0-statement.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,24 @@
+From 627b0d094240c38393b2f2d40626c33a8fff6103 Mon Sep 17 00:00:00 2001
+From: yuehaibing <yuehaibing@huawei.com>
+Date: Wed, 8 Jan 2020 21:57:48 +0800
+Subject: [PATCH] brcmfmac: Remove always false 'idx < 0' statement
+
+idx is declared as u32, it will never less than 0.
+
+Signed-off-by: yuehaibing <yuehaibing@huawei.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c
+@@ -365,7 +365,7 @@ brcmf_msgbuf_get_pktid(struct device *de
+ 	struct brcmf_msgbuf_pktid *pktid;
+ 	struct sk_buff *skb;
+ 
+-	if (idx < 0 || idx >= pktids->array_size) {
++	if (idx >= pktids->array_size) {
+ 		brcmf_err("Invalid packet id %d (max %d)\n", idx,
+ 			  pktids->array_size);
+ 		return NULL;
diff -uprN a/package/kernel/mac80211/patches/brcm/500-brcmfmac-add-stub-for-monitor-interface-xmit.patch b/package/kernel/mac80211/patches/brcm/500-brcmfmac-add-stub-for-monitor-interface-xmit.patch
--- a/package/kernel/mac80211/patches/brcm/500-brcmfmac-add-stub-for-monitor-interface-xmit.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/500-brcmfmac-add-stub-for-monitor-interface-xmit.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,100 @@
+From: =?UTF-8?q?Rafa=C5=82=20Mi=C5=82ecki?= <rafal@milecki.pl>
+Date: Fri, 27 Mar 2020 13:40:50 +0100
+Subject: [PATCH] brcmfmac: add stub for monitor interface xmit
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+According to the struct net_device_ops documentation .ndo_start_xmit is
+"Required; cannot be NULL.". Missing it may crash kernel easily:
+
+[  341.216709] Unable to handle kernel NULL pointer dereference at virtual address 00000000
+[  341.224836] pgd = 26088755
+[  341.227544] [00000000] *pgd=00000000
+[  341.231135] Internal error: Oops: 80000007 [#1] SMP ARM
+[  341.236367] Modules linked in: pppoe ppp_async iptable_nat brcmfmac xt_state xt_nat xt_conntrack xt_REDIRECT xt_MASQU
+[  341.304689] CPU: 0 PID: 0 Comm: swapper/0 Not tainted 5.4.24 #0
+[  341.310621] Hardware name: BCM5301X
+[  341.314116] PC is at 0x0
+[  341.316664] LR is at dev_hard_start_xmit+0x8c/0x11c
+[  341.321546] pc : [<00000000>]    lr : [<c0469fa8>]    psr: 60000113
+[  341.327821] sp : c0801c30  ip : c610cf00  fp : c08048e4
+[  341.333051] r10: c073a63a  r9 : c08044dc  r8 : c6c04e00
+[  341.338283] r7 : 00000000  r6 : c60f5000  r5 : 00000000  r4 : c6a9c3c0
+[  341.344820] r3 : 00000000  r2 : bf25a13c  r1 : c60f5000  r0 : c6a9c3c0
+[  341.351358] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment none
+[  341.358504] Control: 10c5387d  Table: 0611c04a  DAC: 00000051
+[  341.364257] Process swapper/0 (pid: 0, stack limit = 0xc68ed0ca)
+[  341.370271] Stack: (0xc0801c30 to 0xc0802000)
+[  341.374633] 1c20:                                     c6e7d480 c0802d00 c60f5050 c0801c6c
+[  341.382825] 1c40: c60f5000 c6a9c3c0 c6f90000 c6f9005c c6c04e00 c60f5000 00000000 c6f9005c
+[  341.391015] 1c60: 00000000 c04a033c 00f90200 00000010 c6a9c3c0 c6a9c3c0 c6f90000 00000000
+[  341.399205] 1c80: 00000000 00000000 00000000 c046a7ac c6f9005c 00000001 fffffff4 00000000
+[  341.407395] 1ca0: c6f90200 00000000 c60f5000 c0479550 00000000 c6f90200 c6a9c3c0 16000000
+[  341.415586] 1cc0: 0000001c 6f4ad52f c6197040 b6df9387 36000000 c0520404 c073a80c c6a9c3c0
+[  341.423777] 1ce0: 00000000 c6d643c0 c6a9c3c0 c0800024 00000001 00000001 c6d643c8 c6a9c3c0
+[  341.431967] 1d00: c081b9c0 c7abca80 c610c840 c081b9c0 0000001c 00400000 c6bc5e6c c0522fb4
+[  341.440157] 1d20: c6d64400 00000004 c6bc5e0a 00000000 c60f5000 c7abca80 c081b9c0 c0522f54
+[  341.448348] 1d40: c6a9c3c0 c7abca80 c0803e48 c0549c94 c610c828 0000000a c0801d74 00000003
+[  341.456538] 1d60: c6ec8f0a 00000000 c60f5000 c7abca80 c081b9c0 c0548520 0000000a 00000000
+[  341.464728] 1d80: 00000000 003a0000 00000000 00000000 00000000 00000000 00000000 00000000
+[  341.472919] 1da0: 000002ff 00000000 00000000 16000000 00000000 00000000 00000000 00000000
+[  341.481110] 1dc0: 00000000 0000008f 00000000 00000000 00000000 2d132a69 c6bc5e40 00000000
+[  341.489300] 1de0: c6bc5e40 c6a9c3c0 00000000 c6ec8e50 00000001 c054b070 00000001 00000000
+[  341.497490] 1e00: c0807200 c6bc5e00 00000000 ffffe000 00000100 c054aea4 00000000 00000000
+[  341.505681] 1e20: 00000122 00400000 c0802d00 c0172e80 6f56a70e ffffffff 6f56a70e c7eb9cc0
+[  341.513871] 1e40: c7eb82c0 00000000 c0801e60 c017309c 00000000 00000000 07780000 c07382c0
+[  341.522061] 1e60: 00000000 c7eb9cc0 c0739cc0 c0803f74 c0801e70 c0801e70 c0801ea4 c013d380
+[  341.530253] 1e80: 00000000 000000a0 00000001 c0802084 c0802080 40000001 ffffe000 00000100
+[  341.538443] 1ea0: c0802080 c01021e8 c8803100 10c5387d 00000000 c07341f0 c0739880 0000000a
+[  341.546633] 1ec0: c0734180 00001017 c0802d00 c062aa98 00200002 c062aa60 c8803100 c073984c
+[  341.554823] 1ee0: 00000000 00000001 00000000 c7810000 c8803100 10c5387d 00000000 c011c188
+[  341.563014] 1f00: c073984c c015f0f8 c0804244 c0815ae4 c880210c c8802100 c0801f40 c037c584
+[  341.571204] 1f20: c01035f8 60000013 ffffffff c0801f74 c080afd4 c0800000 10c5387d c0101a8c
+[  341.579395] 1f40: 00000000 004ac9dc c7eba4b4 c010ee60 ffffe000 c0803e68 c0803ea8 00000001
+[  341.587587] 1f60: c080afd4 c062ca20 10c5387d 00000000 00000000 c0801f90 c01035f4 c01035f8
+[  341.595776] 1f80: 60000013 ffffffff 00000051 00000000 ffffe000 c013ff50 000000ce c0803e40
+[  341.603967] 1fa0: c082216c 00000000 00000001 c072ba38 10c5387d c0140214 c0822184 c0700df8
+[  341.612157] 1fc0: ffffffff ffffffff 00000000 c070058c c072ba38 2d162e71 00000000 c0700330
+[  341.620348] 1fe0: 00000051 10c0387d 000000ff 00a521d0 413fc090 00000000 00000000 00000000
+[  341.628558] [<c0469fa8>] (dev_hard_start_xmit) from [<c04a033c>] (sch_direct_xmit+0xe4/0x2bc)
+[  341.637106] [<c04a033c>] (sch_direct_xmit) from [<c046a7ac>] (__dev_queue_xmit+0x6a4/0x72c)
+[  341.645481] [<c046a7ac>] (__dev_queue_xmit) from [<c0520404>] (ip6_finish_output2+0x18c/0x434)
+[  341.654112] [<c0520404>] (ip6_finish_output2) from [<c0522fb4>] (ip6_output+0x5c/0xd0)
+[  341.662053] [<c0522fb4>] (ip6_output) from [<c0549c94>] (mld_sendpack+0x1a0/0x1a8)
+[  341.669640] [<c0549c94>] (mld_sendpack) from [<c054b070>] (mld_ifc_timer_expire+0x1cc/0x2e4)
+[  341.678111] [<c054b070>] (mld_ifc_timer_expire) from [<c0172e80>] (call_timer_fn.constprop.3+0x24/0x98)
+[  341.687527] [<c0172e80>] (call_timer_fn.constprop.3) from [<c017309c>] (run_timer_softirq+0x1a8/0x1e4)
+[  341.696860] [<c017309c>] (run_timer_softirq) from [<c01021e8>] (__do_softirq+0x120/0x2b0)
+[  341.705066] [<c01021e8>] (__do_softirq) from [<c011c188>] (irq_exit+0x78/0x84)
+[  341.712317] [<c011c188>] (irq_exit) from [<c015f0f8>] (__handle_domain_irq+0x60/0xb4)
+[  341.720179] [<c015f0f8>] (__handle_domain_irq) from [<c037c584>] (gic_handle_irq+0x4c/0x90)
+[  341.728549] [<c037c584>] (gic_handle_irq) from [<c0101a8c>] (__irq_svc+0x6c/0x90)
+
+Fixes: 20f2c5fa3af0 ("brcmfmac: add initial support for monitor mode")
+Signed-off-by: Rafał Miłecki <rafal@milecki.pl>
+---
+ drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c | 9 +++++++++
+ 1 file changed, 9 insertions(+)
+
+--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
++++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+@@ -746,9 +746,18 @@ static int brcmf_net_mon_stop(struct net
+ 	return err;
+ }
+ 
++static netdev_tx_t brcmf_net_mon_start_xmit(struct sk_buff *skb,
++					    struct net_device *ndev)
++{
++	dev_kfree_skb_any(skb);
++
++	return NETDEV_TX_OK;
++}
++
+ static const struct net_device_ops brcmf_netdev_ops_mon = {
+ 	.ndo_open = brcmf_net_mon_open,
+ 	.ndo_stop = brcmf_net_mon_stop,
++	.ndo_start_xmit = brcmf_net_mon_start_xmit,
+ };
+ 
+ int brcmf_net_mon_attach(struct brcmf_if *ifp)
diff -uprN a/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch b/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch
--- a/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/810-b43-gpio-mask-module-option.patch	2022-04-04 20:20:32.955828000 +0800
@@ -10,7 +10,7 @@
  	struct b43_phy phy;
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -72,6 +72,11 @@ MODULE_FIRMWARE("b43/ucode40.fw");
+@@ -85,6 +85,11 @@ MODULE_FIRMWARE("b43/ucode40.fw");
  MODULE_FIRMWARE("b43/ucode42.fw");
  MODULE_FIRMWARE("b43/ucode9.fw");
  
@@ -22,7 +22,7 @@
  static int modparam_bad_frames_preempt;
  module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
  MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2867,10 +2872,10 @@ static int b43_gpio_init(struct b43_wlde
+@@ -2892,10 +2897,10 @@ static int b43_gpio_init(struct b43_wlde
  	u32 mask, set;
  
  	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
diff -uprN a/package/kernel/mac80211/patches/brcm/811-b43_no_pio.patch b/package/kernel/mac80211/patches/brcm/811-b43_no_pio.patch
--- a/package/kernel/mac80211/patches/brcm/811-b43_no_pio.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/811-b43_no_pio.patch	2022-04-04 20:20:32.955828000 +0800
@@ -11,7 +11,7 @@
  b43-$(CPTCFG_B43_LEDS)		+= leds.o
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2000,10 +2000,12 @@ static void b43_do_interrupt_thread(stru
+@@ -2018,10 +2018,12 @@ static void b43_do_interrupt_thread(stru
  			dma_reason[0], dma_reason[1],
  			dma_reason[2], dma_reason[3],
  			dma_reason[4], dma_reason[5]);
@@ -75,7 +75,7 @@
  #endif /* B43_PIO_H_ */
 --- a/drivers/net/wireless/broadcom/b43/Kconfig
 +++ b/drivers/net/wireless/broadcom/b43/Kconfig
-@@ -100,7 +100,7 @@ config B43_BCMA_PIO
+@@ -98,7 +98,7 @@ config B43_BCMA_PIO
  	default y
  
  config B43_PIO
diff -uprN a/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch b/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch
--- a/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/812-b43-add-antenna-control.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -1642,7 +1642,7 @@ static void b43_write_beacon_template(st
+@@ -1658,7 +1658,7 @@ static void b43_write_beacon_template(st
  				  len, ram_offset, shm_size_offset, rate);
  
  	/* Write the PHY TX control parameters. */
@@ -9,7 +9,7 @@
  	antenna = b43_antenna_to_phyctl(antenna);
  	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
  	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3282,8 +3282,8 @@ static int b43_chip_init(struct b43_wlde
+@@ -3307,8 +3307,8 @@ static int b43_chip_init(struct b43_wlde
  
  	/* Select the antennae */
  	if (phy->ops->set_rx_antenna)
@@ -20,7 +20,7 @@
  
  	if (phy->type == B43_PHYTYPE_B) {
  		value16 = b43_read16(dev, 0x005E);
-@@ -3983,7 +3983,6 @@ static int b43_op_config(struct ieee8021
+@@ -4008,7 +4008,6 @@ static int b43_op_config(struct ieee8021
  	struct b43_wldev *dev = wl->current_dev;
  	struct b43_phy *phy = &dev->phy;
  	struct ieee80211_conf *conf = &hw->conf;
@@ -28,7 +28,7 @@
  	int err = 0;
  
  	mutex_lock(&wl->mutex);
-@@ -4026,11 +4025,9 @@ static int b43_op_config(struct ieee8021
+@@ -4051,11 +4050,9 @@ static int b43_op_config(struct ieee8021
  	}
  
  	/* Antennas for RX and management frame TX. */
@@ -42,7 +42,7 @@
  
  	if (wl->radio_enabled != phy->radio_on) {
  		if (wl->radio_enabled) {
-@@ -5174,6 +5171,47 @@ static int b43_op_get_survey(struct ieee
+@@ -5199,6 +5196,47 @@ static int b43_op_get_survey(struct ieee
  	return 0;
  }
  
@@ -90,7 +90,7 @@
  static const struct ieee80211_ops b43_hw_ops = {
  	.tx			= b43_op_tx,
  	.conf_tx		= b43_op_conf_tx,
-@@ -5195,6 +5233,8 @@ static const struct ieee80211_ops b43_hw
+@@ -5220,6 +5258,8 @@ static const struct ieee80211_ops b43_hw
  	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
  	.get_survey		= b43_op_get_survey,
  	.rfkill_poll		= b43_rfkill_poll,
@@ -99,7 +99,7 @@
  };
  
  /* Hard-reset the chip. Do not call this directly.
-@@ -5496,6 +5536,8 @@ static int b43_one_core_attach(struct b4
+@@ -5523,6 +5563,8 @@ static int b43_one_core_attach(struct b4
  	if (!wldev)
  		goto out;
  
@@ -108,14 +108,14 @@
  	wldev->use_pio = b43_modparam_pio;
  	wldev->dev = dev;
  	wldev->wl = wl;
-@@ -5590,6 +5632,9 @@ static struct b43_wl *b43_wireless_init(
+@@ -5617,6 +5659,9 @@ static struct b43_wl *b43_wireless_init(
  
  	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
  
 +	hw->wiphy->available_antennas_rx = 0x3;
 +	hw->wiphy->available_antennas_tx = 0x3;
 +
- 	wl->hw_registered = false;
+ 	wl->hw_registred = false;
  	hw->max_rates = 2;
  	SET_IEEE80211_DEV(hw, dev->dev);
 --- a/drivers/net/wireless/broadcom/b43/b43.h
diff -uprN a/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch b/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch
--- a/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/814-b43-only-use-gpio-0-1-for-led.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2884,6 +2884,14 @@ static int b43_gpio_init(struct b43_wlde
+@@ -2909,6 +2909,14 @@ static int b43_gpio_init(struct b43_wlde
  	} else if (dev->dev->chip_id == 0x5354) {
  		/* Don't allow overtaking buttons GPIOs */
  		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
diff -uprN a/package/kernel/mac80211/patches/brcm/815-b43-always-take-overlapping-devs.patch b/package/kernel/mac80211/patches/brcm/815-b43-always-take-overlapping-devs.patch
--- a/package/kernel/mac80211/patches/brcm/815-b43-always-take-overlapping-devs.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/815-b43-always-take-overlapping-devs.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -114,7 +114,7 @@ static int b43_modparam_pio = 0;
+@@ -127,7 +127,7 @@ static int b43_modparam_pio = 0;
  module_param_named(pio, b43_modparam_pio, int, 0644);
  MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
  
diff -uprN a/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch b/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch
--- a/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/862-brcmfmac-Disable-power-management.patch	2022-04-04 20:20:32.955828000 +0800
@@ -14,7 +14,7 @@ Signed-off-by: Phil Elwell <phil@raspber
 
 --- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
 +++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2874,6 +2874,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
+@@ -2866,6 +2866,10 @@ brcmf_cfg80211_set_power_mgmt(struct wip
  	 * preference in cfg struct to apply this to
  	 * FW later while initializing the dongle
  	 */
diff -uprN a/package/kernel/mac80211/patches/brcm/998-survey.patch b/package/kernel/mac80211/patches/brcm/998-survey.patch
--- a/package/kernel/mac80211/patches/brcm/998-survey.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/brcm/998-survey.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,148 +0,0 @@
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
-@@ -2826,6 +2826,63 @@ done:
- }
- 
- static int
-+brcmf_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *ndev,
-+			   int idx, struct survey_info *survey)
-+{
-+	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
-+	struct brcmf_if *ifp = netdev_priv(ndev);
-+	struct brcmu_chan ch;
-+	enum nl80211_band band = 0;
-+	s32 err = 0;
-+	int noise;
-+	u32 freq;
-+	u32 chanspec;
-+
-+	memset(survey, 0, sizeof(struct survey_info));
-+	if (idx != 0) {
-+		if (idx >= cfg->pub->num_chan_stats || cfg->pub->chan_stats == NULL)
-+			return -ENOENT;
-+		if (cfg->pub->chan_stats[idx].freq == 0)
-+			return -ENOENT;
-+		survey->filled = SURVEY_INFO_NOISE_DBM;
-+		survey->channel = ieee80211_get_channel(wiphy, cfg->pub->chan_stats[idx].freq);
-+		survey->noise = cfg->pub->chan_stats[idx].noise;
-+		return 0;
-+	}
-+
-+	err = brcmf_fil_iovar_int_get(ifp, "chanspec", &chanspec);
-+	if (err) {
-+		brcmf_err("chanspec failed (%d)\n", err);
-+		return err;
-+	}
-+
-+	ch.chspec = chanspec;
-+	cfg->d11inf.decchspec(&ch);
-+
-+	switch (ch.band) {
-+	case BRCMU_CHAN_BAND_2G:
-+		band = NL80211_BAND_2GHZ;
-+		break;
-+	case BRCMU_CHAN_BAND_5G:
-+		band = NL80211_BAND_5GHZ;
-+		break;
-+	}
-+
-+	freq = ieee80211_channel_to_frequency(ch.control_ch_num, band);
-+	survey->channel = ieee80211_get_channel(wiphy, freq);
-+
-+	err = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_PHY_NOISE, &noise);
-+	if (err) {
-+		brcmf_err("Could not get noise (%d)\n", err);
-+		return err;
-+	}
-+
-+	survey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_IN_USE;
-+	survey->noise = le32_to_cpu(noise);
-+	return 0;
-+}
-+
-+static int
- brcmf_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *ndev,
- 			    int idx, u8 *mac, struct station_info *sinfo)
- {
-@@ -2915,6 +2972,7 @@ static s32 brcmf_inform_single_bss(struc
- 	struct brcmu_chan ch;
- 	u16 channel;
- 	u32 freq;
-+	int i;
- 	u16 notify_capability;
- 	u16 notify_interval;
- 	u8 *notify_ie;
-@@ -2939,6 +2997,17 @@ static s32 brcmf_inform_single_bss(struc
- 		band = NL80211_BAND_5GHZ;
- 
- 	freq = ieee80211_channel_to_frequency(channel, band);
-+	for (i = 0;i < cfg->pub->num_chan_stats;i++) {
-+		if (freq == cfg->pub->chan_stats[i].freq)
-+			break;
-+		if (cfg->pub->chan_stats[i].freq == 0)
-+			break;
-+	}
-+	if (i < cfg->pub->num_chan_stats) {
-+		cfg->pub->chan_stats[i].freq = freq;
-+		cfg->pub->chan_stats[i].noise = bi->phy_noise;
-+	}
-+
- 	bss_data.chan = ieee80211_get_channel(wiphy, freq);
- 	bss_data.scan_width = NL80211_BSS_CHAN_WIDTH_20;
- 	bss_data.boottime_ns = ktime_to_ns(ktime_get_boottime());
-@@ -5356,6 +5425,7 @@ static struct cfg80211_ops brcmf_cfg8021
- 	.leave_ibss = brcmf_cfg80211_leave_ibss,
- 	.get_station = brcmf_cfg80211_get_station,
- 	.dump_station = brcmf_cfg80211_dump_station,
-+	.dump_survey = brcmf_cfg80211_dump_survey,
- 	.set_tx_power = brcmf_cfg80211_set_tx_power,
- 	.get_tx_power = brcmf_cfg80211_get_tx_power,
- 	.add_key = brcmf_cfg80211_add_key,
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
-@@ -1352,6 +1352,8 @@ int brcmf_attach(struct device *dev)
- 
- 	/* Link to bus module */
- 	drvr->hdrlen = 0;
-+	drvr->chan_stats = vzalloc(256 * sizeof(struct brcmf_chan_stats));
-+	drvr->num_chan_stats = 256;
- 
- 	/* Attach and link in the protocol */
- 	ret = brcmf_proto_attach(drvr);
-@@ -1434,6 +1436,12 @@ void brcmf_detach(struct device *dev)
- 	if (drvr == NULL)
- 		return;
- 
-+	drvr->num_chan_stats = 0;
-+	if (drvr->chan_stats) {
-+		vfree(drvr->chan_stats);
-+		drvr->chan_stats = NULL;
-+	}
-+
- #ifdef CONFIG_INET
- 	unregister_inetaddr_notifier(&drvr->inetaddr_notifier);
- #endif
---- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.h
-@@ -91,6 +91,11 @@ struct brcmf_rev_info {
- 	u32 nvramrev;
- };
- 
-+struct brcmf_chan_stats {
-+	u32 freq;
-+	int noise;
-+};
-+
- /* Common structure for module and instance linkage */
- struct brcmf_pub {
- 	/* Linkage ponters */
-@@ -100,6 +105,9 @@ struct brcmf_pub {
- 	struct cfg80211_ops *ops;
- 	struct brcmf_cfg80211_info *config;
- 
-+	int num_chan_stats;
-+	struct brcmf_chan_stats *chan_stats;
-+
- 	/* Internal brcmf items */
- 	uint hdrlen;		/* Total BRCMF header length (proto + bus) */
- 
diff -uprN a/package/kernel/mac80211/patches/build/002-change_allconfig.patch b/package/kernel/mac80211/patches/build/002-change_allconfig.patch
--- a/package/kernel/mac80211/patches/build/002-change_allconfig.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/build/002-change_allconfig.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/kconf/conf.c
 +++ b/kconf/conf.c
-@@ -598,40 +598,12 @@ int main(int ac, char **av)
+@@ -594,40 +594,12 @@ int main(int ac, char **av)
  	case oldconfig:
  	case listnewconfig:
  	case olddefconfig:
diff -uprN a/package/kernel/mac80211/patches/build/015-ipw200-mtu.patch b/package/kernel/mac80211/patches/build/015-ipw200-mtu.patch
--- a/package/kernel/mac80211/patches/build/015-ipw200-mtu.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/build/015-ipw200-mtu.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/intel/ipw2x00/ipw2200.c
 +++ b/drivers/net/wireless/intel/ipw2x00/ipw2200.c
-@@ -11482,6 +11482,15 @@ static const struct attribute_group ipw_
+@@ -11499,6 +11499,15 @@ static const struct attribute_group ipw_
  	.attrs = ipw_sysfs_entries,
  };
  
@@ -16,7 +16,7 @@
  #ifdef CPTCFG_IPW2200_PROMISCUOUS
  static int ipw_prom_open(struct net_device *dev)
  {
-@@ -11530,15 +11539,6 @@ static netdev_tx_t ipw_prom_hard_start_x
+@@ -11547,15 +11556,6 @@ static netdev_tx_t ipw_prom_hard_start_x
  	return NETDEV_TX_OK;
  }
  
diff -uprN a/package/kernel/mac80211/patches/build/050-lib80211_option.patch b/package/kernel/mac80211/patches/build/050-lib80211_option.patch
--- a/package/kernel/mac80211/patches/build/050-lib80211_option.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/build/050-lib80211_option.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/net/wireless/Kconfig
 +++ b/net/wireless/Kconfig
-@@ -186,7 +186,7 @@ config CFG80211_WEXT_EXPORT
+@@ -185,7 +185,7 @@ config CFG80211_WEXT_EXPORT
  endif # CFG80211
  
  config LIB80211
@@ -9,25 +9,22 @@
  	depends on m
  	default n
  	help
-@@ -196,18 +196,18 @@ config LIB80211
+@@ -195,15 +195,15 @@ config LIB80211
  	  Drivers should select this themselves if needed.
  
  config LIB80211_CRYPT_WEP
 -	tristate
 +	tristate "lib80211 WEP support"
  	depends on m
- 	select BPAUTO_CRYPTO_LIB_ARC4
  
  config LIB80211_CRYPT_CCMP
 -	tristate
 +	tristate "lib80211 CCMP support"
  	depends on m
- 	depends on CRYPTO_AES
- 	depends on CRYPTO_CCM
  
  config LIB80211_CRYPT_TKIP
 -	tristate
 +	tristate "lib80211 TKIP support"
  	depends on m
- 	select BPAUTO_CRYPTO_LIB_ARC4
  
+ config LIB80211_DEBUG
diff -uprN a/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch b/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch
--- a/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/build/060-no_local_ssb_bcma.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,9 +1,9 @@
 --- a/local-symbols
 +++ b/local-symbols
-@@ -412,43 +412,6 @@ USB_SIERRA_NET=
+@@ -396,43 +396,6 @@ USB_IPHETH=
+ USB_SIERRA_NET=
  USB_VL600=
  USB_NET_CH9200=
- USB_NET_AQC111=
 -SSB_POSSIBLE=
 -SSB=
 -SSB_SPROM=
@@ -46,7 +46,7 @@
  USB_WDM=
 --- a/drivers/net/wireless/broadcom/b43/Kconfig
 +++ b/drivers/net/wireless/broadcom/b43/Kconfig
-@@ -63,21 +63,21 @@ endchoice
+@@ -61,21 +61,21 @@ endchoice
  config B43_PCI_AUTOSELECT
  	bool
  	depends on B43 && SSB_PCIHOST_POSSIBLE
@@ -72,7 +72,7 @@
  	---help---
  	  Broadcom 43xx device support for Soft-MAC SDIO devices.
  
-@@ -96,13 +96,13 @@ config B43_SDIO
+@@ -94,13 +94,13 @@ config B43_SDIO
  config B43_BCMA_PIO
  	bool
  	depends on B43 && B43_BCMA
@@ -90,7 +90,7 @@
  config B43_PHY_G
 --- a/drivers/net/wireless/broadcom/b43/main.c
 +++ b/drivers/net/wireless/broadcom/b43/main.c
-@@ -2851,7 +2851,7 @@ static struct ssb_device *b43_ssb_gpio_d
+@@ -2876,7 +2876,7 @@ static struct ssb_device *b43_ssb_gpio_d
  {
  	struct ssb_bus *bus = dev->dev->sdev->bus;
  
@@ -99,7 +99,7 @@
  	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
  #else
  	return bus->chipco.dev;
-@@ -4868,7 +4868,7 @@ static int b43_wireless_core_init(struct
+@@ -4893,7 +4893,7 @@ static int b43_wireless_core_init(struct
  	}
  	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
  		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
@@ -110,7 +110,7 @@
  	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
 --- a/drivers/net/wireless/broadcom/b43legacy/Kconfig
 +++ b/drivers/net/wireless/broadcom/b43legacy/Kconfig
-@@ -3,7 +3,7 @@ config B43LEGACY
+@@ -2,7 +2,7 @@ config B43LEGACY
  	tristate "Broadcom 43xx-legacy wireless support (mac80211 stack)"
  	depends on m
  	depends on SSB_POSSIBLE && MAC80211 && HAS_DMA
@@ -119,7 +119,7 @@
  	depends on FW_LOADER
  	---help---
  	  b43legacy is a driver for 802.11b devices from Broadcom (BCM4301 and
-@@ -25,15 +25,15 @@ config B43LEGACY
+@@ -24,15 +24,15 @@ config B43LEGACY
  config B43LEGACY_PCI_AUTOSELECT
  	bool
  	depends on B43LEGACY && SSB_PCIHOST_POSSIBLE
@@ -140,7 +140,7 @@
  # LED support
 --- a/drivers/net/wireless/broadcom/b43legacy/main.c
 +++ b/drivers/net/wireless/broadcom/b43legacy/main.c
-@@ -1906,7 +1906,7 @@ static int b43legacy_gpio_init(struct b4
+@@ -1938,7 +1938,7 @@ static int b43legacy_gpio_init(struct b4
  	if (dev->dev->id.revision >= 2)
  		mask  |= 0x0010; /* FIXME: This is redundant. */
  
@@ -149,7 +149,7 @@
  	pcidev = bus->pcicore.dev;
  #endif
  	gpiodev = bus->chipco.dev ? : pcidev;
-@@ -1925,7 +1925,7 @@ static void b43legacy_gpio_cleanup(struc
+@@ -1957,7 +1957,7 @@ static void b43legacy_gpio_cleanup(struc
  	struct ssb_bus *bus = dev->dev->bus;
  	struct ssb_device *gpiodev, *pcidev = NULL;
  
@@ -181,7 +181,7 @@
  obj-$(CPTCFG_BRCMSMAC)	+= brcmsmac.o
 --- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
 +++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
-@@ -8,7 +8,7 @@ config BRCMSMAC
+@@ -7,7 +7,7 @@ config BRCMSMAC
  	depends on m
  	depends on MAC80211
  	depends on BCMA_POSSIBLE
@@ -192,10 +192,10 @@
  	select BRCMUTIL
 --- a/Kconfig.local
 +++ b/Kconfig.local
-@@ -1240,117 +1240,6 @@ config BACKPORTED_USB_NET_CH9200
- config BACKPORTED_USB_NET_AQC111
+@@ -1192,117 +1192,6 @@ config BACKPORTED_USB_VL600
+ config BACKPORTED_USB_NET_CH9200
  	tristate
- 	default USB_NET_AQC111
+ 	default USB_NET_CH9200
 -config BACKPORTED_SSB_POSSIBLE
 -	tristate
 -	default SSB_POSSIBLE
diff -uprN a/package/kernel/mac80211/patches/build/100-backports-pci-Include-linux-pci-aspm.h.patch b/package/kernel/mac80211/patches/build/100-backports-pci-Include-linux-pci-aspm.h.patch
--- a/package/kernel/mac80211/patches/build/100-backports-pci-Include-linux-pci-aspm.h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/build/100-backports-pci-Include-linux-pci-aspm.h.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,24 @@
+From: Hauke Mehrtens <hauke@hauke-m.de>
+Date: Fri, 27 Sep 2019 23:12:08 +0200
+Subject: [PATCH] backports: pci: Include linux/pci-aspm.h
+
+In upstream commit 7ce2e76a0420 linux/pci-aspm.h was removed and the
+content included into pci.h. Add an include to have the functions
+defined in linux/pci-aspm.h available when linux/pci.h is included.
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+
+--- a/backport-include/linux/pci.h
++++ b/backport-include/linux/pci.h
+@@ -3,6 +3,10 @@
+ #include_next <linux/pci.h>
+ #include <linux/version.h>
+ 
++#if LINUX_VERSION_IS_LESS(5,4,0)
++#include <linux/pci-aspm.h>
++#endif
++
+ #ifndef module_pci_driver
+ /**
+  * module_pci_driver() - Helper macro for registering a PCI driver
diff -uprN a/package/kernel/mac80211/patches/build/101-backport-add-pci_disable_link_state-wrapper-with-ret.patch b/package/kernel/mac80211/patches/build/101-backport-add-pci_disable_link_state-wrapper-with-ret.patch
--- a/package/kernel/mac80211/patches/build/101-backport-add-pci_disable_link_state-wrapper-with-ret.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/build/101-backport-add-pci_disable_link_state-wrapper-with-ret.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,43 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Mon, 28 Oct 2019 15:20:40 +0100
+Subject: [PATCH] backport: add pci_disable_link_state wrapper with return code
+
+The signature of pci_disable_link_state was changed to indicate if the state
+was successfully disabled. Since the old version did not have this, add a
+wrapper which checks the pcie register to determine the return code
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/backport-include/linux/pci.h
++++ b/backport-include/linux/pci.h
+@@ -236,4 +236,29 @@ static inline struct pci_dev *pcie_find_
+ 	(PCI_IRQ_LEGACY | PCI_IRQ_MSI | PCI_IRQ_MSIX)
+ #endif
+ 
++#if defined(CONFIG_PCI) && LINUX_VERSION_IS_LESS(5,3,0)
++
++static inline int
++LINUX_BACKPORT(pci_disable_link_state)(struct pci_dev *pdev, int state)
++{
++	u16 aspmc;
++
++	pci_disable_link_state(pdev, state);
++
++	pcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &aspmc);
++	if ((state & PCIE_LINK_STATE_L0S) &&
++	    (aspmc & PCI_EXP_LNKCTL_ASPM_L0S))
++		return -EPERM;
++
++	if ((state & PCIE_LINK_STATE_L1) &&
++	    (aspmc & PCI_EXP_LNKCTL_ASPM_L1))
++		return -EPERM;
++
++	return 0;
++}
++
++#define pci_disable_link_state LINUX_BACKPORT(pci_disable_link_state)
++
++#endif
++
+ #endif /* _BACKPORT_LINUX_PCI_H */
diff -uprN a/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch b/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch
--- a/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/mwl/700-mwl8k-missing-pci-id-for-WNR854T.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/mwl8k.c
 +++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -5694,6 +5694,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
+@@ -5692,6 +5692,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
  MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
  
  static const struct pci_device_id mwl8k_pci_id_table[] = {
diff -uprN a/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch b/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch
--- a/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/mwl/801-libertas-configure-sysfs-links.patch	2022-04-04 20:20:32.955828000 +0800
@@ -11,7 +11,7 @@
   err_wiphy_new:
 --- a/drivers/net/wireless/marvell/libertas/main.c
 +++ b/drivers/net/wireless/marvell/libertas/main.c
-@@ -935,6 +935,7 @@ struct lbs_private *lbs_add_card(void *c
+@@ -930,6 +930,7 @@ struct lbs_private *lbs_add_card(void *c
  		goto err_adapter;
  	}
  
diff -uprN a/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch b/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch
--- a/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/mwl/940-mwl8k_init_devices_synchronously.patch	2022-04-04 20:20:32.955828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/marvell/mwl8k.c
 +++ b/drivers/net/wireless/marvell/mwl8k.c
-@@ -6279,6 +6279,8 @@ static int mwl8k_probe(struct pci_dev *p
+@@ -6277,6 +6277,8 @@ static int mwl8k_probe(struct pci_dev *p
  
  	priv->running_bsses = 0;
  
@@ -9,7 +9,7 @@
  	return rc;
  
  err_stop_firmware:
-@@ -6312,8 +6314,6 @@ static void mwl8k_remove(struct pci_dev
+@@ -6310,8 +6312,6 @@ static void mwl8k_remove(struct pci_dev
  		return;
  	priv = hw->priv;
  
diff -uprN a/package/kernel/mac80211/patches/rt2x00/001-rt2x00-use-simple_read_from_buffer.patch b/package/kernel/mac80211/patches/rt2x00/001-rt2x00-use-simple_read_from_buffer.patch
--- a/package/kernel/mac80211/patches/rt2x00/001-rt2x00-use-simple_read_from_buffer.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/001-rt2x00-use-simple_read_from_buffer.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,59 @@
+From f483039cf51acf30494cd754194562c22cf98764 Mon Sep 17 00:00:00 2001
+From: Dan Carpenter <dan.carpenter@oracle.com>
+Date: Wed, 22 Aug 2018 13:41:26 +0300
+Subject: [PATCH 01/28] rt2x00: use simple_read_from_buffer()
+
+The problem with this copy_to_user() calls is that they don't ensure
+that "size" is less than the "length" which the user provided.
+
+Obviously, this is debugfs and "size" is normally going to be very small
+so it probably doesn't matter, but this is the correct thing to do.
+
+Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2x00debug.c   | 18 +++---------------
+ 1 file changed, 3 insertions(+), 15 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
+@@ -464,11 +464,7 @@ static ssize_t rt2x00debug_read_##__name
+ 								\
+ 	size = sprintf(line, __format, value);			\
+ 								\
+-	if (copy_to_user(buf, line, size))			\
+-		return -EFAULT;					\
+-								\
+-	*offset += size;					\
+-	return size;						\
++	return simple_read_from_buffer(buf, length, offset, line, size); \
+ }
+ 
+ #define RT2X00DEBUGFS_OPS_WRITE(__name, __type)			\
+@@ -545,11 +541,7 @@ static ssize_t rt2x00debug_read_dev_flag
+ 
+ 	size = sprintf(line, "0x%.8x\n", (unsigned int)intf->rt2x00dev->flags);
+ 
+-	if (copy_to_user(buf, line, size))
+-		return -EFAULT;
+-
+-	*offset += size;
+-	return size;
++	return simple_read_from_buffer(buf, length, offset, line, size);
+ }
+ 
+ static const struct file_operations rt2x00debug_fop_dev_flags = {
+@@ -574,11 +566,7 @@ static ssize_t rt2x00debug_read_cap_flag
+ 
+ 	size = sprintf(line, "0x%.8x\n", (unsigned int)intf->rt2x00dev->cap_flags);
+ 
+-	if (copy_to_user(buf, line, size))
+-		return -EFAULT;
+-
+-	*offset += size;
+-	return size;
++	return simple_read_from_buffer(buf, length, offset, line, size);
+ }
+ 
+ static const struct file_operations rt2x00debug_fop_cap_flags = {
diff -uprN a/package/kernel/mac80211/patches/rt2x00/002-rt2800-move-usb-specific-txdone-txstatus-routines-to.patch b/package/kernel/mac80211/patches/rt2x00/002-rt2800-move-usb-specific-txdone-txstatus-routines-to.patch
--- a/package/kernel/mac80211/patches/rt2x00/002-rt2800-move-usb-specific-txdone-txstatus-routines-to.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/002-rt2800-move-usb-specific-txdone-txstatus-routines-to.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,357 @@
+From 5c656c71b1bf5611ce8262bab338104e04d10b8d Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 26 Sep 2018 12:24:53 +0200
+Subject: [PATCH 02/28] rt2800: move usb specific txdone/txstatus routines to
+ rt2800lib
+
+In order to reuse usb txdone/txstatus routines for mmio, move them
+to common rt2800lib.c file.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 138 +++++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |   3 +
+ .../net/wireless/ralink/rt2x00/rt2800usb.c    | 143 +-----------------
+ 3 files changed, 145 insertions(+), 139 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -957,6 +957,47 @@ static void rt2800_rate_from_status(stru
+ 	skbdesc->tx_rate_flags = flags;
+ }
+ 
++static bool rt2800_txdone_entry_check(struct queue_entry *entry, u32 reg)
++{
++	__le32 *txwi;
++	u32 word;
++	int wcid, ack, pid;
++	int tx_wcid, tx_ack, tx_pid, is_agg;
++
++	/*
++	 * This frames has returned with an IO error,
++	 * so the status report is not intended for this
++	 * frame.
++	 */
++	if (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))
++		return false;
++
++	wcid	= rt2x00_get_field32(reg, TX_STA_FIFO_WCID);
++	ack	= rt2x00_get_field32(reg, TX_STA_FIFO_TX_ACK_REQUIRED);
++	pid	= rt2x00_get_field32(reg, TX_STA_FIFO_PID_TYPE);
++	is_agg	= rt2x00_get_field32(reg, TX_STA_FIFO_TX_AGGRE);
++
++	/*
++	 * Validate if this TX status report is intended for
++	 * this entry by comparing the WCID/ACK/PID fields.
++	 */
++	txwi = rt2800_drv_get_txwi(entry);
++
++	word = rt2x00_desc_read(txwi, 1);
++	tx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);
++	tx_ack  = rt2x00_get_field32(word, TXWI_W1_ACK);
++	tx_pid  = rt2x00_get_field32(word, TXWI_W1_PACKETID);
++
++	if (wcid != tx_wcid || ack != tx_ack || (!is_agg && pid != tx_pid)) {
++		rt2x00_dbg(entry->queue->rt2x00dev,
++			   "TX status report missed for queue %d entry %d\n",
++			   entry->queue->qid, entry->entry_idx);
++		return false;
++	}
++
++	return true;
++}
++
+ void rt2800_txdone_entry(struct queue_entry *entry, u32 status, __le32 *txwi,
+ 			 bool match)
+ {
+@@ -1059,6 +1100,103 @@ void rt2800_txdone_entry(struct queue_en
+ }
+ EXPORT_SYMBOL_GPL(rt2800_txdone_entry);
+ 
++void rt2800_txdone(struct rt2x00_dev *rt2x00dev)
++{
++	struct data_queue *queue;
++	struct queue_entry *entry;
++	u32 reg;
++	u8 qid;
++	bool match;
++
++	while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
++		/*
++		 * TX_STA_FIFO_PID_QUEUE is a 2-bit field, thus qid is
++		 * guaranteed to be one of the TX QIDs .
++		 */
++		qid = rt2x00_get_field32(reg, TX_STA_FIFO_PID_QUEUE);
++		queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
++
++		if (unlikely(rt2x00queue_empty(queue))) {
++			rt2x00_dbg(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
++				   qid);
++			break;
++		}
++
++		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
++
++		if (unlikely(test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||
++			     !test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))) {
++			rt2x00_warn(rt2x00dev, "Data pending for entry %u in queue %u\n",
++				    entry->entry_idx, qid);
++			break;
++		}
++
++		match = rt2800_txdone_entry_check(entry, reg);
++		rt2800_txdone_entry(entry, reg, rt2800_drv_get_txwi(entry), match);
++	}
++}
++EXPORT_SYMBOL_GPL(rt2800_txdone);
++
++static inline bool rt2800_entry_txstatus_timeout(struct queue_entry *entry)
++{
++	bool tout;
++
++	if (!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
++		return false;
++
++	tout = time_after(jiffies, entry->last_action + msecs_to_jiffies(500));
++	if (unlikely(tout))
++		rt2x00_dbg(entry->queue->rt2x00dev,
++			   "TX status timeout for entry %d in queue %d\n",
++			   entry->entry_idx, entry->queue->qid);
++	return tout;
++
++}
++
++bool rt2800_txstatus_timeout(struct rt2x00_dev *rt2x00dev)
++{
++	struct data_queue *queue;
++	struct queue_entry *entry;
++
++	tx_queue_for_each(rt2x00dev, queue) {
++		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
++		if (rt2800_entry_txstatus_timeout(entry))
++			return true;
++	}
++	return false;
++}
++EXPORT_SYMBOL_GPL(rt2800_txstatus_timeout);
++
++void rt2800_txdone_nostatus(struct rt2x00_dev *rt2x00dev)
++{
++	struct data_queue *queue;
++	struct queue_entry *entry;
++
++	/*
++	 * Process any trailing TX status reports for IO failures,
++	 * we loop until we find the first non-IO error entry. This
++	 * can either be a frame which is free, is being uploaded,
++	 * or has completed the upload but didn't have an entry
++	 * in the TX_STAT_FIFO register yet.
++	 */
++	tx_queue_for_each(rt2x00dev, queue) {
++		while (!rt2x00queue_empty(queue)) {
++			entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
++
++			if (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||
++			    !test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
++				break;
++
++			if (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags) ||
++			    rt2800_entry_txstatus_timeout(entry))
++				rt2x00lib_txdone_noinfo(entry, TXDONE_FAILURE);
++			else
++				break;
++		}
++	}
++}
++EXPORT_SYMBOL_GPL(rt2800_txdone_nostatus);
++
+ static unsigned int rt2800_hw_beacon_base(struct rt2x00_dev *rt2x00dev,
+ 					  unsigned int index)
+ {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -195,6 +195,9 @@ void rt2800_process_rxwi(struct queue_en
+ 
+ void rt2800_txdone_entry(struct queue_entry *entry, u32 status, __le32 *txwi,
+ 			 bool match);
++void rt2800_txdone(struct rt2x00_dev *rt2x00dev);
++void rt2800_txdone_nostatus(struct rt2x00_dev *rt2x00dev);
++bool rt2800_txstatus_timeout(struct rt2x00_dev *rt2x00dev);
+ 
+ void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc);
+ void rt2800_clear_beacon(struct queue_entry *entry);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -116,35 +116,6 @@ static bool rt2800usb_txstatus_pending(s
+ 	return false;
+ }
+ 
+-static inline bool rt2800usb_entry_txstatus_timeout(struct queue_entry *entry)
+-{
+-	bool tout;
+-
+-	if (!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
+-		return false;
+-
+-	tout = time_after(jiffies, entry->last_action + msecs_to_jiffies(500));
+-	if (unlikely(tout))
+-		rt2x00_dbg(entry->queue->rt2x00dev,
+-			   "TX status timeout for entry %d in queue %d\n",
+-			   entry->entry_idx, entry->queue->qid);
+-	return tout;
+-
+-}
+-
+-static bool rt2800usb_txstatus_timeout(struct rt2x00_dev *rt2x00dev)
+-{
+-	struct data_queue *queue;
+-	struct queue_entry *entry;
+-
+-	tx_queue_for_each(rt2x00dev, queue) {
+-		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+-		if (rt2800usb_entry_txstatus_timeout(entry))
+-			return true;
+-	}
+-	return false;
+-}
+-
+ #define TXSTATUS_READ_INTERVAL 1000000
+ 
+ static bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,
+@@ -171,7 +142,7 @@ static bool rt2800usb_tx_sta_fifo_read_c
+ 	}
+ 
+ 	/* Check if there is any entry that timedout waiting on TX status */
+-	if (rt2800usb_txstatus_timeout(rt2x00dev))
++	if (rt2800_txstatus_timeout(rt2x00dev))
+ 		queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
+ 
+ 	if (rt2800usb_txstatus_pending(rt2x00dev)) {
+@@ -501,123 +472,17 @@ static int rt2800usb_get_tx_data_len(str
+ /*
+  * TX control handlers
+  */
+-static bool rt2800usb_txdone_entry_check(struct queue_entry *entry, u32 reg)
+-{
+-	__le32 *txwi;
+-	u32 word;
+-	int wcid, ack, pid;
+-	int tx_wcid, tx_ack, tx_pid, is_agg;
+-
+-	/*
+-	 * This frames has returned with an IO error,
+-	 * so the status report is not intended for this
+-	 * frame.
+-	 */
+-	if (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags))
+-		return false;
+-
+-	wcid	= rt2x00_get_field32(reg, TX_STA_FIFO_WCID);
+-	ack	= rt2x00_get_field32(reg, TX_STA_FIFO_TX_ACK_REQUIRED);
+-	pid	= rt2x00_get_field32(reg, TX_STA_FIFO_PID_TYPE);
+-	is_agg	= rt2x00_get_field32(reg, TX_STA_FIFO_TX_AGGRE);
+-
+-	/*
+-	 * Validate if this TX status report is intended for
+-	 * this entry by comparing the WCID/ACK/PID fields.
+-	 */
+-	txwi = rt2800usb_get_txwi(entry);
+-
+-	word = rt2x00_desc_read(txwi, 1);
+-	tx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);
+-	tx_ack  = rt2x00_get_field32(word, TXWI_W1_ACK);
+-	tx_pid  = rt2x00_get_field32(word, TXWI_W1_PACKETID);
+-
+-	if (wcid != tx_wcid || ack != tx_ack || (!is_agg && pid != tx_pid)) {
+-		rt2x00_dbg(entry->queue->rt2x00dev,
+-			   "TX status report missed for queue %d entry %d\n",
+-			   entry->queue->qid, entry->entry_idx);
+-		return false;
+-	}
+-
+-	return true;
+-}
+-
+-static void rt2800usb_txdone(struct rt2x00_dev *rt2x00dev)
+-{
+-	struct data_queue *queue;
+-	struct queue_entry *entry;
+-	u32 reg;
+-	u8 qid;
+-	bool match;
+-
+-	while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
+-		/*
+-		 * TX_STA_FIFO_PID_QUEUE is a 2-bit field, thus qid is
+-		 * guaranteed to be one of the TX QIDs .
+-		 */
+-		qid = rt2x00_get_field32(reg, TX_STA_FIFO_PID_QUEUE);
+-		queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
+-
+-		if (unlikely(rt2x00queue_empty(queue))) {
+-			rt2x00_dbg(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
+-				   qid);
+-			break;
+-		}
+-
+-		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+-
+-		if (unlikely(test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||
+-			     !test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))) {
+-			rt2x00_warn(rt2x00dev, "Data pending for entry %u in queue %u\n",
+-				    entry->entry_idx, qid);
+-			break;
+-		}
+-
+-		match = rt2800usb_txdone_entry_check(entry, reg);
+-		rt2800_txdone_entry(entry, reg, rt2800usb_get_txwi(entry), match);
+-	}
+-}
+-
+-static void rt2800usb_txdone_nostatus(struct rt2x00_dev *rt2x00dev)
+-{
+-	struct data_queue *queue;
+-	struct queue_entry *entry;
+-
+-	/*
+-	 * Process any trailing TX status reports for IO failures,
+-	 * we loop until we find the first non-IO error entry. This
+-	 * can either be a frame which is free, is being uploaded,
+-	 * or has completed the upload but didn't have an entry
+-	 * in the TX_STAT_FIFO register yet.
+-	 */
+-	tx_queue_for_each(rt2x00dev, queue) {
+-		while (!rt2x00queue_empty(queue)) {
+-			entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+-
+-			if (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||
+-			    !test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
+-				break;
+-
+-			if (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags) ||
+-			    rt2800usb_entry_txstatus_timeout(entry))
+-				rt2x00lib_txdone_noinfo(entry, TXDONE_FAILURE);
+-			else
+-				break;
+-		}
+-	}
+-}
+-
+ static void rt2800usb_work_txdone(struct work_struct *work)
+ {
+ 	struct rt2x00_dev *rt2x00dev =
+ 	    container_of(work, struct rt2x00_dev, txdone_work);
+ 
+ 	while (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||
+-	       rt2800usb_txstatus_timeout(rt2x00dev)) {
++	       rt2800_txstatus_timeout(rt2x00dev)) {
+ 
+-		rt2800usb_txdone(rt2x00dev);
++		rt2800_txdone(rt2x00dev);
+ 
+-		rt2800usb_txdone_nostatus(rt2x00dev);
++		rt2800_txdone_nostatus(rt2x00dev);
+ 
+ 		/*
+ 		 * The hw may delay sending the packet after DMA complete
diff -uprN a/package/kernel/mac80211/patches/rt2x00/003-rt2800mmio-use-txdone-txstatus-routines-from-lib.patch b/package/kernel/mac80211/patches/rt2x00/003-rt2800mmio-use-txdone-txstatus-routines-from-lib.patch
--- a/package/kernel/mac80211/patches/rt2x00/003-rt2800mmio-use-txdone-txstatus-routines-from-lib.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/003-rt2800mmio-use-txdone-txstatus-routines-from-lib.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,244 @@
+From 0b0d556e0ebb6c966bc993e21a22a156812d8fdf Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 26 Sep 2018 12:24:54 +0200
+Subject: [PATCH 03/28] rt2800mmio: use txdone/txstatus routines from lib
+
+Use usb txdone/txstatus routines (now in rt2800libc) for mmio devices.
+
+Note this also change how we handle INT_SOURCE_CSR_TX_FIFO_STATUS
+interrupt. Now it is disabled since IRQ routine till end of the txstatus
+tasklet (the same behaviour like others interrupts). Reason to do not
+disable this interrupt was not to miss any tx status from 16 entries
+FIFO register. Now, since we check for tx status timeout, we can
+allow to miss some tx statuses. However this will be improved in further
+patch where I also implement read status FIFO register in the tasklet.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800mmio.c   | 180 +-----------------
+ .../net/wireless/ralink/rt2x00/rt2x00queue.c  |   1 +
+ 2 files changed, 9 insertions(+), 172 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -175,161 +175,6 @@ static void rt2800mmio_wakeup(struct rt2
+ 	rt2800_config(rt2x00dev, &libconf, IEEE80211_CONF_CHANGE_PS);
+ }
+ 
+-static bool rt2800mmio_txdone_entry_check(struct queue_entry *entry, u32 status)
+-{
+-	__le32 *txwi;
+-	u32 word;
+-	int wcid, tx_wcid;
+-
+-	wcid = rt2x00_get_field32(status, TX_STA_FIFO_WCID);
+-
+-	txwi = rt2800_drv_get_txwi(entry);
+-	word = rt2x00_desc_read(txwi, 1);
+-	tx_wcid = rt2x00_get_field32(word, TXWI_W1_WIRELESS_CLI_ID);
+-
+-	return (tx_wcid == wcid);
+-}
+-
+-static bool rt2800mmio_txdone_find_entry(struct queue_entry *entry, void *data)
+-{
+-	u32 status = *(u32 *)data;
+-
+-	/*
+-	 * rt2800pci hardware might reorder frames when exchanging traffic
+-	 * with multiple BA enabled STAs.
+-	 *
+-	 * For example, a tx queue
+-	 *    [ STA1 | STA2 | STA1 | STA2 ]
+-	 * can result in tx status reports
+-	 *    [ STA1 | STA1 | STA2 | STA2 ]
+-	 * when the hw decides to aggregate the frames for STA1 into one AMPDU.
+-	 *
+-	 * To mitigate this effect, associate the tx status to the first frame
+-	 * in the tx queue with a matching wcid.
+-	 */
+-	if (rt2800mmio_txdone_entry_check(entry, status) &&
+-	    !test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+-		/*
+-		 * Got a matching frame, associate the tx status with
+-		 * the frame
+-		 */
+-		entry->status = status;
+-		set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
+-		return true;
+-	}
+-
+-	/* Check the next frame */
+-	return false;
+-}
+-
+-static bool rt2800mmio_txdone_match_first(struct queue_entry *entry, void *data)
+-{
+-	u32 status = *(u32 *)data;
+-
+-	/*
+-	 * Find the first frame without tx status and assign this status to it
+-	 * regardless if it matches or not.
+-	 */
+-	if (!test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+-		/*
+-		 * Got a matching frame, associate the tx status with
+-		 * the frame
+-		 */
+-		entry->status = status;
+-		set_bit(ENTRY_DATA_STATUS_SET, &entry->flags);
+-		return true;
+-	}
+-
+-	/* Check the next frame */
+-	return false;
+-}
+-static bool rt2800mmio_txdone_release_entries(struct queue_entry *entry,
+-					      void *data)
+-{
+-	if (test_bit(ENTRY_DATA_STATUS_SET, &entry->flags)) {
+-		rt2800_txdone_entry(entry, entry->status,
+-				    rt2800mmio_get_txwi(entry), true);
+-		return false;
+-	}
+-
+-	/* No more frames to release */
+-	return true;
+-}
+-
+-static bool rt2800mmio_txdone(struct rt2x00_dev *rt2x00dev)
+-{
+-	struct data_queue *queue;
+-	u32 status;
+-	u8 qid;
+-	int max_tx_done = 16;
+-
+-	while (kfifo_get(&rt2x00dev->txstatus_fifo, &status)) {
+-		qid = rt2x00_get_field32(status, TX_STA_FIFO_PID_QUEUE);
+-		if (unlikely(qid >= QID_RX)) {
+-			/*
+-			 * Unknown queue, this shouldn't happen. Just drop
+-			 * this tx status.
+-			 */
+-			rt2x00_warn(rt2x00dev, "Got TX status report with unexpected pid %u, dropping\n",
+-				    qid);
+-			break;
+-		}
+-
+-		queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
+-		if (unlikely(queue == NULL)) {
+-			/*
+-			 * The queue is NULL, this shouldn't happen. Stop
+-			 * processing here and drop the tx status
+-			 */
+-			rt2x00_warn(rt2x00dev, "Got TX status for an unavailable queue %u, dropping\n",
+-				    qid);
+-			break;
+-		}
+-
+-		if (unlikely(rt2x00queue_empty(queue))) {
+-			/*
+-			 * The queue is empty. Stop processing here
+-			 * and drop the tx status.
+-			 */
+-			rt2x00_warn(rt2x00dev, "Got TX status for an empty queue %u, dropping\n",
+-				    qid);
+-			break;
+-		}
+-
+-		/*
+-		 * Let's associate this tx status with the first
+-		 * matching frame.
+-		 */
+-		if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+-						Q_INDEX, &status,
+-						rt2800mmio_txdone_find_entry)) {
+-			/*
+-			 * We cannot match the tx status to any frame, so just
+-			 * use the first one.
+-			 */
+-			if (!rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+-							Q_INDEX, &status,
+-							rt2800mmio_txdone_match_first)) {
+-				rt2x00_warn(rt2x00dev, "No frame found for TX status on queue %u, dropping\n",
+-					    qid);
+-				break;
+-			}
+-		}
+-
+-		/*
+-		 * Release all frames with a valid tx status.
+-		 */
+-		rt2x00queue_for_each_entry(queue, Q_INDEX_DONE,
+-					   Q_INDEX, NULL,
+-					   rt2800mmio_txdone_release_entries);
+-
+-		if (--max_tx_done == 0)
+-			break;
+-	}
+-
+-	return !max_tx_done;
+-}
+-
+ static inline void rt2800mmio_enable_interrupt(struct rt2x00_dev *rt2x00dev,
+ 					       struct rt2x00_field32 irq_field)
+ {
+@@ -349,14 +194,14 @@ static inline void rt2800mmio_enable_int
+ void rt2800mmio_txstatus_tasklet(unsigned long data)
+ {
+ 	struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+-	if (rt2800mmio_txdone(rt2x00dev))
+-		tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+ 
+-	/*
+-	 * No need to enable the tx status interrupt here as we always
+-	 * leave it enabled to minimize the possibility of a tx status
+-	 * register overflow. See comment in interrupt handler.
+-	 */
++	rt2800_txdone(rt2x00dev);
++
++	rt2800_txdone_nostatus(rt2x00dev);
++
++	if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
++		rt2800mmio_enable_interrupt(rt2x00dev,
++					    INT_SOURCE_CSR_TX_FIFO_STATUS);
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_txstatus_tasklet);
+ 
+@@ -440,10 +285,6 @@ static void rt2800mmio_txstatus_interrup
+ 	 * because we can schedule the tasklet multiple times (when the
+ 	 * interrupt fires again during tx status processing).
+ 	 *
+-	 * Furthermore we don't disable the TX_FIFO_STATUS
+-	 * interrupt here but leave it enabled so that the TX_STA_FIFO
+-	 * can also be read while the tx status tasklet gets executed.
+-	 *
+ 	 * Since we have only one producer and one consumer we don't
+ 	 * need to lock the kfifo.
+ 	 */
+@@ -485,13 +326,8 @@ irqreturn_t rt2800mmio_interrupt(int irq
+ 	 */
+ 	mask = ~reg;
+ 
+-	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
++	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS))
+ 		rt2800mmio_txstatus_interrupt(rt2x00dev);
+-		/*
+-		 * Never disable the TX_FIFO_STATUS interrupt.
+-		 */
+-		rt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);
+-	}
+ 
+ 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))
+ 		tasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
+@@ -113,6 +113,7 @@ int rt2x00queue_map_txskb(struct queue_e
+ 		return -ENOMEM;
+ 
+ 	skbdesc->flags |= SKBDESC_DMA_MAPPED_TX;
++	rt2x00lib_dmadone(entry);
+ 	return 0;
+ }
+ EXPORT_SYMBOL_GPL(rt2x00queue_map_txskb);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/004-rt2x00-do-not-check-for-txstatus-timeout-every-time-.patch b/package/kernel/mac80211/patches/rt2x00/004-rt2x00-do-not-check-for-txstatus-timeout-every-time-.patch
--- a/package/kernel/mac80211/patches/rt2x00/004-rt2x00-do-not-check-for-txstatus-timeout-every-time-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/004-rt2x00-do-not-check-for-txstatus-timeout-every-time-.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,72 @@
+From 5022efb50f625d11fdf18b1fee0f64ebb1863664 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 26 Sep 2018 12:24:55 +0200
+Subject: [PATCH 04/28] rt2x00: do not check for txstatus timeout every time on
+ tasklet
+
+Do not check for tx status timeout everytime we perform txstatus tasklet.
+Perform check once per half a second.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c   | 7 +++++++
+ drivers/net/wireless/ralink/rt2x00/rt2800mmio.c  | 3 ++-
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h      | 2 ++
+ drivers/net/wireless/ralink/rt2x00/rt2x00queue.c | 1 +
+ 4 files changed, 12 insertions(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1158,11 +1158,18 @@ bool rt2800_txstatus_timeout(struct rt2x
+ 	struct data_queue *queue;
+ 	struct queue_entry *entry;
+ 
++	if (time_before(jiffies,
++			rt2x00dev->last_nostatus_check + msecs_to_jiffies(500)))
++		return false;
++
++	rt2x00dev->last_nostatus_check = jiffies;
++
+ 	tx_queue_for_each(rt2x00dev, queue) {
+ 		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+ 		if (rt2800_entry_txstatus_timeout(entry))
+ 			return true;
+ 	}
++
+ 	return false;
+ }
+ EXPORT_SYMBOL_GPL(rt2800_txstatus_timeout);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -197,7 +197,8 @@ void rt2800mmio_txstatus_tasklet(unsigne
+ 
+ 	rt2800_txdone(rt2x00dev);
+ 
+-	rt2800_txdone_nostatus(rt2x00dev);
++	if (rt2800_txstatus_timeout(rt2x00dev))
++		rt2800_txdone_nostatus(rt2x00dev);
+ 
+ 	if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+ 		rt2800mmio_enable_interrupt(rt2x00dev,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -979,6 +979,8 @@ struct rt2x00_dev {
+ 	 */
+ 	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
+ 
++	unsigned long last_nostatus_check;
++
+ 	/*
+ 	 * Timer to ensure tx status reports are read (rt2800usb).
+ 	 */
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
+@@ -1042,6 +1042,7 @@ void rt2x00queue_start_queues(struct rt2
+ 	 */
+ 	tx_queue_for_each(rt2x00dev, queue)
+ 		rt2x00queue_start_queue(queue);
++	rt2x00dev->last_nostatus_check = jiffies;
+ 
+ 	rt2x00queue_start_queue(rt2x00dev->rx);
+ }
diff -uprN a/package/kernel/mac80211/patches/rt2x00/005-rt2x00-use-different-txstatus-timeouts-when-flushing.patch b/package/kernel/mac80211/patches/rt2x00/005-rt2x00-use-different-txstatus-timeouts-when-flushing.patch
--- a/package/kernel/mac80211/patches/rt2x00/005-rt2x00-use-different-txstatus-timeouts-when-flushing.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/005-rt2x00-use-different-txstatus-timeouts-when-flushing.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,112 @@
+From adf26a356f132e35093585521ea3e36cd185af83 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 26 Sep 2018 12:24:56 +0200
+Subject: [PATCH 05/28] rt2x00: use different txstatus timeouts when flushing
+
+Use different tx status timeouts for normal operation and when flushing.
+This increase timeout to 2s for normal operation as when there are bad
+radio conditions and frames are reposted many times device can not provide
+the status for quite long. With new timeout we can still get valid status
+on such bad conditions.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 31 +++++++++++++------
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h   |  1 +
+ .../net/wireless/ralink/rt2x00/rt2x00mac.c    |  4 +++
+ 3 files changed, 26 insertions(+), 10 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1137,36 +1137,47 @@ void rt2800_txdone(struct rt2x00_dev *rt
+ }
+ EXPORT_SYMBOL_GPL(rt2800_txdone);
+ 
+-static inline bool rt2800_entry_txstatus_timeout(struct queue_entry *entry)
++static inline bool rt2800_entry_txstatus_timeout(struct rt2x00_dev *rt2x00dev,
++						 struct queue_entry *entry)
+ {
+-	bool tout;
++	bool ret;
++	unsigned long tout;
+ 
+ 	if (!test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
+ 		return false;
+ 
+-	tout = time_after(jiffies, entry->last_action + msecs_to_jiffies(500));
+-	if (unlikely(tout))
++	if (test_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags))
++		tout = msecs_to_jiffies(100);
++	else
++		tout = msecs_to_jiffies(2000);
++
++	ret = time_after(jiffies, entry->last_action + tout);
++	if (unlikely(ret))
+ 		rt2x00_dbg(entry->queue->rt2x00dev,
+ 			   "TX status timeout for entry %d in queue %d\n",
+ 			   entry->entry_idx, entry->queue->qid);
+-	return tout;
+-
++	return ret;
+ }
+ 
+ bool rt2800_txstatus_timeout(struct rt2x00_dev *rt2x00dev)
+ {
+ 	struct data_queue *queue;
+ 	struct queue_entry *entry;
++	unsigned long tout;
++
++	if (test_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags))
++		tout = msecs_to_jiffies(50);
++	else
++		tout = msecs_to_jiffies(1000);
+ 
+-	if (time_before(jiffies,
+-			rt2x00dev->last_nostatus_check + msecs_to_jiffies(500)))
++	if (time_before(jiffies, rt2x00dev->last_nostatus_check + tout))
+ 		return false;
+ 
+ 	rt2x00dev->last_nostatus_check = jiffies;
+ 
+ 	tx_queue_for_each(rt2x00dev, queue) {
+ 		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+-		if (rt2800_entry_txstatus_timeout(entry))
++		if (rt2800_entry_txstatus_timeout(rt2x00dev, entry))
+ 			return true;
+ 	}
+ 
+@@ -1195,7 +1206,7 @@ void rt2800_txdone_nostatus(struct rt2x0
+ 				break;
+ 
+ 			if (test_bit(ENTRY_DATA_IO_FAILED, &entry->flags) ||
+-			    rt2800_entry_txstatus_timeout(entry))
++			    rt2800_entry_txstatus_timeout(rt2x00dev, entry))
+ 				rt2x00lib_txdone_noinfo(entry, TXDONE_FAILURE);
+ 			else
+ 				break;
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -665,6 +665,7 @@ enum rt2x00_state_flags {
+ 	DEVICE_STATE_STARTED,
+ 	DEVICE_STATE_ENABLED_RADIO,
+ 	DEVICE_STATE_SCANNING,
++	DEVICE_STATE_FLUSHING,
+ 
+ 	/*
+ 	 * Driver configuration
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00mac.c
+@@ -710,8 +710,12 @@ void rt2x00mac_flush(struct ieee80211_hw
+ 	if (!test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
+ 		return;
+ 
++	set_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags);
++
+ 	tx_queue_for_each(rt2x00dev, queue)
+ 		rt2x00queue_flush_queue(queue, drop);
++
++	clear_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags);
+ }
+ EXPORT_SYMBOL_GPL(rt2x00mac_flush);
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/006-rt2800-flush-and-txstatus-rework-for-rt2800mmio.patch b/package/kernel/mac80211/patches/rt2x00/006-rt2800-flush-and-txstatus-rework-for-rt2800mmio.patch
--- a/package/kernel/mac80211/patches/rt2x00/006-rt2800-flush-and-txstatus-rework-for-rt2800mmio.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/006-rt2800-flush-and-txstatus-rework-for-rt2800mmio.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,238 @@
+From 0240564430c0697d8fde3743d70346a922466b36 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 26 Sep 2018 12:24:57 +0200
+Subject: [PATCH 06/28] rt2800: flush and txstatus rework for rt2800mmio
+
+Implement custom rt2800mmio flush routine and change txstatus
+routine to read TX_STA_FIFO also in the tasklet.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    |  14 +--
+ .../net/wireless/ralink/rt2x00/rt2800mmio.c   | 118 +++++++++++++-----
+ .../net/wireless/ralink/rt2x00/rt2800mmio.h   |   1 +
+ .../net/wireless/ralink/rt2x00/rt2800pci.c    |   2 +-
+ 4 files changed, 97 insertions(+), 38 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1147,7 +1147,7 @@ static inline bool rt2800_entry_txstatus
+ 		return false;
+ 
+ 	if (test_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags))
+-		tout = msecs_to_jiffies(100);
++		tout = msecs_to_jiffies(50);
+ 	else
+ 		tout = msecs_to_jiffies(2000);
+ 
+@@ -1163,15 +1163,13 @@ bool rt2800_txstatus_timeout(struct rt2x
+ {
+ 	struct data_queue *queue;
+ 	struct queue_entry *entry;
+-	unsigned long tout;
+ 
+-	if (test_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags))
+-		tout = msecs_to_jiffies(50);
+-	else
+-		tout = msecs_to_jiffies(1000);
++	if (!test_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags)) {
++		unsigned long tout = msecs_to_jiffies(1000);
+ 
+-	if (time_before(jiffies, rt2x00dev->last_nostatus_check + tout))
+-		return false;
++		if (time_before(jiffies, rt2x00dev->last_nostatus_check + tout))
++			return false;
++	}
+ 
+ 	rt2x00dev->last_nostatus_check = jiffies;
+ 
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -191,21 +191,6 @@ static inline void rt2800mmio_enable_int
+ 	spin_unlock_irq(&rt2x00dev->irqmask_lock);
+ }
+ 
+-void rt2800mmio_txstatus_tasklet(unsigned long data)
+-{
+-	struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+-
+-	rt2800_txdone(rt2x00dev);
+-
+-	if (rt2800_txstatus_timeout(rt2x00dev))
+-		rt2800_txdone_nostatus(rt2x00dev);
+-
+-	if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-		rt2800mmio_enable_interrupt(rt2x00dev,
+-					    INT_SOURCE_CSR_TX_FIFO_STATUS);
+-}
+-EXPORT_SYMBOL_GPL(rt2800mmio_txstatus_tasklet);
+-
+ void rt2800mmio_pretbtt_tasklet(unsigned long data)
+ {
+ 	struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+@@ -270,12 +255,26 @@ void rt2800mmio_autowake_tasklet(unsigne
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_autowake_tasklet);
+ 
+-static void rt2800mmio_txstatus_interrupt(struct rt2x00_dev *rt2x00dev)
++static void rt2800mmio_txdone(struct rt2x00_dev *rt2x00dev)
++{
++	bool timeout = false;
++
++	while (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||
++	       (timeout = rt2800_txstatus_timeout(rt2x00dev))) {
++
++		rt2800_txdone(rt2x00dev);
++
++		if (timeout)
++			rt2800_txdone_nostatus(rt2x00dev);
++	}
++}
++
++static bool rt2800mmio_fetch_txstatus(struct rt2x00_dev *rt2x00dev)
+ {
+ 	u32 status;
+-	int i;
++	bool more = false;
+ 
+-	/*
++	/* FIXEME: rewrite this comment
+ 	 * The TX_FIFO_STATUS interrupt needs special care. We should
+ 	 * read TX_STA_FIFO but we should do it immediately as otherwise
+ 	 * the register can overflow and we would lose status reports.
+@@ -286,25 +285,37 @@ static void rt2800mmio_txstatus_interrup
+ 	 * because we can schedule the tasklet multiple times (when the
+ 	 * interrupt fires again during tx status processing).
+ 	 *
+-	 * Since we have only one producer and one consumer we don't
++	 * txstatus tasklet is called with INT_SOURCE_CSR_TX_FIFO_STATUS
++	 * disabled so have only one producer and one consumer - we don't
+ 	 * need to lock the kfifo.
+ 	 */
+-	for (i = 0; i < rt2x00dev->tx->limit; i++) {
++	while (!kfifo_is_full(&rt2x00dev->txstatus_fifo)) {
+ 		status = rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO);
+-
+ 		if (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))
+ 			break;
+ 
+-		if (!kfifo_put(&rt2x00dev->txstatus_fifo, status)) {
+-			rt2x00_warn(rt2x00dev, "TX status FIFO overrun, drop tx status report\n");
+-			break;
+-		}
++		kfifo_put(&rt2x00dev->txstatus_fifo, status);
++		more = true;
+ 	}
+ 
+-	/* Schedule the tasklet for processing the tx status. */
+-	tasklet_schedule(&rt2x00dev->txstatus_tasklet);
++	return more;
+ }
+ 
++void rt2800mmio_txstatus_tasklet(unsigned long data)
++{
++	struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
++
++	do {
++		rt2800mmio_txdone(rt2x00dev);
++
++	} while (rt2800mmio_fetch_txstatus(rt2x00dev));
++
++	if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
++		rt2800mmio_enable_interrupt(rt2x00dev,
++					    INT_SOURCE_CSR_TX_FIFO_STATUS);
++}
++EXPORT_SYMBOL_GPL(rt2800mmio_txstatus_tasklet);
++
+ irqreturn_t rt2800mmio_interrupt(int irq, void *dev_instance)
+ {
+ 	struct rt2x00_dev *rt2x00dev = dev_instance;
+@@ -327,8 +338,10 @@ irqreturn_t rt2800mmio_interrupt(int irq
+ 	 */
+ 	mask = ~reg;
+ 
+-	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS))
+-		rt2800mmio_txstatus_interrupt(rt2x00dev);
++	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
++		rt2800mmio_fetch_txstatus(rt2x00dev);
++		tasklet_schedule(&rt2x00dev->txstatus_tasklet);
++	}
+ 
+ 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))
+ 		tasklet_hi_schedule(&rt2x00dev->pretbtt_tasklet);
+@@ -453,6 +466,53 @@ void rt2800mmio_kick_queue(struct data_q
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_kick_queue);
+ 
++void rt2800mmio_flush_queue(struct data_queue *queue, bool drop)
++{
++	struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
++	bool tx_queue = false;
++	unsigned int i;
++
++	switch (queue->qid) {
++	case QID_AC_VO:
++	case QID_AC_VI:
++	case QID_AC_BE:
++	case QID_AC_BK:
++		tx_queue = true;
++		break;
++	case QID_RX:
++		break;
++	default:
++		return;
++	}
++
++	for (i = 0; i < 5; i++) {
++		/*
++		 * Check if the driver is already done, otherwise we
++		 * have to sleep a little while to give the driver/hw
++		 * the oppurtunity to complete interrupt process itself.
++		 */
++		if (rt2x00queue_empty(queue))
++			break;
++
++		/*
++		 * For TX queues schedule completion tasklet to catch
++		 * tx status timeouts, othewise just wait.
++		 */
++		if (tx_queue) {
++			tasklet_disable(&rt2x00dev->txstatus_tasklet);
++			rt2800mmio_txdone(rt2x00dev);
++			tasklet_enable(&rt2x00dev->txstatus_tasklet);
++		}
++
++		/*
++		 * Wait for a little while to give the driver
++		 * the oppurtunity to recover itself.
++		 */
++		msleep(50);
++	}
++}
++EXPORT_SYMBOL_GPL(rt2800mmio_flush_queue);
++
+ void rt2800mmio_stop_queue(struct data_queue *queue)
+ {
+ 	struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
+@@ -148,6 +148,7 @@ void rt2800mmio_toggle_irq(struct rt2x00
+ /* Queue handlers */
+ void rt2800mmio_start_queue(struct data_queue *queue);
+ void rt2800mmio_kick_queue(struct data_queue *queue);
++void rt2800mmio_flush_queue(struct data_queue *queue, bool drop);
+ void rt2800mmio_stop_queue(struct data_queue *queue);
+ void rt2800mmio_queue_init(struct data_queue *queue);
+ 
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+@@ -364,7 +364,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.start_queue		= rt2800mmio_start_queue,
+ 	.kick_queue		= rt2800mmio_kick_queue,
+ 	.stop_queue		= rt2800mmio_stop_queue,
+-	.flush_queue		= rt2x00mmio_flush_queue,
++	.flush_queue		= rt2800mmio_flush_queue,
+ 	.write_tx_desc		= rt2800mmio_write_tx_desc,
+ 	.write_tx_data		= rt2800_write_tx_data,
+ 	.write_beacon		= rt2800_write_beacon,
diff -uprN a/package/kernel/mac80211/patches/rt2x00/007-rt2x00-rt2400pci-mark-expected-switch-fall-through.patch b/package/kernel/mac80211/patches/rt2x00/007-rt2x00-rt2400pci-mark-expected-switch-fall-through.patch
--- a/package/kernel/mac80211/patches/rt2x00/007-rt2x00-rt2400pci-mark-expected-switch-fall-through.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/007-rt2x00-rt2400pci-mark-expected-switch-fall-through.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,25 @@
+From 6eba8fd2235237784dfd01da55c3210d493aebdb Mon Sep 17 00:00:00 2001
+From: "Gustavo A. R. Silva" <gustavo@embeddedor.com>
+Date: Mon, 22 Oct 2018 22:44:34 +0200
+Subject: [PATCH 07/28] rt2x00: rt2400pci: mark expected switch fall-through
+
+In preparation to enabling -Wimplicit-fallthrough, mark switch cases
+where we are expecting to fall through.
+
+Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2400pci.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2400pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2400pci.c
+@@ -1302,7 +1302,7 @@ static void rt2400pci_txdone(struct rt2x
+ 			break;
+ 		case 2: /* Failure, excessive retries */
+ 			__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);
+-			/* Don't break, this is a failed frame! */
++			/* Fall through - this is a failed frame! */
+ 		default: /* Failure */
+ 			__set_bit(TXDONE_FAILURE, &txdesc.flags);
+ 		}
diff -uprN a/package/kernel/mac80211/patches/rt2x00/008-rt2x00-rt2500pci-mark-expected-switch-fall-through.patch b/package/kernel/mac80211/patches/rt2x00/008-rt2x00-rt2500pci-mark-expected-switch-fall-through.patch
--- a/package/kernel/mac80211/patches/rt2x00/008-rt2x00-rt2500pci-mark-expected-switch-fall-through.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/008-rt2x00-rt2500pci-mark-expected-switch-fall-through.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,25 @@
+From 10bb92217747c3384a01ebec005faa2f5e72bbd8 Mon Sep 17 00:00:00 2001
+From: "Gustavo A. R. Silva" <gustavo@embeddedor.com>
+Date: Mon, 22 Oct 2018 22:45:19 +0200
+Subject: [PATCH 08/28] rt2x00: rt2500pci: mark expected switch fall-through
+
+In preparation to enabling -Wimplicit-fallthrough, mark switch cases
+where we are expecting to fall through.
+
+Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2500pci.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2500pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2500pci.c
+@@ -1430,7 +1430,7 @@ static void rt2500pci_txdone(struct rt2x
+ 			break;
+ 		case 2: /* Failure, excessive retries */
+ 			__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);
+-			/* Don't break, this is a failed frame! */
++			/* Fall through - this is a failed frame! */
+ 		default: /* Failure */
+ 			__set_bit(TXDONE_FAILURE, &txdesc.flags);
+ 		}
diff -uprN a/package/kernel/mac80211/patches/rt2x00/009-rt2x00-rt2800lib-mark-expected-switch-fall-throughs.patch b/package/kernel/mac80211/patches/rt2x00/009-rt2x00-rt2800lib-mark-expected-switch-fall-throughs.patch
--- a/package/kernel/mac80211/patches/rt2x00/009-rt2x00-rt2800lib-mark-expected-switch-fall-throughs.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/009-rt2x00-rt2800lib-mark-expected-switch-fall-throughs.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,44 @@
+From 916e6bbcfcff6cc5d7d33bba8557a30f3af50326 Mon Sep 17 00:00:00 2001
+From: "Gustavo A. R. Silva" <gustavo@embeddedor.com>
+Date: Mon, 22 Oct 2018 22:46:03 +0200
+Subject: [PATCH 09/28] rt2x00: rt2800lib: mark expected switch fall-throughs
+
+In preparation to enabling -Wimplicit-fallthrough, mark switch cases
+where we are expecting to fall through.
+
+Addresses-Coverity-ID: 145198 ("Missing break in switch")
+Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -2482,6 +2482,7 @@ static void rt2800_config_channel_rf3052
+ 		switch (rt2x00dev->default_ant.tx_chain_num) {
+ 		case 1:
+ 			rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 1);
++			/* fall through */
+ 		case 2:
+ 			rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 1);
+ 			break;
+@@ -2490,6 +2491,7 @@ static void rt2800_config_channel_rf3052
+ 		switch (rt2x00dev->default_ant.rx_chain_num) {
+ 		case 1:
+ 			rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 1);
++			/* fall through */
+ 		case 2:
+ 			rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 1);
+ 			break;
+@@ -9457,8 +9459,10 @@ static int rt2800_probe_hw_mode(struct r
+ 	switch (rx_chains) {
+ 	case 3:
+ 		spec->ht.mcs.rx_mask[2] = 0xff;
++		/* fall through */
+ 	case 2:
+ 		spec->ht.mcs.rx_mask[1] = 0xff;
++		/* fall through */
+ 	case 1:
+ 		spec->ht.mcs.rx_mask[0] = 0xff;
+ 		spec->ht.mcs.rx_mask[4] = 0x1; /* MCS32 */
diff -uprN a/package/kernel/mac80211/patches/rt2x00/010-rt2x00-rt61pci-mark-expected-switch-fall-through.patch b/package/kernel/mac80211/patches/rt2x00/010-rt2x00-rt61pci-mark-expected-switch-fall-through.patch
--- a/package/kernel/mac80211/patches/rt2x00/010-rt2x00-rt61pci-mark-expected-switch-fall-through.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/010-rt2x00-rt61pci-mark-expected-switch-fall-through.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,25 @@
+From 641dd8068ecb078e7d12efe465df202bc16ca5eb Mon Sep 17 00:00:00 2001
+From: "Gustavo A. R. Silva" <gustavo@embeddedor.com>
+Date: Mon, 22 Oct 2018 22:46:47 +0200
+Subject: [PATCH 10/28] rt2x00: rt61pci: mark expected switch fall-through
+
+In preparation to enabling -Wimplicit-fallthrough, mark switch cases
+where we are expecting to fall through.
+
+Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt61pci.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt61pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt61pci.c
+@@ -2226,7 +2226,7 @@ static void rt61pci_txdone(struct rt2x00
+ 			break;
+ 		case 6: /* Failure, excessive retries */
+ 			__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);
+-			/* Don't break, this is a failed frame! */
++			/* Fall through - this is a failed frame! */
+ 		default: /* Failure */
+ 			__set_bit(TXDONE_FAILURE, &txdesc.flags);
+ 		}
diff -uprN a/package/kernel/mac80211/patches/rt2x00/011-cross-tree-phase-out-dma_zalloc_coherent.patch b/package/kernel/mac80211/patches/rt2x00/011-cross-tree-phase-out-dma_zalloc_coherent.patch
--- a/package/kernel/mac80211/patches/rt2x00/011-cross-tree-phase-out-dma_zalloc_coherent.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/011-cross-tree-phase-out-dma_zalloc_coherent.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,40 @@
+From 750afb08ca71310fcf0c4e2cb1565c63b8235b60 Mon Sep 17 00:00:00 2001
+From: Luis Chamberlain <mcgrof@kernel.org>
+Date: Fri, 4 Jan 2019 09:23:09 +0100
+Subject: [PATCH 11/28] cross-tree: phase out dma_zalloc_coherent()
+
+We already need to zero out memory for dma_alloc_coherent(), as such
+using dma_zalloc_coherent() is superflous. Phase it out.
+
+This change was generated with the following Coccinelle SmPL patch:
+
+@ replace_dma_zalloc_coherent @
+expression dev, size, data, handle, flags;
+@@
+
+-dma_zalloc_coherent(dev, size, handle, flags)
++dma_alloc_coherent(dev, size, handle, flags)
+
+Suggested-by: Christoph Hellwig <hch@lst.de>
+Signed-off-by: Luis Chamberlain <mcgrof@kernel.org>
+[hch: re-ran the script on the latest tree]
+Signed-off-by: Christoph Hellwig <hch@lst.de>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00mmio.c | 6 +++---
+ 1 file changed, 3 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00mmio.c
+@@ -119,9 +119,9 @@ static int rt2x00mmio_alloc_queue_dma(st
+ 	/*
+ 	 * Allocate DMA memory for descriptor and buffer.
+ 	 */
+-	addr = dma_zalloc_coherent(rt2x00dev->dev,
+-				   queue->limit * queue->desc_size, &dma,
+-				   GFP_KERNEL);
++	addr = dma_alloc_coherent(rt2x00dev->dev,
++				  queue->limit * queue->desc_size, &dma,
++				  GFP_KERNEL);
+ 	if (!addr)
+ 		return -ENOMEM;
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/012-rt2x00-reduce-tx-power-to-nominal-level-on-RT6352.patch b/package/kernel/mac80211/patches/rt2x00/012-rt2x00-reduce-tx-power-to-nominal-level-on-RT6352.patch
--- a/package/kernel/mac80211/patches/rt2x00/012-rt2x00-reduce-tx-power-to-nominal-level-on-RT6352.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/012-rt2x00-reduce-tx-power-to-nominal-level-on-RT6352.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,32 @@
+From c2e28ef7711ffcb083474ee5f154264c6ec1ec07 Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Tomislav=20Po=C5=BEega?= <pozega.tomislav@gmail.com>
+Date: Thu, 27 Dec 2018 15:05:25 +0100
+Subject: [PATCH 12/28] rt2x00: reduce tx power to nominal level on RT6352
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Current implementation of RT6352 support provides too high tx power
+at least on iPA/eLNA devices. Reduce amplification of variable gain
+amplifier by 6dB to match board target power of 17dBm.
+Transmited signal strength with this patch is similar to that of
+stock firmware or pandorabox firmware. Throughput measured with iperf
+improves. Device tested: Xiaomi Miwifi Mini.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -5477,7 +5477,7 @@ static int rt2800_init_registers(struct
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+ 		rt2800_register_write(rt2x00dev, MIMO_PS_CFG, 0x00000002);
+ 		rt2800_register_write(rt2x00dev, TX_PIN_CFG, 0x00150F0F);
+-		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x06060606);
++		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
+ 		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
+ 		rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
+ 		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN, 0x6C6C666C);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/013-rt2x00-Work-around-a-firmware-bug-with-shared-keys.patch b/package/kernel/mac80211/patches/rt2x00/013-rt2x00-Work-around-a-firmware-bug-with-shared-keys.patch
--- a/package/kernel/mac80211/patches/rt2x00/013-rt2x00-Work-around-a-firmware-bug-with-shared-keys.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/013-rt2x00-Work-around-a-firmware-bug-with-shared-keys.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,143 @@
+From a4296994eb8061ee3455721a296c387c639bf635 Mon Sep 17 00:00:00 2001
+From: Bernd Edlinger <bernd.edlinger@hotmail.de>
+Date: Tue, 15 Jan 2019 14:01:29 +0000
+Subject: [PATCH 13/28] rt2x00: Work around a firmware bug with shared keys
+
+Apparently the rt2x61 firmware fails temporarily to decode
+broadcast packets if the shared keys are not assigned
+in the "correct" sequence. At the same time unicast
+packets work fine, since they are encrypted with the
+pairwise key.
+
+At least with WPA2 CCMP mode the shared keys are
+set in the following sequence: keyidx=1, 2, 1, 2.
+After a while only keyidx 2 gets decrypted, and
+keyidx 1 is ignored, probably because there is never
+a keyidx 3.
+
+Symptoms are arping -b works for 10 minutes, since
+keyidx=2 is used for broadcast, and then it stops
+working for 10 minutes, because keyidx=1 is used.
+That failure mode repeats forever.
+
+Note, the firmware does not even know which keyidx
+corresponds to which hw_key_idx so the firmware is
+trying to be smarter than the driver, which is bound
+to fail.
+
+As workaround the function rt61pci_config_shared_key
+requests software decryption of the shared keys,
+by returning EOPNOTSUPP. However, pairwise keys are
+still handled by hardware which works just fine.
+
+Signed-off-by: Bernd Edlinger <bernd.edlinger@hotmail.de>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt61pci.c | 93 +-------------------
+ 1 file changed, 4 insertions(+), 89 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt61pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt61pci.c
+@@ -321,97 +321,12 @@ static int rt61pci_config_shared_key(str
+ 				     struct rt2x00lib_crypto *crypto,
+ 				     struct ieee80211_key_conf *key)
+ {
+-	struct hw_key_entry key_entry;
+-	struct rt2x00_field32 field;
+-	u32 mask;
+-	u32 reg;
+-
+-	if (crypto->cmd == SET_KEY) {
+-		/*
+-		 * rt2x00lib can't determine the correct free
+-		 * key_idx for shared keys. We have 1 register
+-		 * with key valid bits. The goal is simple, read
+-		 * the register, if that is full we have no slots
+-		 * left.
+-		 * Note that each BSS is allowed to have up to 4
+-		 * shared keys, so put a mask over the allowed
+-		 * entries.
+-		 */
+-		mask = (0xf << crypto->bssidx);
+-
+-		reg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR0);
+-		reg &= mask;
+-
+-		if (reg && reg == mask)
+-			return -ENOSPC;
+-
+-		key->hw_key_idx += reg ? ffz(reg) : 0;
+-
+-		/*
+-		 * Upload key to hardware
+-		 */
+-		memcpy(key_entry.key, crypto->key,
+-		       sizeof(key_entry.key));
+-		memcpy(key_entry.tx_mic, crypto->tx_mic,
+-		       sizeof(key_entry.tx_mic));
+-		memcpy(key_entry.rx_mic, crypto->rx_mic,
+-		       sizeof(key_entry.rx_mic));
+-
+-		reg = SHARED_KEY_ENTRY(key->hw_key_idx);
+-		rt2x00mmio_register_multiwrite(rt2x00dev, reg,
+-					       &key_entry, sizeof(key_entry));
+-
+-		/*
+-		 * The cipher types are stored over 2 registers.
+-		 * bssidx 0 and 1 keys are stored in SEC_CSR1 and
+-		 * bssidx 1 and 2 keys are stored in SEC_CSR5.
+-		 * Using the correct defines correctly will cause overhead,
+-		 * so just calculate the correct offset.
+-		 */
+-		if (key->hw_key_idx < 8) {
+-			field.bit_offset = (3 * key->hw_key_idx);
+-			field.bit_mask = 0x7 << field.bit_offset;
+-
+-			reg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR1);
+-			rt2x00_set_field32(&reg, field, crypto->cipher);
+-			rt2x00mmio_register_write(rt2x00dev, SEC_CSR1, reg);
+-		} else {
+-			field.bit_offset = (3 * (key->hw_key_idx - 8));
+-			field.bit_mask = 0x7 << field.bit_offset;
+-
+-			reg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR5);
+-			rt2x00_set_field32(&reg, field, crypto->cipher);
+-			rt2x00mmio_register_write(rt2x00dev, SEC_CSR5, reg);
+-		}
+-
+-		/*
+-		 * The driver does not support the IV/EIV generation
+-		 * in hardware. However it doesn't support the IV/EIV
+-		 * inside the ieee80211 frame either, but requires it
+-		 * to be provided separately for the descriptor.
+-		 * rt2x00lib will cut the IV/EIV data out of all frames
+-		 * given to us by mac80211, but we must tell mac80211
+-		 * to generate the IV/EIV data.
+-		 */
+-		key->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;
+-	}
+-
+ 	/*
+-	 * SEC_CSR0 contains only single-bit fields to indicate
+-	 * a particular key is valid. Because using the FIELD32()
+-	 * defines directly will cause a lot of overhead, we use
+-	 * a calculation to determine the correct bit directly.
++	 * Let the software handle the shared keys,
++	 * since the hardware decryption does not work reliably,
++	 * because the firmware does not know the key's keyidx.
+ 	 */
+-	mask = 1 << key->hw_key_idx;
+-
+-	reg = rt2x00mmio_register_read(rt2x00dev, SEC_CSR0);
+-	if (crypto->cmd == SET_KEY)
+-		reg |= mask;
+-	else if (crypto->cmd == DISABLE_KEY)
+-		reg &= ~mask;
+-	rt2x00mmio_register_write(rt2x00dev, SEC_CSR0, reg);
+-
+-	return 0;
++	return -EOPNOTSUPP;
+ }
+ 
+ static int rt61pci_config_pairwise_key(struct rt2x00_dev *rt2x00dev,
diff -uprN a/package/kernel/mac80211/patches/rt2x00/014-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch b/package/kernel/mac80211/patches/rt2x00/014-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch
--- a/package/kernel/mac80211/patches/rt2x00/014-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/014-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,107 @@
+From 2587791d57588562c21e5ef7e678f02ab2f3eb82 Mon Sep 17 00:00:00 2001
+From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Date: Tue, 22 Jan 2019 16:21:34 +0100
+Subject: [PATCH 14/28] rt2x00: no need to check return value of debugfs_create
+ functions
+
+When calling debugfs functions, there is no need to ever check the
+return value.  The function can work or not, but the code logic should
+never do something different based on this.
+
+Cc: Stanislaw Gruszka <sgruszka@redhat.com>
+Cc: Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@codeaurora.org>
+Cc: linux-wireless@vger.kernel.org
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2x00debug.c  | 27 -------------------
+ 1 file changed, 27 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
+@@ -656,36 +656,24 @@ void rt2x00debug_register(struct rt2x00_
+ 	intf->driver_folder =
+ 	    debugfs_create_dir(intf->rt2x00dev->ops->name,
+ 			       rt2x00dev->hw->wiphy->debugfsdir);
+-	if (IS_ERR(intf->driver_folder) || !intf->driver_folder)
+-		goto exit;
+ 
+ 	intf->driver_entry =
+ 	    rt2x00debug_create_file_driver("driver", intf, &intf->driver_blob);
+-	if (IS_ERR(intf->driver_entry) || !intf->driver_entry)
+-		goto exit;
+ 
+ 	intf->chipset_entry =
+ 	    rt2x00debug_create_file_chipset("chipset",
+ 					    intf, &intf->chipset_blob);
+-	if (IS_ERR(intf->chipset_entry) || !intf->chipset_entry)
+-		goto exit;
+ 
+ 	intf->dev_flags = debugfs_create_file("dev_flags", 0400,
+ 					      intf->driver_folder, intf,
+ 					      &rt2x00debug_fop_dev_flags);
+-	if (IS_ERR(intf->dev_flags) || !intf->dev_flags)
+-		goto exit;
+ 
+ 	intf->cap_flags = debugfs_create_file("cap_flags", 0400,
+ 					      intf->driver_folder, intf,
+ 					      &rt2x00debug_fop_cap_flags);
+-	if (IS_ERR(intf->cap_flags) || !intf->cap_flags)
+-		goto exit;
+ 
+ 	intf->register_folder =
+ 	    debugfs_create_dir("register", intf->driver_folder);
+-	if (IS_ERR(intf->register_folder) || !intf->register_folder)
+-		goto exit;
+ 
+ #define RT2X00DEBUGFS_CREATE_REGISTER_ENTRY(__intf, __name)		\
+ ({									\
+@@ -695,9 +683,6 @@ void rt2x00debug_register(struct rt2x00_
+ 					   0600,			\
+ 					   (__intf)->register_folder,	\
+ 					   &(__intf)->offset_##__name);	\
+-		if (IS_ERR((__intf)->__name##_off_entry) ||		\
+-		    !(__intf)->__name##_off_entry)			\
+-			goto exit;					\
+ 									\
+ 		(__intf)->__name##_val_entry =				\
+ 			debugfs_create_file(__stringify(__name) "_value", \
+@@ -705,9 +690,6 @@ void rt2x00debug_register(struct rt2x00_
+ 					    (__intf)->register_folder,	\
+ 					    (__intf),			\
+ 					    &rt2x00debug_fop_##__name); \
+-		if (IS_ERR((__intf)->__name##_val_entry) ||		\
+-		    !(__intf)->__name##_val_entry)			\
+-			goto exit;					\
+ 	}								\
+ })
+ 
+@@ -721,15 +703,10 @@ void rt2x00debug_register(struct rt2x00_
+ 
+ 	intf->queue_folder =
+ 	    debugfs_create_dir("queue", intf->driver_folder);
+-	if (IS_ERR(intf->queue_folder) || !intf->queue_folder)
+-		goto exit;
+ 
+ 	intf->queue_frame_dump_entry =
+ 		debugfs_create_file("dump", 0400, intf->queue_folder,
+ 				    intf, &rt2x00debug_fop_queue_dump);
+-	if (IS_ERR(intf->queue_frame_dump_entry)
+-		|| !intf->queue_frame_dump_entry)
+-		goto exit;
+ 
+ 	skb_queue_head_init(&intf->frame_dump_skbqueue);
+ 	init_waitqueue_head(&intf->frame_dump_waitqueue);
+@@ -747,10 +724,6 @@ void rt2x00debug_register(struct rt2x00_
+ #endif
+ 
+ 	return;
+-
+-exit:
+-	rt2x00debug_deregister(rt2x00dev);
+-	rt2x00_err(rt2x00dev, "Failed to register debug handler\n");
+ }
+ 
+ void rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev)
diff -uprN a/package/kernel/mac80211/patches/rt2x00/015-rt2x00-remove-unneeded-check.patch b/package/kernel/mac80211/patches/rt2x00/015-rt2x00-remove-unneeded-check.patch
--- a/package/kernel/mac80211/patches/rt2x00/015-rt2x00-remove-unneeded-check.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/015-rt2x00-remove-unneeded-check.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,137 @@
+From 17ae2acd1a6f5148edd80d84194e5d7c80be360e Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Tomislav=20Po=C5=BEega?= <pozega.tomislav@gmail.com>
+Date: Wed, 13 Feb 2019 11:09:12 +0100
+Subject: [PATCH 15/28] rt2x00: remove unneeded check
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Remove band check from rf53xx channel config routine since all chips
+using it are single band.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 103 +++++++++---------
+ 1 file changed, 50 insertions(+), 53 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -2966,6 +2966,7 @@ static void rt2800_config_channel_rf53xx
+ 					 struct channel_info *info)
+ {
+ 	u8 rfcsr;
++	int idx = rf->channel-1;
+ 
+ 	rt2800_rfcsr_write(rt2x00dev, 8, rf->rf1);
+ 	rt2800_rfcsr_write(rt2x00dev, 9, rf->rf3);
+@@ -3003,60 +3004,56 @@ static void rt2800_config_channel_rf53xx
+ 
+ 	rt2800_freq_cal_mode1(rt2x00dev);
+ 
+-	if (rf->channel <= 14) {
+-		int idx = rf->channel-1;
++	if (rt2x00_has_cap_bt_coexist(rt2x00dev)) {
++		if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
++			/* r55/r59 value array of channel 1~14 */
++			static const char r55_bt_rev[] = {0x83, 0x83,
++				0x83, 0x73, 0x73, 0x63, 0x53, 0x53,
++				0x53, 0x43, 0x43, 0x43, 0x43, 0x43};
++			static const char r59_bt_rev[] = {0x0e, 0x0e,
++				0x0e, 0x0e, 0x0e, 0x0b, 0x0a, 0x09,
++				0x07, 0x07, 0x07, 0x07, 0x07, 0x07};
++
++			rt2800_rfcsr_write(rt2x00dev, 55,
++					   r55_bt_rev[idx]);
++			rt2800_rfcsr_write(rt2x00dev, 59,
++					   r59_bt_rev[idx]);
++		} else {
++			static const char r59_bt[] = {0x8b, 0x8b, 0x8b,
++				0x8b, 0x8b, 0x8b, 0x8b, 0x8a, 0x89,
++				0x88, 0x88, 0x86, 0x85, 0x84};
+ 
+-		if (rt2x00_has_cap_bt_coexist(rt2x00dev)) {
+-			if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
+-				/* r55/r59 value array of channel 1~14 */
+-				static const char r55_bt_rev[] = {0x83, 0x83,
+-					0x83, 0x73, 0x73, 0x63, 0x53, 0x53,
+-					0x53, 0x43, 0x43, 0x43, 0x43, 0x43};
+-				static const char r59_bt_rev[] = {0x0e, 0x0e,
+-					0x0e, 0x0e, 0x0e, 0x0b, 0x0a, 0x09,
+-					0x07, 0x07, 0x07, 0x07, 0x07, 0x07};
+-
+-				rt2800_rfcsr_write(rt2x00dev, 55,
+-						   r55_bt_rev[idx]);
+-				rt2800_rfcsr_write(rt2x00dev, 59,
+-						   r59_bt_rev[idx]);
+-			} else {
+-				static const char r59_bt[] = {0x8b, 0x8b, 0x8b,
+-					0x8b, 0x8b, 0x8b, 0x8b, 0x8a, 0x89,
+-					0x88, 0x88, 0x86, 0x85, 0x84};
++			rt2800_rfcsr_write(rt2x00dev, 59, r59_bt[idx]);
++		}
++	} else {
++		if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
++			static const char r55_nonbt_rev[] = {0x23, 0x23,
++				0x23, 0x23, 0x13, 0x13, 0x03, 0x03,
++				0x03, 0x03, 0x03, 0x03, 0x03, 0x03};
++			static const char r59_nonbt_rev[] = {0x07, 0x07,
++				0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
++				0x07, 0x07, 0x06, 0x05, 0x04, 0x04};
++
++			rt2800_rfcsr_write(rt2x00dev, 55,
++					   r55_nonbt_rev[idx]);
++			rt2800_rfcsr_write(rt2x00dev, 59,
++					   r59_nonbt_rev[idx]);
++		} else if (rt2x00_rt(rt2x00dev, RT5390) ||
++			   rt2x00_rt(rt2x00dev, RT5392) ||
++			   rt2x00_rt(rt2x00dev, RT6352)) {
++			static const char r59_non_bt[] = {0x8f, 0x8f,
++				0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8d,
++				0x8a, 0x88, 0x88, 0x87, 0x87, 0x86};
++
++			rt2800_rfcsr_write(rt2x00dev, 59,
++					   r59_non_bt[idx]);
++		} else if (rt2x00_rt(rt2x00dev, RT5350)) {
++			static const char r59_non_bt[] = {0x0b, 0x0b,
++				0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a,
++				0x0a, 0x09, 0x08, 0x07, 0x07, 0x06};
+ 
+-				rt2800_rfcsr_write(rt2x00dev, 59, r59_bt[idx]);
+-			}
+-		} else {
+-			if (rt2x00_rt_rev_gte(rt2x00dev, RT5390, REV_RT5390F)) {
+-				static const char r55_nonbt_rev[] = {0x23, 0x23,
+-					0x23, 0x23, 0x13, 0x13, 0x03, 0x03,
+-					0x03, 0x03, 0x03, 0x03, 0x03, 0x03};
+-				static const char r59_nonbt_rev[] = {0x07, 0x07,
+-					0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
+-					0x07, 0x07, 0x06, 0x05, 0x04, 0x04};
+-
+-				rt2800_rfcsr_write(rt2x00dev, 55,
+-						   r55_nonbt_rev[idx]);
+-				rt2800_rfcsr_write(rt2x00dev, 59,
+-						   r59_nonbt_rev[idx]);
+-			} else if (rt2x00_rt(rt2x00dev, RT5390) ||
+-				   rt2x00_rt(rt2x00dev, RT5392) ||
+-				   rt2x00_rt(rt2x00dev, RT6352)) {
+-				static const char r59_non_bt[] = {0x8f, 0x8f,
+-					0x8f, 0x8f, 0x8f, 0x8f, 0x8f, 0x8d,
+-					0x8a, 0x88, 0x88, 0x87, 0x87, 0x86};
+-
+-				rt2800_rfcsr_write(rt2x00dev, 59,
+-						   r59_non_bt[idx]);
+-			} else if (rt2x00_rt(rt2x00dev, RT5350)) {
+-				static const char r59_non_bt[] = {0x0b, 0x0b,
+-					0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0a,
+-					0x0a, 0x09, 0x08, 0x07, 0x07, 0x06};
+-
+-				rt2800_rfcsr_write(rt2x00dev, 59,
+-						   r59_non_bt[idx]);
+-			}
++			rt2800_rfcsr_write(rt2x00dev, 59,
++					   r59_non_bt[idx]);
+ 		}
+ 	}
+ }
diff -uprN a/package/kernel/mac80211/patches/rt2x00/016-rt2x00-remove-confusing-AGC-register.patch b/package/kernel/mac80211/patches/rt2x00/016-rt2x00-remove-confusing-AGC-register.patch
--- a/package/kernel/mac80211/patches/rt2x00/016-rt2x00-remove-confusing-AGC-register.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/016-rt2x00-remove-confusing-AGC-register.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,34 @@
+From 5991a2ecd070ce5ef646b4e8e0bc8d99110604ed Mon Sep 17 00:00:00 2001
+From: =?UTF-8?q?Tomislav=20Po=C5=BEega?= <pozega.tomislav@gmail.com>
+Date: Wed, 13 Feb 2019 11:09:13 +0100
+Subject: [PATCH 16/28] rt2x00: remove confusing AGC register
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Register 66 was causing issues on RT6352 if set to the same value as
+in MTK driver. With 1c reg value device was working fine in both HT20
+and HT40 modes.
+
+Signed-off-by: Tomislav Požega <pozega.tomislav@gmail.com>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 6 +-----
+ 1 file changed, 1 insertion(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -3983,11 +3983,7 @@ static void rt2800_config_channel(struct
+ 		rt2800_bbp_write(rt2x00dev, 196, reg);
+ 
+ 		/* AGC init */
+-		if (rt2x00_rt(rt2x00dev, RT6352))
+-			reg = 0x04;
+-		else
+-			reg = rf->channel <= 14 ? 0x1c : 0x24;
+-
++		reg = rf->channel <= 14 ? 0x1c : 0x24;
+ 		reg += 2 * rt2x00dev->lna_gain;
+ 		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/017-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-band.patch b/package/kernel/mac80211/patches/rt2x00/017-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-band.patch
--- a/package/kernel/mac80211/patches/rt2x00/017-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-band.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/017-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-band.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,47 @@
+From 9ad3b55654455258a9463384edb40077439d879f Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 13 Feb 2019 11:09:14 +0100
+Subject: [PATCH 17/28] rt2800: enable TX_PIN_CFG_LNA_PE_ bits per band
+
+Do not enable TX_PIN_CFG_LNA_PE_A* bits for 2.4GHz band and
+vice versa TX_PIN_CFG_LNA_PE_G* bits for 5GHz.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 18 ++++++++++++------
+ 1 file changed, 12 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -3893,18 +3893,24 @@ static void rt2800_config_channel(struct
+ 	switch (rt2x00dev->default_ant.rx_chain_num) {
+ 	case 3:
+ 		/* Turn on tertiary LNAs */
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A2_EN, 1);
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G2_EN, 1);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A2_EN,
++				   rf->channel > 14);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G2_EN,
++				   rf->channel <= 14);
+ 		/* fall-through */
+ 	case 2:
+ 		/* Turn on secondary LNAs */
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A1_EN, 1);
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G1_EN, 1);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A1_EN,
++				   rf->channel > 14);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G1_EN,
++				   rf->channel <= 14);
+ 		/* fall-through */
+ 	case 1:
+ 		/* Turn on primary LNAs */
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A0_EN, 1);
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G0_EN, 1);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A0_EN,
++				   rf->channel > 14);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G0_EN,
++				   rf->channel <= 14);
+ 		break;
+ 	}
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/018-rt2800-enable-TX_PIN_CFG_RFRX_EN-only-for-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/018-rt2800-enable-TX_PIN_CFG_RFRX_EN-only-for-MT7620.patch
--- a/package/kernel/mac80211/patches/rt2x00/018-rt2800-enable-TX_PIN_CFG_RFRX_EN-only-for-MT7620.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/018-rt2800-enable-TX_PIN_CFG_RFRX_EN-only-for-MT7620.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,41 @@
+From 7aca14885edeab536a8cbe1e7cfeadd4c3310b9b Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 13 Feb 2019 11:09:15 +0100
+Subject: [PATCH 18/28] rt2800: enable TX_PIN_CFG_RFRX_EN only for MT7620
+
+The TX_PIN_CFG_RFRX_EN bit was not set on other devices than MT7620,
+restore old behavaviour since setting this bit maight not be
+correct for older devices.
+
+Fixes: 41977e86c984 ("rt2x00: add support for MT7620")
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 7 ++++---
+ 1 file changed, 4 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -3858,10 +3858,12 @@ static void rt2800_config_channel(struct
+ 	if (rt2x00_rt(rt2x00dev, RT3572))
+ 		rt2800_rfcsr_write(rt2x00dev, 8, 0);
+ 
+-	if (rt2x00_rt(rt2x00dev, RT6352))
++	if (rt2x00_rt(rt2x00dev, RT6352)) {
+ 		tx_pin = rt2800_register_read(rt2x00dev, TX_PIN_CFG);
+-	else
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_RFRX_EN, 1);
++	} else {
+ 		tx_pin = 0;
++	}
+ 
+ 	switch (rt2x00dev->default_ant.tx_chain_num) {
+ 	case 3:
+@@ -3916,7 +3918,6 @@ static void rt2800_config_channel(struct
+ 
+ 	rt2x00_set_field32(&tx_pin, TX_PIN_CFG_RFTR_EN, 1);
+ 	rt2x00_set_field32(&tx_pin, TX_PIN_CFG_TRSW_EN, 1);
+-	rt2x00_set_field32(&tx_pin, TX_PIN_CFG_RFRX_EN, 1); /* mt7620 */
+ 
+ 	rt2800_register_write(rt2x00dev, TX_PIN_CFG, tx_pin);
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/019-rt2800-comment-and-simplify-AGC-init-for-RT6352.patch b/package/kernel/mac80211/patches/rt2x00/019-rt2800-comment-and-simplify-AGC-init-for-RT6352.patch
--- a/package/kernel/mac80211/patches/rt2x00/019-rt2800-comment-and-simplify-AGC-init-for-RT6352.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/019-rt2800-comment-and-simplify-AGC-init-for-RT6352.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,33 @@
+From c7ff1bfeaf1ca69e3e401be211b55d1738d0c5fc Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Wed, 13 Feb 2019 11:09:16 +0100
+Subject: [PATCH 19/28] rt2800: comment and simplify AGC init for RT6352
+
+We do not need separate lines for calculating register values.
+Also add comment that value is different than in vendor driver.
+
+Suggested-by: Daniel Golle <daniel@makrotopia.org>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 9 ++++++---
+ 1 file changed, 6 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -3989,9 +3989,12 @@ static void rt2800_config_channel(struct
+ 		rt2800_bbp_write(rt2x00dev, 195, 141);
+ 		rt2800_bbp_write(rt2x00dev, 196, reg);
+ 
+-		/* AGC init */
+-		reg = rf->channel <= 14 ? 0x1c : 0x24;
+-		reg += 2 * rt2x00dev->lna_gain;
++		/* AGC init.
++		 * Despite the vendor driver using different values here for
++		 * RT6352 chip, we use 0x1c for now. This may have to be changed
++		 * once TSSI got implemented.
++		 */
++		reg = (rf->channel <= 14 ? 0x1c : 0x24) + 2*rt2x00dev->lna_gain;
+ 		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
+ 
+ 		rt2800_iq_calibrate(rt2x00dev, rf->channel);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/020-cfg80211-add-ratelimited-variants-of-err-and-warn.patch b/package/kernel/mac80211/patches/rt2x00/020-cfg80211-add-ratelimited-variants-of-err-and-warn.patch
--- a/package/kernel/mac80211/patches/rt2x00/020-cfg80211-add-ratelimited-variants-of-err-and-warn.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/020-cfg80211-add-ratelimited-variants-of-err-and-warn.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,39 @@
+From patchwork Tue Mar 12 09:51:40 2019
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10848957
+X-Patchwork-Delegate: johannes@sipsolutions.net
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+To: linux-wireless@vger.kernel.org
+Cc: =?utf-8?q?Tomislav_Po=C5=BEega?= <pozega.tomislav@gmail.com>,
+ Daniel Golle <daniel@makrotopia.org>, Felix Fietkau <nbd@nbd.name>,
+ Mathias Kresin <dev@kresin.me>
+Subject: [PATCH v3 1/4] cfg80211: add ratelimited variants of err and warn
+Date: Tue, 12 Mar 2019 10:51:40 +0100
+Message-Id: <1552384303-29529-2-git-send-email-sgruszka@redhat.com>
+In-Reply-To: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+References: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+
+wiphy_{err,warn}_ratelimited will be used by rt2x00
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ include/net/cfg80211.h | 5 +++++
+ 1 file changed, 5 insertions(+)
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -6632,6 +6632,11 @@ bool cfg80211_iftype_allowed(struct wiph
+ #define wiphy_info(wiphy, format, args...)			\
+ 	dev_info(&(wiphy)->dev, format, ##args)
+ 
++#define wiphy_err_ratelimited(wiphy, format, args...)		\
++	dev_err_ratelimited(&(wiphy)->dev, format, ##args)
++#define wiphy_warn_ratelimited(wiphy, format, args...)		\
++	dev_warn_ratelimited(&(wiphy)->dev, format, ##args)
++
+ #define wiphy_debug(wiphy, format, args...)			\
+ 	wiphy_printk(KERN_DEBUG, wiphy, format, ##args)
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/021-rt2x00-use-ratelimited-variants-dev_warn-dev_err.patch b/package/kernel/mac80211/patches/rt2x00/021-rt2x00-use-ratelimited-variants-dev_warn-dev_err.patch
--- a/package/kernel/mac80211/patches/rt2x00/021-rt2x00-use-ratelimited-variants-dev_warn-dev_err.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/021-rt2x00-use-ratelimited-variants-dev_warn-dev_err.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,42 @@
+From patchwork Tue Mar 12 09:51:41 2019
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10848959
+X-Patchwork-Delegate: kvalo@adurom.com
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+To: linux-wireless@vger.kernel.org
+Cc: =?utf-8?q?Tomislav_Po=C5=BEega?= <pozega.tomislav@gmail.com>,
+ Daniel Golle <daniel@makrotopia.org>, Felix Fietkau <nbd@nbd.name>,
+ Mathias Kresin <dev@kresin.me>
+Subject: [PATCH v3 2/4] rt2x00: use ratelimited variants dev_warn/dev_err
+Date: Tue, 12 Mar 2019 10:51:41 +0100
+Message-Id: <1552384303-29529-3-git-send-email-sgruszka@redhat.com>
+In-Reply-To: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+References: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+
+As reported by Randy we can overwhelm logs on some USB error conditions.
+To avoid that use dev_warn_ratelimited() and dev_err_ratelimitd().
+
+Reported-and-tested-by: Randy Oostdyk <linux-kernel@oostdyk.com>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -69,10 +69,10 @@
+ 	printk(KERN_ERR KBUILD_MODNAME ": %s: Error - " fmt,		\
+ 	       __func__, ##__VA_ARGS__)
+ #define rt2x00_err(dev, fmt, ...)					\
+-	wiphy_err((dev)->hw->wiphy, "%s: Error - " fmt,			\
++	wiphy_err_ratelimited((dev)->hw->wiphy, "%s: Error - " fmt,	\
+ 		  __func__, ##__VA_ARGS__)
+ #define rt2x00_warn(dev, fmt, ...)					\
+-	wiphy_warn((dev)->hw->wiphy, "%s: Warning - " fmt,		\
++	wiphy_warn_ratelimited((dev)->hw->wiphy, "%s: Warning - " fmt,	\
+ 		   __func__, ##__VA_ARGS__)
+ #define rt2x00_info(dev, fmt, ...)					\
+ 	wiphy_info((dev)->hw->wiphy, "%s: Info - " fmt,			\
diff -uprN a/package/kernel/mac80211/patches/rt2x00/022-rt2x00-check-number-of-EPROTO-errors.patch b/package/kernel/mac80211/patches/rt2x00/022-rt2x00-check-number-of-EPROTO-errors.patch
--- a/package/kernel/mac80211/patches/rt2x00/022-rt2x00-check-number-of-EPROTO-errors.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/022-rt2x00-check-number-of-EPROTO-errors.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,96 @@
+From patchwork Tue Mar 12 09:51:42 2019
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10848961
+X-Patchwork-Delegate: kvalo@adurom.com
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+To: linux-wireless@vger.kernel.org
+Cc: =?utf-8?q?Tomislav_Po=C5=BEega?= <pozega.tomislav@gmail.com>,
+ Daniel Golle <daniel@makrotopia.org>, Felix Fietkau <nbd@nbd.name>,
+ Mathias Kresin <dev@kresin.me>
+Subject: [PATCH v3 3/4] rt2x00: check number of EPROTO errors
+Date: Tue, 12 Mar 2019 10:51:42 +0100
+Message-Id: <1552384303-29529-4-git-send-email-sgruszka@redhat.com>
+In-Reply-To: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+References: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+
+Some USB host devices/drivers on some conditions can always return
+EPROTO error on submitted URBs. That can cause infinity loop in the
+rt2x00 driver.
+
+Since we can have single EPROTO errors we can not mark as device as
+removed to avoid infinity loop. However we can count consecutive
+EPROTO errors and mark device as removed if get lot of it.
+I choose number 10 as threshold.
+
+Reported-and-tested-by: Randy Oostdyk <linux-kernel@oostdyk.com>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h    |  1 +
+ drivers/net/wireless/ralink/rt2x00/rt2x00usb.c | 22 +++++++++++++++++++---
+ 2 files changed, 20 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -1016,6 +1016,7 @@ struct rt2x00_dev {
+ 	unsigned int extra_tx_headroom;
+ 
+ 	struct usb_anchor *anchor;
++	unsigned int num_proto_errs;
+ 
+ 	/* Clock for System On Chip devices. */
+ 	struct clk *clk;
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c
+@@ -31,6 +31,22 @@
+ #include "rt2x00.h"
+ #include "rt2x00usb.h"
+ 
++static bool rt2x00usb_check_usb_error(struct rt2x00_dev *rt2x00dev, int status)
++{
++	if (status == -ENODEV || status == -ENOENT)
++		return true;
++
++	if (status == -EPROTO || status == -ETIMEDOUT)
++		rt2x00dev->num_proto_errs++;
++	else
++		rt2x00dev->num_proto_errs = 0;
++
++	if (rt2x00dev->num_proto_errs > 3)
++		return true;
++
++	return false;
++}
++
+ /*
+  * Interfacing with the HW.
+  */
+@@ -57,7 +73,7 @@ int rt2x00usb_vendor_request(struct rt2x
+ 		if (status >= 0)
+ 			return 0;
+ 
+-		if (status == -ENODEV || status == -ENOENT) {
++		if (rt2x00usb_check_usb_error(rt2x00dev, status)) {
+ 			/* Device has disappeared. */
+ 			clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);
+ 			break;
+@@ -321,7 +337,7 @@ static bool rt2x00usb_kick_tx_entry(stru
+ 
+ 	status = usb_submit_urb(entry_priv->urb, GFP_ATOMIC);
+ 	if (status) {
+-		if (status == -ENODEV || status == -ENOENT)
++		if (rt2x00usb_check_usb_error(rt2x00dev, status))
+ 			clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);
+ 		set_bit(ENTRY_DATA_IO_FAILED, &entry->flags);
+ 		rt2x00lib_dmadone(entry);
+@@ -410,7 +426,7 @@ static bool rt2x00usb_kick_rx_entry(stru
+ 
+ 	status = usb_submit_urb(entry_priv->urb, GFP_ATOMIC);
+ 	if (status) {
+-		if (status == -ENODEV || status == -ENOENT)
++		if (rt2x00usb_check_usb_error(rt2x00dev, status))
+ 			clear_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);
+ 		set_bit(ENTRY_DATA_IO_FAILED, &entry->flags);
+ 		rt2x00lib_dmadone(entry);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/023-rt2x00-do-not-print-error-when-queue-is-full.patch b/package/kernel/mac80211/patches/rt2x00/023-rt2x00-do-not-print-error-when-queue-is-full.patch
--- a/package/kernel/mac80211/patches/rt2x00/023-rt2x00-do-not-print-error-when-queue-is-full.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/023-rt2x00-do-not-print-error-when-queue-is-full.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,43 @@
+From patchwork Tue Mar 12 09:51:43 2019
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10848963
+X-Patchwork-Delegate: kvalo@adurom.com
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+To: linux-wireless@vger.kernel.org
+Cc: =?utf-8?q?Tomislav_Po=C5=BEega?= <pozega.tomislav@gmail.com>,
+ Daniel Golle <daniel@makrotopia.org>, Felix Fietkau <nbd@nbd.name>,
+ Mathias Kresin <dev@kresin.me>
+Subject: [PATCH v3 4/4] rt2x00: do not print error when queue is full
+Date: Tue, 12 Mar 2019 10:51:43 +0100
+Message-Id: <1552384303-29529-5-git-send-email-sgruszka@redhat.com>
+In-Reply-To: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+References: <1552384303-29529-1-git-send-email-sgruszka@redhat.com>
+
+For unknown reasons printk() on some context can cause CPU hung on
+embedded MT7620 AP/router MIPS platforms. What can result on wifi
+disconnects.
+
+This patch move queue full messages to debug level what is consistent
+with other mac80211 drivers which drop packet silently if tx queue is
+full. This make MT7620 OpenWRT routers more stable, what was reported
+by various users.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00queue.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
+@@ -674,7 +674,7 @@ int rt2x00queue_write_tx_frame(struct da
+ 	spin_lock(&queue->tx_lock);
+ 
+ 	if (unlikely(rt2x00queue_full(queue))) {
+-		rt2x00_err(queue->rt2x00dev, "Dropping frame due to full tx queue %d\n",
++		rt2x00_dbg(queue->rt2x00dev, "Dropping frame due to full tx queue %d\n",
+ 			   queue->qid);
+ 		ret = -ENOBUFS;
+ 		goto out;
diff -uprN a/package/kernel/mac80211/patches/rt2x00/024-rt2800-partially-restore-old-mmio-txstatus-behaviour.patch b/package/kernel/mac80211/patches/rt2x00/024-rt2800-partially-restore-old-mmio-txstatus-behaviour.patch
--- a/package/kernel/mac80211/patches/rt2x00/024-rt2800-partially-restore-old-mmio-txstatus-behaviour.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/024-rt2800-partially-restore-old-mmio-txstatus-behaviour.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,128 @@
+From 91a5340db0526b7263bc8da14b120ea3129b5f28 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:31 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804437
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 21/28] rt2800: partially restore old mmio txstatus behaviour
+
+Do not disable txstatus interrupt and add quota of processed tx statuses in
+one tasklet. Quota is needed to allow to fed device with new frames during
+processing of tx statuses.
+
+Patch fixes about 15% performance degradation on some scenarios coused by
+0b0d556e0ebb ("rt2800mmio: use txdone/txstatus routines from lib").
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    |  4 +--
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |  2 +-
+ .../net/wireless/ralink/rt2x00/rt2800mmio.c   | 30 +++++--------------
+ .../net/wireless/ralink/rt2x00/rt2800usb.c    |  2 +-
+ 4 files changed, 12 insertions(+), 26 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1100,7 +1100,7 @@ void rt2800_txdone_entry(struct queue_en
+ }
+ EXPORT_SYMBOL_GPL(rt2800_txdone_entry);
+ 
+-void rt2800_txdone(struct rt2x00_dev *rt2x00dev)
++void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota)
+ {
+ 	struct data_queue *queue;
+ 	struct queue_entry *entry;
+@@ -1108,7 +1108,7 @@ void rt2800_txdone(struct rt2x00_dev *rt
+ 	u8 qid;
+ 	bool match;
+ 
+-	while (kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
++	while (quota-- > 0 && kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
+ 		/*
+ 		 * TX_STA_FIFO_PID_QUEUE is a 2-bit field, thus qid is
+ 		 * guaranteed to be one of the TX QIDs .
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -195,7 +195,7 @@ void rt2800_process_rxwi(struct queue_en
+ 
+ void rt2800_txdone_entry(struct queue_entry *entry, u32 status, __le32 *txwi,
+ 			 bool match);
+-void rt2800_txdone(struct rt2x00_dev *rt2x00dev);
++void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota);
+ void rt2800_txdone_nostatus(struct rt2x00_dev *rt2x00dev);
+ bool rt2800_txstatus_timeout(struct rt2x00_dev *rt2x00dev);
+ 
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -255,20 +255,6 @@ void rt2800mmio_autowake_tasklet(unsigne
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_autowake_tasklet);
+ 
+-static void rt2800mmio_txdone(struct rt2x00_dev *rt2x00dev)
+-{
+-	bool timeout = false;
+-
+-	while (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||
+-	       (timeout = rt2800_txstatus_timeout(rt2x00dev))) {
+-
+-		rt2800_txdone(rt2x00dev);
+-
+-		if (timeout)
+-			rt2800_txdone_nostatus(rt2x00dev);
+-	}
+-}
+-
+ static bool rt2800mmio_fetch_txstatus(struct rt2x00_dev *rt2x00dev)
+ {
+ 	u32 status;
+@@ -305,14 +291,11 @@ void rt2800mmio_txstatus_tasklet(unsigne
+ {
+ 	struct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;
+ 
+-	do {
+-		rt2800mmio_txdone(rt2x00dev);
++	rt2800_txdone(rt2x00dev, 16);
+ 
+-	} while (rt2800mmio_fetch_txstatus(rt2x00dev));
++	if (!kfifo_is_empty(&rt2x00dev->txstatus_fifo))
++		tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+ 
+-	if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
+-		rt2800mmio_enable_interrupt(rt2x00dev,
+-					    INT_SOURCE_CSR_TX_FIFO_STATUS);
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_txstatus_tasklet);
+ 
+@@ -339,8 +322,10 @@ irqreturn_t rt2800mmio_interrupt(int irq
+ 	mask = ~reg;
+ 
+ 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_TX_FIFO_STATUS)) {
++		rt2x00_set_field32(&mask, INT_MASK_CSR_TX_FIFO_STATUS, 1);
+ 		rt2800mmio_fetch_txstatus(rt2x00dev);
+-		tasklet_schedule(&rt2x00dev->txstatus_tasklet);
++		if (!kfifo_is_empty(&rt2x00dev->txstatus_fifo))
++			tasklet_schedule(&rt2x00dev->txstatus_tasklet);
+ 	}
+ 
+ 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_PRE_TBTT))
+@@ -500,7 +485,8 @@ void rt2800mmio_flush_queue(struct data_
+ 		 */
+ 		if (tx_queue) {
+ 			tasklet_disable(&rt2x00dev->txstatus_tasklet);
+-			rt2800mmio_txdone(rt2x00dev);
++			rt2800_txdone(rt2x00dev, UINT_MAX);
++			rt2800_txdone_nostatus(rt2x00dev);
+ 			tasklet_enable(&rt2x00dev->txstatus_tasklet);
+ 		}
+ 
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -480,7 +480,7 @@ static void rt2800usb_work_txdone(struct
+ 	while (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||
+ 	       rt2800_txstatus_timeout(rt2x00dev)) {
+ 
+-		rt2800_txdone(rt2x00dev);
++		rt2800_txdone(rt2x00dev, UINT_MAX);
+ 
+ 		rt2800_txdone_nostatus(rt2x00dev);
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/025-rt2800-new-flush-implementation-for-SoC-devices.patch b/package/kernel/mac80211/patches/rt2x00/025-rt2800-new-flush-implementation-for-SoC-devices.patch
--- a/package/kernel/mac80211/patches/rt2x00/025-rt2800-new-flush-implementation-for-SoC-devices.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/025-rt2800-new-flush-implementation-for-SoC-devices.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,27 @@
+From 11f8ad1656035176bad9d89de7ea0e7fe6d82c32 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:32 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804439
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 22/28] rt2800: new flush implementation for SoC devices
+
+Use new flush_queue() calback for SoC devices, what was already done for
+PCIe devices.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800soc.c | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -203,7 +203,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.start_queue		= rt2800mmio_start_queue,
+ 	.kick_queue		= rt2800mmio_kick_queue,
+ 	.stop_queue		= rt2800mmio_stop_queue,
+-	.flush_queue		= rt2x00mmio_flush_queue,
++	.flush_queue		= rt2800mmio_flush_queue,
+ 	.write_tx_desc		= rt2800mmio_write_tx_desc,
+ 	.write_tx_data		= rt2800_write_tx_data,
+ 	.write_beacon		= rt2800_write_beacon,
diff -uprN a/package/kernel/mac80211/patches/rt2x00/026-rt2800-move-txstatus-pending-routine.patch b/package/kernel/mac80211/patches/rt2x00/026-rt2800-move-txstatus-pending-routine.patch
--- a/package/kernel/mac80211/patches/rt2x00/026-rt2800-move-txstatus-pending-routine.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/026-rt2800-move-txstatus-pending-routine.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,106 @@
+From 2bbea7645c3d095014a080db170941818650e141 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:33 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804441
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 23/28] rt2800: move txstatus pending routine
+
+Move rt2800usb_txstatus_pending routine to rt2800lib. It will be reused
+by rt2800mmio code.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 17 ++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800usb.c    | 22 +++----------------
+ 3 files changed, 21 insertions(+), 19 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1183,6 +1183,23 @@ bool rt2800_txstatus_timeout(struct rt2x
+ }
+ EXPORT_SYMBOL_GPL(rt2800_txstatus_timeout);
+ 
++/*
++ * test if there is an entry in any TX queue for which DMA is done
++ * but the TX status has not been returned yet
++ */
++bool rt2800_txstatus_pending(struct rt2x00_dev *rt2x00dev)
++{
++	struct data_queue *queue;
++
++	tx_queue_for_each(rt2x00dev, queue) {
++		if (rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE) !=
++		    rt2x00queue_get_entry(queue, Q_INDEX_DONE))
++			return true;
++	}
++	return false;
++}
++EXPORT_SYMBOL_GPL(rt2800_txstatus_pending);
++
+ void rt2800_txdone_nostatus(struct rt2x00_dev *rt2x00dev)
+ {
+ 	struct data_queue *queue;
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -198,6 +198,7 @@ void rt2800_txdone_entry(struct queue_en
+ void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota);
+ void rt2800_txdone_nostatus(struct rt2x00_dev *rt2x00dev);
+ bool rt2800_txstatus_timeout(struct rt2x00_dev *rt2x00dev);
++bool rt2800_txstatus_pending(struct rt2x00_dev *rt2x00dev);
+ 
+ void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc);
+ void rt2800_clear_beacon(struct queue_entry *entry);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -100,22 +100,6 @@ static void rt2800usb_stop_queue(struct
+ 	}
+ }
+ 
+-/*
+- * test if there is an entry in any TX queue for which DMA is done
+- * but the TX status has not been returned yet
+- */
+-static bool rt2800usb_txstatus_pending(struct rt2x00_dev *rt2x00dev)
+-{
+-	struct data_queue *queue;
+-
+-	tx_queue_for_each(rt2x00dev, queue) {
+-		if (rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE) !=
+-		    rt2x00queue_get_entry(queue, Q_INDEX_DONE))
+-			return true;
+-	}
+-	return false;
+-}
+-
+ #define TXSTATUS_READ_INTERVAL 1000000
+ 
+ static bool rt2800usb_tx_sta_fifo_read_completed(struct rt2x00_dev *rt2x00dev,
+@@ -145,7 +129,7 @@ static bool rt2800usb_tx_sta_fifo_read_c
+ 	if (rt2800_txstatus_timeout(rt2x00dev))
+ 		queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
+ 
+-	if (rt2800usb_txstatus_pending(rt2x00dev)) {
++	if (rt2800_txstatus_pending(rt2x00dev)) {
+ 		/* Read register after 1 ms */
+ 		hrtimer_start(&rt2x00dev->txstatus_timer,
+ 			      TXSTATUS_READ_INTERVAL,
+@@ -160,7 +144,7 @@ stop_reading:
+ 	 * clear_bit someone could do rt2x00usb_interrupt_txdone, so recheck
+ 	 * here again if status reading is needed.
+ 	 */
+-	if (rt2800usb_txstatus_pending(rt2x00dev) &&
++	if (rt2800_txstatus_pending(rt2x00dev) &&
+ 	    !test_and_set_bit(TX_STATUS_READING, &rt2x00dev->flags))
+ 		return true;
+ 	else
+@@ -489,7 +473,7 @@ static void rt2800usb_work_txdone(struct
+ 		 * if the medium is busy, thus the TX_STA_FIFO entry is
+ 		 * also delayed -> use a timer to retrieve it.
+ 		 */
+-		if (rt2800usb_txstatus_pending(rt2x00dev))
++		if (rt2800_txstatus_pending(rt2x00dev))
+ 			rt2800usb_async_read_tx_status(rt2x00dev);
+ 	}
+ }
diff -uprN a/package/kernel/mac80211/patches/rt2x00/027-rt2800mmio-fetch-tx-status-changes.patch b/package/kernel/mac80211/patches/rt2x00/027-rt2800mmio-fetch-tx-status-changes.patch
--- a/package/kernel/mac80211/patches/rt2x00/027-rt2800mmio-fetch-tx-status-changes.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/027-rt2800mmio-fetch-tx-status-changes.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,61 @@
+From f6a9618198e190a2ba09ce3f0aa8e9ee1763bd38 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:34 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804443
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 24/28] rt2800mmio: fetch tx status changes
+
+Prepare to use rt2800mmio_fetch_txstatus() in concurrent manner and drop
+return value since is not longer needed.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800mmio.c | 17 +++++++++--------
+ 1 file changed, 9 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -255,12 +255,12 @@ void rt2800mmio_autowake_tasklet(unsigne
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_autowake_tasklet);
+ 
+-static bool rt2800mmio_fetch_txstatus(struct rt2x00_dev *rt2x00dev)
++static void rt2800mmio_fetch_txstatus(struct rt2x00_dev *rt2x00dev)
+ {
+ 	u32 status;
+-	bool more = false;
++	unsigned long flags;
+ 
+-	/* FIXEME: rewrite this comment
++	/*
+ 	 * The TX_FIFO_STATUS interrupt needs special care. We should
+ 	 * read TX_STA_FIFO but we should do it immediately as otherwise
+ 	 * the register can overflow and we would lose status reports.
+@@ -271,20 +271,21 @@ static bool rt2800mmio_fetch_txstatus(st
+ 	 * because we can schedule the tasklet multiple times (when the
+ 	 * interrupt fires again during tx status processing).
+ 	 *
+-	 * txstatus tasklet is called with INT_SOURCE_CSR_TX_FIFO_STATUS
+-	 * disabled so have only one producer and one consumer - we don't
+-	 * need to lock the kfifo.
++	 * We also read statuses from tx status timeout timer, use
++	 * lock to prevent concurent writes to fifo.
+ 	 */
++
++	spin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);
++
+ 	while (!kfifo_is_full(&rt2x00dev->txstatus_fifo)) {
+ 		status = rt2x00mmio_register_read(rt2x00dev, TX_STA_FIFO);
+ 		if (!rt2x00_get_field32(status, TX_STA_FIFO_VALID))
+ 			break;
+ 
+ 		kfifo_put(&rt2x00dev->txstatus_fifo, status);
+-		more = true;
+ 	}
+ 
+-	return more;
++	spin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);
+ }
+ 
+ void rt2800mmio_txstatus_tasklet(unsigned long data)
diff -uprN a/package/kernel/mac80211/patches/rt2x00/028-rt2800mmio-use-timer-and-work-for-handling-tx-status.patch b/package/kernel/mac80211/patches/rt2x00/028-rt2800mmio-use-timer-and-work-for-handling-tx-status.patch
--- a/package/kernel/mac80211/patches/rt2x00/028-rt2800mmio-use-timer-and-work-for-handling-tx-status.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/028-rt2800mmio-use-timer-and-work-for-handling-tx-status.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,194 @@
+From 175c2548332b45b144af673e70fdbb1a947d7aba Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:35 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804445
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 25/28] rt2800mmio: use timer and work for handling tx statuses
+ timeouts
+
+Sometimes we can get into situation when there are pending statuses,
+but we do not get INT_SOURCE_CSR_TX_FIFO_STATUS. Handle this situation
+by arming timeout timer and read statuses (it will fix case when
+we just do not have irq) and queue work to handle case we missed
+statues from hardware FIFO.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ .../net/wireless/ralink/rt2x00/rt2800mmio.c   | 81 +++++++++++++++++--
+ .../net/wireless/ralink/rt2x00/rt2800mmio.h   |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800pci.c    |  2 +-
+ .../net/wireless/ralink/rt2x00/rt2800soc.c    |  2 +-
+ .../net/wireless/ralink/rt2x00/rt2x00dev.c    |  4 +
+ 5 files changed, 82 insertions(+), 8 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -426,6 +426,9 @@ void rt2800mmio_start_queue(struct data_
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_start_queue);
+ 
++/* 200 ms */
++#define TXSTATUS_TIMEOUT 200000000
++
+ void rt2800mmio_kick_queue(struct data_queue *queue)
+ {
+ 	struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
+@@ -440,6 +443,8 @@ void rt2800mmio_kick_queue(struct data_q
+ 		entry = rt2x00queue_get_entry(queue, Q_INDEX);
+ 		rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),
+ 					  entry->entry_idx);
++		hrtimer_start(&rt2x00dev->txstatus_timer,
++			      TXSTATUS_TIMEOUT, HRTIMER_MODE_REL);
+ 		break;
+ 	case QID_MGMT:
+ 		entry = rt2x00queue_get_entry(queue, Q_INDEX);
+@@ -484,12 +489,8 @@ void rt2800mmio_flush_queue(struct data_
+ 		 * For TX queues schedule completion tasklet to catch
+ 		 * tx status timeouts, othewise just wait.
+ 		 */
+-		if (tx_queue) {
+-			tasklet_disable(&rt2x00dev->txstatus_tasklet);
+-			rt2800_txdone(rt2x00dev, UINT_MAX);
+-			rt2800_txdone_nostatus(rt2x00dev);
+-			tasklet_enable(&rt2x00dev->txstatus_tasklet);
+-		}
++		if (tx_queue)
++			queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
+ 
+ 		/*
+ 		 * Wait for a little while to give the driver
+@@ -627,6 +628,10 @@ void rt2800mmio_clear_entry(struct queue
+ 		word = rt2x00_desc_read(entry_priv->desc, 1);
+ 		rt2x00_set_field32(&word, TXD_W1_DMA_DONE, 1);
+ 		rt2x00_desc_write(entry_priv->desc, 1, word);
++
++		/* If last entry stop txstatus timer */
++		if (entry->queue->length == 1)
++			hrtimer_cancel(&rt2x00dev->txstatus_timer);
+ 	}
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_clear_entry);
+@@ -759,6 +764,70 @@ int rt2800mmio_enable_radio(struct rt2x0
+ }
+ EXPORT_SYMBOL_GPL(rt2800mmio_enable_radio);
+ 
++static void rt2800mmio_work_txdone(struct work_struct *work)
++{
++	struct rt2x00_dev *rt2x00dev =
++	    container_of(work, struct rt2x00_dev, txdone_work);
++
++	if (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
++		return;
++
++	while (!kfifo_is_empty(&rt2x00dev->txstatus_fifo) ||
++	       rt2800_txstatus_timeout(rt2x00dev)) {
++
++		tasklet_disable(&rt2x00dev->txstatus_tasklet);
++		rt2800_txdone(rt2x00dev, UINT_MAX);
++		rt2800_txdone_nostatus(rt2x00dev);
++		tasklet_enable(&rt2x00dev->txstatus_tasklet);
++	}
++
++	if (rt2800_txstatus_pending(rt2x00dev))
++		hrtimer_start(&rt2x00dev->txstatus_timer,
++			      TXSTATUS_TIMEOUT, HRTIMER_MODE_REL);
++}
++
++static enum hrtimer_restart rt2800mmio_tx_sta_fifo_timeout(struct hrtimer *timer)
++{
++	struct rt2x00_dev *rt2x00dev =
++	    container_of(timer, struct rt2x00_dev, txstatus_timer);
++
++	if (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))
++		goto out;
++
++	if (!rt2800_txstatus_pending(rt2x00dev))
++		goto out;
++
++	rt2800mmio_fetch_txstatus(rt2x00dev);
++	if (!kfifo_is_empty(&rt2x00dev->txstatus_fifo))
++		tasklet_schedule(&rt2x00dev->txstatus_tasklet);
++	else
++		queue_work(rt2x00dev->workqueue, &rt2x00dev->txdone_work);
++out:
++	return HRTIMER_NORESTART;
++}
++
++int rt2800mmio_probe_hw(struct rt2x00_dev *rt2x00dev)
++{
++	int retval;
++
++	retval = rt2800_probe_hw(rt2x00dev);
++	if (retval)
++		return retval;
++
++	/*
++	 * Set txstatus timer function.
++	 */
++	rt2x00dev->txstatus_timer.function = rt2800mmio_tx_sta_fifo_timeout;
++
++	/*
++	 * Overwrite TX done handler
++	 */
++	INIT_WORK(&rt2x00dev->txdone_work, rt2800mmio_work_txdone);
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(rt2800mmio_probe_hw);
++
+ MODULE_AUTHOR(DRV_PROJECT);
+ MODULE_VERSION(DRV_VERSION);
+ MODULE_DESCRIPTION("rt2800 MMIO library");
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
+@@ -153,6 +153,7 @@ void rt2800mmio_stop_queue(struct data_q
+ void rt2800mmio_queue_init(struct data_queue *queue);
+ 
+ /* Initialization functions */
++int rt2800mmio_probe_hw(struct rt2x00_dev *rt2x00dev);
+ bool rt2800mmio_get_entry_state(struct queue_entry *entry);
+ void rt2800mmio_clear_entry(struct queue_entry *entry);
+ int rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+@@ -346,7 +346,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.tbtt_tasklet		= rt2800mmio_tbtt_tasklet,
+ 	.rxdone_tasklet		= rt2800mmio_rxdone_tasklet,
+ 	.autowake_tasklet	= rt2800mmio_autowake_tasklet,
+-	.probe_hw		= rt2800_probe_hw,
++	.probe_hw		= rt2800mmio_probe_hw,
+ 	.get_firmware_name	= rt2800pci_get_firmware_name,
+ 	.check_firmware		= rt2800_check_firmware,
+ 	.load_firmware		= rt2800_load_firmware,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -185,7 +185,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.tbtt_tasklet		= rt2800mmio_tbtt_tasklet,
+ 	.rxdone_tasklet		= rt2800mmio_rxdone_tasklet,
+ 	.autowake_tasklet	= rt2800mmio_autowake_tasklet,
+-	.probe_hw		= rt2800_probe_hw,
++	.probe_hw		= rt2800mmio_probe_hw,
+ 	.get_firmware_name	= rt2800soc_get_firmware_name,
+ 	.check_firmware		= rt2800soc_check_firmware,
+ 	.load_firmware		= rt2800soc_load_firmware,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+@@ -1391,6 +1391,8 @@ int rt2x00lib_probe_dev(struct rt2x00_de
+ 	mutex_init(&rt2x00dev->conf_mutex);
+ 	INIT_LIST_HEAD(&rt2x00dev->bar_list);
+ 	spin_lock_init(&rt2x00dev->bar_list_lock);
++	hrtimer_init(&rt2x00dev->txstatus_timer, CLOCK_MONOTONIC,
++		     HRTIMER_MODE_REL);
+ 
+ 	set_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags);
+ 
+@@ -1515,6 +1517,8 @@ void rt2x00lib_remove_dev(struct rt2x00_
+ 	cancel_delayed_work_sync(&rt2x00dev->autowakeup_work);
+ 	cancel_work_sync(&rt2x00dev->sleep_work);
+ 
++	hrtimer_cancel(&rt2x00dev->txstatus_timer);
++
+ 	/*
+ 	 * Kill the tx status tasklet.
+ 	 */
diff -uprN a/package/kernel/mac80211/patches/rt2x00/029-rt2x00-remove-last_nostatus_check.patch b/package/kernel/mac80211/patches/rt2x00/029-rt2x00-remove-last_nostatus_check.patch
--- a/package/kernel/mac80211/patches/rt2x00/029-rt2x00-remove-last_nostatus_check.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/029-rt2x00-remove-last_nostatus_check.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,57 @@
+From 6013a91f15c9dabd668d5736652b9bcfb0ef0378 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:36 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804447
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 26/28] rt2x00: remove last_nostatus_check
+
+We do not any longer check txstatus timeout from tasklet, so do not need
+this optimization.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c   | 9 ---------
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h      | 2 --
+ drivers/net/wireless/ralink/rt2x00/rt2x00queue.c | 1 -
+ 3 files changed, 12 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1164,15 +1164,6 @@ bool rt2800_txstatus_timeout(struct rt2x
+ 	struct data_queue *queue;
+ 	struct queue_entry *entry;
+ 
+-	if (!test_bit(DEVICE_STATE_FLUSHING, &rt2x00dev->flags)) {
+-		unsigned long tout = msecs_to_jiffies(1000);
+-
+-		if (time_before(jiffies, rt2x00dev->last_nostatus_check + tout))
+-			return false;
+-	}
+-
+-	rt2x00dev->last_nostatus_check = jiffies;
+-
+ 	tx_queue_for_each(rt2x00dev, queue) {
+ 		entry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);
+ 		if (rt2800_entry_txstatus_timeout(rt2x00dev, entry))
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -980,8 +980,6 @@ struct rt2x00_dev {
+ 	 */
+ 	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
+ 
+-	unsigned long last_nostatus_check;
+-
+ 	/*
+ 	 * Timer to ensure tx status reports are read (rt2800usb).
+ 	 */
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.c
+@@ -1042,7 +1042,6 @@ void rt2x00queue_start_queues(struct rt2
+ 	 */
+ 	tx_queue_for_each(rt2x00dev, queue)
+ 		rt2x00queue_start_queue(queue);
+-	rt2x00dev->last_nostatus_check = jiffies;
+ 
+ 	rt2x00queue_start_queue(rt2x00dev->rx);
+ }
diff -uprN a/package/kernel/mac80211/patches/rt2x00/030-rt2x00-remove-not-used-entry-field.patch b/package/kernel/mac80211/patches/rt2x00/030-rt2x00-remove-not-used-entry-field.patch
--- a/package/kernel/mac80211/patches/rt2x00/030-rt2x00-remove-not-used-entry-field.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/030-rt2x00-remove-not-used-entry-field.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,34 @@
+From 2758f09b22bc08e89e0391486b2d707ad2479599 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:37 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804449
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 27/28] rt2x00: remove not used entry field
+
+Remove not used any longer queue_entry field and flag.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00queue.h | 3 ---
+ 1 file changed, 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
+@@ -361,7 +361,6 @@ enum queue_entry_flags {
+ 	ENTRY_DATA_PENDING,
+ 	ENTRY_DATA_IO_FAILED,
+ 	ENTRY_DATA_STATUS_PENDING,
+-	ENTRY_DATA_STATUS_SET,
+ };
+ 
+ /**
+@@ -387,8 +386,6 @@ struct queue_entry {
+ 
+ 	unsigned int entry_idx;
+ 
+-	u32 status;
+-
+ 	void *priv_data;
+ };
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/031-rt2x00mmio-remove-legacy-comment.patch b/package/kernel/mac80211/patches/rt2x00/031-rt2x00mmio-remove-legacy-comment.patch
--- a/package/kernel/mac80211/patches/rt2x00/031-rt2x00mmio-remove-legacy-comment.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/031-rt2x00mmio-remove-legacy-comment.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,26 @@
+From f44e145869bb517460648e4ed71b7e9001964d06 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 9 Feb 2019 12:08:38 +0100
+X-Patchwork-Submitter: Stanislaw Gruszka <sgruszka@redhat.com>
+X-Patchwork-Id: 10804451
+X-Patchwork-Delegate: kvalo@adurom.com
+Subject: [PATCH 28/28] rt2x00mmio: remove legacy comment
+
+Remove comment about fields that ware removed.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00mmio.h | 2 --
+ 1 file changed, 2 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00mmio.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00mmio.h
+@@ -80,8 +80,6 @@ int rt2x00mmio_regbusy_read(struct rt2x0
+  *
+  * @desc: Pointer to device descriptor
+  * @desc_dma: DMA pointer to &desc.
+- * @data: Pointer to device's entry memory.
+- * @data_dma: DMA pointer to &data.
+  */
+ struct queue_entry_priv_mmio {
+ 	__le32 *desc;
diff -uprN a/package/kernel/mac80211/patches/rt2x00/050-rt2x00-add-RT3883-support.patch b/package/kernel/mac80211/patches/rt2x00/050-rt2x00-add-RT3883-support.patch
--- a/package/kernel/mac80211/patches/rt2x00/050-rt2x00-add-RT3883-support.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/050-rt2x00-add-RT3883-support.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,959 @@
+From d0e61a0f7cca51ce340a5a73595189972122ff25 Mon Sep 17 00:00:00 2001
+From: Gabor Juhos <juhosg@openwrt.org>
+Date: Wed, 24 Apr 2019 09:49:24 +0200
+Subject: [PATCH] rt2x00: add RT3883 support
+
+Patch add support for RT3883 chip. Code was taken direclty
+from openwrt project and merge into one patch.
+
+Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800.h   |  19 +-
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 598 +++++++++++++++++-
+ .../net/wireless/ralink/rt2x00/rt2800soc.c    |   9 +-
+ 3 files changed, 607 insertions(+), 19 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
+@@ -48,7 +48,8 @@
+  * RF2853 2.4G/5G 3T3R
+  * RF3320 2.4G 1T1R(RT3350/RT3370/RT3390)
+  * RF3322 2.4G 2T2R(RT3352/RT3371/RT3372/RT3391/RT3392)
+- * RF3053 2.4G/5G 3T3R(RT3883/RT3563/RT3573/RT3593/RT3662)
++ * RF3053 2.4G/5G 3T3R(RT3563/RT3573/RT3593)
++ * RF3853 2.4G/5G 3T3R(RT3883/RT3662)
+  * RF5592 2.4G/5G 2T2R
+  * RF3070 2.4G 1T1R
+  * RF5360 2.4G 1T1R
+@@ -72,6 +73,7 @@
+ #define RF5592				0x000f
+ #define RF3070				0x3070
+ #define RF3290				0x3290
++#define RF3853				0x3853
+ #define RF5350				0x5350
+ #define RF5360				0x5360
+ #define RF5362				0x5362
+@@ -1726,6 +1728,20 @@
+ #define TX_PWR_CFG_9B_STBC_MCS7		FIELD32(0x000000ff)
+ 
+ /*
++ * TX_TXBF_CFG:
++ */
++#define TX_TXBF_CFG_0			0x138c
++#define TX_TXBF_CFG_1			0x13a4
++#define TX_TXBF_CFG_2			0x13a8
++#define TX_TXBF_CFG_3			0x13ac
++
++/*
++ * TX_FBK_CFG_3S:
++ */
++#define TX_FBK_CFG_3S_0			0x13c4
++#define TX_FBK_CFG_3S_1			0x13c8
++
++/*
+  * RX_FILTER_CFG: RX configuration register.
+  */
+ #define RX_FILTER_CFG			0x1400
+@@ -2296,6 +2312,7 @@ struct mac_iveiv_entry {
+ /*
+  * RFCSR 2:
+  */
++#define RFCSR2_RESCAL_BP		FIELD8(0x40)
+ #define RFCSR2_RESCAL_EN		FIELD8(0x80)
+ #define RFCSR2_RX2_EN_MT7620		FIELD8(0x02)
+ #define RFCSR2_TX2_EN_MT7620		FIELD8(0x20)
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -381,7 +381,8 @@ static unsigned int rt2800_eeprom_word_i
+ 		      wiphy_name(rt2x00dev->hw->wiphy), word))
+ 		return 0;
+ 
+-	if (rt2x00_rt(rt2x00dev, RT3593))
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883))
+ 		map = rt2800_eeprom_map_ext;
+ 	else
+ 		map = rt2800_eeprom_map;
+@@ -590,6 +591,7 @@ void rt2800_get_txwi_rxwi_size(struct rt
+ {
+ 	switch (rt2x00dev->chip.rt) {
+ 	case RT3593:
++	case RT3883:
+ 		*txwi_size = TXWI_DESC_SIZE_4WORDS;
+ 		*rxwi_size = RXWI_DESC_SIZE_5WORDS;
+ 		break;
+@@ -2180,7 +2182,8 @@ void rt2800_config_ant(struct rt2x00_dev
+ 	rt2800_bbp_write(rt2x00dev, 3, r3);
+ 	rt2800_bbp_write(rt2x00dev, 1, r1);
+ 
+-	if (rt2x00_rt(rt2x00dev, RT3593)) {
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883)) {
+ 		if (ant->rx_chain_num == 1)
+ 			rt2800_bbp_write(rt2x00dev, 86, 0x00);
+ 		else
+@@ -2202,7 +2205,8 @@ static void rt2800_config_lna_gain(struc
+ 		eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_LNA);
+ 		lna_gain = rt2x00_get_field16(eeprom, EEPROM_LNA_A0);
+ 	} else if (libconf->rf.channel <= 128) {
+-		if (rt2x00_rt(rt2x00dev, RT3593)) {
++		if (rt2x00_rt(rt2x00dev, RT3593) ||
++		    rt2x00_rt(rt2x00dev, RT3883)) {
+ 			eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2);
+ 			lna_gain = rt2x00_get_field16(eeprom,
+ 						      EEPROM_EXT_LNA2_A1);
+@@ -2212,7 +2216,8 @@ static void rt2800_config_lna_gain(struc
+ 						      EEPROM_RSSI_BG2_LNA_A1);
+ 		}
+ 	} else {
+-		if (rt2x00_rt(rt2x00dev, RT3593)) {
++		if (rt2x00_rt(rt2x00dev, RT3593) ||
++		    rt2x00_rt(rt2x00dev, RT3883)) {
+ 			eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2);
+ 			lna_gain = rt2x00_get_field16(eeprom,
+ 						      EEPROM_EXT_LNA2_A2);
+@@ -2880,6 +2885,211 @@ static void rt2800_config_channel_rf3053
+ 	}
+ }
+ 
++static void rt2800_config_channel_rf3853(struct rt2x00_dev *rt2x00dev,
++					 struct ieee80211_conf *conf,
++					 struct rf_channel *rf,
++					 struct channel_info *info)
++{
++	u8 rfcsr;
++	u8 bbp;
++	u8 pwr1, pwr2, pwr3;
++
++	const bool txbf_enabled = false; /* TODO */
++
++	/* TODO: add band selection */
++
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
++	else if (rf->channel < 132)
++		rt2800_rfcsr_write(rt2x00dev, 6, 0x80);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
++
++	rt2800_rfcsr_write(rt2x00dev, 8, rf->rf1);
++	rt2800_rfcsr_write(rt2x00dev, 9, rf->rf3);
++
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 11, 0x46);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 11, 0x48);
++
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 12, 0x1a);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 12, 0x52);
++
++	rt2800_rfcsr_write(rt2x00dev, 13, 0x12);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RF_BLOCK_EN, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_PLL_PD, 1);
++
++	switch (rt2x00dev->default_ant.tx_chain_num) {
++	case 3:
++		rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 1);
++		/* fallthrough */
++	case 2:
++		rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 1);
++		/* fallthrough */
++	case 1:
++		rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 1);
++		break;
++	}
++
++	switch (rt2x00dev->default_ant.rx_chain_num) {
++	case 3:
++		rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 1);
++		/* fallthrough */
++	case 2:
++		rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 1);
++		/* fallthrough */
++	case 1:
++		rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 1);
++		break;
++	}
++	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
++
++	rt2800_freq_cal_mode1(rt2x00dev);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 30);
++	if (!conf_is_ht40(conf))
++		rfcsr &= ~(0x06);
++	else
++		rfcsr |= 0x06;
++	rt2800_rfcsr_write(rt2x00dev, 30, rfcsr);
++
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 31, 0xa0);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
++
++	if (conf_is_ht40(conf))
++		rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 32, 0xd8);
++
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 34, 0x3c);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 34, 0x20);
++
++	/* loopback RF_BS */
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 36);
++	if (rf->channel <= 14)
++		rt2x00_set_field8(&rfcsr, RFCSR36_RF_BS, 1);
++	else
++		rt2x00_set_field8(&rfcsr, RFCSR36_RF_BS, 0);
++	rt2800_rfcsr_write(rt2x00dev, 36, rfcsr);
++
++	if (rf->channel <= 14)
++		rfcsr = 0x23;
++	else if (rf->channel < 100)
++		rfcsr = 0x36;
++	else if (rf->channel < 132)
++		rfcsr = 0x32;
++	else
++		rfcsr = 0x30;
++
++	if (txbf_enabled)
++		rfcsr |= 0x40;
++
++	rt2800_rfcsr_write(rt2x00dev, 39, rfcsr);
++
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 44, 0x93);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 44, 0x9b);
++
++	if (rf->channel <= 14)
++		rfcsr = 0xbb;
++	else if (rf->channel < 100)
++		rfcsr = 0xeb;
++	else if (rf->channel < 132)
++		rfcsr = 0xb3;
++	else
++		rfcsr = 0x9b;
++	rt2800_rfcsr_write(rt2x00dev, 45, rfcsr);
++
++	if (rf->channel <= 14)
++		rfcsr = 0x8e;
++	else
++		rfcsr = 0x8a;
++
++	if (txbf_enabled)
++		rfcsr |= 0x20;
++
++	rt2800_rfcsr_write(rt2x00dev, 49, rfcsr);
++
++	rt2800_rfcsr_write(rt2x00dev, 50, 0x86);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 51);
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 51, 0x75);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 51, 0x51);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 52);
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 52, 0x45);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 52, 0x05);
++
++	if (rf->channel <= 14) {
++		pwr1 = info->default_power1 & 0x1f;
++		pwr2 = info->default_power2 & 0x1f;
++		pwr3 = info->default_power3 & 0x1f;
++	} else {
++		pwr1 = 0x48 | ((info->default_power1 & 0x18) << 1) |
++			(info->default_power1 & 0x7);
++		pwr2 = 0x48 | ((info->default_power2 & 0x18) << 1) |
++			(info->default_power2 & 0x7);
++		pwr3 = 0x48 | ((info->default_power3 & 0x18) << 1) |
++			(info->default_power3 & 0x7);
++	}
++
++	rt2800_rfcsr_write(rt2x00dev, 53, pwr1);
++	rt2800_rfcsr_write(rt2x00dev, 54, pwr2);
++	rt2800_rfcsr_write(rt2x00dev, 55, pwr3);
++
++	rt2x00_dbg(rt2x00dev, "Channel:%d, pwr1:%02x, pwr2:%02x, pwr3:%02x\n",
++		   rf->channel, pwr1, pwr2, pwr3);
++
++	bbp = (info->default_power1 >> 5) |
++	      ((info->default_power2 & 0xe0) >> 1);
++	rt2800_bbp_write(rt2x00dev, 109, bbp);
++
++	bbp = rt2800_bbp_read(rt2x00dev, 110);
++	bbp &= 0x0f;
++	bbp |= (info->default_power3 & 0xe0) >> 1;
++	rt2800_bbp_write(rt2x00dev, 110, bbp);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 57);
++	if (rf->channel <= 14)
++		rt2800_rfcsr_write(rt2x00dev, 57, 0x6e);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 57, 0x3e);
++
++	/* Enable RF tuning */
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 3);
++	rt2x00_set_field8(&rfcsr, RFCSR3_VCOCAL_EN, 1);
++	rt2800_rfcsr_write(rt2x00dev, 3, rfcsr);
++
++	udelay(2000);
++
++	bbp = rt2800_bbp_read(rt2x00dev, 49);
++	/* clear update flag */
++	rt2800_bbp_write(rt2x00dev, 49, bbp & 0xfe);
++	rt2800_bbp_write(rt2x00dev, 49, bbp);
++
++	/* TODO: add calibration for TxBF */
++}
++
+ #define POWER_BOUND		0x27
+ #define POWER_BOUND_5G		0x2b
+ 
+@@ -3683,19 +3893,51 @@ static char rt2800_txpower_to_dev(struct
+ 				  unsigned int channel,
+ 				  char txpower)
+ {
+-	if (rt2x00_rt(rt2x00dev, RT3593))
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883))
+ 		txpower = rt2x00_get_field8(txpower, EEPROM_TXPOWER_ALC);
+ 
+ 	if (channel <= 14)
+ 		return clamp_t(char, txpower, MIN_G_TXPOWER, MAX_G_TXPOWER);
+ 
+-	if (rt2x00_rt(rt2x00dev, RT3593))
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883))
+ 		return clamp_t(char, txpower, MIN_A_TXPOWER_3593,
+ 			       MAX_A_TXPOWER_3593);
+ 	else
+ 		return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);
+ }
+ 
++static void rt3883_bbp_adjust(struct rt2x00_dev *rt2x00dev,
++			      struct rf_channel *rf)
++{
++	u8 bbp;
++
++	bbp = (rf->channel > 14) ? 0x48 : 0x38;
++	rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, bbp);
++
++	rt2800_bbp_write(rt2x00dev, 69, 0x12);
++
++	if (rf->channel <= 14) {
++		rt2800_bbp_write(rt2x00dev, 70, 0x0a);
++	} else {
++		/* Disable CCK packet detection */
++		rt2800_bbp_write(rt2x00dev, 70, 0x00);
++	}
++
++	rt2800_bbp_write(rt2x00dev, 73, 0x10);
++
++	if (rf->channel > 14) {
++		rt2800_bbp_write(rt2x00dev, 62, 0x1d);
++		rt2800_bbp_write(rt2x00dev, 63, 0x1d);
++		rt2800_bbp_write(rt2x00dev, 64, 0x1d);
++	} else {
++		rt2800_bbp_write(rt2x00dev, 62, 0x2d);
++		rt2800_bbp_write(rt2x00dev, 63, 0x2d);
++		rt2800_bbp_write(rt2x00dev, 64, 0x2d);
++	}
++}
++
+ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 				  struct ieee80211_conf *conf,
+ 				  struct rf_channel *rf,
+@@ -3714,6 +3956,12 @@ static void rt2800_config_channel(struct
+ 			rt2800_txpower_to_dev(rt2x00dev, rf->channel,
+ 					      info->default_power3);
+ 
++	switch (rt2x00dev->chip.rt) {
++	case RT3883:
++		rt3883_bbp_adjust(rt2x00dev, rf);
++		break;
++	}
++
+ 	switch (rt2x00dev->chip.rf) {
+ 	case RF2020:
+ 	case RF3020:
+@@ -3734,6 +3982,9 @@ static void rt2800_config_channel(struct
+ 	case RF3322:
+ 		rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
+ 		break;
++	case RF3853:
++		rt2800_config_channel_rf3853(rt2x00dev, conf, rf, info);
++		break;
+ 	case RF3070:
+ 	case RF5350:
+ 	case RF5360:
+@@ -3815,6 +4066,15 @@ static void rt2800_config_channel(struct
+ 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 77, 0x98);
++	} else if (rt2x00_rt(rt2x00dev, RT3883)) {
++		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
++
++		if (rt2x00dev->default_ant.rx_chain_num > 1)
++			rt2800_bbp_write(rt2x00dev, 86, 0x46);
++		else
++			rt2800_bbp_write(rt2x00dev, 86, 0);
+ 	} else {
+ 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+@@ -3828,6 +4088,7 @@ static void rt2800_config_channel(struct
+ 		    !rt2x00_rt(rt2x00dev, RT6352)) {
+ 			if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
+ 				rt2800_bbp_write(rt2x00dev, 82, 0x62);
++				rt2800_bbp_write(rt2x00dev, 82, 0x62);
+ 				rt2800_bbp_write(rt2x00dev, 75, 0x46);
+ 			} else {
+ 				if (rt2x00_rt(rt2x00dev, RT3593))
+@@ -3836,19 +4097,22 @@ static void rt2800_config_channel(struct
+ 					rt2800_bbp_write(rt2x00dev, 82, 0x84);
+ 				rt2800_bbp_write(rt2x00dev, 75, 0x50);
+ 			}
+-			if (rt2x00_rt(rt2x00dev, RT3593))
++			if (rt2x00_rt(rt2x00dev, RT3593) ||
++			    rt2x00_rt(rt2x00dev, RT3883))
+ 				rt2800_bbp_write(rt2x00dev, 83, 0x8a);
+ 		}
+ 
+ 	} else {
+ 		if (rt2x00_rt(rt2x00dev, RT3572))
+ 			rt2800_bbp_write(rt2x00dev, 82, 0x94);
+-		else if (rt2x00_rt(rt2x00dev, RT3593))
++		else if (rt2x00_rt(rt2x00dev, RT3593) ||
++			 rt2x00_rt(rt2x00dev, RT3883))
+ 			rt2800_bbp_write(rt2x00dev, 82, 0x82);
+ 		else if (!rt2x00_rt(rt2x00dev, RT6352))
+ 			rt2800_bbp_write(rt2x00dev, 82, 0xf2);
+ 
+-		if (rt2x00_rt(rt2x00dev, RT3593))
++		if (rt2x00_rt(rt2x00dev, RT3593) ||
++		    rt2x00_rt(rt2x00dev, RT3883))
+ 			rt2800_bbp_write(rt2x00dev, 83, 0x9a);
+ 
+ 		if (rt2x00_has_cap_external_lna_a(rt2x00dev))
+@@ -3984,6 +4248,23 @@ static void rt2800_config_channel(struct
+ 		usleep_range(1000, 1500);
+ 	}
+ 
++	if (rt2x00_rt(rt2x00dev, RT3883)) {
++		if (!conf_is_ht40(conf))
++			rt2800_bbp_write(rt2x00dev, 105, 0x34);
++		else
++			rt2800_bbp_write(rt2x00dev, 105, 0x04);
++
++		/* AGC init */
++		if (rf->channel <= 14)
++			reg = 0x2e + rt2x00dev->lna_gain;
++		else
++			reg = 0x20 + ((rt2x00dev->lna_gain * 5) / 3);
++
++		rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, reg);
++
++		usleep_range(1000, 1500);
++	}
++
+ 	if (rt2x00_rt(rt2x00dev, RT5592) || rt2x00_rt(rt2x00dev, RT6352)) {
+ 		reg = 0x10;
+ 		if (!conf_is_ht40(conf)) {
+@@ -4243,6 +4524,9 @@ static u8 rt2800_compensate_txpower(stru
+ 	if (rt2x00_rt(rt2x00dev, RT3593))
+ 		return min_t(u8, txpower, 0xc);
+ 
++	if (rt2x00_rt(rt2x00dev, RT3883))
++		return min_t(u8, txpower, 0xf);
++
+ 	if (rt2x00_has_cap_power_limit(rt2x00dev)) {
+ 		/*
+ 		 * Check if eirp txpower exceed txpower_limit.
+@@ -5004,7 +5288,8 @@ static void rt2800_config_txpower(struct
+ 				  struct ieee80211_channel *chan,
+ 				  int power_level)
+ {
+-	if (rt2x00_rt(rt2x00dev, RT3593))
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883))
+ 		rt2800_config_txpower_rt3593(rt2x00dev, chan, power_level);
+ 	else if (rt2x00_rt(rt2x00dev, RT6352))
+ 		rt2800_config_txpower_rt6352(rt2x00dev, chan, power_level);
+@@ -5051,6 +5336,7 @@ void rt2800_vco_calibration(struct rt2x0
+ 	case RF3053:
+ 	case RF3070:
+ 	case RF3290:
++	case RF3853:
+ 	case RF5350:
+ 	case RF5360:
+ 	case RF5362:
+@@ -5251,7 +5537,8 @@ static u8 rt2800_get_default_vgc(struct
+ 		else
+ 			vgc = 0x2e + rt2x00dev->lna_gain;
+ 	} else { /* 5GHZ band */
+-		if (rt2x00_rt(rt2x00dev, RT3593))
++		if (rt2x00_rt(rt2x00dev, RT3593) ||
++		    rt2x00_rt(rt2x00dev, RT3883))
+ 			vgc = 0x20 + (rt2x00dev->lna_gain * 5) / 3;
+ 		else if (rt2x00_rt(rt2x00dev, RT5592))
+ 			vgc = 0x24 + (2 * rt2x00dev->lna_gain);
+@@ -5271,7 +5558,8 @@ static inline void rt2800_set_vgc(struct
+ {
+ 	if (qual->vgc_level != vgc_level) {
+ 		if (rt2x00_rt(rt2x00dev, RT3572) ||
+-		    rt2x00_rt(rt2x00dev, RT3593)) {
++		    rt2x00_rt(rt2x00dev, RT3593) ||
++		    rt2x00_rt(rt2x00dev, RT3883)) {
+ 			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
+ 						       vgc_level);
+ 		} else if (rt2x00_rt(rt2x00dev, RT5592)) {
+@@ -5318,6 +5606,11 @@ void rt2800_link_tuner(struct rt2x00_dev
+ 		}
+ 		break;
+ 
++	case RT3883:
++		if (qual->rssi > -65)
++			vgc += 0x10;
++		break;
++
+ 	case RT5592:
+ 		if (qual->rssi > -65)
+ 			vgc += 0x20;
+@@ -5470,6 +5763,12 @@ static int rt2800_init_registers(struct
+ 			rt2800_register_write(rt2x00dev, TX_SW_CFG2,
+ 					      0x00000000);
+ 		}
++	} else if (rt2x00_rt(rt2x00dev, RT3883)) {
++		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000402);
++		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00000000);
++		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00040000);
++		rt2800_register_write(rt2x00dev, TX_TXBF_CFG_0, 0x8000fc21);
++		rt2800_register_write(rt2x00dev, TX_TXBF_CFG_3, 0x00009c40);
+ 	} else if (rt2x00_rt(rt2x00dev, RT5390) ||
+ 		   rt2x00_rt(rt2x00dev, RT5392) ||
+ 		   rt2x00_rt(rt2x00dev, RT6352)) {
+@@ -5683,6 +5982,11 @@ static int rt2800_init_registers(struct
+ 	reg = rt2x00_rt(rt2x00dev, RT5592) ? 0x00000082 : 0x00000002;
+ 	rt2800_register_write(rt2x00dev, TXOP_HLDR_ET, reg);
+ 
++	if (rt2x00_rt(rt2x00dev, RT3883)) {
++		rt2800_register_write(rt2x00dev, TX_FBK_CFG_3S_0, 0x12111008);
++		rt2800_register_write(rt2x00dev, TX_FBK_CFG_3S_1, 0x16151413);
++	}
++
+ 	reg = rt2800_register_read(rt2x00dev, TX_RTS_CFG);
+ 	rt2x00_set_field32(&reg, TX_RTS_CFG_AUTO_RTS_RETRY_LIMIT, 7);
+ 	rt2x00_set_field32(&reg, TX_RTS_CFG_RTS_THRES,
+@@ -6299,6 +6603,47 @@ static void rt2800_init_bbp_3593(struct
+ 		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
+ }
+ 
++static void rt2800_init_bbp_3883(struct rt2x00_dev *rt2x00dev)
++{
++	rt2800_init_bbp_early(rt2x00dev);
++
++	rt2800_bbp_write(rt2x00dev, 4, 0x50);
++	rt2800_bbp_write(rt2x00dev, 47, 0x48);
++
++	rt2800_bbp_write(rt2x00dev, 86, 0x46);
++	rt2800_bbp_write(rt2x00dev, 88, 0x90);
++
++	rt2800_bbp_write(rt2x00dev, 92, 0x02);
++
++	rt2800_bbp_write(rt2x00dev, 103, 0xc0);
++	rt2800_bbp_write(rt2x00dev, 104, 0x92);
++	rt2800_bbp_write(rt2x00dev, 105, 0x34);
++	rt2800_bbp_write(rt2x00dev, 106, 0x12);
++	rt2800_bbp_write(rt2x00dev, 120, 0x50);
++	rt2800_bbp_write(rt2x00dev, 137, 0x0f);
++	rt2800_bbp_write(rt2x00dev, 163, 0x9d);
++
++	/* Set ITxBF timeout to 0x9C40=1000msec */
++	rt2800_bbp_write(rt2x00dev, 179, 0x02);
++	rt2800_bbp_write(rt2x00dev, 180, 0x00);
++	rt2800_bbp_write(rt2x00dev, 182, 0x40);
++	rt2800_bbp_write(rt2x00dev, 180, 0x01);
++	rt2800_bbp_write(rt2x00dev, 182, 0x9c);
++
++	rt2800_bbp_write(rt2x00dev, 179, 0x00);
++
++	/* Reprogram the inband interface to put right values in RXWI */
++	rt2800_bbp_write(rt2x00dev, 142, 0x04);
++	rt2800_bbp_write(rt2x00dev, 143, 0x3b);
++	rt2800_bbp_write(rt2x00dev, 142, 0x06);
++	rt2800_bbp_write(rt2x00dev, 143, 0xa0);
++	rt2800_bbp_write(rt2x00dev, 142, 0x07);
++	rt2800_bbp_write(rt2x00dev, 143, 0xa1);
++	rt2800_bbp_write(rt2x00dev, 142, 0x08);
++	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
++	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
++}
++
+ static void rt2800_init_bbp_53xx(struct rt2x00_dev *rt2x00dev)
+ {
+ 	int ant, div_mode;
+@@ -6743,6 +7088,9 @@ static void rt2800_init_bbp(struct rt2x0
+ 	case RT3593:
+ 		rt2800_init_bbp_3593(rt2x00dev);
+ 		return;
++	case RT3883:
++		rt2800_init_bbp_3883(rt2x00dev);
++		return;
+ 	case RT5390:
+ 	case RT5392:
+ 		rt2800_init_bbp_53xx(rt2x00dev);
+@@ -7614,6 +7962,144 @@ static void rt2800_init_rfcsr_5350(struc
+ 	rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
+ }
+ 
++static void rt2800_init_rfcsr_3883(struct rt2x00_dev *rt2x00dev)
++{
++	u8 rfcsr;
++
++	/* TODO: get the actual ECO value from the SoC */
++	const unsigned int eco = 5;
++
++	rt2800_rf_init_calibration(rt2x00dev, 2);
++
++	rt2800_rfcsr_write(rt2x00dev, 0, 0xe0);
++	rt2800_rfcsr_write(rt2x00dev, 1, 0x03);
++	rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
++	rt2800_rfcsr_write(rt2x00dev, 3, 0x20);
++	rt2800_rfcsr_write(rt2x00dev, 4, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 5, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 6, 0x40);
++	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 8, 0x5b);
++	rt2800_rfcsr_write(rt2x00dev, 9, 0x08);
++	rt2800_rfcsr_write(rt2x00dev, 10, 0xd3);
++	rt2800_rfcsr_write(rt2x00dev, 11, 0x48);
++	rt2800_rfcsr_write(rt2x00dev, 12, 0x1a);
++	rt2800_rfcsr_write(rt2x00dev, 13, 0x12);
++	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 16, 0x00);
++
++	/* RFCSR 17 will be initialized later based on the
++	 * frequency offset stored in the EEPROM
++	 */
++
++	rt2800_rfcsr_write(rt2x00dev, 18, 0x40);
++	rt2800_rfcsr_write(rt2x00dev, 19, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 22, 0x20);
++	rt2800_rfcsr_write(rt2x00dev, 23, 0xc0);
++	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 28, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 29, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
++	rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
++	rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
++	rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 34, 0x20);
++	rt2800_rfcsr_write(rt2x00dev, 35, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 36, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 37, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 38, 0x86);
++	rt2800_rfcsr_write(rt2x00dev, 39, 0x23);
++	rt2800_rfcsr_write(rt2x00dev, 40, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 41, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 42, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 44, 0x93);
++	rt2800_rfcsr_write(rt2x00dev, 45, 0xbb);
++	rt2800_rfcsr_write(rt2x00dev, 46, 0x60);
++	rt2800_rfcsr_write(rt2x00dev, 47, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 48, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 49, 0x8e);
++	rt2800_rfcsr_write(rt2x00dev, 50, 0x86);
++	rt2800_rfcsr_write(rt2x00dev, 51, 0x51);
++	rt2800_rfcsr_write(rt2x00dev, 52, 0x05);
++	rt2800_rfcsr_write(rt2x00dev, 53, 0x76);
++	rt2800_rfcsr_write(rt2x00dev, 54, 0x76);
++	rt2800_rfcsr_write(rt2x00dev, 55, 0x76);
++	rt2800_rfcsr_write(rt2x00dev, 56, 0xdb);
++	rt2800_rfcsr_write(rt2x00dev, 57, 0x3e);
++	rt2800_rfcsr_write(rt2x00dev, 58, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
++	rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
++
++	/* TODO: rx filter calibration? */
++
++	rt2800_bbp_write(rt2x00dev, 137, 0x0f);
++
++	rt2800_bbp_write(rt2x00dev, 163, 0x9d);
++
++	rt2800_bbp_write(rt2x00dev, 105, 0x05);
++
++	rt2800_bbp_write(rt2x00dev, 179, 0x02);
++	rt2800_bbp_write(rt2x00dev, 180, 0x00);
++	rt2800_bbp_write(rt2x00dev, 182, 0x40);
++	rt2800_bbp_write(rt2x00dev, 180, 0x01);
++	rt2800_bbp_write(rt2x00dev, 182, 0x9c);
++
++	rt2800_bbp_write(rt2x00dev, 179, 0x00);
++
++	rt2800_bbp_write(rt2x00dev, 142, 0x04);
++	rt2800_bbp_write(rt2x00dev, 143, 0x3b);
++	rt2800_bbp_write(rt2x00dev, 142, 0x06);
++	rt2800_bbp_write(rt2x00dev, 143, 0xa0);
++	rt2800_bbp_write(rt2x00dev, 142, 0x07);
++	rt2800_bbp_write(rt2x00dev, 143, 0xa1);
++	rt2800_bbp_write(rt2x00dev, 142, 0x08);
++	rt2800_bbp_write(rt2x00dev, 143, 0xa2);
++	rt2800_bbp_write(rt2x00dev, 148, 0xc8);
++
++	if (eco == 5) {
++		rt2800_rfcsr_write(rt2x00dev, 32, 0xd8);
++		rt2800_rfcsr_write(rt2x00dev, 33, 0x32);
++	}
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 2);
++	rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_BP, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_EN, 1);
++	rt2800_rfcsr_write(rt2x00dev, 2, rfcsr);
++	msleep(1);
++	rt2x00_set_field8(&rfcsr, RFCSR2_RESCAL_EN, 0);
++	rt2800_rfcsr_write(rt2x00dev, 2, rfcsr);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RF_BLOCK_EN, 1);
++	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 6);
++	rfcsr |= 0xc0;
++	rt2800_rfcsr_write(rt2x00dev, 6, rfcsr);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 22);
++	rfcsr |= 0x20;
++	rt2800_rfcsr_write(rt2x00dev, 22, rfcsr);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 46);
++	rfcsr |= 0x20;
++	rt2800_rfcsr_write(rt2x00dev, 46, rfcsr);
++
++	rfcsr = rt2800_rfcsr_read(rt2x00dev, 20);
++	rfcsr &= ~0xee;
++	rt2800_rfcsr_write(rt2x00dev, 20, rfcsr);
++}
++
+ static void rt2800_init_rfcsr_5390(struct rt2x00_dev *rt2x00dev)
+ {
+ 	rt2800_rf_init_calibration(rt2x00dev, 2);
+@@ -8456,6 +8942,9 @@ static void rt2800_init_rfcsr(struct rt2
+ 	case RT3390:
+ 		rt2800_init_rfcsr_3390(rt2x00dev);
+ 		break;
++	case RT3883:
++		rt2800_init_rfcsr_3883(rt2x00dev);
++		break;
+ 	case RT3572:
+ 		rt2800_init_rfcsr_3572(rt2x00dev);
+ 		break;
+@@ -8661,7 +9150,8 @@ static u8 rt2800_get_txmixer_gain_24g(st
+ {
+ 	u16 word;
+ 
+-	if (rt2x00_rt(rt2x00dev, RT3593))
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883))
+ 		return 0;
+ 
+ 	word = rt2800_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_BG);
+@@ -8675,7 +9165,8 @@ static u8 rt2800_get_txmixer_gain_5g(str
+ {
+ 	u16 word;
+ 
+-	if (rt2x00_rt(rt2x00dev, RT3593))
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883))
+ 		return 0;
+ 
+ 	word = rt2800_eeprom_read(rt2x00dev, EEPROM_TXMIXER_GAIN_A);
+@@ -8781,7 +9272,8 @@ static int rt2800_validate_eeprom(struct
+ 	word = rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_BG2);
+ 	if (abs(rt2x00_get_field16(word, EEPROM_RSSI_BG2_OFFSET2)) > 10)
+ 		rt2x00_set_field16(&word, EEPROM_RSSI_BG2_OFFSET2, 0);
+-	if (!rt2x00_rt(rt2x00dev, RT3593)) {
++	if (!rt2x00_rt(rt2x00dev, RT3593) &&
++	    !rt2x00_rt(rt2x00dev, RT3883)) {
+ 		if (rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0x00 ||
+ 		    rt2x00_get_field16(word, EEPROM_RSSI_BG2_LNA_A1) == 0xff)
+ 			rt2x00_set_field16(&word, EEPROM_RSSI_BG2_LNA_A1,
+@@ -8801,7 +9293,8 @@ static int rt2800_validate_eeprom(struct
+ 	word = rt2800_eeprom_read(rt2x00dev, EEPROM_RSSI_A2);
+ 	if (abs(rt2x00_get_field16(word, EEPROM_RSSI_A2_OFFSET2)) > 10)
+ 		rt2x00_set_field16(&word, EEPROM_RSSI_A2_OFFSET2, 0);
+-	if (!rt2x00_rt(rt2x00dev, RT3593)) {
++	if (!rt2x00_rt(rt2x00dev, RT3593) &&
++	    !rt2x00_rt(rt2x00dev, RT3883)) {
+ 		if (rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0x00 ||
+ 		    rt2x00_get_field16(word, EEPROM_RSSI_A2_LNA_A2) == 0xff)
+ 			rt2x00_set_field16(&word, EEPROM_RSSI_A2_LNA_A2,
+@@ -8809,7 +9302,8 @@ static int rt2800_validate_eeprom(struct
+ 	}
+ 	rt2800_eeprom_write(rt2x00dev, EEPROM_RSSI_A2, word);
+ 
+-	if (rt2x00_rt(rt2x00dev, RT3593)) {
++	if (rt2x00_rt(rt2x00dev, RT3593) ||
++	    rt2x00_rt(rt2x00dev, RT3883)) {
+ 		word = rt2800_eeprom_read(rt2x00dev, EEPROM_EXT_LNA2);
+ 		if (rt2x00_get_field16(word, EEPROM_EXT_LNA2_A1) == 0x00 ||
+ 		    rt2x00_get_field16(word, EEPROM_EXT_LNA2_A1) == 0xff)
+@@ -8848,6 +9342,8 @@ static int rt2800_init_eeprom(struct rt2
+ 		rf = rt2800_eeprom_read(rt2x00dev, EEPROM_CHIP_ID);
+ 	else if (rt2x00_rt(rt2x00dev, RT3352))
+ 		rf = RF3322;
++	else if (rt2x00_rt(rt2x00dev, RT3883))
++		rf = RF3853;
+ 	else if (rt2x00_rt(rt2x00dev, RT5350))
+ 		rf = RF5350;
+ 	else
+@@ -8868,6 +9364,7 @@ static int rt2800_init_eeprom(struct rt2
+ 	case RF3290:
+ 	case RF3320:
+ 	case RF3322:
++	case RF3853:
+ 	case RF5350:
+ 	case RF5360:
+ 	case RF5362:
+@@ -9154,6 +9651,66 @@ static const struct rf_channel rf_vals_3
+ 	{14,   0xF0,	 2,  0x18},
+ };
+ 
++static const struct rf_channel rf_vals_3853[] = {
++	{1,  241, 6, 2},
++	{2,  241, 6, 7},
++	{3,  242, 6, 2},
++	{4,  242, 6, 7},
++	{5,  243, 6, 2},
++	{6,  243, 6, 7},
++	{7,  244, 6, 2},
++	{8,  244, 6, 7},
++	{9,  245, 6, 2},
++	{10, 245, 6, 7},
++	{11, 246, 6, 2},
++	{12, 246, 6, 7},
++	{13, 247, 6, 2},
++	{14, 248, 6, 4},
++
++	{36, 0x56, 8, 4},
++	{38, 0x56, 8, 6},
++	{40, 0x56, 8, 8},
++	{44, 0x57, 8, 0},
++	{46, 0x57, 8, 2},
++	{48, 0x57, 8, 4},
++	{52, 0x57, 8, 8},
++	{54, 0x57, 8, 10},
++	{56, 0x58, 8, 0},
++	{60, 0x58, 8, 4},
++	{62, 0x58, 8, 6},
++	{64, 0x58, 8, 8},
++
++	{100, 0x5b, 8, 8},
++	{102, 0x5b, 8, 10},
++	{104, 0x5c, 8, 0},
++	{108, 0x5c, 8, 4},
++	{110, 0x5c, 8, 6},
++	{112, 0x5c, 8, 8},
++	{114, 0x5c, 8, 10},
++	{116, 0x5d, 8, 0},
++	{118, 0x5d, 8, 2},
++	{120, 0x5d, 8, 4},
++	{124, 0x5d, 8, 8},
++	{126, 0x5d, 8, 10},
++	{128, 0x5e, 8, 0},
++	{132, 0x5e, 8, 4},
++	{134, 0x5e, 8, 6},
++	{136, 0x5e, 8, 8},
++	{140, 0x5f, 8, 0},
++
++	{149, 0x5f, 8, 9},
++	{151, 0x5f, 8, 11},
++	{153, 0x60, 8, 1},
++	{157, 0x60, 8, 5},
++	{159, 0x60, 8, 7},
++	{161, 0x60, 8, 9},
++	{165, 0x61, 8, 1},
++	{167, 0x61, 8, 3},
++	{169, 0x61, 8, 5},
++	{171, 0x61, 8, 7},
++	{173, 0x61, 8, 9},
++};
++
+ static const struct rf_channel rf_vals_5592_xtal20[] = {
+ 	/* Channel, N, K, mod, R */
+ 	{1, 482, 4, 10, 3},
+@@ -9417,6 +9974,11 @@ static int rt2800_probe_hw_mode(struct r
+ 		spec->channels = rf_vals_3x;
+ 		break;
+ 
++	case RF3853:
++		spec->num_channels = ARRAY_SIZE(rf_vals_3853);
++		spec->channels = rf_vals_3853;
++		break;
++
+ 	case RF5592:
+ 		reg = rt2800_register_read(rt2x00dev, MAC_DEBUG_INDEX);
+ 		if (rt2x00_get_field32(reg, MAC_DEBUG_INDEX_XTAL)) {
+@@ -9536,6 +10098,7 @@ static int rt2800_probe_hw_mode(struct r
+ 	case RF3053:
+ 	case RF3070:
+ 	case RF3290:
++	case RF3853:
+ 	case RF5350:
+ 	case RF5360:
+ 	case RF5362:
+@@ -9578,6 +10141,7 @@ static int rt2800_probe_rt(struct rt2x00
+ 	case RT3390:
+ 	case RT3572:
+ 	case RT3593:
++	case RT3883:
+ 	case RT5350:
+ 	case RT5390:
+ 	case RT5392:
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -51,9 +51,16 @@ static bool rt2800soc_hwcrypt_disabled(s
+ 
+ static void rt2800soc_disable_radio(struct rt2x00_dev *rt2x00dev)
+ {
++	u32 reg;
++
+ 	rt2800_disable_radio(rt2x00dev);
+ 	rt2x00mmio_register_write(rt2x00dev, PWR_PIN_CFG, 0);
+-	rt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, 0);
++
++	reg = 0;
++	if (rt2x00_rt(rt2x00dev, RT3883))
++		rt2x00_set_field32(&reg, TX_PIN_CFG_RFTR_EN, 1);
++
++	rt2x00mmio_register_write(rt2x00dev, TX_PIN_CFG, reg);
+ }
+ 
+ static int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,
diff -uprN a/package/kernel/mac80211/patches/rt2x00/060-rt2x00-allow-to-specify-watchdog-interval.patch b/package/kernel/mac80211/patches/rt2x00/060-rt2x00-allow-to-specify-watchdog-interval.patch
--- a/package/kernel/mac80211/patches/rt2x00/060-rt2x00-allow-to-specify-watchdog-interval.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/060-rt2x00-allow-to-specify-watchdog-interval.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,56 @@
+From 9f3e3323e9966d9f21bea0c81b1acb36c0e15cec Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:00:54 +0200
+Subject: [PATCH 01/15] rt2x00: allow to specify watchdog interval
+
+Allow subdriver to change watchdog interval by intialize
+link->watchdog_interval value before rt2x00link_register().
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h     |  1 +
+ drivers/net/wireless/ralink/rt2x00/rt2x00link.c | 13 +++++++++----
+ 2 files changed, 10 insertions(+), 4 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -336,6 +336,7 @@ struct link {
+ 	 * to bring the device/driver back into the desired state.
+ 	 */
+ 	struct delayed_work watchdog_work;
++	unsigned int watchdog_interval;
+ 
+ 	/*
+ 	 * Work structure for scheduling periodic AGC adjustments.
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00link.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00link.c
+@@ -398,7 +398,7 @@ void rt2x00link_start_watchdog(struct rt
+ 	    rt2x00dev->ops->lib->watchdog)
+ 		ieee80211_queue_delayed_work(rt2x00dev->hw,
+ 					     &link->watchdog_work,
+-					     WATCHDOG_INTERVAL);
++					     link->watchdog_interval);
+ }
+ 
+ void rt2x00link_stop_watchdog(struct rt2x00_dev *rt2x00dev)
+@@ -424,11 +424,16 @@ static void rt2x00link_watchdog(struct w
+ 	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))
+ 		ieee80211_queue_delayed_work(rt2x00dev->hw,
+ 					     &link->watchdog_work,
+-					     WATCHDOG_INTERVAL);
++					     link->watchdog_interval);
+ }
+ 
+ void rt2x00link_register(struct rt2x00_dev *rt2x00dev)
+ {
+-	INIT_DELAYED_WORK(&rt2x00dev->link.watchdog_work, rt2x00link_watchdog);
+-	INIT_DELAYED_WORK(&rt2x00dev->link.work, rt2x00link_tuner);
++	struct link *link = &rt2x00dev->link;
++
++	INIT_DELAYED_WORK(&link->work, rt2x00link_tuner);
++	INIT_DELAYED_WORK(&link->watchdog_work, rt2x00link_watchdog);
++
++	if (link->watchdog_interval == 0)
++		link->watchdog_interval = WATCHDOG_INTERVAL;
+ }
diff -uprN a/package/kernel/mac80211/patches/rt2x00/061-rt2800-add-helpers-for-reading-dma-done-index.patch b/package/kernel/mac80211/patches/rt2x00/061-rt2800-add-helpers-for-reading-dma-done-index.patch
--- a/package/kernel/mac80211/patches/rt2x00/061-rt2800-add-helpers-for-reading-dma-done-index.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/061-rt2800-add-helpers-for-reading-dma-done-index.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,144 @@
+From 2034afe4db4a2a4f22541d7f7b426e38d2093d38 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:00:55 +0200
+Subject: [PATCH 02/15] rt2800: add helpers for reading dma done index
+
+For mmio we do not properlly trace dma done Q_INDEX_DMA_DONE index
+for TX queues. That would require implementing INT_SOURCE_CSR_*_DMA_DONE
+interrupts, what is rather not worth to do due to adding extra
+CPU load (small but still somewhat not necessary otherwise).
+
+We can just read TX DMA done indexes from registers directly. What
+will be used by watchdog.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |  8 +++++
+ .../net/wireless/ralink/rt2x00/rt2800mmio.c   | 31 +++++++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2800mmio.h   |  2 ++
+ .../net/wireless/ralink/rt2x00/rt2800pci.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800soc.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800usb.c    |  9 ++++++
+ 6 files changed, 52 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -76,6 +76,7 @@ struct rt2800_ops {
+ 				  const u8 *data, const size_t len);
+ 	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
+ 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
++	unsigned int (*drv_get_dma_done)(struct data_queue *queue);
+ };
+ 
+ static inline u32 rt2800_register_read(struct rt2x00_dev *rt2x00dev,
+@@ -177,6 +178,13 @@ static inline __le32 *rt2800_drv_get_txw
+ 	return rt2800ops->drv_get_txwi(entry);
+ }
+ 
++static inline unsigned int rt2800_drv_get_dma_done(struct data_queue *queue)
++{
++	const struct rt2800_ops *rt2800ops = queue->rt2x00dev->ops->drv;
++
++	return rt2800ops->drv_get_dma_done(queue);
++}
++
+ void rt2800_mcu_request(struct rt2x00_dev *rt2x00dev,
+ 			const u8 command, const u8 token,
+ 			const u8 arg0, const u8 arg1);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+@@ -36,6 +36,37 @@
+ #include "rt2800lib.h"
+ #include "rt2800mmio.h"
+ 
++unsigned int rt2800mmio_get_dma_done(struct data_queue *queue)
++{
++	struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
++	struct queue_entry *entry;
++	int idx, qid;
++
++	switch (queue->qid) {
++	case QID_AC_VO:
++	case QID_AC_VI:
++	case QID_AC_BE:
++	case QID_AC_BK:
++		qid = queue->qid;
++		idx = rt2x00mmio_register_read(rt2x00dev, TX_DTX_IDX(qid));
++		break;
++	case QID_MGMT:
++		idx = rt2x00mmio_register_read(rt2x00dev, TX_DTX_IDX(5));
++		break;
++	case QID_RX:
++		entry = rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE);
++		idx = entry->entry_idx;
++		break;
++	default:
++		WARN_ON_ONCE(1);
++		idx = 0;
++		break;
++	}
++
++	return idx;
++}
++EXPORT_SYMBOL_GPL(rt2800mmio_get_dma_done);
++
+ /*
+  * TX descriptor initialization
+  */
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.h
+@@ -126,6 +126,8 @@
+ #define RXD_W3_PLCP_SIGNAL		FIELD32(0x00020000)
+ #define RXD_W3_PLCP_RSSI		FIELD32(0x00040000)
+ 
++unsigned int rt2800mmio_get_dma_done(struct data_queue *queue);
++
+ /* TX descriptor initialization */
+ __le32 *rt2800mmio_get_txwi(struct queue_entry *entry);
+ void rt2800mmio_write_tx_desc(struct queue_entry *entry,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+@@ -337,6 +337,7 @@ static const struct rt2800_ops rt2800pci
+ 	.drv_write_firmware	= rt2800pci_write_firmware,
+ 	.drv_init_registers	= rt2800mmio_init_registers,
+ 	.drv_get_txwi		= rt2800mmio_get_txwi,
++	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+ };
+ 
+ static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -183,6 +183,7 @@ static const struct rt2800_ops rt2800soc
+ 	.drv_write_firmware	= rt2800soc_write_firmware,
+ 	.drv_init_registers	= rt2800mmio_init_registers,
+ 	.drv_get_txwi		= rt2800mmio_get_txwi,
++	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+ };
+ 
+ static const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -390,6 +390,14 @@ static int rt2800usb_set_device_state(st
+ 	return retval;
+ }
+ 
++static unsigned int rt2800usb_get_dma_done(struct data_queue *queue)
++{
++	struct queue_entry *entry;
++
++	entry = rt2x00queue_get_entry(queue, Q_INDEX_DMA_DONE);
++	return entry->entry_idx;
++}
++
+ /*
+  * TX descriptor initialization
+  */
+@@ -672,6 +680,7 @@ static const struct rt2800_ops rt2800usb
+ 	.drv_write_firmware	= rt2800usb_write_firmware,
+ 	.drv_init_registers	= rt2800usb_init_registers,
+ 	.drv_get_txwi		= rt2800usb_get_txwi,
++	.drv_get_dma_done	= rt2800usb_get_dma_done,
+ };
+ 
+ static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
diff -uprN a/package/kernel/mac80211/patches/rt2x00/062-rt2800-initial-watchdog-implementation.patch b/package/kernel/mac80211/patches/rt2x00/062-rt2800-initial-watchdog-implementation.patch
--- a/package/kernel/mac80211/patches/rt2x00/062-rt2800-initial-watchdog-implementation.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/062-rt2800-initial-watchdog-implementation.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,158 @@
+From 759c5b599cf4ddb3b56e66d459b1bf0fe2724fb8 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:00:56 +0200
+Subject: [PATCH 03/15] rt2800: initial watchdog implementation
+
+Add watchdog for rt2800 devices. For now it only detect hung
+and print error.
+
+[Note: I verified that printing messages from process context is
+fine on MT7620 (WT3020) platform that have problem when printk
+is called from interrupt context].
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 56 +++++++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |  2 +
+ .../net/wireless/ralink/rt2x00/rt2800pci.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800soc.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800usb.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2x00queue.h  |  6 ++
+ 6 files changed, 67 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1223,6 +1223,60 @@ void rt2800_txdone_nostatus(struct rt2x0
+ }
+ EXPORT_SYMBOL_GPL(rt2800_txdone_nostatus);
+ 
++static int rt2800_check_hung(struct data_queue *queue)
++{
++	unsigned int cur_idx = rt2800_drv_get_dma_done(queue);
++
++	if (queue->wd_idx != cur_idx)
++		queue->wd_count = 0;
++	else
++		queue->wd_count++;
++
++	return queue->wd_count > 16;
++}
++
++void rt2800_watchdog(struct rt2x00_dev *rt2x00dev)
++{
++	struct data_queue *queue;
++	bool hung_tx = false;
++	bool hung_rx = false;
++
++	if (test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
++		return;
++
++	queue_for_each(rt2x00dev, queue) {
++		switch (queue->qid) {
++		case QID_AC_VO:
++		case QID_AC_VI:
++		case QID_AC_BE:
++		case QID_AC_BK:
++		case QID_MGMT:
++			if (rt2x00queue_empty(queue))
++				continue;
++			hung_tx = rt2800_check_hung(queue);
++			break;
++		case QID_RX:
++			/* For station mode we should reactive at least
++			 * beacons. TODO: need to find good way detect
++			 * RX hung for AP mode.
++			 */
++			if (rt2x00dev->intf_sta_count == 0)
++				continue;
++			hung_rx = rt2800_check_hung(queue);
++			break;
++		default:
++			break;
++		}
++	}
++
++	if (hung_tx)
++		rt2x00_warn(rt2x00dev, "Watchdog TX hung detected\n");
++
++	if (hung_rx)
++		rt2x00_warn(rt2x00dev, "Watchdog RX hung detected\n");
++}
++EXPORT_SYMBOL_GPL(rt2800_watchdog);
++
+ static unsigned int rt2800_hw_beacon_base(struct rt2x00_dev *rt2x00dev,
+ 					  unsigned int index)
+ {
+@@ -10222,6 +10276,8 @@ int rt2800_probe_hw(struct rt2x00_dev *r
+ 		__set_bit(REQUIRE_TASKLET_CONTEXT, &rt2x00dev->cap_flags);
+ 	}
+ 
++	rt2x00dev->link.watchdog_interval = msecs_to_jiffies(100);
++
+ 	/*
+ 	 * Set the rssi offset.
+ 	 */
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -208,6 +208,8 @@ void rt2800_txdone_nostatus(struct rt2x0
+ bool rt2800_txstatus_timeout(struct rt2x00_dev *rt2x00dev);
+ bool rt2800_txstatus_pending(struct rt2x00_dev *rt2x00dev);
+ 
++void rt2800_watchdog(struct rt2x00_dev *rt2x00dev);
++
+ void rt2800_write_beacon(struct queue_entry *entry, struct txentry_desc *txdesc);
+ void rt2800_clear_beacon(struct queue_entry *entry);
+ 
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+@@ -362,6 +362,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.link_tuner		= rt2800_link_tuner,
+ 	.gain_calibration	= rt2800_gain_calibration,
+ 	.vco_calibration	= rt2800_vco_calibration,
++	.watchdog		= rt2800_watchdog,
+ 	.start_queue		= rt2800mmio_start_queue,
+ 	.kick_queue		= rt2800mmio_kick_queue,
+ 	.stop_queue		= rt2800mmio_stop_queue,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -208,6 +208,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.link_tuner		= rt2800_link_tuner,
+ 	.gain_calibration	= rt2800_gain_calibration,
+ 	.vco_calibration	= rt2800_vco_calibration,
++	.watchdog		= rt2800_watchdog,
+ 	.start_queue		= rt2800mmio_start_queue,
+ 	.kick_queue		= rt2800mmio_kick_queue,
+ 	.stop_queue		= rt2800mmio_stop_queue,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -698,6 +698,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.link_tuner		= rt2800_link_tuner,
+ 	.gain_calibration	= rt2800_gain_calibration,
+ 	.vco_calibration	= rt2800_vco_calibration,
++	.watchdog		= rt2800_watchdog,
+ 	.start_queue		= rt2800usb_start_queue,
+ 	.kick_queue		= rt2x00usb_kick_queue,
+ 	.stop_queue		= rt2800usb_stop_queue,
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
+@@ -446,6 +446,9 @@ enum data_queue_flags {
+  * @length: Number of frames in queue.
+  * @index: Index pointers to entry positions in the queue,
+  *	use &enum queue_index to get a specific index field.
++ * @wd_count: watchdog counter number of times entry does change
++ *      in the queue
++ * @wd_idx: index of queue entry saved by watchdog
+  * @txop: maximum burst time.
+  * @aifs: The aifs value for outgoing frames (field ignored in RX queue).
+  * @cw_min: The cw min value for outgoing frames (field ignored in RX queue).
+@@ -473,6 +476,9 @@ struct data_queue {
+ 	unsigned short length;
+ 	unsigned short index[Q_INDEX_MAX];
+ 
++	unsigned short wd_count;
++	unsigned int wd_idx;
++
+ 	unsigned short txop;
+ 	unsigned short aifs;
+ 	unsigned short cw_min;
diff -uprN a/package/kernel/mac80211/patches/rt2x00/063-rt2800-add-pre_reset_hw-callback.patch b/package/kernel/mac80211/patches/rt2x00/063-rt2800-add-pre_reset_hw-callback.patch
--- a/package/kernel/mac80211/patches/rt2x00/063-rt2800-add-pre_reset_hw-callback.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/063-rt2800-add-pre_reset_hw-callback.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,96 @@
+From 09db3b000619b38d504e1fff66efed33dfacb6c0 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:00:57 +0200
+Subject: [PATCH 04/15] rt2800: add pre_reset_hw callback
+
+Add routine to cleanup interfaces data before hw reset as
+ieee80211_restart_hw() will do setup interfaces again.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 19 +++++++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2800lib.h    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800pci.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800soc.c    |  1 +
+ .../net/wireless/ralink/rt2x00/rt2800usb.c    |  1 +
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h   |  1 +
+ 6 files changed, 24 insertions(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1854,6 +1854,25 @@ int rt2800_sta_remove(struct ieee80211_h
+ }
+ EXPORT_SYMBOL_GPL(rt2800_sta_remove);
+ 
++void rt2800_pre_reset_hw(struct rt2x00_dev *rt2x00dev)
++{
++	struct rt2800_drv_data *drv_data = rt2x00dev->drv_data;
++	struct data_queue *queue = rt2x00dev->bcn;
++	struct queue_entry *entry;
++	int i, wcid;
++
++	for (wcid = WCID_START; wcid < WCID_END; wcid++) {
++		drv_data->wcid_to_sta[wcid - WCID_START] = NULL;
++		__clear_bit(wcid - WCID_START, drv_data->sta_ids);
++	}
++
++	for (i = 0; i < queue->limit; i++) {
++		entry = &queue->entries[i];
++		clear_bit(ENTRY_BCN_ASSIGNED, &entry->flags);
++	}
++}
++EXPORT_SYMBOL_GPL(rt2800_pre_reset_hw);
++
+ void rt2800_config_filter(struct rt2x00_dev *rt2x00dev,
+ 			  const unsigned int filter_flags)
+ {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -268,5 +268,6 @@ void rt2800_disable_wpdma(struct rt2x00_
+ void rt2800_get_txwi_rxwi_size(struct rt2x00_dev *rt2x00dev,
+ 			       unsigned short *txwi_size,
+ 			       unsigned short *rxwi_size);
++void rt2800_pre_reset_hw(struct rt2x00_dev *rt2x00dev);
+ 
+ #endif /* RT2800LIB_H */
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+@@ -379,6 +379,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.config_erp		= rt2800_config_erp,
+ 	.config_ant		= rt2800_config_ant,
+ 	.config			= rt2800_config,
++	.pre_reset_hw		= rt2800_pre_reset_hw,
+ };
+ 
+ static const struct rt2x00_ops rt2800pci_ops = {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+@@ -225,6 +225,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.config_erp		= rt2800_config_erp,
+ 	.config_ant		= rt2800_config_ant,
+ 	.config			= rt2800_config,
++	.pre_reset_hw		= rt2800_pre_reset_hw,
+ };
+ 
+ static const struct rt2x00_ops rt2800soc_ops = {
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -717,6 +717,7 @@ static const struct rt2x00lib_ops rt2800
+ 	.config_erp		= rt2800_config_erp,
+ 	.config_ant		= rt2800_config_ant,
+ 	.config			= rt2800_config,
++	.pre_reset_hw		= rt2800_pre_reset_hw,
+ };
+ 
+ static void rt2800usb_queue_init(struct data_queue *queue)
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -627,6 +627,7 @@ struct rt2x00lib_ops {
+ 	void (*config) (struct rt2x00_dev *rt2x00dev,
+ 			struct rt2x00lib_conf *libconf,
+ 			const unsigned int changed_flags);
++	void (*pre_reset_hw) (struct rt2x00_dev *rt2x00dev);
+ 	int (*sta_add) (struct rt2x00_dev *rt2x00dev,
+ 			struct ieee80211_vif *vif,
+ 			struct ieee80211_sta *sta);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/064-rt2800-do-not-nullify-initialization-vector-data.patch b/package/kernel/mac80211/patches/rt2x00/064-rt2800-do-not-nullify-initialization-vector-data.patch
--- a/package/kernel/mac80211/patches/rt2x00/064-rt2800-do-not-nullify-initialization-vector-data.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/064-rt2800-do-not-nullify-initialization-vector-data.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,51 @@
+From 710e6cc1595e25378c4b9977f7a8b4ad4a72a109 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:00:58 +0200
+Subject: [PATCH 05/15] rt2800: do not nullify initialization vector data
+
+If we restart hw we should keep existing IV (initialization vector)
+otherwise HW encryption will be broken after restart.
+
+Also fix some coding style issues on the way.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 9 ++++-----
+ 1 file changed, 4 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1658,14 +1658,15 @@ static void rt2800_config_wcid_attr_ciph
+ 
+ 	offset = MAC_IVEIV_ENTRY(key->hw_key_idx);
+ 
+-	memset(&iveiv_entry, 0, sizeof(iveiv_entry));
++	rt2800_register_multiread(rt2x00dev, offset,
++				  &iveiv_entry, sizeof(iveiv_entry));
+ 	if ((crypto->cipher == CIPHER_TKIP) ||
+ 	    (crypto->cipher == CIPHER_TKIP_NO_MIC) ||
+ 	    (crypto->cipher == CIPHER_AES))
+ 		iveiv_entry.iv[3] |= 0x20;
+ 	iveiv_entry.iv[3] |= key->keyidx << 6;
+ 	rt2800_register_multiwrite(rt2x00dev, offset,
+-				      &iveiv_entry, sizeof(iveiv_entry));
++				   &iveiv_entry, sizeof(iveiv_entry));
+ }
+ 
+ int rt2800_config_shared_key(struct rt2x00_dev *rt2x00dev,
+@@ -6090,13 +6091,11 @@ static int rt2800_init_registers(struct
+ 	 * ASIC will keep garbage value after boot, clear encryption keys.
+ 	 */
+ 	for (i = 0; i < 4; i++)
+-		rt2800_register_write(rt2x00dev,
+-					 SHARED_KEY_MODE_ENTRY(i), 0);
++		rt2800_register_write(rt2x00dev, SHARED_KEY_MODE_ENTRY(i), 0);
+ 
+ 	for (i = 0; i < 256; i++) {
+ 		rt2800_config_wcid(rt2x00dev, NULL, i);
+ 		rt2800_delete_wcid_attr(rt2x00dev, i);
+-		rt2800_register_write(rt2x00dev, MAC_IVEIV_ENTRY(i), 0);
+ 	}
+ 
+ 	/*
diff -uprN a/package/kernel/mac80211/patches/rt2x00/065-rt2x00-add-restart-hw.patch b/package/kernel/mac80211/patches/rt2x00/065-rt2x00-add-restart-hw.patch
--- a/package/kernel/mac80211/patches/rt2x00/065-rt2x00-add-restart-hw.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/065-rt2x00-add-restart-hw.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,151 @@
+From e403fa31ed71e87de8e5991e23406b8377c9c894 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:00:59 +0200
+Subject: [PATCH 06/15] rt2x00: add restart hw
+
+Add ieee80211_restart_hw() to watchdog and debugfs file for testing
+if restart works as expected.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    |  4 +++
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h   |  7 ++++
+ .../net/wireless/ralink/rt2x00/rt2x00debug.c  | 35 +++++++++++++++++++
+ .../net/wireless/ralink/rt2x00/rt2x00dev.c    | 10 ++++--
+ 4 files changed, 54 insertions(+), 2 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1274,6 +1274,9 @@ void rt2800_watchdog(struct rt2x00_dev *
+ 
+ 	if (hung_rx)
+ 		rt2x00_warn(rt2x00dev, "Watchdog RX hung detected\n");
++
++	if (hung_tx || hung_rx)
++		ieee80211_restart_hw(rt2x00dev->hw);
+ }
+ EXPORT_SYMBOL_GPL(rt2800_watchdog);
+ 
+@@ -10294,6 +10297,7 @@ int rt2800_probe_hw(struct rt2x00_dev *r
+ 		__set_bit(REQUIRE_TASKLET_CONTEXT, &rt2x00dev->cap_flags);
+ 	}
+ 
++	__set_bit(CAPABILITY_RESTART_HW, &rt2x00dev->cap_flags);
+ 	rt2x00dev->link.watchdog_interval = msecs_to_jiffies(100);
+ 
+ 	/*
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -723,6 +723,7 @@ enum rt2x00_capability_flags {
+ 	CAPABILITY_VCO_RECALIBRATION,
+ 	CAPABILITY_EXTERNAL_PA_TX0,
+ 	CAPABILITY_EXTERNAL_PA_TX1,
++	CAPABILITY_RESTART_HW,
+ };
+ 
+ /*
+@@ -1279,6 +1280,12 @@ rt2x00_has_cap_vco_recalibration(struct
+ 	return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_VCO_RECALIBRATION);
+ }
+ 
++static inline bool
++rt2x00_has_cap_restart_hw(struct rt2x00_dev *rt2x00dev)
++{
++	return rt2x00_has_cap_flag(rt2x00dev, CAPABILITY_RESTART_HW);
++}
++
+ /**
+  * rt2x00queue_map_txskb - Map a skb into DMA for TX purposes.
+  * @entry: Pointer to &struct queue_entry
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
+@@ -63,6 +63,7 @@ struct rt2x00debug_intf {
+ 	 *   - chipset file
+ 	 *   - device state flags file
+ 	 *   - device capability flags file
++	 *   - hardware restart file
+ 	 *   - register folder
+ 	 *     - csr offset/value files
+ 	 *     - eeprom offset/value files
+@@ -79,6 +80,7 @@ struct rt2x00debug_intf {
+ 	struct dentry *chipset_entry;
+ 	struct dentry *dev_flags;
+ 	struct dentry *cap_flags;
++	struct dentry *restart_hw;
+ 	struct dentry *register_folder;
+ 	struct dentry *csr_off_entry;
+ 	struct dentry *csr_val_entry;
+@@ -577,6 +579,34 @@ static const struct file_operations rt2x
+ 	.llseek		= default_llseek,
+ };
+ 
++static ssize_t rt2x00debug_write_restart_hw(struct file *file,
++					    const char __user *buf,
++					    size_t length,
++					    loff_t *offset)
++{
++	struct rt2x00debug_intf *intf =	file->private_data;
++	struct rt2x00_dev *rt2x00dev = intf->rt2x00dev;
++	static unsigned long last_reset;
++
++	if (!rt2x00_has_cap_restart_hw(rt2x00dev))
++		return -EOPNOTSUPP;
++
++	if (time_before(jiffies, last_reset + msecs_to_jiffies(2000)))
++		return -EBUSY;
++
++	last_reset = jiffies;
++
++	ieee80211_restart_hw(rt2x00dev->hw);
++	return length;
++}
++
++static const struct file_operations rt2x00debug_restart_hw = {
++	.owner = THIS_MODULE,
++	.write = rt2x00debug_write_restart_hw,
++	.open = simple_open,
++	.llseek = generic_file_llseek,
++};
++
+ static struct dentry *rt2x00debug_create_file_driver(const char *name,
+ 						     struct rt2x00debug_intf
+ 						     *intf,
+@@ -672,6 +702,10 @@ void rt2x00debug_register(struct rt2x00_
+ 					      intf->driver_folder, intf,
+ 					      &rt2x00debug_fop_cap_flags);
+ 
++	intf->restart_hw = debugfs_create_file("restart_hw", 0200,
++					       intf->driver_folder, intf,
++					       &rt2x00debug_restart_hw);
++
+ 	intf->register_folder =
+ 	    debugfs_create_dir("register", intf->driver_folder);
+ 
+@@ -753,6 +787,7 @@ void rt2x00debug_deregister(struct rt2x0
+ 	debugfs_remove(intf->csr_off_entry);
+ 	debugfs_remove(intf->register_folder);
+ 	debugfs_remove(intf->dev_flags);
++	debugfs_remove(intf->restart_hw);
+ 	debugfs_remove(intf->cap_flags);
+ 	debugfs_remove(intf->chipset_entry);
+ 	debugfs_remove(intf->driver_entry);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+@@ -1269,8 +1269,14 @@ int rt2x00lib_start(struct rt2x00_dev *r
+ {
+ 	int retval;
+ 
+-	if (test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags))
+-		return 0;
++	if (test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags)) {
++		/*
++		 * This is special case for ieee80211_restart_hw(), otherwise
++		 * mac80211 never call start() two times in row without stop();
++		 */
++		rt2x00dev->ops->lib->pre_reset_hw(rt2x00dev);
++		rt2x00lib_stop(rt2x00dev);
++	}
+ 
+ 	/*
+ 	 * If this is the first interface which is added,
diff -uprN a/package/kernel/mac80211/patches/rt2x00/066-rt2800-do-not-enable-watchdog-by-default.patch b/package/kernel/mac80211/patches/rt2x00/066-rt2800-do-not-enable-watchdog-by-default.patch
--- a/package/kernel/mac80211/patches/rt2x00/066-rt2800-do-not-enable-watchdog-by-default.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/066-rt2800-do-not-enable-watchdog-by-default.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,71 @@
+From 0f47aeeada2a1fe296258eab9a08ced258009481 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Sat, 15 Jun 2019 12:01:00 +0200
+Subject: [PATCH 07/15] rt2800: do not enable watchdog by default
+
+Make watchdog disabled by default and add module parameter to enable it.
+
+User will have to create file in /etc/modprobe.d/ with
+
+options rt2800lib watchdog=1
+
+to enable the watchdog or load "rt2800lib watchdog=1" module manually
+before loading rt2800{soc,pci,usb} module.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c  | 12 ++++++++++--
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h     |  1 +
+ drivers/net/wireless/ralink/rt2x00/rt2x00link.c |  2 +-
+ 3 files changed, 12 insertions(+), 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -41,6 +41,10 @@
+ #include "rt2800lib.h"
+ #include "rt2800.h"
+ 
++static bool modparam_watchdog;
++module_param_named(watchdog, modparam_watchdog, bool, S_IRUGO);
++MODULE_PARM_DESC(watchdog, "Enable watchdog to detect tx/rx hangs and reset hardware if detected");
++
+ /*
+  * Register access.
+  * All access to the CSR registers will go through the methods
+@@ -10297,8 +10301,12 @@ int rt2800_probe_hw(struct rt2x00_dev *r
+ 		__set_bit(REQUIRE_TASKLET_CONTEXT, &rt2x00dev->cap_flags);
+ 	}
+ 
+-	__set_bit(CAPABILITY_RESTART_HW, &rt2x00dev->cap_flags);
+-	rt2x00dev->link.watchdog_interval = msecs_to_jiffies(100);
++	if (modparam_watchdog) {
++		__set_bit(CAPABILITY_RESTART_HW, &rt2x00dev->cap_flags);
++		rt2x00dev->link.watchdog_interval = msecs_to_jiffies(100);
++	} else {
++		rt2x00dev->link.watchdog_disabled = true;
++	}
+ 
+ 	/*
+ 	 * Set the rssi offset.
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -337,6 +337,7 @@ struct link {
+ 	 */
+ 	struct delayed_work watchdog_work;
+ 	unsigned int watchdog_interval;
++	bool watchdog_disabled;
+ 
+ 	/*
+ 	 * Work structure for scheduling periodic AGC adjustments.
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00link.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00link.c
+@@ -395,7 +395,7 @@ void rt2x00link_start_watchdog(struct rt
+ 	struct link *link = &rt2x00dev->link;
+ 
+ 	if (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&
+-	    rt2x00dev->ops->lib->watchdog)
++	    rt2x00dev->ops->lib->watchdog && !link->watchdog_disabled)
+ 		ieee80211_queue_delayed_work(rt2x00dev->hw,
+ 					     &link->watchdog_work,
+ 					     link->watchdog_interval);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/067-rt2x00usb-fix-rx-queue-hang.patch b/package/kernel/mac80211/patches/rt2x00/067-rt2x00usb-fix-rx-queue-hang.patch
--- a/package/kernel/mac80211/patches/rt2x00/067-rt2x00usb-fix-rx-queue-hang.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/067-rt2x00usb-fix-rx-queue-hang.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,67 @@
+From 41a531ffa4c5aeb062f892227c00fabb3b4a9c91 Mon Sep 17 00:00:00 2001
+From: Soeren Moch <smoch@web.de>
+Date: Mon, 1 Jul 2019 12:53:13 +0200
+Subject: [PATCH 08/15] rt2x00usb: fix rx queue hang
+
+Since commit ed194d136769 ("usb: core: remove local_irq_save() around
+ ->complete() handler") the handler rt2x00usb_interrupt_rxdone() is
+not running with interrupts disabled anymore. So this completion handler
+is not guaranteed to run completely before workqueue processing starts
+for the same queue entry.
+Be sure to set all other flags in the entry correctly before marking
+this entry ready for workqueue processing. This way we cannot miss error
+conditions that need to be signalled from the completion handler to the
+worker thread.
+Note that rt2x00usb_work_rxdone() processes all available entries, not
+only such for which queue_work() was called.
+
+This patch is similar to what commit df71c9cfceea ("rt2x00: fix order
+of entry flags modification") did for TX processing.
+
+This fixes a regression on a RT5370 based wifi stick in AP mode, which
+suddenly stopped data transmission after some period of heavy load. Also
+stopping the hanging hostapd resulted in the error message "ieee80211
+phy0: rt2x00queue_flush_queue: Warning - Queue 14 failed to flush".
+Other operation modes are probably affected as well, this just was
+the used testcase.
+
+Fixes: ed194d136769 ("usb: core: remove local_irq_save() around ->complete() handler")
+Cc: stable@vger.kernel.org # 4.20+
+Signed-off-by: Soeren Moch <smoch@web.de>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00usb.c | 12 ++++++------
+ 1 file changed, 6 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c
+@@ -383,15 +383,10 @@ static void rt2x00usb_interrupt_rxdone(s
+ 	struct queue_entry *entry = (struct queue_entry *)urb->context;
+ 	struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
+ 
+-	if (!test_and_clear_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))
++	if (!test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))
+ 		return;
+ 
+ 	/*
+-	 * Report the frame as DMA done
+-	 */
+-	rt2x00lib_dmadone(entry);
+-
+-	/*
+ 	 * Check if the received data is simply too small
+ 	 * to be actually valid, or if the urb is signaling
+ 	 * a problem.
+@@ -400,6 +395,11 @@ static void rt2x00usb_interrupt_rxdone(s
+ 		set_bit(ENTRY_DATA_IO_FAILED, &entry->flags);
+ 
+ 	/*
++	 * Report the frame as DMA done
++	 */
++	rt2x00lib_dmadone(entry);
++
++	/*
+ 	 * Schedule the delayed work for reading the RX status
+ 	 * from the device.
+ 	 */
diff -uprN a/package/kernel/mac80211/patches/rt2x00/068-rt2x00usb-remove-unnecessary-rx-flag-checks.patch b/package/kernel/mac80211/patches/rt2x00/068-rt2x00usb-remove-unnecessary-rx-flag-checks.patch
--- a/package/kernel/mac80211/patches/rt2x00/068-rt2x00usb-remove-unnecessary-rx-flag-checks.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/068-rt2x00usb-remove-unnecessary-rx-flag-checks.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,51 @@
+From 3b902fa811cf6bf7f9ad0ffb77d0a133e0b3bd61 Mon Sep 17 00:00:00 2001
+From: Soeren Moch <smoch@web.de>
+Date: Mon, 1 Jul 2019 12:53:14 +0200
+Subject: [PATCH 09/15] rt2x00usb: remove unnecessary rx flag checks
+
+In contrast to the TX path, there is no need to separately read the transfer
+status from the device after receiving RX data. Consequently, there is no
+real STATUS_PENDING RX processing queue entry state.
+Remove the unnecessary ENTRY_DATA_STATUS_PENDING flag checks from the RX path.
+Also remove the misleading comment about reading RX status from device.
+
+Suggested-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Soeren Moch <smoch@web.de>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00usb.c | 9 +++------
+ 1 file changed, 3 insertions(+), 6 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c
+@@ -360,8 +360,7 @@ static void rt2x00usb_work_rxdone(struct
+ 	while (!rt2x00queue_empty(rt2x00dev->rx)) {
+ 		entry = rt2x00queue_get_entry(rt2x00dev->rx, Q_INDEX_DONE);
+ 
+-		if (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||
+-		    !test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
++		if (test_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))
+ 			break;
+ 
+ 		/*
+@@ -400,8 +399,7 @@ static void rt2x00usb_interrupt_rxdone(s
+ 	rt2x00lib_dmadone(entry);
+ 
+ 	/*
+-	 * Schedule the delayed work for reading the RX status
+-	 * from the device.
++	 * Schedule the delayed work for processing RX data
+ 	 */
+ 	queue_work(rt2x00dev->workqueue, &rt2x00dev->rxdone_work);
+ }
+@@ -413,8 +411,7 @@ static bool rt2x00usb_kick_rx_entry(stru
+ 	struct queue_entry_priv_usb *entry_priv = entry->priv_data;
+ 	int status;
+ 
+-	if (test_and_set_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags) ||
+-	    test_bit(ENTRY_DATA_STATUS_PENDING, &entry->flags))
++	if (test_and_set_bit(ENTRY_OWNER_DEVICE_DATA, &entry->flags))
+ 		return false;
+ 
+ 	rt2x00lib_dmastart(entry);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/069-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch b/package/kernel/mac80211/patches/rt2x00/069-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch
--- a/package/kernel/mac80211/patches/rt2x00/069-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/069-rt2x00-no-need-to-check-return-value-of-debugfs_crea.patch	2022-04-04 20:20:32.955828000 +0800
@@ -0,0 +1,248 @@
+From 1dc244064c47d6df7925ca0895f8365e68d3abd1 Mon Sep 17 00:00:00 2001
+From: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Date: Wed, 3 Jul 2019 13:39:56 +0200
+Subject: [PATCH 10/15] rt2x00: no need to check return value of debugfs_create
+ functions
+
+When calling debugfs functions, there is no need to ever check the
+return value.  The function can work or not, but the code logic should
+never do something different based on this.
+
+Because we don't need to save the individual debugfs files and
+directories, remove the local storage of them and just remove the entire
+debugfs directory in a single call, making things a lot simpler.
+
+Cc: Stanislaw Gruszka <sgruszka@redhat.com>
+Cc: Helmut Schaa <helmut.schaa@googlemail.com>
+Cc: Kalle Valo <kvalo@codeaurora.org>
+Cc: "David S. Miller" <davem@davemloft.net>
+Cc: linux-wireless@vger.kernel.org
+Cc: netdev@vger.kernel.org
+Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2x00debug.c  | 136 +++++-------------
+ 1 file changed, 35 insertions(+), 101 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00debug.c
+@@ -76,26 +76,6 @@ struct rt2x00debug_intf {
+ 	 *     - crypto stats file
+ 	 */
+ 	struct dentry *driver_folder;
+-	struct dentry *driver_entry;
+-	struct dentry *chipset_entry;
+-	struct dentry *dev_flags;
+-	struct dentry *cap_flags;
+-	struct dentry *restart_hw;
+-	struct dentry *register_folder;
+-	struct dentry *csr_off_entry;
+-	struct dentry *csr_val_entry;
+-	struct dentry *eeprom_off_entry;
+-	struct dentry *eeprom_val_entry;
+-	struct dentry *bbp_off_entry;
+-	struct dentry *bbp_val_entry;
+-	struct dentry *rf_off_entry;
+-	struct dentry *rf_val_entry;
+-	struct dentry *rfcsr_off_entry;
+-	struct dentry *rfcsr_val_entry;
+-	struct dentry *queue_folder;
+-	struct dentry *queue_frame_dump_entry;
+-	struct dentry *queue_stats_entry;
+-	struct dentry *crypto_stats_entry;
+ 
+ 	/*
+ 	 * The frame dump file only allows a single reader,
+@@ -607,39 +587,34 @@ static const struct file_operations rt2x
+ 	.llseek = generic_file_llseek,
+ };
+ 
+-static struct dentry *rt2x00debug_create_file_driver(const char *name,
+-						     struct rt2x00debug_intf
+-						     *intf,
+-						     struct debugfs_blob_wrapper
+-						     *blob)
++static void rt2x00debug_create_file_driver(const char *name,
++					   struct rt2x00debug_intf *intf,
++					   struct debugfs_blob_wrapper *blob)
+ {
+ 	char *data;
+ 
+ 	data = kzalloc(3 * MAX_LINE_LENGTH, GFP_KERNEL);
+ 	if (!data)
+-		return NULL;
++		return;
+ 
+ 	blob->data = data;
+ 	data += sprintf(data, "driver:\t%s\n", intf->rt2x00dev->ops->name);
+ 	data += sprintf(data, "version:\t%s\n", DRV_VERSION);
+ 	blob->size = strlen(blob->data);
+ 
+-	return debugfs_create_blob(name, 0400, intf->driver_folder, blob);
++	debugfs_create_blob(name, 0400, intf->driver_folder, blob);
+ }
+ 
+-static struct dentry *rt2x00debug_create_file_chipset(const char *name,
+-						      struct rt2x00debug_intf
+-						      *intf,
+-						      struct
+-						      debugfs_blob_wrapper
+-						      *blob)
++static void rt2x00debug_create_file_chipset(const char *name,
++					    struct rt2x00debug_intf *intf,
++					    struct debugfs_blob_wrapper *blob)
+ {
+ 	const struct rt2x00debug *debug = intf->debug;
+ 	char *data;
+ 
+ 	data = kzalloc(9 * MAX_LINE_LENGTH, GFP_KERNEL);
+ 	if (!data)
+-		return NULL;
++		return;
+ 
+ 	blob->data = data;
+ 	data += sprintf(data, "rt chip:\t%04x\n", intf->rt2x00dev->chip.rt);
+@@ -665,13 +640,15 @@ static struct dentry *rt2x00debug_create
+ 
+ 	blob->size = strlen(blob->data);
+ 
+-	return debugfs_create_blob(name, 0400, intf->driver_folder, blob);
++	debugfs_create_blob(name, 0400, intf->driver_folder, blob);
+ }
+ 
+ void rt2x00debug_register(struct rt2x00_dev *rt2x00dev)
+ {
+ 	const struct rt2x00debug *debug = rt2x00dev->ops->debugfs;
+ 	struct rt2x00debug_intf *intf;
++	struct dentry *queue_folder;
++	struct dentry *register_folder;
+ 
+ 	intf = kzalloc(sizeof(struct rt2x00debug_intf), GFP_KERNEL);
+ 	if (!intf) {
+@@ -687,43 +664,27 @@ void rt2x00debug_register(struct rt2x00_
+ 	    debugfs_create_dir(intf->rt2x00dev->ops->name,
+ 			       rt2x00dev->hw->wiphy->debugfsdir);
+ 
+-	intf->driver_entry =
+-	    rt2x00debug_create_file_driver("driver", intf, &intf->driver_blob);
+-
+-	intf->chipset_entry =
+-	    rt2x00debug_create_file_chipset("chipset",
+-					    intf, &intf->chipset_blob);
+-
+-	intf->dev_flags = debugfs_create_file("dev_flags", 0400,
+-					      intf->driver_folder, intf,
+-					      &rt2x00debug_fop_dev_flags);
+-
+-	intf->cap_flags = debugfs_create_file("cap_flags", 0400,
+-					      intf->driver_folder, intf,
+-					      &rt2x00debug_fop_cap_flags);
+-
+-	intf->restart_hw = debugfs_create_file("restart_hw", 0200,
+-					       intf->driver_folder, intf,
+-					       &rt2x00debug_restart_hw);
++	rt2x00debug_create_file_driver("driver", intf, &intf->driver_blob);
++	rt2x00debug_create_file_chipset("chipset", intf, &intf->chipset_blob);
++	debugfs_create_file("dev_flags", 0400, intf->driver_folder, intf,
++			    &rt2x00debug_fop_dev_flags);
++	debugfs_create_file("cap_flags", 0400, intf->driver_folder, intf,
++			    &rt2x00debug_fop_cap_flags);
++	debugfs_create_file("restart_hw", 0200, intf->driver_folder, intf,
++			    &rt2x00debug_restart_hw);
+ 
+-	intf->register_folder =
+-	    debugfs_create_dir("register", intf->driver_folder);
++	register_folder = debugfs_create_dir("register", intf->driver_folder);
+ 
+ #define RT2X00DEBUGFS_CREATE_REGISTER_ENTRY(__intf, __name)		\
+ ({									\
+ 	if (debug->__name.read) {					\
+-		(__intf)->__name##_off_entry =				\
+-			debugfs_create_u32(__stringify(__name) "_offset", \
+-					   0600,			\
+-					   (__intf)->register_folder,	\
+-					   &(__intf)->offset_##__name);	\
++		debugfs_create_u32(__stringify(__name) "_offset", 0600,	\
++				   register_folder,			\
++				   &(__intf)->offset_##__name);		\
+ 									\
+-		(__intf)->__name##_val_entry =				\
+-			debugfs_create_file(__stringify(__name) "_value", \
+-					    0600,			\
+-					    (__intf)->register_folder,	\
+-					    (__intf),			\
+-					    &rt2x00debug_fop_##__name); \
++		debugfs_create_file(__stringify(__name) "_value", 0600,	\
++				    register_folder, (__intf),		\
++				    &rt2x00debug_fop_##__name);		\
+ 	}								\
+ })
+ 
+@@ -735,26 +696,21 @@ void rt2x00debug_register(struct rt2x00_
+ 
+ #undef RT2X00DEBUGFS_CREATE_REGISTER_ENTRY
+ 
+-	intf->queue_folder =
+-	    debugfs_create_dir("queue", intf->driver_folder);
++	queue_folder = debugfs_create_dir("queue", intf->driver_folder);
+ 
+-	intf->queue_frame_dump_entry =
+-		debugfs_create_file("dump", 0400, intf->queue_folder,
+-				    intf, &rt2x00debug_fop_queue_dump);
++	debugfs_create_file("dump", 0400, queue_folder, intf,
++			    &rt2x00debug_fop_queue_dump);
+ 
+ 	skb_queue_head_init(&intf->frame_dump_skbqueue);
+ 	init_waitqueue_head(&intf->frame_dump_waitqueue);
+ 
+-	intf->queue_stats_entry =
+-		debugfs_create_file("queue", 0400, intf->queue_folder,
+-				    intf, &rt2x00debug_fop_queue_stats);
++	debugfs_create_file("queue", 0400, queue_folder, intf,
++			    &rt2x00debug_fop_queue_stats);
+ 
+ #ifdef CPTCFG_RT2X00_LIB_CRYPTO
+ 	if (rt2x00_has_cap_hw_crypto(rt2x00dev))
+-		intf->crypto_stats_entry =
+-			debugfs_create_file("crypto", 0444, intf->queue_folder,
+-					    intf,
+-					    &rt2x00debug_fop_crypto_stats);
++		debugfs_create_file("crypto", 0444, queue_folder, intf,
++				    &rt2x00debug_fop_crypto_stats);
+ #endif
+ 
+ 	return;
+@@ -769,31 +725,7 @@ void rt2x00debug_deregister(struct rt2x0
+ 
+ 	skb_queue_purge(&intf->frame_dump_skbqueue);
+ 
+-#ifdef CPTCFG_RT2X00_LIB_CRYPTO
+-	debugfs_remove(intf->crypto_stats_entry);
+-#endif
+-	debugfs_remove(intf->queue_stats_entry);
+-	debugfs_remove(intf->queue_frame_dump_entry);
+-	debugfs_remove(intf->queue_folder);
+-	debugfs_remove(intf->rfcsr_val_entry);
+-	debugfs_remove(intf->rfcsr_off_entry);
+-	debugfs_remove(intf->rf_val_entry);
+-	debugfs_remove(intf->rf_off_entry);
+-	debugfs_remove(intf->bbp_val_entry);
+-	debugfs_remove(intf->bbp_off_entry);
+-	debugfs_remove(intf->eeprom_val_entry);
+-	debugfs_remove(intf->eeprom_off_entry);
+-	debugfs_remove(intf->csr_val_entry);
+-	debugfs_remove(intf->csr_off_entry);
+-	debugfs_remove(intf->register_folder);
+-	debugfs_remove(intf->dev_flags);
+-	debugfs_remove(intf->restart_hw);
+-	debugfs_remove(intf->cap_flags);
+-	debugfs_remove(intf->chipset_entry);
+-	debugfs_remove(intf->driver_entry);
+-	debugfs_remove(intf->driver_folder);
+-	kfree(intf->chipset_blob.data);
+-	kfree(intf->driver_blob.data);
++	debugfs_remove_recursive(intf->driver_folder);
+ 	kfree(intf);
+ 
+ 	rt2x00dev->debugfs_intf = NULL;
diff -uprN a/package/kernel/mac80211/patches/rt2x00/070-rt2800usb-Add-new-rt2800usb-device-PLANEX-GW-USMicro.patch b/package/kernel/mac80211/patches/rt2x00/070-rt2800usb-Add-new-rt2800usb-device-PLANEX-GW-USMicro.patch
--- a/package/kernel/mac80211/patches/rt2x00/070-rt2800usb-Add-new-rt2800usb-device-PLANEX-GW-USMicro.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/070-rt2800usb-Add-new-rt2800usb-device-PLANEX-GW-USMicro.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,29 @@
+From 706f0182b1add0fc41a8c40662f659b7426f0629 Mon Sep 17 00:00:00 2001
+From: Masanari Iida <standby24x7@gmail.com>
+Date: Sun, 28 Jul 2019 23:07:42 +0900
+Subject: [PATCH 11/15] rt2800usb: Add new rt2800usb device PLANEX GW-USMicroN
+
+This patch add a device ID for PLANEX GW-USMicroN.
+Without this patch, I had to echo the device IDs in order to
+recognize the device.
+
+# lsusb |grep PLANEX
+Bus 002 Device 005: ID 2019:ed14 PLANEX GW-USMicroN
+
+Signed-off-by: Masanari Iida <standby24x7@gmail.com>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800usb.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+@@ -1097,6 +1097,7 @@ static const struct usb_device_id rt2800
+ 	{ USB_DEVICE(0x0846, 0x9013) },
+ 	{ USB_DEVICE(0x0846, 0x9019) },
+ 	/* Planex */
++	{ USB_DEVICE(0x2019, 0xed14) },
+ 	{ USB_DEVICE(0x2019, 0xed19) },
+ 	/* Ralink */
+ 	{ USB_DEVICE(0x148f, 0x3573) },
diff -uprN a/package/kernel/mac80211/patches/rt2x00/071-rt2x00-clear-IV-s-on-start-to-fix-AP-mode-regression.patch b/package/kernel/mac80211/patches/rt2x00/071-rt2x00-clear-IV-s-on-start-to-fix-AP-mode-regression.patch
--- a/package/kernel/mac80211/patches/rt2x00/071-rt2x00-clear-IV-s-on-start-to-fix-AP-mode-regression.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/071-rt2x00-clear-IV-s-on-start-to-fix-AP-mode-regression.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,102 @@
+From 95844124385eae4bd9ca5f9514a0fc33d561ac3c Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Mon, 19 Aug 2019 13:20:07 +0200
+Subject: [PATCH 12/15] rt2x00: clear IV's on start to fix AP mode regression
+
+To do not brake HW restart we should keep initialization vectors data.
+I assumed that on start the data is already initialized to zeros, but
+that not true on some scenarios and we should clear it. So add
+additional flag to check if we are under HW restart and clear IV's
+data if we are not.
+
+Patch fixes AP mode regression.
+
+Reported-and-tested-by: Emil Karlson <jekarl@iki.fi>
+Fixes: 710e6cc1595e ("rt2800: do not nullify initialization vector data")
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c |  9 +++++++++
+ drivers/net/wireless/ralink/rt2x00/rt2x00.h    |  1 +
+ drivers/net/wireless/ralink/rt2x00/rt2x00dev.c | 13 ++++++++-----
+ 3 files changed, 18 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -6106,6 +6106,15 @@ static int rt2800_init_registers(struct
+ 	}
+ 
+ 	/*
++	 * Clear encryption initialization vectors on start, but keep them
++	 * for watchdog reset. Otherwise we will have wrong IVs and not be
++	 * able to keep connections after reset.
++	 */
++	if (!test_bit(DEVICE_STATE_RESET, &rt2x00dev->flags))
++		for (i = 0; i < 256; i++)
++			rt2800_register_write(rt2x00dev, MAC_IVEIV_ENTRY(i), 0);
++
++	/*
+ 	 * Clear all beacons
+ 	 */
+ 	for (i = 0; i < 8; i++)
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -669,6 +669,7 @@ enum rt2x00_state_flags {
+ 	DEVICE_STATE_ENABLED_RADIO,
+ 	DEVICE_STATE_SCANNING,
+ 	DEVICE_STATE_FLUSHING,
++	DEVICE_STATE_RESET,
+ 
+ 	/*
+ 	 * Driver configuration
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+@@ -1267,13 +1267,14 @@ static int rt2x00lib_initialize(struct r
+ 
+ int rt2x00lib_start(struct rt2x00_dev *rt2x00dev)
+ {
+-	int retval;
++	int retval = 0;
+ 
+ 	if (test_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags)) {
+ 		/*
+ 		 * This is special case for ieee80211_restart_hw(), otherwise
+ 		 * mac80211 never call start() two times in row without stop();
+ 		 */
++		set_bit(DEVICE_STATE_RESET, &rt2x00dev->flags);
+ 		rt2x00dev->ops->lib->pre_reset_hw(rt2x00dev);
+ 		rt2x00lib_stop(rt2x00dev);
+ 	}
+@@ -1284,14 +1285,14 @@ int rt2x00lib_start(struct rt2x00_dev *r
+ 	 */
+ 	retval = rt2x00lib_load_firmware(rt2x00dev);
+ 	if (retval)
+-		return retval;
++		goto out;
+ 
+ 	/*
+ 	 * Initialize the device.
+ 	 */
+ 	retval = rt2x00lib_initialize(rt2x00dev);
+ 	if (retval)
+-		return retval;
++		goto out;
+ 
+ 	rt2x00dev->intf_ap_count = 0;
+ 	rt2x00dev->intf_sta_count = 0;
+@@ -1300,11 +1301,13 @@ int rt2x00lib_start(struct rt2x00_dev *r
+ 	/* Enable the radio */
+ 	retval = rt2x00lib_enable_radio(rt2x00dev);
+ 	if (retval)
+-		return retval;
++		goto out;
+ 
+ 	set_bit(DEVICE_STATE_STARTED, &rt2x00dev->flags);
+ 
+-	return 0;
++out:
++	clear_bit(DEVICE_STATE_RESET, &rt2x00dev->flags);
++	return retval;
+ }
+ 
+ void rt2x00lib_stop(struct rt2x00_dev *rt2x00dev)
diff -uprN a/package/kernel/mac80211/patches/rt2x00/072-rt2x00-do-not-set-IEEE80211_TX_STAT_AMPDU_NO_BACK-on.patch b/package/kernel/mac80211/patches/rt2x00/072-rt2x00-do-not-set-IEEE80211_TX_STAT_AMPDU_NO_BACK-on.patch
--- a/package/kernel/mac80211/patches/rt2x00/072-rt2x00-do-not-set-IEEE80211_TX_STAT_AMPDU_NO_BACK-on.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/072-rt2x00-do-not-set-IEEE80211_TX_STAT_AMPDU_NO_BACK-on.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,40 @@
+From 567a9b766b47caffe4b1bf74823e7bc18532d875 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Fri, 23 Aug 2019 09:09:56 +0200
+Subject: [PATCH 13/15] rt2x00: do not set IEEE80211_TX_STAT_AMPDU_NO_BACK on
+ tx status
+
+According to documentation IEEE80211_TX_STAT_AMPDU_NO_BACK is suppose
+to be used when we do not recive BA (BlockAck). However on rt2x00 we
+use it when remote station fail to decode one or more subframes within
+AMPDU (some bits are not set in BlockAck bitmap). Setting the flag result
+in sent of BAR (BlockAck Request) frame and this might result of abuse
+of BA session, since remote station can sent BA with incorrect
+sequence numbers after receiving BAR. This problem is visible especially
+when connecting two rt2800 devices.
+
+Previously I observed some performance benefits when using the flag
+when connecting with iwlwifi devices. But currently possibly due
+to reacent changes in rt2x00 removing the flag has no effect on
+those test cases.
+
+So remove the IEEE80211_TX_STAT_AMPDU_NO_BACK.
+
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2x00dev.c | 3 ---
+ 1 file changed, 3 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+@@ -382,9 +382,6 @@ static void rt2x00lib_fill_tx_status(str
+ 				  IEEE80211_TX_CTL_AMPDU;
+ 		tx_info->status.ampdu_len = 1;
+ 		tx_info->status.ampdu_ack_len = success ? 1 : 0;
+-
+-		if (!success)
+-			tx_info->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;
+ 	}
+ 
+ 	if (rate_flags & IEEE80211_TX_RC_USE_RTS_CTS) {
diff -uprN a/package/kernel/mac80211/patches/rt2x00/073-rt2x00-clear-up-IV-s-on-key-removal.patch b/package/kernel/mac80211/patches/rt2x00/073-rt2x00-clear-up-IV-s-on-key-removal.patch
--- a/package/kernel/mac80211/patches/rt2x00/073-rt2x00-clear-up-IV-s-on-key-removal.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/073-rt2x00-clear-up-IV-s-on-key-removal.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,46 @@
+From 14d5e14c8a6c257eb322ddeb294ac4c243a7d2e1 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Fri, 23 Aug 2019 14:48:03 +0200
+Subject: [PATCH 14/15] rt2x00: clear up IV's on key removal
+
+After looking at code I realized that my previous fix
+95844124385e ("rt2x00: clear IV's on start to fix AP mode regression")
+was incomplete. We can still have wrong IV's after re-keyring.
+To fix that, clear up IV's also on key removal.
+
+Fixes: 710e6cc1595e ("rt2800: do not nullify initialization vector data")
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+tested-by: Emil Karlson <jekarl@iki.fi>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ .../net/wireless/ralink/rt2x00/rt2800lib.c    | 19 ++++++++++++-------
+ 1 file changed, 12 insertions(+), 7 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -1665,13 +1665,18 @@ static void rt2800_config_wcid_attr_ciph
+ 
+ 	offset = MAC_IVEIV_ENTRY(key->hw_key_idx);
+ 
+-	rt2800_register_multiread(rt2x00dev, offset,
+-				  &iveiv_entry, sizeof(iveiv_entry));
+-	if ((crypto->cipher == CIPHER_TKIP) ||
+-	    (crypto->cipher == CIPHER_TKIP_NO_MIC) ||
+-	    (crypto->cipher == CIPHER_AES))
+-		iveiv_entry.iv[3] |= 0x20;
+-	iveiv_entry.iv[3] |= key->keyidx << 6;
++	if (crypto->cmd == SET_KEY) {
++		rt2800_register_multiread(rt2x00dev, offset,
++					  &iveiv_entry, sizeof(iveiv_entry));
++		if ((crypto->cipher == CIPHER_TKIP) ||
++		    (crypto->cipher == CIPHER_TKIP_NO_MIC) ||
++		    (crypto->cipher == CIPHER_AES))
++			iveiv_entry.iv[3] |= 0x20;
++		iveiv_entry.iv[3] |= key->keyidx << 6;
++	} else {
++		memset(&iveiv_entry, 0, sizeof(iveiv_entry));
++	}
++
+ 	rt2800_register_multiwrite(rt2x00dev, offset,
+ 				   &iveiv_entry, sizeof(iveiv_entry));
+ }
diff -uprN a/package/kernel/mac80211/patches/rt2x00/074-Revert-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-ban.patch b/package/kernel/mac80211/patches/rt2x00/074-Revert-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-ban.patch
--- a/package/kernel/mac80211/patches/rt2x00/074-Revert-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-ban.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/074-Revert-rt2800-enable-TX_PIN_CFG_LNA_PE_-bits-per-ban.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,61 @@
+From 13fa451568ab9e8b3074ef741477c7938c713c42 Mon Sep 17 00:00:00 2001
+From: Stanislaw Gruszka <sgruszka@redhat.com>
+Date: Thu, 29 Aug 2019 13:29:59 +0200
+Subject: [PATCH 15/15] Revert "rt2800: enable TX_PIN_CFG_LNA_PE_ bits per
+ band"
+
+This reverts commit 9ad3b55654455258a9463384edb40077439d879f.
+
+As reported by Sergey:
+
+"I got some problem after upgrade kernel to 5.2 version (debian testing
+linux-image-5.2.0-2-amd64). 5Ghz client  stopped to see AP.
+Some tests with 1metre distance between client-AP: 2.4Ghz  -22dBm, for
+5Ghz - 53dBm !, for longer distance (8m + walls) 2.4 - 61dBm, 5Ghz not
+visible."
+
+It was identified that rx signal level degradation was caused by
+9ad3b5565445 ("rt2800: enable TX_PIN_CFG_LNA_PE_ bits per band").
+So revert this commit.
+
+Cc: <stable@vger.kernel.org> # v5.1+
+Reported-and-tested-by: Sergey Maranchuk <slav0nic0@gmail.com>
+Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
+Signed-off-by: Kalle Valo <kvalo@codeaurora.org>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 18 ++++++------------
+ 1 file changed, 6 insertions(+), 12 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -4253,24 +4253,18 @@ static void rt2800_config_channel(struct
+ 	switch (rt2x00dev->default_ant.rx_chain_num) {
+ 	case 3:
+ 		/* Turn on tertiary LNAs */
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A2_EN,
+-				   rf->channel > 14);
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G2_EN,
+-				   rf->channel <= 14);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A2_EN, 1);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G2_EN, 1);
+ 		/* fall-through */
+ 	case 2:
+ 		/* Turn on secondary LNAs */
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A1_EN,
+-				   rf->channel > 14);
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G1_EN,
+-				   rf->channel <= 14);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A1_EN, 1);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G1_EN, 1);
+ 		/* fall-through */
+ 	case 1:
+ 		/* Turn on primary LNAs */
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A0_EN,
+-				   rf->channel > 14);
+-		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G0_EN,
+-				   rf->channel <= 14);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_A0_EN, 1);
++		rt2x00_set_field32(&tx_pin, TX_PIN_CFG_LNA_PE_G0_EN, 1);
+ 		break;
+ 	}
+ 
diff -uprN a/package/kernel/mac80211/patches/rt2x00/075-rt2800-remove-errornous-duplicate-condition.patch b/package/kernel/mac80211/patches/rt2x00/075-rt2800-remove-errornous-duplicate-condition.patch
--- a/package/kernel/mac80211/patches/rt2x00/075-rt2800-remove-errornous-duplicate-condition.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/075-rt2800-remove-errornous-duplicate-condition.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,88 @@
+From patchwork Sat Nov  2 17:47:01 2019
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+X-Patchwork-Submitter: Daniel Golle <daniel@makrotopia.org>
+X-Patchwork-Id: 11224189
+X-Patchwork-Delegate: kvalo@adurom.com
+Return-Path: <SRS0=CgQo=Y2=vger.kernel.org=linux-wireless-owner@kernel.org>
+Date: Sat, 2 Nov 2019 18:47:01 +0100
+From: Daniel Golle <daniel@makrotopia.org>
+To: Stanislaw Gruszka <sgruszka@redhat.com>
+Cc: linux-wireless@vger.kernel.org, Roman Yeryomin <roman@advem.lv>,
+        wbob <wbob@jify.de>
+Subject: [PATCH v2] rt2800: remove errornous duplicate condition
+Message-ID: <20191102174701.GA1489@makrotopia.org>
+References: <20191102154639.GA4589@redhat.com>
+MIME-Version: 1.0
+Content-Disposition: inline
+In-Reply-To: <20191102154639.GA4589@redhat.com>
+User-Agent: Mutt/1.12.2 (2019-09-21)
+Sender: linux-wireless-owner@vger.kernel.org
+Precedence: bulk
+List-ID: <linux-wireless.vger.kernel.org>
+X-Mailing-List: linux-wireless@vger.kernel.org
+
+On 2019-10-28 06:07, wbob wrote:
+> Hello Roman,
+>
+> while reading around drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+> I stumbled on what I think is an edit of yours made in error in march
+> 2017:
+>
+> https://github.com/torvalds/linux/commit/41977e86#diff-dae5dc10da180f3b055809a48118e18aR5281
+>
+> RT6352 in line 5281 should not have been introduced as the "else if"
+> below line 5291 can then not take effect for a RT6352 device. Another
+> possibility is for line 5291 to be not for RT6352, but this seems
+> very unlikely. Are you able to clarify still after this substantial time?
+>
+> 5277: static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
+> ...
+> 5279:  } else if (rt2x00_rt(rt2x00dev, RT5390) ||
+> 5280:         rt2x00_rt(rt2x00dev, RT5392) ||
+> 5281:         rt2x00_rt(rt2x00dev, RT6352)) {
+> ...
+> 5291:  } else if (rt2x00_rt(rt2x00dev, RT6352)) {
+> ...
+
+Hence remove errornous line 5281 to make the driver actually
+execute the correct initialization routine for MT7620 chips.
+
+As it was requested by Stanislaw Gruszka remove setting values of
+MIMO_PS_CFG and TX_PIN_CFG. MIMO_PS_CFG is responsible for MIMO
+power-safe mode (which is disabled), hence we can drop setting it.
+TX_PIN_CFG is set correctly in other functions, and as setting this
+value breaks some devices, rather don't set it here during init, but
+only modify it later on.
+
+Fixes: 41977e86c984 ("rt2x00: add support for MT7620")
+Reported-by: wbob <wbob@jify.de>
+Reported-by: Roman Yeryomin <roman@advem.lv>
+Signed-off-by: Daniel Golle <daniel@makrotopia.org>
+Acked-by: Stanislaw Gruszka <sgruszka@redhat.com>
+---
+ drivers/net/wireless/ralink/rt2x00/rt2800lib.c | 5 +----
+ 1 file changed, 1 insertion(+), 4 deletions(-)
+
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+@@ -5850,8 +5850,7 @@ static int rt2800_init_registers(struct
+ 		rt2800_register_write(rt2x00dev, TX_TXBF_CFG_0, 0x8000fc21);
+ 		rt2800_register_write(rt2x00dev, TX_TXBF_CFG_3, 0x00009c40);
+ 	} else if (rt2x00_rt(rt2x00dev, RT5390) ||
+-		   rt2x00_rt(rt2x00dev, RT5392) ||
+-		   rt2x00_rt(rt2x00dev, RT6352)) {
++		   rt2x00_rt(rt2x00dev, RT5392)) {
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+@@ -5865,8 +5864,6 @@ static int rt2800_init_registers(struct
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0000);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+-		rt2800_register_write(rt2x00dev, MIMO_PS_CFG, 0x00000002);
+-		rt2800_register_write(rt2x00dev, TX_PIN_CFG, 0x00150F0F);
+ 		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
+ 		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
+ 		rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
diff -uprN a/package/kernel/mac80211/patches/rt2x00/100-rt2x00_options.patch b/package/kernel/mac80211/patches/rt2x00/100-rt2x00_options.patch
--- a/package/kernel/mac80211/patches/rt2x00/100-rt2x00_options.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/100-rt2x00_options.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/Kconfig
 +++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -226,36 +226,37 @@ config RT2800SOC
+@@ -225,36 +225,37 @@ config RT2800SOC
  
  
  config RT2800_LIB
diff -uprN a/package/kernel/mac80211/patches/rt2x00/501-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch b/package/kernel/mac80211/patches/rt2x00/501-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch
--- a/package/kernel/mac80211/patches/rt2x00/501-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/501-rt2x00-allow-to-build-rt2800soc-module-for-RT3883.patch	2022-04-04 20:20:32.959828000 +0800
@@ -10,7 +10,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
 
 --- a/drivers/net/wireless/ralink/rt2x00/Kconfig
 +++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -211,7 +211,7 @@ endif
+@@ -210,7 +210,7 @@ endif
  config RT2800SOC
  	tristate "Ralink WiSoC support"
  	depends on m
@@ -19,7 +19,7 @@ Signed-off-by: Gabor Juhos <juhosg@openw
  	select RT2X00_LIB_SOC
  	select RT2X00_LIB_MMIO
  	select RT2X00_LIB_CRYPTO
-@@ -246,7 +246,7 @@ config RT2X00_LIB_PCI
+@@ -245,7 +245,7 @@ config RT2X00_LIB_PCI
  
  config RT2X00_LIB_SOC
  	tristate "RT2x00 SoC support"
diff -uprN a/package/kernel/mac80211/patches/rt2x00/601-rt2x00-introduce-rt2x00_platform_h.patch b/package/kernel/mac80211/patches/rt2x00/601-rt2x00-introduce-rt2x00_platform_h.patch
--- a/package/kernel/mac80211/patches/rt2x00/601-rt2x00-introduce-rt2x00_platform_h.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/601-rt2x00-introduce-rt2x00_platform_h.patch	2022-04-04 20:20:32.959828000 +0800
@@ -22,7 +22,7 @@
 +#endif /* _RT2X00_PLATFORM_H */
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -28,6 +28,7 @@
+@@ -40,6 +40,7 @@
  #include <linux/average.h>
  #include <linux/usb.h>
  #include <linux/clk.h>
diff -uprN a/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch b/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch
--- a/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/602-rt2x00-introduce-rt2x00eeprom.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/local-symbols
 +++ b/local-symbols
-@@ -313,6 +313,7 @@ RT2X00_LIB_FIRMWARE=
+@@ -305,6 +305,7 @@ RT2X00_LIB_FIRMWARE=
  RT2X00_LIB_CRYPTO=
  RT2X00_LIB_LEDS=
  RT2X00_LIB_DEBUGFS=
@@ -10,7 +10,7 @@
  RTL8180=
 --- a/drivers/net/wireless/ralink/rt2x00/Kconfig
 +++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -70,6 +70,7 @@ config RT2800PCI
+@@ -69,6 +69,7 @@ config RT2800PCI
  	select RT2X00_LIB_MMIO
  	select RT2X00_LIB_PCI
  	select RT2X00_LIB_FIRMWARE
@@ -18,7 +18,7 @@
  	select RT2X00_LIB_CRYPTO
  	depends on CRC_CCITT
  	depends on EEPROM_93CX6
-@@ -216,6 +217,7 @@ config RT2800SOC
+@@ -215,6 +216,7 @@ config RT2800SOC
  	select RT2X00_LIB_MMIO
  	select RT2X00_LIB_CRYPTO
  	select RT2X00_LIB_FIRMWARE
@@ -26,12 +26,12 @@
  	select RT2800_LIB
  	select RT2800_LIB_MMIO
  	---help---
-@@ -266,6 +268,9 @@ config RT2X00_LIB_FIRMWARE
+@@ -265,6 +267,9 @@ config RT2X00_LIB_FIRMWARE
  config RT2X00_LIB_CRYPTO
  	bool
  
 +config RT2X00_LIB_EEPROM
-+	bool
++	boolean
 +
  config RT2X00_LIB_LEDS
  	bool
@@ -48,7 +48,7 @@
  obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -37,6 +37,8 @@ struct rt2800_drv_data {
+@@ -48,6 +48,8 @@ struct rt2800_drv_data {
  	struct ieee80211_sta *wcid_to_sta[STA_IDS_SIZE];
  };
  
@@ -57,7 +57,7 @@
  struct rt2800_ops {
  	u32 (*register_read)(struct rt2x00_dev *rt2x00dev,
  			      const unsigned int offset);
-@@ -135,6 +137,15 @@ static inline int rt2800_read_eeprom(str
+@@ -146,6 +148,15 @@ static inline int rt2800_read_eeprom(str
  {
  	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
  
@@ -75,7 +75,7 @@
  
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -90,19 +90,6 @@ static int rt2800soc_set_device_state(st
+@@ -102,19 +102,6 @@ static int rt2800soc_set_device_state(st
  	return retval;
  }
  
@@ -95,7 +95,7 @@
  /* Firmware functions */
  static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
  {
-@@ -166,7 +153,6 @@ static const struct rt2800_ops rt2800soc
+@@ -178,7 +165,6 @@ static const struct rt2800_ops rt2800soc
  	.register_multiread	= rt2x00mmio_register_multiread,
  	.register_multiwrite	= rt2x00mmio_register_multiwrite,
  	.regbusy_read		= rt2x00mmio_regbusy_read,
@@ -105,7 +105,7 @@
  	.drv_init_registers	= rt2800mmio_init_registers,
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -694,6 +694,7 @@ enum rt2x00_capability_flags {
+@@ -706,6 +706,7 @@ enum rt2x00_capability_flags {
  	REQUIRE_HT_TX_DESC,
  	REQUIRE_PS_AUTOWAKE,
  	REQUIRE_DELAYED_RFKILL,
@@ -113,7 +113,7 @@
  
  	/*
  	 * Capabilities
-@@ -970,6 +971,11 @@ struct rt2x00_dev {
+@@ -982,6 +983,11 @@ struct rt2x00_dev {
  	const struct firmware *fw;
  
  	/*
@@ -127,7 +127,7 @@
  	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1418,6 +1418,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
+@@ -1429,6 +1429,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
  	INIT_DELAYED_WORK(&rt2x00dev->autowakeup_work, rt2x00lib_autowakeup);
  	INIT_WORK(&rt2x00dev->sleep_work, rt2x00lib_sleep);
  
@@ -138,7 +138,7 @@
  	/*
  	 * Let the driver probe the device to detect the capabilities.
  	 */
-@@ -1561,6 +1565,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
+@@ -1572,6 +1576,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
  	 * Free the driver data.
  	 */
  	kfree(rt2x00dev->drv_data);
@@ -261,7 +261,7 @@
 +}
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00lib.h
-@@ -286,6 +286,22 @@ static inline void rt2x00lib_free_firmwa
+@@ -297,6 +297,22 @@ static inline void rt2x00lib_free_firmwa
  #endif /* CPTCFG_RT2X00_LIB_FIRMWARE */
  
  /*
@@ -286,7 +286,7 @@
  #ifdef CPTCFG_RT2X00_LIB_DEBUGFS
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
-@@ -86,6 +86,7 @@ int rt2x00soc_probe(struct platform_devi
+@@ -97,6 +97,7 @@ int rt2x00soc_probe(struct platform_devi
  	if (IS_ERR(rt2x00dev->clk))
  		rt2x00dev->clk = NULL;
  
diff -uprN a/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch b/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch
--- a/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/604-rt2x00-load-eeprom-on-SoC-from-a-mtd-device-defines-.patch	2022-04-04 20:20:32.959828000 +0800
@@ -12,7 +12,7 @@ Signed-off-by: John Crispin <blogic@open
 
 --- a/drivers/net/wireless/ralink/rt2x00/Kconfig
 +++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
-@@ -220,6 +220,7 @@ config RT2800SOC
+@@ -219,6 +219,7 @@ config RT2800SOC
  	select RT2X00_LIB_EEPROM
  	select RT2800_LIB
  	select RT2800_LIB_MMIO
@@ -22,20 +22,17 @@ Signed-off-by: John Crispin <blogic@open
  	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
-@@ -26,11 +26,76 @@
+@@ -26,11 +26,72 @@
  
  #include <linux/kernel.h>
  #include <linux/module.h>
-+#if IS_ENABLED(CONFIG_MTD)
 +#include <linux/mtd/mtd.h>
 +#include <linux/mtd/partitions.h>
-+#endif
  #include <linux/of.h>
  
  #include "rt2x00.h"
  #include "rt2x00lib.h"
  
-+#if IS_ENABLED(CONFIG_MTD)
 +static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
 +{
 +	int ret = -EINVAL;
@@ -94,19 +91,16 @@ Signed-off-by: John Crispin <blogic@open
 +
 +	return ret;
 +}
-+#endif
 +
  static const char *
  rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
  {
-@@ -58,6 +123,11 @@ static int rt2x00lib_request_eeprom_file
+@@ -58,6 +119,9 @@ static int rt2x00lib_request_eeprom_file
  	const char *ee_name;
  	int retval;
  
-+#if IS_ENABLED(CONFIG_MTD)
 +	if (!rt2800lib_read_eeprom_mtd(rt2x00dev))
 +		return 0;
-+#endif
 +
  	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
  	if (!ee_name && test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags)) {
diff -uprN a/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch b/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch
--- a/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/606-rt2x00-allow_disabling_bands_through_platform_data.patch	2022-04-04 20:20:32.959828000 +0800
@@ -12,7 +12,7 @@
  #endif /* _RT2X00_PLATFORM_H */
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1012,6 +1012,22 @@ static int rt2x00lib_probe_hw_modes(stru
+@@ -1023,6 +1023,22 @@ static int rt2x00lib_probe_hw_modes(stru
  	unsigned int num_rates;
  	unsigned int i;
  
@@ -37,7 +37,7 @@
  		num_rates += 4;
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
-@@ -399,6 +399,7 @@ struct hw_mode_spec {
+@@ -411,6 +411,7 @@ struct hw_mode_spec {
  	unsigned int supported_bands;
  #define SUPPORT_BAND_2GHZ	0x00000001
  #define SUPPORT_BAND_5GHZ	0x00000002
diff -uprN a/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch b/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch
--- a/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/607-rt2x00-add_platform_data_mac_addr.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -990,8 +990,13 @@ static void rt2x00lib_rate(struct ieee80
+@@ -1001,8 +1001,13 @@ static void rt2x00lib_rate(struct ieee80
  
  void rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)
  {
@@ -12,7 +12,7 @@
 +		ether_addr_copy(eeprom_mac_addr, pdata->mac_address);
 +
  	mac_addr = of_get_mac_address(rt2x00dev->dev->of_node);
- 	if (!IS_ERR(mac_addr))
+ 	if (mac_addr)
  		ether_addr_copy(eeprom_mac_addr, mac_addr);
 --- a/include/linux/rt2x00_platform.h
 +++ b/include/linux/rt2x00_platform.h
diff -uprN a/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch b/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch
--- a/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/608-rt2x00-allow_disabling_bands_through_dts.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1016,6 +1016,16 @@ static int rt2x00lib_probe_hw_modes(stru
+@@ -1027,6 +1027,16 @@ static int rt2x00lib_probe_hw_modes(stru
  	struct ieee80211_rate *rates;
  	unsigned int num_rates;
  	unsigned int i;
diff -uprN a/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch b/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch
--- a/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/609-rt2x00-make-wmac-loadable-via-OF-on-rt288x-305x-SoC.patch	2022-04-04 20:20:32.959828000 +0800
@@ -13,7 +13,7 @@ Signed-off-by: John Crispin <blogic@open
 
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
-@@ -223,10 +223,17 @@ static int rt2800soc_probe(struct platfo
+@@ -235,10 +235,17 @@ static int rt2800soc_probe(struct platfo
  	return rt2x00soc_probe(pdev, &rt2800soc_ops);
  }
  
diff -uprN a/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch b/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch
--- a/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/610-rt2x00-change-led-polarity-from-OF.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -25,6 +25,7 @@
+@@ -36,6 +36,7 @@
  #include <linux/kernel.h>
  #include <linux/module.h>
  #include <linux/slab.h>
@@ -8,7 +8,7 @@
  
  #include "rt2x00.h"
  #include "rt2800lib.h"
-@@ -9531,6 +9532,17 @@ static int rt2800_init_eeprom(struct rt2
+@@ -9542,6 +9543,17 @@ static int rt2800_init_eeprom(struct rt2
  	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
  	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
  
@@ -28,7 +28,7 @@
  
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
-@@ -98,6 +98,9 @@ static int rt2x00leds_register_led(struc
+@@ -109,6 +109,9 @@ static int rt2x00leds_register_led(struc
  	led->led_dev.name = name;
  	led->led_dev.brightness = LED_OFF;
  
diff -uprN a/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch b/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch
--- a/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/611-rt2x00-add-AP+STA-support.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1356,7 +1356,7 @@ static inline void rt2x00lib_set_if_comb
+@@ -1367,7 +1367,7 @@ static inline void rt2x00lib_set_if_comb
  	 */
  	if_limit = &rt2x00dev->if_limits_ap;
  	if_limit->max = rt2x00dev->ops->max_ap_intf;
diff -uprN a/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch b/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch
--- a/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/612-rt2x00-led-tpt-trigger-support.patch	2022-04-04 20:20:32.959828000 +0800
@@ -11,7 +11,7 @@ Tested-by: Christoph Krapp <achterin@goo
 
 --- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
-@@ -1129,6 +1129,19 @@ static void rt2x00lib_remove_hw(struct r
+@@ -1140,6 +1140,19 @@ static void rt2x00lib_remove_hw(struct r
  	kfree(rt2x00dev->spec.channels_info);
  }
  
@@ -31,7 +31,7 @@ Tested-by: Christoph Krapp <achterin@goo
  static int rt2x00lib_probe_hw(struct rt2x00_dev *rt2x00dev)
  {
  	struct hw_mode_spec *spec = &rt2x00dev->spec;
-@@ -1211,6 +1224,10 @@ static int rt2x00lib_probe_hw(struct rt2
+@@ -1222,6 +1235,10 @@ static int rt2x00lib_probe_hw(struct rt2
  
  #undef RT2X00_TASKLET_INIT
  
diff -uprN a/package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch b/package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch
--- a/package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/650-rt2x00-add-support-for-external-PA-on-MT7620.patch	2022-04-04 20:20:32.959828000 +0800
@@ -20,7 +20,7 @@ Signed-off-by: Tomislav Po=C5=BEega <poz
 
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
-@@ -2739,6 +2739,7 @@ enum rt2800_eeprom_word {
+@@ -2750,6 +2750,7 @@ enum rt2800_eeprom_word {
  #define EEPROM_NIC_CONF2_RX_STREAM	FIELD16(0x000f)
  #define EEPROM_NIC_CONF2_TX_STREAM	FIELD16(0x00f0)
  #define EEPROM_NIC_CONF2_CRYSTAL	FIELD16(0x0600)
@@ -30,7 +30,7 @@ Signed-off-by: Tomislav Po=C5=BEega <poz
   * EEPROM LNA
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -4359,6 +4359,45 @@ static void rt2800_config_channel(struct
+@@ -4370,6 +4370,45 @@ static void rt2800_config_channel(struct
  		rt2800_iq_calibrate(rt2x00dev, rf->channel);
  	}
  
@@ -76,7 +76,7 @@ Signed-off-by: Tomislav Po=C5=BEega <poz
  	bbp = rt2800_bbp_read(rt2x00dev, 4);
  	rt2x00_set_field8(&bbp, BBP4_BANDWIDTH, 2 * conf_is_ht40(conf));
  	rt2800_bbp_write(rt2x00dev, 4, bbp);
-@@ -9560,7 +9599,8 @@ static int rt2800_init_eeprom(struct rt2
+@@ -9571,7 +9610,8 @@ static int rt2800_init_eeprom(struct rt2
  	 */
  	eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1);
  
@@ -86,7 +86,7 @@ Signed-off-by: Tomislav Po=C5=BEega <poz
  		if (rt2x00_get_field16(eeprom,
  		    EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352))
  		    __set_bit(CAPABILITY_EXTERNAL_PA_TX0,
-@@ -9571,6 +9611,18 @@ static int rt2800_init_eeprom(struct rt2
+@@ -9582,6 +9622,18 @@ static int rt2800_init_eeprom(struct rt2
  			      &rt2x00dev->cap_flags);
  	}
  
diff -uprN a/package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch b/package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch
--- a/package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/982-rt2x00-add-rf-self-txdc-calibration.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,10 +1,10 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8422,6 +8422,56 @@ static void rt2800_init_rfcsr_5592(struc
+@@ -8433,6 +8433,58 @@ static void rt2800_init_rfcsr_5592(struc
  	rt2800_led_open_drain_enable(rt2x00dev);
  }
  
-+static void rt2800_rf_self_txdc_cal(struct rt2x00_dev *rt2x00dev)
++void rt2800_rf_self_txdc_cal(struct rt2x00_dev *rt2x00dev)
 +{
 +	u8 rfb5r1_org, rfb7r1_org, rfvalue;
 +	u32 mac0518, mac051c, mac0528, mac052c;
@@ -52,12 +52,14 @@
 +	rt2800_register_write(rt2x00dev, RF_BYPASS2, mac052c);
 +
 +	rt2x00_info(rt2x00dev, "RF Tx self calibration end\n");
++
 +}
++EXPORT_SYMBOL_GPL(rt2800_rf_self_txdc_cal);
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9029,6 +9079,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9040,6 +9092,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
  	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
  
@@ -65,3 +67,23 @@
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
  }
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -253,6 +253,7 @@ void rt2800_link_tuner(struct rt2x00_dev
+ 		       const u32 count);
+ void rt2800_gain_calibration(struct rt2x00_dev *rt2x00dev);
+ void rt2800_vco_calibration(struct rt2x00_dev *rt2x00dev);
++void rt2800_rf_self_txdc_cal(struct rt2x00_dev *rt2x00dev);
+ 
+ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev);
+ void rt2800_disable_radio(struct rt2x00_dev *rt2x00dev);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -574,6 +574,7 @@ struct rt2x00lib_ops {
+ 			    struct link_qual *qual, const u32 count);
+ 	void (*gain_calibration) (struct rt2x00_dev *rt2x00dev);
+ 	void (*vco_calibration) (struct rt2x00_dev *rt2x00dev);
++	void (*rf_self_txdc_cal) (struct rt2x00_dev *rt2x00dev);
+ 
+ 	/*
+ 	 * Data queue handlers.
diff -uprN a/package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch b/package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch
--- a/package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/983-rt2x00-add-r-calibration.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,10 +1,10 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8472,6 +8472,155 @@ static void rt2800_rf_self_txdc_cal(stru
- 	rt2x00_info(rt2x00dev, "RF Tx self calibration end\n");
+@@ -8485,6 +8485,160 @@ void rt2800_rf_self_txdc_cal(struct rt2x
  }
+ EXPORT_SYMBOL_GPL(rt2800_rf_self_txdc_cal);
  
-+static int rt2800_calcrcalibrationcode(struct rt2x00_dev *rt2x00dev, int d1, int d2)
++int rt2800_calcrcalibrationcode(struct rt2x00_dev *rt2x00dev, int d1, int d2)
 +{
 +	int calcode;
 +	calcode = ((d2 - d1) * 1000) / 43;
@@ -14,8 +14,9 @@
 +
 +	return calcode;
 +}
++EXPORT_SYMBOL_GPL(rt2800_calcrcalibrationcode);
 +
-+static void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev)
++void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev)
 +{
 +	u32 savemacsysctrl;
 +	u8 saverfb0r1, saverfb0r34, saverfb0r35;
@@ -28,8 +29,6 @@
 +	char d1 = 0, d2 = 0;
 +	u8 rfvalue;
 +	u32 MAC_RF_BYPASS0, MAC_RF_CONTROL0, MAC_PWR_PIN_CFG;
-+	u32 maccfg, macstatus;
-+	int i;
 +
 +	saverfb0r1 = rt2800_rfcsr_read_bank(rt2x00dev, 0, 1);
 +	saverfb0r34 = rt2800_rfcsr_read_bank(rt2x00dev, 0, 34);
@@ -49,6 +48,10 @@
 +	MAC_RF_CONTROL0 = rt2800_register_read(rt2x00dev, RF_CONTROL0);
 +	MAC_PWR_PIN_CFG = rt2800_register_read(rt2x00dev, PWR_PIN_CFG);
 +
++	{
++	u32 maccfg, macstatus;
++	int i;
++
 +	maccfg = rt2800_register_read(rt2x00dev, MAC_SYS_CTRL);
 +	maccfg &= (~0x04);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, maccfg);
@@ -59,7 +62,7 @@
 +			udelay(50);
 +		else
 +			break;
-+	}
++		}
 +
 +	if (i == 10000)
 +		rt2x00_warn(rt2x00dev, "Wait MAC Tx Status to MAX !!!\n");
@@ -78,6 +81,7 @@
 +
 +	if (i == 10000)
 +		rt2x00_warn(rt2x00dev, "Wait MAC Rx Status to MAX !!!\n");
++	}
 +
 +	rfvalue = (MAC_RF_BYPASS0 | 0x3004);
 +	rt2800_register_write(rt2x00dev, RF_BYPASS0, rfvalue);
@@ -152,11 +156,12 @@
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, savemacsysctrl);
 +	rt2800_register_write(rt2x00dev, PWR_PIN_CFG, MAC_PWR_PIN_CFG);
 +}
++EXPORT_SYMBOL_GPL(rt2800_r_calibration);
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9079,6 +9228,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9092,6 +9246,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
  	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
  
@@ -164,3 +169,25 @@
  	rt2800_rf_self_txdc_cal(rt2x00dev);
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -254,6 +254,8 @@ void rt2800_link_tuner(struct rt2x00_dev
+ void rt2800_gain_calibration(struct rt2x00_dev *rt2x00dev);
+ void rt2800_vco_calibration(struct rt2x00_dev *rt2x00dev);
+ void rt2800_rf_self_txdc_cal(struct rt2x00_dev *rt2x00dev);
++int rt2800_calcrcalibrationcode(struct rt2x00_dev *rt2x00dev, int d1, int d2);
++void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev);
+ 
+ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev);
+ void rt2800_disable_radio(struct rt2x00_dev *rt2x00dev);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -575,6 +575,8 @@ struct rt2x00lib_ops {
+ 	void (*gain_calibration) (struct rt2x00_dev *rt2x00dev);
+ 	void (*vco_calibration) (struct rt2x00_dev *rt2x00dev);
+ 	void (*rf_self_txdc_cal) (struct rt2x00_dev *rt2x00dev);
++	int (*calcrcalibrationcode) (struct rt2x00_dev *rt2x00dev, int d1, int d2);
++	void (*r_calibration) (struct rt2x00_dev *rt2x00dev);
+ 
+ 	/*
+ 	 * Data queue handlers.
diff -uprN a/package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch b/package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch
--- a/package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/984-rt2x00-add-rxdcoc-calibration.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,10 +1,10 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8621,6 +8621,70 @@ static void rt2800_r_calibration(struct
- 	rt2800_register_write(rt2x00dev, PWR_PIN_CFG, MAC_PWR_PIN_CFG);
+@@ -8639,6 +8639,71 @@ void rt2800_r_calibration(struct rt2x00_
  }
+ EXPORT_SYMBOL_GPL(rt2800_r_calibration);
  
-+static void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev)
++void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev)
 +{
 +	u8 bbpreg = 0;
 +	u32 macvalue = 0, macvalue1 = 0;
@@ -67,11 +67,12 @@
 +
 +	rt2800_rfcsr_write_bank(rt2x00dev, 0, 2, saverfb0r2);
 +}
++EXPORT_SYMBOL_GPL(rt2800_rxdcoc_calibration);
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9230,6 +9294,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9248,6 +9313,7 @@ static void rt2800_init_rfcsr_6352(struc
  
  	rt2800_r_calibration(rt2x00dev);
  	rt2800_rf_self_txdc_cal(rt2x00dev);
@@ -79,3 +80,23 @@
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
  }
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -256,6 +256,7 @@ void rt2800_vco_calibration(struct rt2x0
+ void rt2800_rf_self_txdc_cal(struct rt2x00_dev *rt2x00dev);
+ int rt2800_calcrcalibrationcode(struct rt2x00_dev *rt2x00dev, int d1, int d2);
+ void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev);
++void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev);
+ 
+ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev);
+ void rt2800_disable_radio(struct rt2x00_dev *rt2x00dev);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -577,6 +577,7 @@ struct rt2x00lib_ops {
+ 	void (*rf_self_txdc_cal) (struct rt2x00_dev *rt2x00dev);
+ 	int (*calcrcalibrationcode) (struct rt2x00_dev *rt2x00dev, int d1, int d2);
+ 	void (*r_calibration) (struct rt2x00_dev *rt2x00dev);
++	void (*rxdcoc_calibration) (struct rt2x00_dev *rt2x00dev);
+ 
+ 	/*
+ 	 * Data queue handlers.
diff -uprN a/package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch b/package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch
--- a/package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/985-rt2x00-add-rxiq-calibration.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,8 +1,8 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -8685,6 +8685,384 @@ static void rt2800_rxdcoc_calibration(st
- 	rt2800_rfcsr_write_bank(rt2x00dev, 0, 2, saverfb0r2);
+@@ -8704,6 +8704,386 @@ void rt2800_rxdcoc_calibration(struct rt
  }
+ EXPORT_SYMBOL_GPL(rt2800_rxdcoc_calibration);
  
 +static u32 rt2800_do_sqrt_accumulation(u32 si) {
 +	u32 root, root_pre, bit;
@@ -18,8 +18,9 @@
 +
 +	return root;
 +}
++EXPORT_SYMBOL_GPL(rt2800_do_sqrt_accumulation);
 +
-+static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev) {
++void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev) {
 +	u8 rfb0r1, rfb0r2, rfb0r42;
 +	u8 rfb4r0, rfb4r19;
 +	u8 rfb5r3, rfb5r4, rfb5r17, rfb5r18, rfb5r19, rfb5r20;
@@ -82,11 +83,11 @@
 +
 +	rt2800_register_write(rt2x00dev, RF_CONTROL1, 0x00000202);
 +	rt2800_register_write(rt2x00dev, RF_BYPASS1, 0x00000303);
-+	if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags))
++	if (test_bit(CAPABILITY_EXTERNAL_PA_TX0, &rt2x00dev->cap_flags)) {
 +		rt2800_register_write(rt2x00dev, RF_CONTROL3, 0x0101);
-+	else
++	} else {
 +		rt2800_register_write(rt2x00dev, RF_CONTROL3, 0x0000);
-+
++	}
 +	rt2800_register_write(rt2x00dev, RF_BYPASS3, 0xf1f1);
 +
 +	rfb0r1 = rt2800_rfcsr_read_bank(rt2x00dev, 0, 1);
@@ -340,10 +341,10 @@
 +
 +	rt2800_bbp_write(rt2x00dev, 244, 0x00);
 +	bbpval = rt2800_bbp_read(rt2x00dev, 21);
-+	bbpval |= 0x1;
++	bbpval = (bbpval | 0x1);
 +	rt2800_bbp_write(rt2x00dev, 21, bbpval);
 +	usleep_range(10, 200);
-+	bbpval &= 0xfe;
++	bbpval = (bbpval & 0xfe);
 +	rt2800_bbp_write(rt2x00dev, 21, bbpval);
 +
 +	rt2800_rfcsr_write_bank(rt2x00dev, 0, 1, rfb0r1);
@@ -381,11 +382,12 @@
 +	rt2800_register_write(rt2x00dev, RF_BYPASS3, orig_RF_BYPASS3);
 +	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, savemacsysctrl);
 +}
++EXPORT_SYMBOL_GPL(rt2800_rxiq_calibration);
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9297,6 +9675,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9316,6 +9696,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rxdcoc_calibration(rt2x00dev);
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
@@ -393,3 +395,23 @@
  }
  
  static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
+--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+@@ -257,6 +257,7 @@ void rt2800_rf_self_txdc_cal(struct rt2x
+ int rt2800_calcrcalibrationcode(struct rt2x00_dev *rt2x00dev, int d1, int d2);
+ void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev);
+ void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev);
++void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev);
+ 
+ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev);
+ void rt2800_disable_radio(struct rt2x00_dev *rt2x00dev);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -578,6 +578,7 @@ struct rt2x00lib_ops {
+ 	int (*calcrcalibrationcode) (struct rt2x00_dev *rt2x00dev, int d1, int d2);
+ 	void (*r_calibration) (struct rt2x00_dev *rt2x00dev);
+ 	void (*rxdcoc_calibration) (struct rt2x00_dev *rt2x00dev);
++	void (*rxiq_calibration) (struct rt2x00_dev *rt2x00dev);
+ 
+ 	/*
+ 	 * Data queue handlers.
diff -uprN a/package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch b/package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch
--- a/package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/rt2x00/986-rt2x00-add-TX-LOFT-calibration.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,8 +1,8 @@
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
-@@ -9063,6 +9063,943 @@ restore_value:
- 	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, savemacsysctrl);
+@@ -9084,6 +9084,954 @@ restore_value:
  }
+ EXPORT_SYMBOL_GPL(rt2800_rxiq_calibration);
  
 +static void rt2800_rf_configstore(struct rt2x00_dev *rt2x00dev, rf_reg_pair rf_reg_record[][13], u8 chain)
 +{
@@ -121,6 +121,7 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_rf_configstore);
 +
 +static void rt2800_rf_configrecover(struct rt2x00_dev *rt2x00dev, rf_reg_pair rf_record[][13])
 +{
@@ -139,6 +140,7 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_rf_configrecover);
 +
 +static void rt2800_setbbptonegenerator(struct rt2x00_dev *rt2x00dev)
 +{
@@ -158,8 +160,9 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_setbbptonegenerator);
 +
-+static u32 rt2800_do_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx, u8 read_neg)
++u32 rt2800_do_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx, u8 read_neg)
 +{
 +	u32 macvalue = 0;
 +	int fftout_i = 0, fftout_q = 0;
@@ -217,8 +220,9 @@
 +
 +	return pint;
 +}
++EXPORT_SYMBOL_GPL(rt2800_do_fft_accumulation);
 +
-+static u32 rt2800_read_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx) {
++u32 rt2800_read_fft_accumulation(struct rt2x00_dev *rt2x00dev, u8 tidx) {
 +	u32 macvalue = 0;
 +	int fftout_i = 0, fftout_q = 0;
 +	u32 ptmp=0, pint = 0;
@@ -241,6 +245,7 @@
 +
 +	return pint;
 +}
++EXPORT_SYMBOL_GPL(rt2800_read_fft_accumulation);
 +
 +static void rt2800_write_dc(struct rt2x00_dev *rt2x00dev, u8 ch_idx, u8 alc, u8 iorq, u8 dc)
 +{
@@ -261,6 +266,7 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_write_dc);
 +
 +static void rt2800_loft_search(struct rt2x00_dev *rt2x00dev, u8 ch_idx, u8 alc_idx, u8 dc_result[][RF_ALC_NUM][2])
 +{
@@ -318,6 +324,7 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_loft_search);
 +
 +static void rt2800_iq_search(struct rt2x00_dev *rt2x00dev, u8 ch_idx, u8 *ges, u8 *pes)
 +{
@@ -443,6 +450,7 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_iq_search);
 +
 +static void rt2800_rf_aux_tx0_loopback(struct rt2x00_dev *rt2x00dev)
 +{
@@ -460,6 +468,7 @@
 +	rt2800_rfcsr_write_bank(rt2x00dev, 5, 19, 0xa2);
 +	rt2800_rfcsr_write_bank(rt2x00dev, 5, 20, 0x20);
 +}
++EXPORT_SYMBOL_GPL(rt2800_rf_aux_tx0_loopback);
 +
 +static void rt2800_rf_aux_tx1_loopback(struct rt2x00_dev *rt2x00dev)
 +{
@@ -477,6 +486,7 @@
 +	rt2800_rfcsr_write_bank(rt2x00dev, 7, 19, 0xa2);
 +	rt2800_rfcsr_write_bank(rt2x00dev, 7, 20, 0x20);
 +}
++EXPORT_SYMBOL_GPL(rt2800_rf_aux_tx1_loopback);
 +
 +void rt2800_loft_iq_calibration(struct rt2x00_dev *rt2x00dev)
 +{
@@ -940,11 +950,12 @@
 +
 +	return;
 +}
++EXPORT_SYMBOL_GPL(rt2800_loft_iq_calibration);
 +
  static void rt2800_bbp_core_soft_reset(struct rt2x00_dev *rt2x00dev,
  				       bool set_bw, bool is_ht40)
  {
-@@ -9675,6 +10612,7 @@ static void rt2800_init_rfcsr_6352(struc
+@@ -9696,6 +10644,7 @@ static void rt2800_init_rfcsr_6352(struc
  	rt2800_rxdcoc_calibration(rt2x00dev);
  	rt2800_bw_filter_calibration(rt2x00dev, true);
  	rt2800_bw_filter_calibration(rt2x00dev, false);
@@ -954,7 +965,7 @@
  
 --- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
 +++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
-@@ -17,6 +17,16 @@
+@@ -28,6 +28,16 @@
  #define WCID_START	33
  #define WCID_END	222
  #define STA_IDS_SIZE	(WCID_END - WCID_START + 2)
@@ -971,3 +982,21 @@
  
  /* RT2800 driver data structure */
  struct rt2800_drv_data {
+@@ -258,6 +268,7 @@ int rt2800_calcrcalibrationcode(struct r
+ void rt2800_r_calibration(struct rt2x00_dev *rt2x00dev);
+ void rt2800_rxdcoc_calibration(struct rt2x00_dev *rt2x00dev);
+ void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev);
++void rt2800_loft_iq_calibration(struct rt2x00_dev *rt2x00dev);
+ 
+ int rt2800_enable_radio(struct rt2x00_dev *rt2x00dev);
+ void rt2800_disable_radio(struct rt2x00_dev *rt2x00dev);
+--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+@@ -579,6 +579,7 @@ struct rt2x00lib_ops {
+ 	void (*r_calibration) (struct rt2x00_dev *rt2x00dev);
+ 	void (*rxdcoc_calibration) (struct rt2x00_dev *rt2x00dev);
+ 	void (*rxiq_calibration) (struct rt2x00_dev *rt2x00dev);
++	void (*loft_iq_calibration) (struct rt2x00_dev *rt2x00dev);
+ 
+ 	/*
+ 	 * Data queue handlers.
diff -uprN a/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch b/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch
--- a/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/100-remove-cryptoapi-dependencies.patch	2022-04-04 20:20:32.959828000 +0800
@@ -20,14 +20,17 @@
  	ethtool.o \
 --- a/net/mac80211/aead_api.c
 +++ /dev/null
-@@ -1,112 +0,0 @@
--// SPDX-License-Identifier: GPL-2.0-only
+@@ -1,115 +0,0 @@
 -/*
 - * Copyright 2003-2004, Instant802 Networks, Inc.
 - * Copyright 2005-2006, Devicescape Software, Inc.
 - * Copyright 2014-2015, Qualcomm Atheros, Inc.
 - *
 - * Rewrite: Copyright (C) 2013 Linaro Ltd <ard.biesheuvel@linaro.org>
+- *
+- * This program is free software; you can redistribute it and/or modify
+- * it under the terms of the GNU General Public License version 2 as
+- * published by the Free Software Foundation.
 - */
 -
 -#include <linux/kernel.h>
@@ -135,8 +138,12 @@
 -}
 --- a/net/mac80211/aead_api.h
 +++ /dev/null
-@@ -1,23 +0,0 @@
--/* SPDX-License-Identifier: GPL-2.0-only */
+@@ -1,27 +0,0 @@
+-/*
+- * This program is free software; you can redistribute it and/or modify
+- * it under the terms of the GNU General Public License version 2 as
+- * published by the Free Software Foundation.
+- */
 -
 -#ifndef _AEAD_API_H
 -#define _AEAD_API_H
@@ -161,7 +168,7 @@
 -#endif /* _AEAD_API_H */
 --- a/net/mac80211/aes_ccm.h
 +++ b/net/mac80211/aes_ccm.h
-@@ -7,39 +7,17 @@
+@@ -10,39 +10,17 @@
  #ifndef AES_CCM_H
  #define AES_CCM_H
  
@@ -326,7 +333,7 @@
 +}
 --- a/net/mac80211/aes_gcm.h
 +++ b/net/mac80211/aes_gcm.h
-@@ -6,38 +6,30 @@
+@@ -9,38 +9,30 @@
  #ifndef AES_GCM_H
  #define AES_GCM_H
  
@@ -378,7 +385,7 @@
  #endif /* AES_GCM_H */
 --- a/net/mac80211/wpa.c
 +++ b/net/mac80211/wpa.c
-@@ -311,7 +311,8 @@ ieee80211_crypto_tkip_decrypt(struct iee
+@@ -315,7 +315,8 @@ ieee80211_crypto_tkip_decrypt(struct iee
  }
  
  
@@ -388,7 +395,7 @@
  {
  	__le16 mask_fc;
  	int a4_included, mgmt;
-@@ -341,14 +342,8 @@ static void ccmp_special_blocks(struct s
+@@ -345,14 +346,8 @@ static void ccmp_special_blocks(struct s
  	else
  		qos_tid = 0;
  
@@ -405,7 +412,7 @@
  
  	/* Nonce: Nonce Flags | A2 | PN
  	 * Nonce Flags: Priority (b0..b3) | Management (b4) | Reserved (b5..b7)
-@@ -356,6 +351,8 @@ static void ccmp_special_blocks(struct s
+@@ -360,6 +355,8 @@ static void ccmp_special_blocks(struct s
  	b_0[1] = qos_tid | (mgmt << 4);
  	memcpy(&b_0[2], hdr->addr2, ETH_ALEN);
  	memcpy(&b_0[8], pn, IEEE80211_CCMP_PN_LEN);
@@ -414,7 +421,7 @@
  
  	/* AAD (extra authenticate-only data) / masked 802.11 header
  	 * FC | A1 | A2 | A3 | SC | [A4] | [QC] */
-@@ -412,7 +409,7 @@ static int ccmp_encrypt_skb(struct ieee8
+@@ -416,7 +413,7 @@ static int ccmp_encrypt_skb(struct ieee8
  	u8 *pos;
  	u8 pn[6];
  	u64 pn64;
@@ -423,7 +430,7 @@
  	u8 b_0[AES_BLOCK_SIZE];
  
  	if (info->control.hw_key &&
-@@ -467,9 +464,11 @@ static int ccmp_encrypt_skb(struct ieee8
+@@ -471,9 +468,11 @@ static int ccmp_encrypt_skb(struct ieee8
  		return 0;
  
  	pos += IEEE80211_CCMP_HDR_LEN;
@@ -438,7 +445,7 @@
  }
  
  
-@@ -542,13 +541,13 @@ ieee80211_crypto_ccmp_decrypt(struct iee
+@@ -546,13 +545,13 @@ ieee80211_crypto_ccmp_decrypt(struct iee
  			u8 aad[2 * AES_BLOCK_SIZE];
  			u8 b_0[AES_BLOCK_SIZE];
  			/* hardware didn't decrypt/verify MIC */
@@ -454,7 +461,7 @@
  				return RX_DROP_UNUSABLE;
  		}
  
-@@ -643,7 +642,7 @@ static int gcmp_encrypt_skb(struct ieee8
+@@ -649,7 +648,7 @@ static int gcmp_encrypt_skb(struct ieee8
  	u8 *pos;
  	u8 pn[6];
  	u64 pn64;
@@ -463,7 +470,7 @@
  	u8 j_0[AES_BLOCK_SIZE];
  
  	if (info->control.hw_key &&
-@@ -700,8 +699,10 @@ static int gcmp_encrypt_skb(struct ieee8
+@@ -706,8 +705,10 @@ static int gcmp_encrypt_skb(struct ieee8
  
  	pos += IEEE80211_GCMP_HDR_LEN;
  	gcmp_special_blocks(skb, pn, j_0, aad);
@@ -476,7 +483,7 @@
  }
  
  ieee80211_tx_result
-@@ -1128,9 +1129,9 @@ ieee80211_crypto_aes_gmac_encrypt(struct
+@@ -1132,9 +1133,9 @@ ieee80211_crypto_aes_gmac_encrypt(struct
  	struct ieee80211_key *key = tx->key;
  	struct ieee80211_mmie_16 *mmie;
  	struct ieee80211_hdr *hdr;
@@ -488,7 +495,7 @@
  
  	if (WARN_ON(skb_queue_len(&tx->skbs) != 1))
  		return TX_DROP;
-@@ -1176,7 +1177,7 @@ ieee80211_crypto_aes_gmac_decrypt(struct
+@@ -1180,7 +1181,7 @@ ieee80211_crypto_aes_gmac_decrypt(struct
  	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
  	struct ieee80211_key *key = rx->key;
  	struct ieee80211_mmie_16 *mmie;
@@ -646,9 +653,9 @@
 +}
 --- a/net/mac80211/Kconfig
 +++ b/net/mac80211/Kconfig
-@@ -6,8 +6,6 @@ config MAC80211
+@@ -5,8 +5,6 @@ config MAC80211
  	depends on CRYPTO
- 	select BPAUTO_CRYPTO_LIB_ARC4
+ 	depends on CRYPTO_ARC4
  	depends on CRYPTO_AES
 -	depends on CRYPTO_CCM
 -	depends on CRYPTO_GCM
@@ -657,7 +664,7 @@
  	---help---
 --- a/net/mac80211/aes_gmac.h
 +++ b/net/mac80211/aes_gmac.h
-@@ -12,10 +12,22 @@
+@@ -15,10 +15,22 @@
  #define GMAC_MIC_LEN	16
  #define GMAC_NONCE_LEN	12
  
diff -uprN a/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch b/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch
--- a/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/110-mac80211_keep_keys_on_stop_ap.patch	2022-04-04 20:20:32.959828000 +0800
@@ -2,8 +2,8 @@ Used for AP+STA support in OpenWrt - pre
 
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -1172,7 +1172,6 @@ static int ieee80211_stop_ap(struct wiph
- 	sdata->vif.bss_conf.ftmr_params = NULL;
+@@ -1068,7 +1068,6 @@ static int ieee80211_stop_ap(struct wiph
+ 	sdata->u.ap.driver_smps_mode = IEEE80211_SMPS_OFF;
  
  	__sta_info_flush(sdata, true);
 -	ieee80211_free_keys(sdata, true);
diff -uprN a/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch b/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch
--- a/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/120-cfg80211_allow_perm_addr_change.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/net/wireless/sysfs.c
 +++ b/net/wireless/sysfs.c
-@@ -23,18 +23,35 @@ static inline struct cfg80211_registered
+@@ -24,18 +24,35 @@ static inline struct cfg80211_registered
  	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
  }
  
diff -uprN a/package/kernel/mac80211/patches/subsys/130-disable-fils.patch b/package/kernel/mac80211/patches/subsys/130-disable-fils.patch
--- a/package/kernel/mac80211/patches/subsys/130-disable-fils.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/130-disable-fils.patch	2022-04-04 20:20:32.959828000 +0800
@@ -2,7 +2,7 @@ Disable FILS support, since it pulls in
 
 --- a/net/mac80211/fils_aead.h
 +++ b/net/mac80211/fils_aead.h
-@@ -7,7 +7,7 @@
+@@ -10,7 +10,7 @@
  #ifndef FILS_AEAD_H
  #define FILS_AEAD_H
  
@@ -16,12 +16,12 @@ Disable FILS support, since it pulls in
 @@ -1,4 +1,4 @@
 -#if LINUX_VERSION_IS_GEQ(4,3,0)
 +#if 0 /* LINUX_VERSION_IS_GEQ(4,3,0) */
- // SPDX-License-Identifier: GPL-2.0-only
  /*
   * FILS AEAD for (Re)Association Request/Response frames
+  * Copyright 2016, Qualcomm Atheros, Inc.
 --- a/net/mac80211/main.c
 +++ b/net/mac80211/main.c
-@@ -571,7 +571,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+@@ -570,7 +570,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
  			   NL80211_FEATURE_MAC_ON_CREATE |
  			   NL80211_FEATURE_USERSPACE_MPM |
  			   NL80211_FEATURE_FULL_AP_CLIENT_STATE;
diff -uprN a/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch b/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch
--- a/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/131-Revert-mac80211-aes-cmac-switch-to-shash-CMAC-driver.patch	2022-04-04 20:20:32.959828000 +0800
@@ -11,7 +11,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
 
 --- a/net/mac80211/aes_cmac.c
 +++ b/net/mac80211/aes_cmac.c
-@@ -19,50 +19,126 @@
+@@ -22,50 +22,126 @@
  #define CMAC_TLEN_256 16 /* CMAC TLen = 128 bits (16 octets) */
  #define AAD_LEN 20
  
@@ -166,7 +166,7 @@ Signed-off-by: Felix Fietkau <nbd@nbd.na
  }
 --- a/net/mac80211/aes_cmac.h
 +++ b/net/mac80211/aes_cmac.h
-@@ -7,14 +7,13 @@
+@@ -10,14 +10,13 @@
  #define AES_CMAC_H
  
  #include <linux/crypto.h>
diff -uprN a/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch b/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch
--- a/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/132-mac80211-remove-cmac-dependency.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,8 +1,8 @@
 --- a/net/mac80211/Kconfig
 +++ b/net/mac80211/Kconfig
-@@ -6,7 +6,6 @@ config MAC80211
+@@ -5,7 +5,6 @@ config MAC80211
  	depends on CRYPTO
- 	select BPAUTO_CRYPTO_LIB_ARC4
+ 	depends on CRYPTO_ARC4
  	depends on CRYPTO_AES
 -	depends on CRYPTO_CMAC
  	depends on CRC32
diff -uprN a/package/kernel/mac80211/patches/subsys/140-tweak-TSQ-setting.patch b/package/kernel/mac80211/patches/subsys/140-tweak-TSQ-setting.patch
--- a/package/kernel/mac80211/patches/subsys/140-tweak-TSQ-setting.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/140-tweak-TSQ-setting.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/net/mac80211/tx.c
 +++ b/net/mac80211/tx.c
-@@ -4024,6 +4024,12 @@ out:
+@@ -3833,6 +3833,12 @@ out:
  netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
  				       struct net_device *dev)
  {
diff -uprN a/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch b/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch
--- a/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/150-disable_addr_notifier.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/net/mac80211/main.c
 +++ b/net/mac80211/main.c
-@@ -314,7 +314,7 @@ void ieee80211_restart_hw(struct ieee802
+@@ -315,7 +315,7 @@ void ieee80211_restart_hw(struct ieee802
  }
  EXPORT_SYMBOL(ieee80211_restart_hw);
  
@@ -9,7 +9,7 @@
  static int ieee80211_ifa_changed(struct notifier_block *nb,
  				 unsigned long data, void *arg)
  {
-@@ -373,7 +373,7 @@ static int ieee80211_ifa_changed(struct
+@@ -374,7 +374,7 @@ static int ieee80211_ifa_changed(struct
  }
  #endif
  
@@ -18,7 +18,7 @@
  static int ieee80211_ifa6_changed(struct notifier_block *nb,
  				  unsigned long data, void *arg)
  {
-@@ -1264,14 +1264,14 @@ int ieee80211_register_hw(struct ieee802
+@@ -1182,14 +1182,14 @@ int ieee80211_register_hw(struct ieee802
  
  	rtnl_unlock();
  
@@ -35,7 +35,7 @@
  	local->ifa6_notifier.notifier_call = ieee80211_ifa6_changed;
  	result = register_inet6addr_notifier(&local->ifa6_notifier);
  	if (result)
-@@ -1280,13 +1280,13 @@ int ieee80211_register_hw(struct ieee802
+@@ -1198,13 +1198,13 @@ int ieee80211_register_hw(struct ieee802
  
  	return 0;
  
@@ -52,7 +52,7 @@
   fail_ifa:
  #endif
  	rtnl_lock();
-@@ -1314,10 +1314,10 @@ void ieee80211_unregister_hw(struct ieee
+@@ -1233,10 +1233,10 @@ void ieee80211_unregister_hw(struct ieee
  	tasklet_kill(&local->tx_pending_tasklet);
  	tasklet_kill(&local->tasklet);
  
diff -uprN a/package/kernel/mac80211/patches/subsys/210-ap_scan.patch b/package/kernel/mac80211/patches/subsys/210-ap_scan.patch
--- a/package/kernel/mac80211/patches/subsys/210-ap_scan.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/210-ap_scan.patch	2022-04-04 20:20:32.959828000 +0800
@@ -1,6 +1,6 @@
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -2317,7 +2317,7 @@ static int ieee80211_scan(struct wiphy *
+@@ -2192,7 +2192,7 @@ static int ieee80211_scan(struct wiphy *
  		 * the  frames sent while scanning on other channel will be
  		 * lost)
  		 */
diff -uprN a/package/kernel/mac80211/patches/subsys/300-mac80211-add-stop-start-logic-for-software-TXQs.patch b/package/kernel/mac80211/patches/subsys/300-mac80211-add-stop-start-logic-for-software-TXQs.patch
--- a/package/kernel/mac80211/patches/subsys/300-mac80211-add-stop-start-logic-for-software-TXQs.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/300-mac80211-add-stop-start-logic-for-software-TXQs.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,272 @@
+From: Manikanta Pubbisetty <mpubbise@codeaurora.org>
+Date: Wed, 11 Jul 2018 00:12:53 +0530
+Subject: [PATCH] mac80211: add stop/start logic for software TXQs
+
+Sometimes, it is required to stop the transmissions momentarily and
+resume it later; stopping the txqs becomes very critical in scenarios where
+the packet transmission has to be ceased completely. For example, during
+the hardware restart, during off channel operations,
+when initiating CSA(upon detecting a radar on the DFS channel), etc.
+
+The TX queue stop/start logic in mac80211 works well in stopping the TX
+when drivers make use of netdev queues, i.e, when Qdiscs in network layer
+take care of traffic scheduling. Since the devices implementing
+wake_tx_queue can run without Qdiscs, packets will be handed to mac80211
+directly without queueing them in the netdev queues.
+
+Also, mac80211 does not invoke any of the
+netif_stop_*/netif_wake_* APIs if wake_tx_queue is implemented.
+Since the queues are not stopped in this case, transmissions can continue
+and this will impact negatively on the operation of the wireless device.
+
+For example,
+During hardware restart, we stop the netdev queues so that packets are
+not sent to the driver. Since ath10k implements wake_tx_queue,
+TX queues will not be stopped and packets might reach the hardware while
+it is restarting; this can make hardware unresponsive and the only
+possible option for recovery is to reboot the entire system.
+
+There is another problem to this, it is observed that the packets
+were sent on the DFS channel for a prolonged duration after radar
+detection impacting the channel closing time.
+
+We can still invoke netif stop/wake APIs when wake_tx_queue is implemented
+but this could lead to packet drops in network layer; adding stop/start
+logic for software TXQs in mac80211 instead makes more sense; the change
+proposed adds the same in mac80211.
+
+Signed-off-by: Manikanta Pubbisetty <mpubbise@codeaurora.org>
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -1504,6 +1504,8 @@ enum ieee80211_vif_flags {
+  * @drv_priv: data area for driver use, will always be aligned to
+  *	sizeof(void \*).
+  * @txq: the multicast data TX queue (if driver uses the TXQ abstraction)
++ * @txqs_stopped: per AC flag to indicate that intermediate TXQs are stopped,
++ *	protected by fq->lock.
+  */
+ struct ieee80211_vif {
+ 	enum nl80211_iftype type;
+@@ -1528,6 +1530,8 @@ struct ieee80211_vif {
+ 
+ 	unsigned int probe_req_reg;
+ 
++	bool txqs_stopped[IEEE80211_NUM_ACS];
++
+ 	/* must be last */
+ 	u8 drv_priv[0] __aligned(sizeof(void *));
+ };
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -807,6 +807,7 @@ enum txq_info_flags {
+ 	IEEE80211_TXQ_STOP,
+ 	IEEE80211_TXQ_AMPDU,
+ 	IEEE80211_TXQ_NO_AMSDU,
++	IEEE80211_TXQ_STOP_NETIF_TX,
+ };
+ 
+ /**
+@@ -1214,6 +1215,7 @@ struct ieee80211_local {
+ 
+ 	struct sk_buff_head pending[IEEE80211_MAX_QUEUES];
+ 	struct tasklet_struct tx_pending_tasklet;
++	struct tasklet_struct wake_txqs_tasklet;
+ 
+ 	atomic_t agg_queue_stop[IEEE80211_MAX_QUEUES];
+ 
+@@ -2035,6 +2037,7 @@ void ieee80211_txq_remove_vlan(struct ie
+ 			       struct ieee80211_sub_if_data *sdata);
+ void ieee80211_fill_txq_stats(struct cfg80211_txq_stats *txqstats,
+ 			      struct txq_info *txqi);
++void ieee80211_wake_txqs(unsigned long data);
+ void ieee80211_send_auth(struct ieee80211_sub_if_data *sdata,
+ 			 u16 transaction, u16 auth_alg, u16 status,
+ 			 const u8 *extra, size_t extra_len, const u8 *bssid,
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -686,6 +686,10 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 	tasklet_init(&local->tx_pending_tasklet, ieee80211_tx_pending,
+ 		     (unsigned long)local);
+ 
++	if (ops->wake_tx_queue)
++		tasklet_init(&local->wake_txqs_tasklet, ieee80211_wake_txqs,
++			     (unsigned long)local);
++
+ 	tasklet_init(&local->tasklet,
+ 		     ieee80211_tasklet_handler,
+ 		     (unsigned long) local);
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3498,13 +3498,19 @@ struct sk_buff *ieee80211_tx_dequeue(str
+ 	struct ieee80211_tx_info *info;
+ 	struct ieee80211_tx_data tx;
+ 	ieee80211_tx_result r;
+-	struct ieee80211_vif *vif;
++	struct ieee80211_vif *vif = txq->vif;
+ 
+ 	spin_lock_bh(&fq->lock);
+ 
+-	if (test_bit(IEEE80211_TXQ_STOP, &txqi->flags))
++	if (test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ||
++	    test_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags))
+ 		goto out;
+ 
++	if (vif->txqs_stopped[ieee80211_ac_from_tid(txq->tid)]) {
++		set_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags);
++		goto out;
++	}
++
+ 	/* Make sure fragments stay together. */
+ 	skb = __skb_dequeue(&txqi->frags);
+ 	if (skb)
+@@ -3617,6 +3623,7 @@ begin:
+ 	}
+ 
+ 	IEEE80211_SKB_CB(skb)->control.vif = vif;
++
+ out:
+ 	spin_unlock_bh(&fq->lock);
+ 
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -240,6 +240,99 @@ __le16 ieee80211_ctstoself_duration(stru
+ }
+ EXPORT_SYMBOL(ieee80211_ctstoself_duration);
+ 
++static void __ieee80211_wake_txqs(struct ieee80211_sub_if_data *sdata, int ac)
++{
++	struct ieee80211_local *local = sdata->local;
++	struct ieee80211_vif *vif = &sdata->vif;
++	struct fq *fq = &local->fq;
++	struct ps_data *ps = NULL;
++	struct txq_info *txqi;
++	struct sta_info *sta;
++	int i;
++
++	spin_lock_bh(&fq->lock);
++
++	if (sdata->vif.type == NL80211_IFTYPE_AP)
++		ps = &sdata->bss->ps;
++
++	sdata->vif.txqs_stopped[ac] = false;
++
++	list_for_each_entry_rcu(sta, &local->sta_list, list) {
++		if (sdata != sta->sdata)
++			continue;
++
++		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
++			struct ieee80211_txq *txq = sta->sta.txq[i];
++
++			txqi = to_txq_info(txq);
++
++			if (ac != txq->ac)
++				continue;
++
++			if (!test_and_clear_bit(IEEE80211_TXQ_STOP_NETIF_TX,
++						&txqi->flags))
++				continue;
++
++			spin_unlock_bh(&fq->lock);
++			drv_wake_tx_queue(local, txqi);
++			spin_lock_bh(&fq->lock);
++		}
++	}
++
++	if (!vif->txq)
++		goto out;
++
++	txqi = to_txq_info(vif->txq);
++
++	if (!test_and_clear_bit(IEEE80211_TXQ_STOP_NETIF_TX, &txqi->flags) ||
++	    (ps && atomic_read(&ps->num_sta_ps)) || ac != vif->txq->ac)
++		goto out;
++
++	spin_unlock_bh(&fq->lock);
++
++	drv_wake_tx_queue(local, txqi);
++	return;
++out:
++	spin_unlock_bh(&fq->lock);
++}
++
++void ieee80211_wake_txqs(unsigned long data)
++{
++	struct ieee80211_local *local = (struct ieee80211_local *)data;
++	struct ieee80211_sub_if_data *sdata;
++	int n_acs = IEEE80211_NUM_ACS;
++	unsigned long flags;
++	int i;
++
++	rcu_read_lock();
++	spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
++
++	if (local->hw.queues < IEEE80211_NUM_ACS)
++		n_acs = 1;
++
++	for (i = 0; i < local->hw.queues; i++) {
++		if (local->queue_stop_reasons[i])
++			continue;
++
++		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
++		list_for_each_entry_rcu(sdata, &local->interfaces, list) {
++			int ac;
++
++			for (ac = 0; ac < n_acs; ac++) {
++				int ac_queue = sdata->vif.hw_queue[ac];
++
++				if (ac_queue == i ||
++				    sdata->vif.cab_queue == i)
++					__ieee80211_wake_txqs(sdata, ac);
++			}
++		}
++		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
++	}
++
++	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
++	rcu_read_unlock();
++}
++
+ void ieee80211_propagate_queue_wake(struct ieee80211_local *local, int queue)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+@@ -308,6 +401,9 @@ static void __ieee80211_wake_queue(struc
+ 		rcu_read_unlock();
+ 	} else
+ 		tasklet_schedule(&local->tx_pending_tasklet);
++
++	if (local->ops->wake_tx_queue)
++		tasklet_schedule(&local->wake_txqs_tasklet);
+ }
+ 
+ void ieee80211_wake_queue_by_reason(struct ieee80211_hw *hw, int queue,
+@@ -351,9 +447,6 @@ static void __ieee80211_stop_queue(struc
+ 	if (__test_and_set_bit(reason, &local->queue_stop_reasons[queue]))
+ 		return;
+ 
+-	if (local->ops->wake_tx_queue)
+-		return;
+-
+ 	if (local->hw.queues < IEEE80211_NUM_ACS)
+ 		n_acs = 1;
+ 
+@@ -366,8 +459,15 @@ static void __ieee80211_stop_queue(struc
+ 
+ 		for (ac = 0; ac < n_acs; ac++) {
+ 			if (sdata->vif.hw_queue[ac] == queue ||
+-			    sdata->vif.cab_queue == queue)
+-				netif_stop_subqueue(sdata->dev, ac);
++			    sdata->vif.cab_queue == queue) {
++				if (!local->ops->wake_tx_queue) {
++					netif_stop_subqueue(sdata->dev, ac);
++					continue;
++				}
++				spin_lock(&local->fq.lock);
++				sdata->vif.txqs_stopped[ac] = true;
++				spin_unlock(&local->fq.lock);
++			}
+ 		}
+ 	}
+ 	rcu_read_unlock();
diff -uprN a/package/kernel/mac80211/patches/subsys/300-mac80211-optimize-skb-resizing.patch b/package/kernel/mac80211/patches/subsys/300-mac80211-optimize-skb-resizing.patch
--- a/package/kernel/mac80211/patches/subsys/300-mac80211-optimize-skb-resizing.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/300-mac80211-optimize-skb-resizing.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,201 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sun, 17 Mar 2019 18:11:30 +0100
-Subject: [PATCH] mac80211: optimize skb resizing
-
-When forwarding unicast packets from ethernet to batman-adv over 802.11s
-(with forwarding disabled), the typical required headroom to transmit
-encrypted packets on mt76 is 32 (802.11) + 6 (802.11s) + 8 (CCMP) +
-2 (padding) + 6 (LLC) + 18 (batman-adv) - 14 (old ethernet header) = 58 bytes.
-
-On systems where NET_SKB_PAD is 64 this leads to a call to pskb_expand_head
-for every packet, since mac80211 also tries to allocate 16 bytes status
-headroom for radiotap headers.
-
-This patch fixes these unnecessary reallocations by only requiring the extra
-status headroom in ieee80211_tx_monitor()
-If however a reallocation happens before that call, the status headroom gets
-added there as well, in order to avoid double reallocation.
-
-The patch also cleans up the code by moving the headroom calculation to
-ieee80211_skb_resize.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1782,6 +1782,9 @@ int ieee80211_tx_control_port(struct wip
- 			      const u8 *dest, __be16 proto, bool unencrypted);
- int ieee80211_probe_mesh_link(struct wiphy *wiphy, struct net_device *dev,
- 			      const u8 *buf, size_t len);
-+int ieee80211_skb_resize(struct ieee80211_local *local,
-+			 struct ieee80211_sub_if_data *sdata,
-+			 struct sk_buff *skb, int hdrlen, int hdr_add);
- 
- /* HT */
- void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -815,6 +815,11 @@ void ieee80211_tx_monitor(struct ieee802
- 	struct net_device *prev_dev = NULL;
- 	int rtap_len;
- 
-+	if (ieee80211_skb_resize(local, NULL, skb, 0, 0)) {
-+		dev_kfree_skb(skb);
-+		return;
-+	}
-+
- 	/* send frame to monitor interfaces now */
- 	rtap_len = ieee80211_tx_radiotap_len(info, status);
- 	if (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1937,37 +1937,53 @@ static bool ieee80211_tx(struct ieee8021
- }
- 
- /* device xmit handlers */
--
--static int ieee80211_skb_resize(struct ieee80211_sub_if_data *sdata,
--				struct sk_buff *skb,
--				int head_need, bool may_encrypt)
-+int ieee80211_skb_resize(struct ieee80211_local *local,
-+			 struct ieee80211_sub_if_data *sdata,
-+			 struct sk_buff *skb, int hdr_len, int hdr_extra)
- {
--	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
- 	struct ieee80211_hdr *hdr;
--	bool enc_tailroom;
--	int tail_need = 0;
--
--	hdr = (struct ieee80211_hdr *) skb->data;
--	enc_tailroom = may_encrypt &&
--		       (sdata->crypto_tx_tailroom_needed_cnt ||
--			ieee80211_is_mgmt(hdr->frame_control));
--
--	if (enc_tailroom) {
--		tail_need = IEEE80211_ENCRYPT_TAILROOM;
--		tail_need -= skb_tailroom(skb);
--		tail_need = max_t(int, tail_need, 0);
-+	int head_need, head_max;
-+	int tail_need, tail_max;
-+	bool enc_tailroom = false;
-+
-+	if (sdata && !hdr_len &&
-+	    !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT)) {
-+		hdr = (struct ieee80211_hdr *) skb->data;
-+		enc_tailroom = (sdata->crypto_tx_tailroom_needed_cnt ||
-+				ieee80211_is_mgmt(hdr->frame_control));
-+		hdr_len += sdata->encrypt_headroom;
-+	}
-+
-+	head_need = head_max = hdr_len;
-+	tail_need = tail_max = 0;
-+	if (!sdata) {
-+		head_need = head_max = local->tx_headroom;
-+	} else {
-+		head_max += hdr_extra;
-+		head_max += max_t(int, local->tx_headroom,
-+				  local->hw.extra_tx_headroom);
-+		head_need += local->hw.extra_tx_headroom;
-+
-+		tail_max = IEEE80211_ENCRYPT_TAILROOM;
-+		if (enc_tailroom)
-+			tail_need = tail_max;
- 	}
- 
- 	if (skb_cloned(skb) &&
- 	    (!ieee80211_hw_check(&local->hw, SUPPORTS_CLONED_SKBS) ||
- 	     !skb_clone_writable(skb, ETH_HLEN) || enc_tailroom))
- 		I802_DEBUG_INC(local->tx_expand_skb_head_cloned);
--	else if (head_need || tail_need)
-+	else if (head_need > skb_headroom(skb) ||
-+		 tail_need > skb_tailroom(skb))
- 		I802_DEBUG_INC(local->tx_expand_skb_head);
- 	else
- 		return 0;
- 
--	if (pskb_expand_head(skb, head_need, tail_need, GFP_ATOMIC)) {
-+	head_max = max_t(int, 0, head_max - skb_headroom(skb));
-+	tail_max = max_t(int, 0, tail_max - skb_tailroom(skb));
-+
-+	if (pskb_expand_head(skb, head_max, tail_max, GFP_ATOMIC)) {
- 		wiphy_debug(local->hw.wiphy,
- 			    "failed to reallocate TX buffer\n");
- 		return -ENOMEM;
-@@ -1983,18 +1999,8 @@ void ieee80211_xmit(struct ieee80211_sub
- 	struct ieee80211_local *local = sdata->local;
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
- 	struct ieee80211_hdr *hdr;
--	int headroom;
--	bool may_encrypt;
--
--	may_encrypt = !(info->flags & IEEE80211_TX_INTFL_DONT_ENCRYPT);
- 
--	headroom = local->tx_headroom;
--	if (may_encrypt)
--		headroom += sdata->encrypt_headroom;
--	headroom -= skb_headroom(skb);
--	headroom = max_t(int, 0, headroom);
--
--	if (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {
-+	if (ieee80211_skb_resize(local, sdata, skb, 0, 0)) {
- 		ieee80211_free_txskb(&local->hw, skb);
- 		return;
- 	}
-@@ -2784,29 +2790,13 @@ static struct sk_buff *ieee80211_build_h
- 	}
- 
- 	skb_pull(skb, skip_header_bytes);
--	head_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);
-+	head_need = hdrlen + encaps_len + meshhdrlen;
- 
--	/*
--	 * So we need to modify the skb header and hence need a copy of
--	 * that. The head_need variable above doesn't, so far, include
--	 * the needed header space that we don't need right away. If we
--	 * can, then we don't reallocate right now but only after the
--	 * frame arrives at the master device (if it does...)
--	 *
--	 * If we cannot, however, then we will reallocate to include all
--	 * the ever needed space. Also, if we need to reallocate it anyway,
--	 * make it big enough for everything we may ever need.
--	 */
--
--	if (head_need > 0 || skb_cloned(skb)) {
--		head_need += sdata->encrypt_headroom;
--		head_need += local->tx_headroom;
--		head_need = max_t(int, 0, head_need);
--		if (ieee80211_skb_resize(sdata, skb, head_need, true)) {
--			ieee80211_free_txskb(&local->hw, skb);
--			skb = NULL;
--			return ERR_PTR(-ENOMEM);
--		}
-+	if (ieee80211_skb_resize(local, sdata, skb, head_need,
-+				 sdata->encrypt_headroom)) {
-+		ieee80211_free_txskb(&local->hw, skb);
-+		skb = NULL;
-+		return ERR_PTR(-ENOMEM);
- 	}
- 
- 	if (encaps_data)
-@@ -3421,7 +3411,6 @@ static bool ieee80211_xmit_fast(struct i
- 	struct ieee80211_local *local = sdata->local;
- 	u16 ethertype = (skb->data[12] << 8) | skb->data[13];
- 	int extra_head = fast_tx->hdr_len - (ETH_HLEN - 2);
--	int hw_headroom = sdata->local->hw.extra_tx_headroom;
- 	struct ethhdr eth;
- 	struct ieee80211_tx_info *info;
- 	struct ieee80211_hdr *hdr = (void *)fast_tx->hdr;
-@@ -3473,10 +3462,7 @@ static bool ieee80211_xmit_fast(struct i
- 	 * as the may-encrypt argument for the resize to not account for
- 	 * more room than we already have in 'extra_head'
- 	 */
--	if (unlikely(ieee80211_skb_resize(sdata, skb,
--					  max_t(int, extra_head + hw_headroom -
--						     skb_headroom(skb), 0),
--					  false))) {
-+	if (unlikely(ieee80211_skb_resize(local, sdata, skb, extra_head, 0))) {
- 		kfree_skb(skb);
- 		return true;
- 	}
diff -uprN a/package/kernel/mac80211/patches/subsys/301-mac80211-minstrel-remove-divisions-in-tx-status-path.patch b/package/kernel/mac80211/patches/subsys/301-mac80211-minstrel-remove-divisions-in-tx-status-path.patch
--- a/package/kernel/mac80211/patches/subsys/301-mac80211-minstrel-remove-divisions-in-tx-status-path.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/301-mac80211-minstrel-remove-divisions-in-tx-status-path.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,61 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 28 Sep 2019 15:44:06 +0200
-Subject: [PATCH] mac80211: minstrel: remove divisions in tx status path
-
-Use a slightly different threshold for downgrading spatial streams to
-make it easier to calculate without divisions.
-Slightly reduces CPU overhead.
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel.c
-+++ b/net/mac80211/rc80211_minstrel.c
-@@ -289,8 +289,7 @@ minstrel_tx_status(void *priv, struct ie
- 	if (mi->sample_deferred > 0)
- 		mi->sample_deferred--;
- 
--	if (time_after(jiffies, mi->last_stats_update +
--				(mp->update_interval * HZ) / 1000))
-+	if (time_after(jiffies, mi->last_stats_update + mp->update_interval))
- 		minstrel_update_stats(mp, mi);
- }
- 
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -970,23 +970,21 @@ minstrel_ht_tx_status(void *priv, struct
- 		 */
- 		rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
- 		if (rate->attempts > 30 &&
--		    MINSTREL_FRAC(rate->success, rate->attempts) <
--		    MINSTREL_FRAC(20, 100)) {
-+		    rate->success < rate->attempts / 4) {
- 			minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
- 			update = true;
- 		}
- 
- 		rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
- 		if (rate2->attempts > 30 &&
--		    MINSTREL_FRAC(rate2->success, rate2->attempts) <
--		    MINSTREL_FRAC(20, 100)) {
-+		    rate2->success < rate2->attempts / 4) {
- 			minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
- 			update = true;
- 		}
- 	}
- 
- 	if (time_after(jiffies, mi->last_stats_update +
--				(mp->update_interval / 2 * HZ) / 1000)) {
-+				mp->update_interval / 2)) {
- 		update = true;
- 		minstrel_ht_update_stats(mp, mi, true);
- 	}
-@@ -1666,7 +1664,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 		mp->has_mrr = true;
- 
- 	mp->hw = hw;
--	mp->update_interval = 100;
-+	mp->update_interval = HZ / 10;
- 
- #ifdef CPTCFG_MAC80211_DEBUGFS
- 	mp->fixed_rate_idx = (u32) -1;
diff -uprN a/package/kernel/mac80211/patches/subsys/302-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch b/package/kernel/mac80211/patches/subsys/302-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch
--- a/package/kernel/mac80211/patches/subsys/302-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/302-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,235 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Sat, 28 Sep 2019 15:46:06 +0200
-Subject: [PATCH] mac80211: minstrel_ht: replace rate stats ewma with a
- better moving average
-
-Rate success probability usually fluctuates a lot under normal conditions.
-With a simple EWMA, noise and fluctuation can be reduced by increasing the
-window length, but that comes at the cost of introducing lag on sudden
-changes.
-
-This change replaces the EWMA implementation with a moving average that's
-designed to significantly reduce lag while keeping a bigger window size
-by being better at filtering out noise.
-
-It is only slightly more expensive than the simple EWMA and still avoids
-divisions in its calculation.
-
-The algorithm is adapted from an implementation intended for a completely
-different field (stock market trading), where the tradeoff of lag vs
-noise filtering is equally important.
-
-The algorithm works in the same way as the "smoothing filter" from
-http://www.stockspotter.com/files/PredictiveIndicators.pdf adapted for
-fixed-point math with some constants, using only addition, bit shifts
-and multiplication
-
-To better make use of the filtering and bigger window size, the update
-interval is cut in half.
-
-For testing, the algorithm can be reverted to the older one via debugfs
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel.c
-+++ b/net/mac80211/rc80211_minstrel.c
-@@ -157,14 +157,18 @@ minstrel_update_rates(struct minstrel_pr
- * Recalculate statistics and counters of a given rate
- */
- void
--minstrel_calc_rate_stats(struct minstrel_rate_stats *mrs)
-+minstrel_calc_rate_stats(struct minstrel_priv *mp,
-+			 struct minstrel_rate_stats *mrs)
- {
- 	unsigned int cur_prob;
- 
- 	if (unlikely(mrs->attempts > 0)) {
- 		mrs->sample_skipped = 0;
- 		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
--		if (unlikely(!mrs->att_hist)) {
-+		if (mp->new_avg) {
-+			mrs->prob_ewma = minstrel_filter_avg_add(&mrs->avg,
-+								 cur_prob);
-+		} else if (unlikely(!mrs->att_hist)) {
- 			mrs->prob_ewma = cur_prob;
- 		} else {
- 			/*update exponential weighted moving avarage */
-@@ -200,7 +204,7 @@ minstrel_update_stats(struct minstrel_pr
- 		struct minstrel_rate_stats *tmp_mrs = &mi->r[tmp_prob_rate].stats;
- 
- 		/* Update statistics of success probability per rate */
--		minstrel_calc_rate_stats(mrs);
-+		minstrel_calc_rate_stats(mp, mrs);
- 
- 		/* Sample less often below the 10% chance of success.
- 		 * Sample less often above the 95% chance of success. */
-@@ -289,7 +293,8 @@ minstrel_tx_status(void *priv, struct ie
- 	if (mi->sample_deferred > 0)
- 		mi->sample_deferred--;
- 
--	if (time_after(jiffies, mi->last_stats_update + mp->update_interval))
-+	if (time_after(jiffies, mi->last_stats_update +
-+				mp->update_interval / (mp->new_avg ? 2 : 1)))
- 		minstrel_update_stats(mp, mi);
- }
- 
---- a/net/mac80211/rc80211_minstrel.h
-+++ b/net/mac80211/rc80211_minstrel.h
-@@ -19,6 +19,21 @@
- #define MAX_THR_RATES 4
- 
- /*
-+ * Coefficients for moving average with noise filter (period=16),
-+ * scaled by 10 bits
-+ *
-+ * a1 = exp(-pi * sqrt(2) / period)
-+ * coeff2 = 2 * a1 * cos(sqrt(2) * 2 * pi / period)
-+ * coeff3 = -sqr(a1)
-+ * coeff1 = 1 - coeff2 - coeff3
-+ */
-+#define MINSTREL_AVG_COEFF1		(MINSTREL_FRAC(1, 1) - \
-+					 MINSTREL_AVG_COEFF2 - \
-+					 MINSTREL_AVG_COEFF3)
-+#define MINSTREL_AVG_COEFF2		0x00001499
-+#define MINSTREL_AVG_COEFF3		-0x0000092e
-+
-+/*
-  * Perform EWMA (Exponentially Weighted Moving Average) calculation
-  */
- static inline int
-@@ -32,6 +47,41 @@ minstrel_ewma(int old, int new, int weig
- 	return old + incr;
- }
- 
-+struct minstrel_avg_ctx {
-+	s32 prev[2];
-+};
-+
-+static inline int minstrel_filter_avg_add(struct minstrel_avg_ctx *ctx, s32 in)
-+{
-+	s32 out_1 = ctx->prev[0];
-+	s32 out_2 = ctx->prev[1];
-+	s32 val;
-+
-+	if (!in)
-+		in += 1;
-+
-+	if (!out_1) {
-+		val = out_1 = in;
-+		goto out;
-+	}
-+
-+	val = MINSTREL_AVG_COEFF1 * in;
-+	val += MINSTREL_AVG_COEFF2 * out_1;
-+	val += MINSTREL_AVG_COEFF3 * out_2;
-+	val >>= MINSTREL_SCALE;
-+
-+	if (val > 1 << MINSTREL_SCALE)
-+		val = 1 << MINSTREL_SCALE;
-+	if (val < 0)
-+		val = 1;
-+
-+out:
-+	ctx->prev[1] = out_1;
-+	ctx->prev[0] = val;
-+
-+	return val;
-+}
-+
- struct minstrel_rate_stats {
- 	/* current / last sampling period attempts/success counters */
- 	u16 attempts, last_attempts;
-@@ -40,6 +90,8 @@ struct minstrel_rate_stats {
- 	/* total attempts/success counters */
- 	u32 att_hist, succ_hist;
- 
-+	struct minstrel_avg_ctx avg;
-+
- 	/* prob_ewma - exponential weighted moving average of prob */
- 	u16 prob_ewma;
- 
-@@ -95,6 +147,7 @@ struct minstrel_sta_info {
- struct minstrel_priv {
- 	struct ieee80211_hw *hw;
- 	bool has_mrr;
-+	bool new_avg;
- 	u32 sample_switch;
- 	unsigned int cw_min;
- 	unsigned int cw_max;
-@@ -126,7 +179,8 @@ extern const struct rate_control_ops mac
- void minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
- 
- /* Recalculate success probabilities and counters for a given rate using EWMA */
--void minstrel_calc_rate_stats(struct minstrel_rate_stats *mrs);
-+void minstrel_calc_rate_stats(struct minstrel_priv *mp,
-+			      struct minstrel_rate_stats *mrs);
- int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma);
- 
- /* debugfs */
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -737,7 +737,7 @@ minstrel_ht_update_stats(struct minstrel
- 
- 			mrs = &mg->rates[i];
- 			mrs->retry_updated = false;
--			minstrel_calc_rate_stats(mrs);
-+			minstrel_calc_rate_stats(mp, mrs);
- 			cur_prob = mrs->prob_ewma;
- 
- 			if (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)
-@@ -773,6 +773,8 @@ minstrel_ht_update_stats(struct minstrel
- 
- 	/* try to sample all available rates during each interval */
- 	mi->sample_count *= 8;
-+	if (mp->new_avg)
-+		mi->sample_count /= 2;
- 
- 	if (sample)
- 		minstrel_ht_rate_sample_switch(mp, mi);
-@@ -889,6 +891,7 @@ minstrel_ht_tx_status(void *priv, struct
- 	struct ieee80211_tx_rate *ar = info->status.rates;
- 	struct minstrel_rate_stats *rate, *rate2, *rate_sample = NULL;
- 	struct minstrel_priv *mp = priv;
-+	u32 update_interval = mp->update_interval / 2;
- 	bool last, update = false;
- 	bool sample_status = false;
- 	int i;
-@@ -943,6 +946,10 @@ minstrel_ht_tx_status(void *priv, struct
- 
- 	switch (mi->sample_mode) {
- 	case MINSTREL_SAMPLE_IDLE:
-+		if (mp->new_avg &&
-+		    (mp->hw->max_rates > 1 ||
-+		     mi->total_packets_cur < SAMPLE_SWITCH_THR))
-+			update_interval /= 2;
- 		break;
- 
- 	case MINSTREL_SAMPLE_ACTIVE:
-@@ -983,8 +990,7 @@ minstrel_ht_tx_status(void *priv, struct
- 		}
- 	}
- 
--	if (time_after(jiffies, mi->last_stats_update +
--				mp->update_interval / 2)) {
-+	if (time_after(jiffies, mi->last_stats_update + update_interval)) {
- 		update = true;
- 		minstrel_ht_update_stats(mp, mi, true);
- 	}
-@@ -1665,6 +1671,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 
- 	mp->hw = hw;
- 	mp->update_interval = HZ / 10;
-+	mp->new_avg = true;
- 
- #ifdef CPTCFG_MAC80211_DEBUGFS
- 	mp->fixed_rate_idx = (u32) -1;
-@@ -1672,6 +1679,8 @@ minstrel_ht_alloc(struct ieee80211_hw *h
- 			   &mp->fixed_rate_idx);
- 	debugfs_create_u32("sample_switch", S_IRUGO | S_IWUSR, debugfsdir,
- 			   &mp->sample_switch);
-+	debugfs_create_bool("new_avg", S_IRUGO | S_IWUSR, debugfsdir,
-+			   &mp->new_avg);
- #endif
- 
- 	minstrel_ht_init_cck_rates(mp);
diff -uprN a/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel-Enable-STBC-and-LDPC-for-VHT-Rates.patch b/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel-Enable-STBC-and-LDPC-for-VHT-Rates.patch
--- a/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel-Enable-STBC-and-LDPC-for-VHT-Rates.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel-Enable-STBC-and-LDPC-for-VHT-Rates.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,81 @@
+From: Chaitanya T K <chaitanya.mgit@gmail.com>
+Date: Mon, 27 Jun 2016 15:23:26 +0530
+Subject: [PATCH] mac80211: minstrel: Enable STBC and LDPC for VHT Rates
+
+If peer support reception of STBC and LDPC, enable them for better
+performance.
+
+Signed-off-by: Chaitanya TK <chaitanya.mgit@gmail.com>
+---
+
+--- a/include/linux/ieee80211.h
++++ b/include/linux/ieee80211.h
+@@ -1668,6 +1668,7 @@ struct ieee80211_mu_edca_param_set {
+ #define IEEE80211_VHT_CAP_RXSTBC_3				0x00000300
+ #define IEEE80211_VHT_CAP_RXSTBC_4				0x00000400
+ #define IEEE80211_VHT_CAP_RXSTBC_MASK				0x00000700
++#define IEEE80211_VHT_CAP_RXSTBC_SHIFT				8
+ #define IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE			0x00000800
+ #define IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE			0x00001000
+ #define IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT                  13
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -1136,13 +1136,14 @@ minstrel_ht_update_caps(void *priv, stru
+ 	struct minstrel_ht_sta_priv *msp = priv_sta;
+ 	struct minstrel_ht_sta *mi = &msp->ht;
+ 	struct ieee80211_mcs_info *mcs = &sta->ht_cap.mcs;
+-	u16 sta_cap = sta->ht_cap.cap;
++	u16 ht_cap = sta->ht_cap.cap;
+ 	struct ieee80211_sta_vht_cap *vht_cap = &sta->vht_cap;
+ 	int use_vht;
+ 	int n_supported = 0;
+ 	int ack_dur;
+ 	int stbc;
+ 	int i;
++	bool ldpc = false;
+ 
+ 	/* fall back to the old minstrel for legacy stations */
+ 	if (!sta->ht_cap.ht_supported)
+@@ -1180,16 +1181,24 @@ minstrel_ht_update_caps(void *priv, stru
+ 	}
+ 	mi->sample_tries = 4;
+ 
+-	/* TODO tx_flags for vht - ATM the RC API is not fine-grained enough */
+ 	if (!use_vht) {
+-		stbc = (sta_cap & IEEE80211_HT_CAP_RX_STBC) >>
++		stbc = (ht_cap & IEEE80211_HT_CAP_RX_STBC) >>
+ 			IEEE80211_HT_CAP_RX_STBC_SHIFT;
+-		mi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;
+ 
+-		if (sta_cap & IEEE80211_HT_CAP_LDPC_CODING)
+-			mi->tx_flags |= IEEE80211_TX_CTL_LDPC;
++		if (ht_cap & IEEE80211_HT_CAP_LDPC_CODING)
++			ldpc = true;
++	} else {
++		stbc = (vht_cap->cap & IEEE80211_VHT_CAP_RXSTBC_MASK) >>
++			IEEE80211_VHT_CAP_RXSTBC_SHIFT;
++
++		if (vht_cap->cap & IEEE80211_VHT_CAP_RXLDPC)
++			ldpc = true;
+ 	}
+ 
++	mi->tx_flags |= stbc << IEEE80211_TX_CTL_STBC_SHIFT;
++	if (ldpc)
++		mi->tx_flags |= IEEE80211_TX_CTL_LDPC;
++
+ 	for (i = 0; i < ARRAY_SIZE(mi->groups); i++) {
+ 		u32 gflags = minstrel_mcs_groups[i].flags;
+ 		int bw, nss;
+@@ -1202,10 +1211,10 @@ minstrel_ht_update_caps(void *priv, stru
+ 
+ 		if (gflags & IEEE80211_TX_RC_SHORT_GI) {
+ 			if (gflags & IEEE80211_TX_RC_40_MHZ_WIDTH) {
+-				if (!(sta_cap & IEEE80211_HT_CAP_SGI_40))
++				if (!(ht_cap & IEEE80211_HT_CAP_SGI_40))
+ 					continue;
+ 			} else {
+-				if (!(sta_cap & IEEE80211_HT_CAP_SGI_20))
++				if (!(ht_cap & IEEE80211_HT_CAP_SGI_20))
+ 					continue;
+ 			}
+ 		}
diff -uprN a/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch b/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch
--- a/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/303-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,424 +0,0 @@
-From: Felix Fietkau <nbd@nbd.name>
-Date: Tue, 8 Oct 2019 18:54:46 +0200
-Subject: [PATCH] mac80211: minstrel_ht: rename prob_ewma to prob_avg, use it
- for the new average
-
-Reduces per-rate data structure size
-
-Signed-off-by: Felix Fietkau <nbd@nbd.name>
----
-
---- a/net/mac80211/rc80211_minstrel.c
-+++ b/net/mac80211/rc80211_minstrel.c
-@@ -70,7 +70,7 @@ rix_to_ndx(struct minstrel_sta_info *mi,
- }
- 
- /* return current EMWA throughput */
--int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma)
-+int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_avg)
- {
- 	int usecs;
- 
-@@ -79,13 +79,13 @@ int minstrel_get_tp_avg(struct minstrel_
- 		usecs = 1000000;
- 
- 	/* reset thr. below 10% success */
--	if (mr->stats.prob_ewma < MINSTREL_FRAC(10, 100))
-+	if (mr->stats.prob_avg < MINSTREL_FRAC(10, 100))
- 		return 0;
- 
--	if (prob_ewma > MINSTREL_FRAC(90, 100))
-+	if (prob_avg > MINSTREL_FRAC(90, 100))
- 		return MINSTREL_TRUNC(100000 * (MINSTREL_FRAC(90, 100) / usecs));
- 	else
--		return MINSTREL_TRUNC(100000 * (prob_ewma / usecs));
-+		return MINSTREL_TRUNC(100000 * (prob_avg / usecs));
- }
- 
- /* find & sort topmost throughput rates */
-@@ -98,8 +98,8 @@ minstrel_sort_best_tp_rates(struct minst
- 
- 	for (j = MAX_THR_RATES; j > 0; --j) {
- 		tmp_mrs = &mi->r[tp_list[j - 1]].stats;
--		if (minstrel_get_tp_avg(&mi->r[i], cur_mrs->prob_ewma) <=
--		    minstrel_get_tp_avg(&mi->r[tp_list[j - 1]], tmp_mrs->prob_ewma))
-+		if (minstrel_get_tp_avg(&mi->r[i], cur_mrs->prob_avg) <=
-+		    minstrel_get_tp_avg(&mi->r[tp_list[j - 1]], tmp_mrs->prob_avg))
- 			break;
- 	}
- 
-@@ -166,15 +166,15 @@ minstrel_calc_rate_stats(struct minstrel
- 		mrs->sample_skipped = 0;
- 		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
- 		if (mp->new_avg) {
--			mrs->prob_ewma = minstrel_filter_avg_add(&mrs->avg,
--								 cur_prob);
-+			minstrel_filter_avg_add(&mrs->prob_avg,
-+						&mrs->prob_avg_1, cur_prob);
- 		} else if (unlikely(!mrs->att_hist)) {
--			mrs->prob_ewma = cur_prob;
-+			mrs->prob_avg = cur_prob;
- 		} else {
- 			/*update exponential weighted moving avarage */
--			mrs->prob_ewma = minstrel_ewma(mrs->prob_ewma,
--						       cur_prob,
--						       EWMA_LEVEL);
-+			mrs->prob_avg = minstrel_ewma(mrs->prob_avg,
-+						      cur_prob,
-+						      EWMA_LEVEL);
- 		}
- 		mrs->att_hist += mrs->attempts;
- 		mrs->succ_hist += mrs->success;
-@@ -208,8 +208,8 @@ minstrel_update_stats(struct minstrel_pr
- 
- 		/* Sample less often below the 10% chance of success.
- 		 * Sample less often above the 95% chance of success. */
--		if (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||
--		    mrs->prob_ewma < MINSTREL_FRAC(10, 100)) {
-+		if (mrs->prob_avg > MINSTREL_FRAC(95, 100) ||
-+		    mrs->prob_avg < MINSTREL_FRAC(10, 100)) {
- 			mr->adjusted_retry_count = mrs->retry_count >> 1;
- 			if (mr->adjusted_retry_count > 2)
- 				mr->adjusted_retry_count = 2;
-@@ -229,14 +229,14 @@ minstrel_update_stats(struct minstrel_pr
- 		 * choose the maximum throughput rate as max_prob_rate
- 		 * (2) if all success probabilities < 95%, the rate with
- 		 * highest success probability is chosen as max_prob_rate */
--		if (mrs->prob_ewma >= MINSTREL_FRAC(95, 100)) {
--			tmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_ewma);
-+		if (mrs->prob_avg >= MINSTREL_FRAC(95, 100)) {
-+			tmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_avg);
- 			tmp_prob_tp = minstrel_get_tp_avg(&mi->r[tmp_prob_rate],
--							  tmp_mrs->prob_ewma);
-+							  tmp_mrs->prob_avg);
- 			if (tmp_cur_tp >= tmp_prob_tp)
- 				tmp_prob_rate = i;
- 		} else {
--			if (mrs->prob_ewma >= tmp_mrs->prob_ewma)
-+			if (mrs->prob_avg >= tmp_mrs->prob_avg)
- 				tmp_prob_rate = i;
- 		}
- 	}
-@@ -426,7 +426,7 @@ minstrel_get_rate(void *priv, struct iee
- 	 * has a probability of >95%, we shouldn't be attempting
- 	 * to use it, as this only wastes precious airtime */
- 	if (!mrr_capable &&
--	   (mi->r[ndx].stats.prob_ewma > MINSTREL_FRAC(95, 100)))
-+	   (mi->r[ndx].stats.prob_avg > MINSTREL_FRAC(95, 100)))
- 		return;
- 
- 	mi->prev_sample = true;
-@@ -577,7 +577,7 @@ static u32 minstrel_get_expected_through
- 	 * computing cur_tp
- 	 */
- 	tmp_mrs = &mi->r[idx].stats;
--	tmp_cur_tp = minstrel_get_tp_avg(&mi->r[idx], tmp_mrs->prob_ewma) * 10;
-+	tmp_cur_tp = minstrel_get_tp_avg(&mi->r[idx], tmp_mrs->prob_avg) * 10;
- 	tmp_cur_tp = tmp_cur_tp * 1200 * 8 / 1024;
- 
- 	return tmp_cur_tp;
---- a/net/mac80211/rc80211_minstrel.h
-+++ b/net/mac80211/rc80211_minstrel.h
-@@ -47,14 +47,10 @@ minstrel_ewma(int old, int new, int weig
- 	return old + incr;
- }
- 
--struct minstrel_avg_ctx {
--	s32 prev[2];
--};
--
--static inline int minstrel_filter_avg_add(struct minstrel_avg_ctx *ctx, s32 in)
-+static inline int minstrel_filter_avg_add(u16 *prev_1, u16 *prev_2, s32 in)
- {
--	s32 out_1 = ctx->prev[0];
--	s32 out_2 = ctx->prev[1];
-+	s32 out_1 = *prev_1;
-+	s32 out_2 = *prev_2;
- 	s32 val;
- 
- 	if (!in)
-@@ -76,8 +72,8 @@ static inline int minstrel_filter_avg_ad
- 		val = 1;
- 
- out:
--	ctx->prev[1] = out_1;
--	ctx->prev[0] = val;
-+	*prev_2 = out_1;
-+	*prev_1 = val;
- 
- 	return val;
- }
-@@ -90,10 +86,9 @@ struct minstrel_rate_stats {
- 	/* total attempts/success counters */
- 	u32 att_hist, succ_hist;
- 
--	struct minstrel_avg_ctx avg;
--
--	/* prob_ewma - exponential weighted moving average of prob */
--	u16 prob_ewma;
-+	/* prob_avg - moving average of prob */
-+	u16 prob_avg;
-+	u16 prob_avg_1;
- 
- 	/* maximum retry counts */
- 	u8 retry_count;
-@@ -181,7 +176,7 @@ void minstrel_add_sta_debugfs(void *priv
- /* Recalculate success probabilities and counters for a given rate using EWMA */
- void minstrel_calc_rate_stats(struct minstrel_priv *mp,
- 			      struct minstrel_rate_stats *mrs);
--int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma);
-+int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_avg);
- 
- /* debugfs */
- int minstrel_stats_open(struct inode *inode, struct file *file);
---- a/net/mac80211/rc80211_minstrel_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_debugfs.c
-@@ -90,8 +90,8 @@ minstrel_stats_open(struct inode *inode,
- 		p += sprintf(p, "%6u ", mr->perfect_tx_time);
- 
- 		tp_max = minstrel_get_tp_avg(mr, MINSTREL_FRAC(100,100));
--		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_ewma);
--		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
-+		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_avg);
-+		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
- 
- 		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u"
- 				"     %3u   %3u %-3u   "
-@@ -147,8 +147,8 @@ minstrel_stats_csv_open(struct inode *in
- 		p += sprintf(p, "%u,",mr->perfect_tx_time);
- 
- 		tp_max = minstrel_get_tp_avg(mr, MINSTREL_FRAC(100,100));
--		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_ewma);
--		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
-+		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_avg);
-+		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
- 
- 		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u,%u,%u,"
- 				"%llu,%llu,%d,%d\n",
---- a/net/mac80211/rc80211_minstrel_ht.c
-+++ b/net/mac80211/rc80211_minstrel_ht.c
-@@ -346,12 +346,12 @@ minstrel_ht_avg_ampdu_len(struct minstre
-  */
- int
- minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
--		       int prob_ewma)
-+		       int prob_avg)
- {
- 	unsigned int nsecs = 0;
- 
- 	/* do not account throughput if sucess prob is below 10% */
--	if (prob_ewma < MINSTREL_FRAC(10, 100))
-+	if (prob_avg < MINSTREL_FRAC(10, 100))
- 		return 0;
- 
- 	if (group != MINSTREL_CCK_GROUP)
-@@ -365,11 +365,11 @@ minstrel_ht_get_tp_avg(struct minstrel_h
- 	 * account for collision related packet error rate fluctuation
- 	 * (prob is scaled - see MINSTREL_FRAC above)
- 	 */
--	if (prob_ewma > MINSTREL_FRAC(90, 100))
-+	if (prob_avg > MINSTREL_FRAC(90, 100))
- 		return MINSTREL_TRUNC(100000 * ((MINSTREL_FRAC(90, 100) * 1000)
- 								      / nsecs));
- 	else
--		return MINSTREL_TRUNC(100000 * ((prob_ewma * 1000) / nsecs));
-+		return MINSTREL_TRUNC(100000 * ((prob_avg * 1000) / nsecs));
- }
- 
- /*
-@@ -389,13 +389,13 @@ minstrel_ht_sort_best_tp_rates(struct mi
- 
- 	cur_group = index / MCS_GROUP_RATES;
- 	cur_idx = index  % MCS_GROUP_RATES;
--	cur_prob = mi->groups[cur_group].rates[cur_idx].prob_ewma;
-+	cur_prob = mi->groups[cur_group].rates[cur_idx].prob_avg;
- 	cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx, cur_prob);
- 
- 	do {
- 		tmp_group = tp_list[j - 1] / MCS_GROUP_RATES;
- 		tmp_idx = tp_list[j - 1] % MCS_GROUP_RATES;
--		tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
-+		tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 		tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx,
- 						    tmp_prob);
- 		if (cur_tp_avg < tmp_tp_avg ||
-@@ -432,7 +432,7 @@ minstrel_ht_set_best_prob_rate(struct mi
- 
- 	tmp_group = mi->max_prob_rate / MCS_GROUP_RATES;
- 	tmp_idx = mi->max_prob_rate % MCS_GROUP_RATES;
--	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
-+	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
- 	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
-@@ -444,11 +444,11 @@ minstrel_ht_set_best_prob_rate(struct mi
- 
- 	max_gpr_group = mg->max_group_prob_rate / MCS_GROUP_RATES;
- 	max_gpr_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
--	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_ewma;
-+	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
- 
--	if (mrs->prob_ewma > MINSTREL_FRAC(75, 100)) {
-+	if (mrs->prob_avg > MINSTREL_FRAC(75, 100)) {
- 		cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx,
--						    mrs->prob_ewma);
-+						    mrs->prob_avg);
- 		if (cur_tp_avg > tmp_tp_avg)
- 			mi->max_prob_rate = index;
- 
-@@ -458,9 +458,9 @@ minstrel_ht_set_best_prob_rate(struct mi
- 		if (cur_tp_avg > max_gpr_tp_avg)
- 			mg->max_group_prob_rate = index;
- 	} else {
--		if (mrs->prob_ewma > tmp_prob)
-+		if (mrs->prob_avg > tmp_prob)
- 			mi->max_prob_rate = index;
--		if (mrs->prob_ewma > max_gpr_prob)
-+		if (mrs->prob_avg > max_gpr_prob)
- 			mg->max_group_prob_rate = index;
- 	}
- }
-@@ -482,12 +482,12 @@ minstrel_ht_assign_best_tp_rates(struct
- 
- 	tmp_group = tmp_cck_tp_rate[0] / MCS_GROUP_RATES;
- 	tmp_idx = tmp_cck_tp_rate[0] % MCS_GROUP_RATES;
--	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
-+	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
- 	tmp_group = tmp_mcs_tp_rate[0] / MCS_GROUP_RATES;
- 	tmp_idx = tmp_mcs_tp_rate[0] % MCS_GROUP_RATES;
--	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
-+	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
- 	tmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
- 
- 	if (tmp_cck_tp_rate && tmp_cck_tp > tmp_mcs_tp) {
-@@ -518,7 +518,7 @@ minstrel_ht_prob_rate_reduce_streams(str
- 			continue;
- 
- 		tmp_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
--		tmp_prob = mi->groups[group].rates[tmp_idx].prob_ewma;
-+		tmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;
- 
- 		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&
- 		   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {
-@@ -623,7 +623,7 @@ minstrel_ht_rate_sample_switch(struct mi
- 	 * If that fails, look again for a rate that is at least as fast
- 	 */
- 	mrs = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
--	faster_rate = mrs->prob_ewma > MINSTREL_FRAC(75, 100);
-+	faster_rate = mrs->prob_avg > MINSTREL_FRAC(75, 100);
- 	minstrel_ht_find_probe_rates(mi, rates, &n_rates, faster_rate);
- 	if (!n_rates && faster_rate)
- 		minstrel_ht_find_probe_rates(mi, rates, &n_rates, false);
-@@ -738,7 +738,7 @@ minstrel_ht_update_stats(struct minstrel
- 			mrs = &mg->rates[i];
- 			mrs->retry_updated = false;
- 			minstrel_calc_rate_stats(mp, mrs);
--			cur_prob = mrs->prob_ewma;
-+			cur_prob = mrs->prob_avg;
- 
- 			if (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)
- 				continue;
-@@ -1012,7 +1012,7 @@ minstrel_calc_retransmit(struct minstrel
- 	unsigned int overhead = 0, overhead_rtscts = 0;
- 
- 	mrs = minstrel_get_ratestats(mi, index);
--	if (mrs->prob_ewma < MINSTREL_FRAC(1, 10)) {
-+	if (mrs->prob_avg < MINSTREL_FRAC(1, 10)) {
- 		mrs->retry_count = 1;
- 		mrs->retry_count_rtscts = 1;
- 		return;
-@@ -1069,7 +1069,7 @@ minstrel_ht_set_rate(struct minstrel_pri
- 	if (!mrs->retry_updated)
- 		minstrel_calc_retransmit(mp, mi, index);
- 
--	if (mrs->prob_ewma < MINSTREL_FRAC(20, 100) || !mrs->retry_count) {
-+	if (mrs->prob_avg < MINSTREL_FRAC(20, 100) || !mrs->retry_count) {
- 		ratetbl->rate[offset].count = 2;
- 		ratetbl->rate[offset].count_rts = 2;
- 		ratetbl->rate[offset].count_cts = 2;
-@@ -1103,11 +1103,11 @@ minstrel_ht_set_rate(struct minstrel_pri
- }
- 
- static inline int
--minstrel_ht_get_prob_ewma(struct minstrel_ht_sta *mi, int rate)
-+minstrel_ht_get_prob_avg(struct minstrel_ht_sta *mi, int rate)
- {
- 	int group = rate / MCS_GROUP_RATES;
- 	rate %= MCS_GROUP_RATES;
--	return mi->groups[group].rates[rate].prob_ewma;
-+	return mi->groups[group].rates[rate].prob_avg;
- }
- 
- static int
-@@ -1119,7 +1119,7 @@ minstrel_ht_get_max_amsdu_len(struct min
- 	unsigned int duration;
- 
- 	/* Disable A-MSDU if max_prob_rate is bad */
--	if (mi->groups[group].rates[rate].prob_ewma < MINSTREL_FRAC(50, 100))
-+	if (mi->groups[group].rates[rate].prob_avg < MINSTREL_FRAC(50, 100))
- 		return 1;
- 
- 	duration = g->duration[rate];
-@@ -1142,7 +1142,7 @@ minstrel_ht_get_max_amsdu_len(struct min
- 	 * data packet size
- 	 */
- 	if (duration > MCS_DURATION(1, 0, 260) ||
--	    (minstrel_ht_get_prob_ewma(mi, mi->max_tp_rate[0]) <
-+	    (minstrel_ht_get_prob_avg(mi, mi->max_tp_rate[0]) <
- 	     MINSTREL_FRAC(75, 100)))
- 		return 3200;
- 
-@@ -1247,7 +1247,7 @@ minstrel_get_sample_rate(struct minstrel
- 	 * rate, to avoid wasting airtime.
- 	 */
- 	sample_dur = minstrel_get_duration(sample_idx);
--	if (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||
-+	if (mrs->prob_avg > MINSTREL_FRAC(95, 100) ||
- 	    minstrel_get_duration(mi->max_prob_rate) * 3 < sample_dur)
- 		return -1;
- 
-@@ -1705,7 +1705,7 @@ static u32 minstrel_ht_get_expected_thro
- 
- 	i = mi->max_tp_rate[0] / MCS_GROUP_RATES;
- 	j = mi->max_tp_rate[0] % MCS_GROUP_RATES;
--	prob = mi->groups[i].rates[j].prob_ewma;
-+	prob = mi->groups[i].rates[j].prob_avg;
- 
- 	/* convert tp_avg from pkt per second in kbps */
- 	tp_avg = minstrel_ht_get_tp_avg(mi, i, j, prob) * 10;
---- a/net/mac80211/rc80211_minstrel_ht.h
-+++ b/net/mac80211/rc80211_minstrel_ht.h
-@@ -119,6 +119,6 @@ struct minstrel_ht_sta_priv {
- 
- void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
- int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
--			   int prob_ewma);
-+			   int prob_avg);
- 
- #endif
---- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
-+++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
-@@ -98,8 +98,8 @@ minstrel_ht_stats_dump(struct minstrel_h
- 		p += sprintf(p, "%6u  ", tx_time);
- 
- 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
--		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_ewma);
--		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
-+		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_avg);
-+		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
- 
- 		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u"
- 				"     %3u   %3u %-3u   "
-@@ -243,8 +243,8 @@ minstrel_ht_stats_csv_dump(struct minstr
- 		p += sprintf(p, "%u,", tx_time);
- 
- 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
--		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_ewma);
--		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
-+		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_avg);
-+		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
- 
- 		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u,%u,"
- 				"%u,%llu,%llu,",
diff -uprN a/package/kernel/mac80211/patches/subsys/304-mac80211-minstrel-remove-unnecessary-debugfs-cleanup.patch b/package/kernel/mac80211/patches/subsys/304-mac80211-minstrel-remove-unnecessary-debugfs-cleanup.patch
--- a/package/kernel/mac80211/patches/subsys/304-mac80211-minstrel-remove-unnecessary-debugfs-cleanup.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/304-mac80211-minstrel-remove-unnecessary-debugfs-cleanup.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,150 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 10 Feb 2018 12:41:51 +0100
+Subject: [PATCH] mac80211: minstrel: remove unnecessary debugfs cleanup
+ code
+
+debugfs entries are cleaned up by debugfs_remove_recursive already.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel.c
++++ b/net/mac80211/rc80211_minstrel.c
+@@ -672,8 +672,8 @@ minstrel_alloc(struct ieee80211_hw *hw,
+ 
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+ 	mp->fixed_rate_idx = (u32) -1;
+-	mp->dbg_fixed_rate = debugfs_create_u32("fixed_rate_idx",
+-			0666, debugfsdir, &mp->fixed_rate_idx);
++	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
++			   &mp->fixed_rate_idx);
+ #endif
+ 
+ 	minstrel_init_cck_rates(mp);
+@@ -684,9 +684,6 @@ minstrel_alloc(struct ieee80211_hw *hw,
+ static void
+ minstrel_free(void *priv)
+ {
+-#ifdef CPTCFG_MAC80211_DEBUGFS
+-	debugfs_remove(((struct minstrel_priv *)priv)->dbg_fixed_rate);
+-#endif
+ 	kfree(priv);
+ }
+ 
+@@ -718,7 +715,6 @@ const struct rate_control_ops mac80211_m
+ 	.free_sta = minstrel_free_sta,
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+ 	.add_sta_debugfs = minstrel_add_sta_debugfs,
+-	.remove_sta_debugfs = minstrel_remove_sta_debugfs,
+ #endif
+ 	.get_expected_throughput = minstrel_get_expected_throughput,
+ };
+--- a/net/mac80211/rc80211_minstrel.h
++++ b/net/mac80211/rc80211_minstrel.h
+@@ -108,11 +108,6 @@ struct minstrel_sta_info {
+ 
+ 	/* sampling table */
+ 	u8 *sample_table;
+-
+-#ifdef CPTCFG_MAC80211_DEBUGFS
+-	struct dentry *dbg_stats;
+-	struct dentry *dbg_stats_csv;
+-#endif
+ };
+ 
+ struct minstrel_priv {
+@@ -136,7 +131,6 @@ struct minstrel_priv {
+ 	 *   - setting will be applied on next update
+ 	 */
+ 	u32 fixed_rate_idx;
+-	struct dentry *dbg_fixed_rate;
+ #endif
+ };
+ 
+@@ -155,7 +149,6 @@ minstrel_get_ewmsd10(struct minstrel_rat
+ 
+ extern const struct rate_control_ops mac80211_minstrel;
+ void minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+-void minstrel_remove_sta_debugfs(void *priv, void *priv_sta);
+ 
+ /* Recalculate success probabilities and counters for a given rate using EWMA */
+ void minstrel_calc_rate_stats(struct minstrel_rate_stats *mrs);
+--- a/net/mac80211/rc80211_minstrel_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_debugfs.c
+@@ -214,19 +214,7 @@ minstrel_add_sta_debugfs(void *priv, voi
+ {
+ 	struct minstrel_sta_info *mi = priv_sta;
+ 
+-	mi->dbg_stats = debugfs_create_file("rc_stats", 0444, dir, mi,
+-					    &minstrel_stat_fops);
+-
+-	mi->dbg_stats_csv = debugfs_create_file("rc_stats_csv", 0444, dir, mi,
+-						&minstrel_stat_csv_fops);
+-}
+-
+-void
+-minstrel_remove_sta_debugfs(void *priv, void *priv_sta)
+-{
+-	struct minstrel_sta_info *mi = priv_sta;
+-
+-	debugfs_remove(mi->dbg_stats);
+-
+-	debugfs_remove(mi->dbg_stats_csv);
++	debugfs_create_file("rc_stats", S_IRUGO, dir, mi, &minstrel_stat_fops);
++	debugfs_create_file("rc_stats_csv", S_IRUGO, dir, mi,
++			    &minstrel_stat_csv_fops);
+ }
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -1397,7 +1397,6 @@ static const struct rate_control_ops mac
+ 	.free = minstrel_ht_free,
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+ 	.add_sta_debugfs = minstrel_ht_add_sta_debugfs,
+-	.remove_sta_debugfs = minstrel_ht_remove_sta_debugfs,
+ #endif
+ 	.get_expected_throughput = minstrel_ht_get_expected_throughput,
+ };
+--- a/net/mac80211/rc80211_minstrel_ht.h
++++ b/net/mac80211/rc80211_minstrel_ht.h
+@@ -110,17 +110,12 @@ struct minstrel_ht_sta_priv {
+ 		struct minstrel_ht_sta ht;
+ 		struct minstrel_sta_info legacy;
+ 	};
+-#ifdef CPTCFG_MAC80211_DEBUGFS
+-	struct dentry *dbg_stats;
+-	struct dentry *dbg_stats_csv;
+-#endif
+ 	void *ratelist;
+ 	void *sample_table;
+ 	bool is_ht;
+ };
+ 
+ void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+-void minstrel_ht_remove_sta_debugfs(void *priv, void *priv_sta);
+ int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
+ 			   int prob_ewma);
+ 
+--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
+@@ -303,17 +303,8 @@ minstrel_ht_add_sta_debugfs(void *priv,
+ {
+ 	struct minstrel_ht_sta_priv *msp = priv_sta;
+ 
+-	msp->dbg_stats = debugfs_create_file("rc_stats", 0444, dir, msp,
+-					     &minstrel_ht_stat_fops);
+-	msp->dbg_stats_csv = debugfs_create_file("rc_stats_csv", 0444, dir, msp,
+-						 &minstrel_ht_stat_csv_fops);
+-}
+-
+-void
+-minstrel_ht_remove_sta_debugfs(void *priv, void *priv_sta)
+-{
+-	struct minstrel_ht_sta_priv *msp = priv_sta;
+-
+-	debugfs_remove(msp->dbg_stats);
+-	debugfs_remove(msp->dbg_stats_csv);
++	debugfs_create_file("rc_stats", S_IRUGO, dir, msp,
++			    &minstrel_ht_stat_fops);
++	debugfs_create_file("rc_stats_csv", S_IRUGO, dir, msp,
++			    &minstrel_ht_stat_csv_fops);
+ }
diff -uprN a/package/kernel/mac80211/patches/subsys/304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch b/package/kernel/mac80211/patches/subsys/304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
--- a/package/kernel/mac80211/patches/subsys/304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/304-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,38 +0,0 @@
-From b478e06a16a8baa00c5ecc87c1d636981f2206d5 Mon Sep 17 00:00:00 2001
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Tue, 29 Oct 2019 10:25:25 +0100
-Subject: [PATCH] mac80211: sta: randomize BA session dialog token allocator
-
-We currently always start the dialog token generator at zero,
-so the first dialog token we use is always 1. This would be
-OK if we had a perfect guarantee that we always do a proper
-deauth/re-auth handshake, but in IBSS mode this doesn't always
-happen properly.
-
-To make problems with block ack (aggregation) sessions getting
-stuck less likely, randomize the dialog token so if we start a
-new session but the peer still has old state for us, it can
-better detect this.
-
-This is really just a workaround to make things a bit more
-robust than they are now - a better fix would be to do a full
-authentication handshake in IBSS mode upon having discovered a
-new station, and on the receiver resetting the state (removing
-and re-adding the station) on receiving the authentication
-packet.
-
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
- net/mac80211/sta_info.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -324,6 +324,7 @@ struct sta_info *sta_info_alloc(struct i
- 	INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);
- 	INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
- 	mutex_init(&sta->ampdu_mlme.mtx);
-+	sta->ampdu_mlme.dialog_token_allocator = prandom_u32_max(U8_MAX);
- #ifdef CPTCFG_MAC80211_MESH
- 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
- 		sta->mesh = kzalloc(sizeof(*sta->mesh), gfp);
diff -uprN a/package/kernel/mac80211/patches/subsys/305-mac80211-fix-tx-status-for-no-ack-cases.patch b/package/kernel/mac80211/patches/subsys/305-mac80211-fix-tx-status-for-no-ack-cases.patch
--- a/package/kernel/mac80211/patches/subsys/305-mac80211-fix-tx-status-for-no-ack-cases.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/305-mac80211-fix-tx-status-for-no-ack-cases.patch	2022-04-04 20:20:32.959828000 +0800
@@ -12,7 +12,7 @@ Signed-off-by: Johannes Berg <johannes.b
 
 --- a/net/mac80211/status.c
 +++ b/net/mac80211/status.c
-@@ -881,6 +881,7 @@ static void __ieee80211_tx_status(struct
+@@ -718,6 +718,7 @@ static void __ieee80211_tx_status(struct
  	int rates_idx;
  	bool send_to_cooked;
  	bool acked;
@@ -20,7 +20,7 @@ Signed-off-by: Johannes Berg <johannes.b
  	struct ieee80211_bar *bar;
  	int shift = 0;
  	int tid = IEEE80211_NUM_TIDS;
-@@ -898,6 +899,8 @@ static void __ieee80211_tx_status(struct
+@@ -735,6 +736,8 @@ static void __ieee80211_tx_status(struct
  			clear_sta_flag(sta, WLAN_STA_SP);
  
  		acked = !!(info->flags & IEEE80211_TX_STAT_ACK);
@@ -29,7 +29,7 @@ Signed-off-by: Johannes Berg <johannes.b
  
  		/* mesh Peer Service Period support */
  		if (ieee80211_vif_is_mesh(&sta->sdata->vif) &&
-@@ -962,12 +965,12 @@ static void __ieee80211_tx_status(struct
+@@ -799,12 +802,12 @@ static void __ieee80211_tx_status(struct
  			ieee80211_handle_filtered_frame(local, sta, skb);
  			return;
  		} else {
@@ -44,8 +44,8 @@ Signed-off-by: Johannes Berg <johannes.b
  					sta->status_stats.msdu_failed[tid]++;
  
  				sta->status_stats.msdu_retries[tid] +=
-@@ -994,7 +997,7 @@ static void __ieee80211_tx_status(struct
- 						       info->status.tx_time, 0);
+@@ -825,7 +828,7 @@ static void __ieee80211_tx_status(struct
+ 						acked, info->status.tx_time);
  
  		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
 -			if (info->flags & IEEE80211_TX_STAT_ACK) {
@@ -53,7 +53,7 @@ Signed-off-by: Johannes Berg <johannes.b
  				if (sta->status_stats.lost_packets)
  					sta->status_stats.lost_packets = 0;
  
-@@ -1002,6 +1005,8 @@ static void __ieee80211_tx_status(struct
+@@ -833,6 +836,8 @@ static void __ieee80211_tx_status(struct
  				if (test_sta_flag(sta, WLAN_STA_TDLS_PEER_AUTH))
  					sta->status_stats.last_tdls_pkt_time =
  						jiffies;
@@ -62,7 +62,7 @@ Signed-off-by: Johannes Berg <johannes.b
  			} else {
  				ieee80211_lost_packet(sta, info);
  			}
-@@ -1128,7 +1133,7 @@ void ieee80211_tx_status_ext(struct ieee
+@@ -958,7 +963,7 @@ void ieee80211_tx_status_ext(struct ieee
  
  		sta = container_of(pubsta, struct sta_info, sta);
  
@@ -71,7 +71,7 @@ Signed-off-by: Johannes Berg <johannes.b
  			sta->status_stats.retry_failed++;
  		sta->status_stats.retry_count += retry_count;
  
-@@ -1143,6 +1148,8 @@ void ieee80211_tx_status_ext(struct ieee
+@@ -973,6 +978,8 @@ void ieee80211_tx_status_ext(struct ieee
  				sta->status_stats.last_tdls_pkt_time = jiffies;
  		} else if (test_sta_flag(sta, WLAN_STA_PS_STA)) {
  			return;
diff -uprN a/package/kernel/mac80211/patches/subsys/305-mac80211-minstrel-merge-with-minstrel_ht-always-enab.patch b/package/kernel/mac80211/patches/subsys/305-mac80211-minstrel-merge-with-minstrel_ht-always-enab.patch
--- a/package/kernel/mac80211/patches/subsys/305-mac80211-minstrel-merge-with-minstrel_ht-always-enab.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/305-mac80211-minstrel-merge-with-minstrel_ht-always-enab.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,575 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 10 Feb 2018 12:43:30 +0100
+Subject: [PATCH] mac80211: minstrel: merge with minstrel_ht, always enable
+ VHT support
+
+Legacy-only devices are not very common and the overhead of the extra
+code for HT and VHT rates is not big enough to justify all those extra
+lines of code to make it optional.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/Kconfig
++++ b/net/mac80211/Kconfig
+@@ -25,20 +25,6 @@ config MAC80211_RC_MINSTREL
+ 	---help---
+ 	  This option enables the 'minstrel' TX rate control algorithm
+ 
+-config MAC80211_RC_MINSTREL_HT
+-	bool "Minstrel 802.11n support" if EXPERT
+-	depends on MAC80211_RC_MINSTREL
+-	default y
+-	---help---
+-	  This option enables the 'minstrel_ht' TX rate control algorithm
+-
+-config MAC80211_RC_MINSTREL_VHT
+-	bool "Minstrel 802.11ac support" if EXPERT
+-	depends on MAC80211_RC_MINSTREL_HT
+-	default n
+-	---help---
+-	  This option enables VHT in the 'minstrel_ht' TX rate control algorithm
+-
+ choice
+ 	prompt "Default rate control algorithm"
+ 	depends on MAC80211_HAS_RC
+@@ -60,8 +46,7 @@ endchoice
+ 
+ config MAC80211_RC_DEFAULT
+ 	string
+-	default "minstrel_ht" if MAC80211_RC_DEFAULT_MINSTREL && MAC80211_RC_MINSTREL_HT
+-	default "minstrel" if MAC80211_RC_DEFAULT_MINSTREL
++	default "minstrel_ht" if MAC80211_RC_DEFAULT_MINSTREL
+ 	default ""
+ 
+ endif
+--- a/net/mac80211/Makefile
++++ b/net/mac80211/Makefile
+@@ -52,13 +52,14 @@ mac80211-$(CONFIG_PM) += pm.o
+ 
+ CFLAGS_trace.o := -I$(src)
+ 
+-rc80211_minstrel-y := rc80211_minstrel.o
+-rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += rc80211_minstrel_debugfs.o
++rc80211_minstrel-y := \
++	rc80211_minstrel.o \
++	rc80211_minstrel_ht.o
+ 
+-rc80211_minstrel_ht-y := rc80211_minstrel_ht.o
+-rc80211_minstrel_ht-$(CPTCFG_MAC80211_DEBUGFS) += rc80211_minstrel_ht_debugfs.o
++rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
++	rc80211_minstrel_debugfs.o \
++	rc80211_minstrel_ht_debugfs.o
+ 
+ mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
+-mac80211-$(CPTCFG_MAC80211_RC_MINSTREL_HT) += $(rc80211_minstrel_ht-y)
+ 
+ ccflags-y += -DDEBUG
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -1322,18 +1322,12 @@ static int __init ieee80211_init(void)
+ 	if (ret)
+ 		return ret;
+ 
+-	ret = rc80211_minstrel_ht_init();
+-	if (ret)
+-		goto err_minstrel;
+-
+ 	ret = ieee80211_iface_init();
+ 	if (ret)
+ 		goto err_netdev;
+ 
+ 	return 0;
+  err_netdev:
+-	rc80211_minstrel_ht_exit();
+- err_minstrel:
+ 	rc80211_minstrel_exit();
+ 
+ 	return ret;
+@@ -1341,7 +1335,6 @@ static int __init ieee80211_init(void)
+ 
+ static void __exit ieee80211_exit(void)
+ {
+-	rc80211_minstrel_ht_exit();
+ 	rc80211_minstrel_exit();
+ 
+ 	ieee80211s_stop();
+--- a/net/mac80211/rate.h
++++ b/net/mac80211/rate.h
+@@ -95,18 +95,5 @@ static inline void rc80211_minstrel_exit
+ }
+ #endif
+ 
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_HT
+-int rc80211_minstrel_ht_init(void);
+-void rc80211_minstrel_ht_exit(void);
+-#else
+-static inline int rc80211_minstrel_ht_init(void)
+-{
+-	return 0;
+-}
+-static inline void rc80211_minstrel_ht_exit(void)
+-{
+-}
+-#endif
+-
+ 
+ #endif /* IEEE80211_RATE_H */
+--- a/net/mac80211/rc80211_minstrel.c
++++ b/net/mac80211/rc80211_minstrel.c
+@@ -555,138 +555,6 @@ minstrel_rate_init(void *priv, struct ie
+ 	minstrel_update_rates(mp, mi);
+ }
+ 
+-static void *
+-minstrel_alloc_sta(void *priv, struct ieee80211_sta *sta, gfp_t gfp)
+-{
+-	struct ieee80211_supported_band *sband;
+-	struct minstrel_sta_info *mi;
+-	struct minstrel_priv *mp = priv;
+-	struct ieee80211_hw *hw = mp->hw;
+-	int max_rates = 0;
+-	int i;
+-
+-	mi = kzalloc(sizeof(struct minstrel_sta_info), gfp);
+-	if (!mi)
+-		return NULL;
+-
+-	for (i = 0; i < NUM_NL80211_BANDS; i++) {
+-		sband = hw->wiphy->bands[i];
+-		if (sband && sband->n_bitrates > max_rates)
+-			max_rates = sband->n_bitrates;
+-	}
+-
+-	mi->r = kcalloc(max_rates, sizeof(struct minstrel_rate), gfp);
+-	if (!mi->r)
+-		goto error;
+-
+-	mi->sample_table = kmalloc_array(max_rates, SAMPLE_COLUMNS, gfp);
+-	if (!mi->sample_table)
+-		goto error1;
+-
+-	mi->last_stats_update = jiffies;
+-	return mi;
+-
+-error1:
+-	kfree(mi->r);
+-error:
+-	kfree(mi);
+-	return NULL;
+-}
+-
+-static void
+-minstrel_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
+-{
+-	struct minstrel_sta_info *mi = priv_sta;
+-
+-	kfree(mi->sample_table);
+-	kfree(mi->r);
+-	kfree(mi);
+-}
+-
+-static void
+-minstrel_init_cck_rates(struct minstrel_priv *mp)
+-{
+-	static const int bitrates[4] = { 10, 20, 55, 110 };
+-	struct ieee80211_supported_band *sband;
+-	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
+-	int i, j;
+-
+-	sband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];
+-	if (!sband)
+-		return;
+-
+-	for (i = 0, j = 0; i < sband->n_bitrates; i++) {
+-		struct ieee80211_rate *rate = &sband->bitrates[i];
+-
+-		if (rate->flags & IEEE80211_RATE_ERP_G)
+-			continue;
+-
+-		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
+-			continue;
+-
+-		for (j = 0; j < ARRAY_SIZE(bitrates); j++) {
+-			if (rate->bitrate != bitrates[j])
+-				continue;
+-
+-			mp->cck_rates[j] = i;
+-			break;
+-		}
+-	}
+-}
+-
+-static void *
+-minstrel_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
+-{
+-	struct minstrel_priv *mp;
+-
+-	mp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);
+-	if (!mp)
+-		return NULL;
+-
+-	/* contention window settings
+-	 * Just an approximation. Using the per-queue values would complicate
+-	 * the calculations and is probably unnecessary */
+-	mp->cw_min = 15;
+-	mp->cw_max = 1023;
+-
+-	/* number of packets (in %) to use for sampling other rates
+-	 * sample less often for non-mrr packets, because the overhead
+-	 * is much higher than with mrr */
+-	mp->lookaround_rate = 5;
+-	mp->lookaround_rate_mrr = 10;
+-
+-	/* maximum time that the hw is allowed to stay in one MRR segment */
+-	mp->segment_size = 6000;
+-
+-	if (hw->max_rate_tries > 0)
+-		mp->max_retry = hw->max_rate_tries;
+-	else
+-		/* safe default, does not necessarily have to match hw properties */
+-		mp->max_retry = 7;
+-
+-	if (hw->max_rates >= 4)
+-		mp->has_mrr = true;
+-
+-	mp->hw = hw;
+-	mp->update_interval = 100;
+-
+-#ifdef CPTCFG_MAC80211_DEBUGFS
+-	mp->fixed_rate_idx = (u32) -1;
+-	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
+-			   &mp->fixed_rate_idx);
+-#endif
+-
+-	minstrel_init_cck_rates(mp);
+-
+-	return mp;
+-}
+-
+-static void
+-minstrel_free(void *priv)
+-{
+-	kfree(priv);
+-}
+-
+ static u32 minstrel_get_expected_throughput(void *priv_sta)
+ {
+ 	struct minstrel_sta_info *mi = priv_sta;
+@@ -705,28 +573,8 @@ static u32 minstrel_get_expected_through
+ }
+ 
+ const struct rate_control_ops mac80211_minstrel = {
+-	.name = "minstrel",
+ 	.tx_status_ext = minstrel_tx_status,
+ 	.get_rate = minstrel_get_rate,
+ 	.rate_init = minstrel_rate_init,
+-	.alloc = minstrel_alloc,
+-	.free = minstrel_free,
+-	.alloc_sta = minstrel_alloc_sta,
+-	.free_sta = minstrel_free_sta,
+-#ifdef CPTCFG_MAC80211_DEBUGFS
+-	.add_sta_debugfs = minstrel_add_sta_debugfs,
+-#endif
+ 	.get_expected_throughput = minstrel_get_expected_throughput,
+ };
+-
+-int __init
+-rc80211_minstrel_init(void)
+-{
+-	return ieee80211_rate_control_register(&mac80211_minstrel);
+-}
+-
+-void
+-rc80211_minstrel_exit(void)
+-{
+-	ieee80211_rate_control_unregister(&mac80211_minstrel);
+-}
+--- a/net/mac80211/rc80211_minstrel.h
++++ b/net/mac80211/rc80211_minstrel.h
+@@ -157,7 +157,5 @@ int minstrel_get_tp_avg(struct minstrel_
+ /* debugfs */
+ int minstrel_stats_open(struct inode *inode, struct file *file);
+ int minstrel_stats_csv_open(struct inode *inode, struct file *file);
+-ssize_t minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos);
+-int minstrel_stats_release(struct inode *inode, struct file *file);
+ 
+ #endif
+--- a/net/mac80211/rc80211_minstrel_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_debugfs.c
+@@ -54,22 +54,6 @@
+ #include <net/mac80211.h>
+ #include "rc80211_minstrel.h"
+ 
+-ssize_t
+-minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
+-{
+-	struct minstrel_debugfs_info *ms;
+-
+-	ms = file->private_data;
+-	return simple_read_from_buffer(buf, len, ppos, ms->buf, ms->len);
+-}
+-
+-int
+-minstrel_stats_release(struct inode *inode, struct file *file)
+-{
+-	kfree(file->private_data);
+-	return 0;
+-}
+-
+ int
+ minstrel_stats_open(struct inode *inode, struct file *file)
+ {
+@@ -135,14 +119,6 @@ minstrel_stats_open(struct inode *inode,
+ 	return 0;
+ }
+ 
+-static const struct file_operations minstrel_stat_fops = {
+-	.owner = THIS_MODULE,
+-	.open = minstrel_stats_open,
+-	.read = minstrel_stats_read,
+-	.release = minstrel_stats_release,
+-	.llseek = default_llseek,
+-};
+-
+ int
+ minstrel_stats_csv_open(struct inode *inode, struct file *file)
+ {
+@@ -200,21 +176,3 @@ minstrel_stats_csv_open(struct inode *in
+ 
+ 	return 0;
+ }
+-
+-static const struct file_operations minstrel_stat_csv_fops = {
+-	.owner = THIS_MODULE,
+-	.open = minstrel_stats_csv_open,
+-	.read = minstrel_stats_read,
+-	.release = minstrel_stats_release,
+-	.llseek = default_llseek,
+-};
+-
+-void
+-minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir)
+-{
+-	struct minstrel_sta_info *mi = priv_sta;
+-
+-	debugfs_create_file("rc_stats", S_IRUGO, dir, mi, &minstrel_stat_fops);
+-	debugfs_create_file("rc_stats_csv", S_IRUGO, dir, mi,
+-			    &minstrel_stat_csv_fops);
+-}
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -137,12 +137,10 @@
+ 		}					\
+ 	}
+ 
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+ static bool minstrel_vht_only = true;
+ module_param(minstrel_vht_only, bool, 0644);
+ MODULE_PARM_DESC(minstrel_vht_only,
+ 		 "Use only VHT rates when VHT is supported by sta.");
+-#endif
+ 
+ /*
+  * To enable sufficiently targeted rate sampling, MCS rates are divided into
+@@ -171,7 +169,6 @@ const struct mcs_group minstrel_mcs_grou
+ 
+ 	CCK_GROUP,
+ 
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+ 	VHT_GROUP(1, 0, BW_20),
+ 	VHT_GROUP(2, 0, BW_20),
+ 	VHT_GROUP(3, 0, BW_20),
+@@ -195,7 +192,6 @@ const struct mcs_group minstrel_mcs_grou
+ 	VHT_GROUP(1, 1, BW_80),
+ 	VHT_GROUP(2, 1, BW_80),
+ 	VHT_GROUP(3, 1, BW_80),
+-#endif
+ };
+ 
+ static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
+@@ -1151,12 +1147,10 @@ minstrel_ht_update_caps(void *priv, stru
+ 
+ 	BUILD_BUG_ON(ARRAY_SIZE(minstrel_mcs_groups) != MINSTREL_GROUPS_NB);
+ 
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+ 	if (vht_cap->vht_supported)
+ 		use_vht = vht_cap->vht_mcs.tx_mcs_map != cpu_to_le16(~0);
+ 	else
+-#endif
+-	use_vht = 0;
++		use_vht = 0;
+ 
+ 	msp->is_ht = true;
+ 	memset(mi, 0, sizeof(*mi));
+@@ -1231,10 +1225,9 @@ minstrel_ht_update_caps(void *priv, stru
+ 
+ 		/* HT rate */
+ 		if (gflags & IEEE80211_TX_RC_MCS) {
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+ 			if (use_vht && minstrel_vht_only)
+ 				continue;
+-#endif
++
+ 			mi->supported[i] = mcs->rx_mask[nss - 1];
+ 			if (mi->supported[i])
+ 				n_supported++;
+@@ -1353,16 +1346,88 @@ minstrel_ht_free_sta(void *priv, struct
+ 	kfree(msp);
+ }
+ 
++static void
++minstrel_ht_init_cck_rates(struct minstrel_priv *mp)
++{
++	static const int bitrates[4] = { 10, 20, 55, 110 };
++	struct ieee80211_supported_band *sband;
++	u32 rate_flags = ieee80211_chandef_rate_flags(&mp->hw->conf.chandef);
++	int i, j;
++
++	sband = mp->hw->wiphy->bands[NL80211_BAND_2GHZ];
++	if (!sband)
++		return;
++
++	for (i = 0, j = 0; i < sband->n_bitrates; i++) {
++		struct ieee80211_rate *rate = &sband->bitrates[i];
++
++		if (rate->flags & IEEE80211_RATE_ERP_G)
++			continue;
++
++		if ((rate_flags & sband->bitrates[i].flags) != rate_flags)
++			continue;
++
++		for (j = 0; j < ARRAY_SIZE(bitrates); j++) {
++			if (rate->bitrate != bitrates[j])
++				continue;
++
++			mp->cck_rates[j] = i;
++			break;
++		}
++	}
++}
++
+ static void *
+ minstrel_ht_alloc(struct ieee80211_hw *hw, struct dentry *debugfsdir)
+ {
+-	return mac80211_minstrel.alloc(hw, debugfsdir);
++	struct minstrel_priv *mp;
++
++	mp = kzalloc(sizeof(struct minstrel_priv), GFP_ATOMIC);
++	if (!mp)
++		return NULL;
++
++	/* contention window settings
++	 * Just an approximation. Using the per-queue values would complicate
++	 * the calculations and is probably unnecessary */
++	mp->cw_min = 15;
++	mp->cw_max = 1023;
++
++	/* number of packets (in %) to use for sampling other rates
++	 * sample less often for non-mrr packets, because the overhead
++	 * is much higher than with mrr */
++	mp->lookaround_rate = 5;
++	mp->lookaround_rate_mrr = 10;
++
++	/* maximum time that the hw is allowed to stay in one MRR segment */
++	mp->segment_size = 6000;
++
++	if (hw->max_rate_tries > 0)
++		mp->max_retry = hw->max_rate_tries;
++	else
++		/* safe default, does not necessarily have to match hw properties */
++		mp->max_retry = 7;
++
++	if (hw->max_rates >= 4)
++		mp->has_mrr = true;
++
++	mp->hw = hw;
++	mp->update_interval = 100;
++
++#ifdef CPTCFG_MAC80211_DEBUGFS
++	mp->fixed_rate_idx = (u32) -1;
++	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
++			   &mp->fixed_rate_idx);
++#endif
++
++	minstrel_ht_init_cck_rates(mp);
++
++	return mp;
+ }
+ 
+ static void
+ minstrel_ht_free(void *priv)
+ {
+-	mac80211_minstrel.free(priv);
++	kfree(priv);
+ }
+ 
+ static u32 minstrel_ht_get_expected_throughput(void *priv_sta)
+@@ -1421,14 +1486,14 @@ static void __init init_sample_table(voi
+ }
+ 
+ int __init
+-rc80211_minstrel_ht_init(void)
++rc80211_minstrel_init(void)
+ {
+ 	init_sample_table();
+ 	return ieee80211_rate_control_register(&mac80211_minstrel_ht);
+ }
+ 
+ void
+-rc80211_minstrel_ht_exit(void)
++rc80211_minstrel_exit(void)
+ {
+ 	ieee80211_rate_control_unregister(&mac80211_minstrel_ht);
+ }
+--- a/net/mac80211/rc80211_minstrel_ht.h
++++ b/net/mac80211/rc80211_minstrel_ht.h
+@@ -15,11 +15,7 @@
+  */
+ #define MINSTREL_MAX_STREAMS		3
+ #define MINSTREL_HT_STREAM_GROUPS	4 /* BW(=2) * SGI(=2) */
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+ #define MINSTREL_VHT_STREAM_GROUPS	6 /* BW(=3) * SGI(=2) */
+-#else
+-#define MINSTREL_VHT_STREAM_GROUPS	0
+-#endif
+ 
+ #define MINSTREL_HT_GROUPS_NB	(MINSTREL_MAX_STREAMS *		\
+ 				 MINSTREL_HT_STREAM_GROUPS)
+@@ -34,11 +30,7 @@
+ #define MINSTREL_CCK_GROUP	(MINSTREL_HT_GROUP_0 + MINSTREL_HT_GROUPS_NB)
+ #define MINSTREL_VHT_GROUP_0	(MINSTREL_CCK_GROUP + 1)
+ 
+-#ifdef CPTCFG_MAC80211_RC_MINSTREL_VHT
+ #define MCS_GROUP_RATES		10
+-#else
+-#define MCS_GROUP_RATES		8
+-#endif
+ 
+ struct mcs_group {
+ 	u32 flags;
+--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
+@@ -15,6 +15,22 @@
+ #include "rc80211_minstrel.h"
+ #include "rc80211_minstrel_ht.h"
+ 
++static ssize_t
++minstrel_stats_read(struct file *file, char __user *buf, size_t len, loff_t *ppos)
++{
++	struct minstrel_debugfs_info *ms;
++
++	ms = file->private_data;
++	return simple_read_from_buffer(buf, len, ppos, ms->buf, ms->len);
++}
++
++static int
++minstrel_stats_release(struct inode *inode, struct file *file)
++{
++	kfree(file->private_data);
++	return 0;
++}
++
+ static char *
+ minstrel_ht_stats_dump(struct minstrel_ht_sta *mi, int i, char *p)
+ {
diff -uprN a/package/kernel/mac80211/patches/subsys/306-mac80211-minstrel-reduce-minstrel_mcs_groups-size.patch b/package/kernel/mac80211/patches/subsys/306-mac80211-minstrel-reduce-minstrel_mcs_groups-size.patch
--- a/package/kernel/mac80211/patches/subsys/306-mac80211-minstrel-reduce-minstrel_mcs_groups-size.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/306-mac80211-minstrel-reduce-minstrel_mcs_groups-size.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,368 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 10 Feb 2018 12:45:47 +0100
+Subject: [PATCH] mac80211: minstrel: reduce minstrel_mcs_groups size
+
+By storing a shift value for all duration values of a group, we can
+reduce precision by a neglegible amount to make it fit into a u16 value.
+This improves cache footprint and reduces size:
+
+Before:
+   text    data     bss     dec     hex filename
+  10024     116       0   10140    279c rc80211_minstrel_ht.o
+
+After:
+   text    data     bss     dec     hex filename
+   9368     116       0    9484    250c rc80211_minstrel_ht.o
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -52,22 +52,23 @@
+ 	_streams - 1
+ 
+ /* MCS rate information for an MCS group */
+-#define MCS_GROUP(_streams, _sgi, _ht40)				\
++#define MCS_GROUP(_streams, _sgi, _ht40, _s)				\
+ 	[GROUP_IDX(_streams, _sgi, _ht40)] = {				\
+ 	.streams = _streams,						\
++	.shift = _s,							\
+ 	.flags =							\
+ 		IEEE80211_TX_RC_MCS |					\
+ 		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+ 		(_ht40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),		\
+ 	.duration = {							\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26),		\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52),		\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78),		\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104),	\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156),	\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208),	\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234),	\
+-		MCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260)		\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 108 : 52) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 162 : 78) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 216 : 104) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 324 : 156) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 432 : 208) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 486 : 234) >> _s,	\
++		MCS_DURATION(_streams, _sgi, _ht40 ? 540 : 260) >> _s	\
+ 	}								\
+ }
+ 
+@@ -80,9 +81,10 @@
+ #define BW2VBPS(_bw, r3, r2, r1)					\
+ 	(_bw == BW_80 ? r3 : _bw == BW_40 ? r2 : r1)
+ 
+-#define VHT_GROUP(_streams, _sgi, _bw)					\
++#define VHT_GROUP(_streams, _sgi, _bw, _s)				\
+ 	[VHT_GROUP_IDX(_streams, _sgi, _bw)] = {			\
+ 	.streams = _streams,						\
++	.shift = _s,							\
+ 	.flags =							\
+ 		IEEE80211_TX_RC_VHT_MCS |				\
+ 		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+@@ -90,25 +92,25 @@
+ 		 _bw == BW_40 ? IEEE80211_TX_RC_40_MHZ_WIDTH : 0),	\
+ 	.duration = {							\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw,  117,  54,  26)),		\
++			     BW2VBPS(_bw,  117,  54,  26)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw,  234, 108,  52)),		\
++			     BW2VBPS(_bw,  234, 108,  52)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw,  351, 162,  78)),		\
++			     BW2VBPS(_bw,  351, 162,  78)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw,  468, 216, 104)),		\
++			     BW2VBPS(_bw,  468, 216, 104)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw,  702, 324, 156)),		\
++			     BW2VBPS(_bw,  702, 324, 156)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw,  936, 432, 208)),		\
++			     BW2VBPS(_bw,  936, 432, 208)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw, 1053, 486, 234)),		\
++			     BW2VBPS(_bw, 1053, 486, 234)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw, 1170, 540, 260)),		\
++			     BW2VBPS(_bw, 1170, 540, 260)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw, 1404, 648, 312)),		\
++			     BW2VBPS(_bw, 1404, 648, 312)) >> _s,	\
+ 		MCS_DURATION(_streams, _sgi,				\
+-			     BW2VBPS(_bw, 1560, 720, 346))		\
++			     BW2VBPS(_bw, 1560, 720, 346)) >> _s	\
+ 	}								\
+ }
+ 
+@@ -121,19 +123,20 @@
+ 	(CCK_DURATION((_bitrate > 10 ? 20 : 10), false, 60) +	\
+ 	 CCK_DURATION(_bitrate, _short, AVG_PKT_SIZE))
+ 
+-#define CCK_DURATION_LIST(_short)			\
+-	CCK_ACK_DURATION(10, _short),			\
+-	CCK_ACK_DURATION(20, _short),			\
+-	CCK_ACK_DURATION(55, _short),			\
+-	CCK_ACK_DURATION(110, _short)
++#define CCK_DURATION_LIST(_short, _s)			\
++	CCK_ACK_DURATION(10, _short) >> _s,		\
++	CCK_ACK_DURATION(20, _short) >> _s,		\
++	CCK_ACK_DURATION(55, _short) >> _s,		\
++	CCK_ACK_DURATION(110, _short) >> _s
+ 
+-#define CCK_GROUP					\
++#define CCK_GROUP(_s)					\
+ 	[MINSTREL_CCK_GROUP] = {			\
+ 		.streams = 1,				\
+ 		.flags = 0,				\
++		.shift = _s,				\
+ 		.duration = {				\
+-			CCK_DURATION_LIST(false),	\
+-			CCK_DURATION_LIST(true)		\
++			CCK_DURATION_LIST(false, _s),	\
++			CCK_DURATION_LIST(true, _s)	\
+ 		}					\
+ 	}
+ 
+@@ -151,47 +154,47 @@ MODULE_PARM_DESC(minstrel_vht_only,
+  * BW -> SGI -> #streams
+  */
+ const struct mcs_group minstrel_mcs_groups[] = {
+-	MCS_GROUP(1, 0, BW_20),
+-	MCS_GROUP(2, 0, BW_20),
+-	MCS_GROUP(3, 0, BW_20),
+-
+-	MCS_GROUP(1, 1, BW_20),
+-	MCS_GROUP(2, 1, BW_20),
+-	MCS_GROUP(3, 1, BW_20),
+-
+-	MCS_GROUP(1, 0, BW_40),
+-	MCS_GROUP(2, 0, BW_40),
+-	MCS_GROUP(3, 0, BW_40),
+-
+-	MCS_GROUP(1, 1, BW_40),
+-	MCS_GROUP(2, 1, BW_40),
+-	MCS_GROUP(3, 1, BW_40),
+-
+-	CCK_GROUP,
+-
+-	VHT_GROUP(1, 0, BW_20),
+-	VHT_GROUP(2, 0, BW_20),
+-	VHT_GROUP(3, 0, BW_20),
+-
+-	VHT_GROUP(1, 1, BW_20),
+-	VHT_GROUP(2, 1, BW_20),
+-	VHT_GROUP(3, 1, BW_20),
+-
+-	VHT_GROUP(1, 0, BW_40),
+-	VHT_GROUP(2, 0, BW_40),
+-	VHT_GROUP(3, 0, BW_40),
+-
+-	VHT_GROUP(1, 1, BW_40),
+-	VHT_GROUP(2, 1, BW_40),
+-	VHT_GROUP(3, 1, BW_40),
+-
+-	VHT_GROUP(1, 0, BW_80),
+-	VHT_GROUP(2, 0, BW_80),
+-	VHT_GROUP(3, 0, BW_80),
+-
+-	VHT_GROUP(1, 1, BW_80),
+-	VHT_GROUP(2, 1, BW_80),
+-	VHT_GROUP(3, 1, BW_80),
++	MCS_GROUP(1, 0, BW_20, 5),
++	MCS_GROUP(2, 0, BW_20, 4),
++	MCS_GROUP(3, 0, BW_20, 4),
++
++	MCS_GROUP(1, 1, BW_20, 5),
++	MCS_GROUP(2, 1, BW_20, 4),
++	MCS_GROUP(3, 1, BW_20, 4),
++
++	MCS_GROUP(1, 0, BW_40, 4),
++	MCS_GROUP(2, 0, BW_40, 4),
++	MCS_GROUP(3, 0, BW_40, 4),
++
++	MCS_GROUP(1, 1, BW_40, 4),
++	MCS_GROUP(2, 1, BW_40, 4),
++	MCS_GROUP(3, 1, BW_40, 4),
++
++	CCK_GROUP(8),
++
++	VHT_GROUP(1, 0, BW_20, 5),
++	VHT_GROUP(2, 0, BW_20, 4),
++	VHT_GROUP(3, 0, BW_20, 4),
++
++	VHT_GROUP(1, 1, BW_20, 5),
++	VHT_GROUP(2, 1, BW_20, 4),
++	VHT_GROUP(3, 1, BW_20, 4),
++
++	VHT_GROUP(1, 0, BW_40, 4),
++	VHT_GROUP(2, 0, BW_40, 4),
++	VHT_GROUP(3, 0, BW_40, 4),
++
++	VHT_GROUP(1, 1, BW_40, 4),
++	VHT_GROUP(2, 1, BW_40, 4),
++	VHT_GROUP(3, 1, BW_40, 4),
++
++	VHT_GROUP(1, 0, BW_80, 4),
++	VHT_GROUP(2, 0, BW_80, 4),
++	VHT_GROUP(3, 0, BW_80, 4),
++
++	VHT_GROUP(1, 1, BW_80, 4),
++	VHT_GROUP(2, 1, BW_80, 4),
++	VHT_GROUP(3, 1, BW_80, 4),
+ };
+ 
+ static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
+@@ -308,7 +311,8 @@ minstrel_ht_get_tp_avg(struct minstrel_h
+ 	if (group != MINSTREL_CCK_GROUP)
+ 		nsecs = 1000 * mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);
+ 
+-	nsecs += minstrel_mcs_groups[group].duration[rate];
++	nsecs += minstrel_mcs_groups[group].duration[rate] <<
++		 minstrel_mcs_groups[group].shift;
+ 
+ 	/*
+ 	 * For the throughput calculation, limit the probability value to 90% to
+@@ -756,12 +760,19 @@ minstrel_ht_tx_status(void *priv, struct
+ 		minstrel_ht_update_rates(mp, mi);
+ }
+ 
++static inline int
++minstrel_get_duration(int index)
++{
++	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
++	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
++	return duration << group->shift;
++}
++
+ static void
+ minstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+                          int index)
+ {
+ 	struct minstrel_rate_stats *mrs;
+-	const struct mcs_group *group;
+ 	unsigned int tx_time, tx_time_rtscts, tx_time_data;
+ 	unsigned int cw = mp->cw_min;
+ 	unsigned int ctime = 0;
+@@ -780,8 +791,7 @@ minstrel_calc_retransmit(struct minstrel
+ 	mrs->retry_count_rtscts = 2;
+ 	mrs->retry_updated = true;
+ 
+-	group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
+-	tx_time_data = group->duration[index % MCS_GROUP_RATES] * ampdu_len / 1000;
++	tx_time_data = minstrel_get_duration(index) * ampdu_len / 1000;
+ 
+ 	/* Contention time for first 2 tries */
+ 	ctime = (t_slot * cw) >> 1;
+@@ -875,20 +885,24 @@ minstrel_ht_get_max_amsdu_len(struct min
+ 	int group = mi->max_prob_rate / MCS_GROUP_RATES;
+ 	const struct mcs_group *g = &minstrel_mcs_groups[group];
+ 	int rate = mi->max_prob_rate % MCS_GROUP_RATES;
++	unsigned int duration;
+ 
+ 	/* Disable A-MSDU if max_prob_rate is bad */
+ 	if (mi->groups[group].rates[rate].prob_ewma < MINSTREL_FRAC(50, 100))
+ 		return 1;
+ 
++	duration = g->duration[rate];
++	duration <<= g->shift;
++
+ 	/* If the rate is slower than single-stream MCS1, make A-MSDU limit small */
+-	if (g->duration[rate] > MCS_DURATION(1, 0, 52))
++	if (duration > MCS_DURATION(1, 0, 52))
+ 		return 500;
+ 
+ 	/*
+ 	 * If the rate is slower than single-stream MCS4, limit A-MSDU to usual
+ 	 * data packet size
+ 	 */
+-	if (g->duration[rate] > MCS_DURATION(1, 0, 104))
++	if (duration > MCS_DURATION(1, 0, 104))
+ 		return 1600;
+ 
+ 	/*
+@@ -896,7 +910,7 @@ minstrel_ht_get_max_amsdu_len(struct min
+ 	 * rate success probability is less than 75%, limit A-MSDU to twice the usual
+ 	 * data packet size
+ 	 */
+-	if (g->duration[rate] > MCS_DURATION(1, 0, 260) ||
++	if (duration > MCS_DURATION(1, 0, 260) ||
+ 	    (minstrel_ht_get_prob_ewma(mi, mi->max_tp_rate[0]) <
+ 	     MINSTREL_FRAC(75, 100)))
+ 		return 3200;
+@@ -943,13 +957,6 @@ minstrel_ht_update_rates(struct minstrel
+ 	rate_control_set_rates(mp->hw, mi->sta, rates);
+ }
+ 
+-static inline int
+-minstrel_get_duration(int index)
+-{
+-	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
+-	return group->duration[index % MCS_GROUP_RATES];
+-}
+-
+ static int
+ minstrel_get_sample_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+ {
+--- a/net/mac80211/rc80211_minstrel_ht.h
++++ b/net/mac80211/rc80211_minstrel_ht.h
+@@ -33,9 +33,10 @@
+ #define MCS_GROUP_RATES		10
+ 
+ struct mcs_group {
+-	u32 flags;
+-	unsigned int streams;
+-	unsigned int duration[MCS_GROUP_RATES];
++	u16 flags;
++	u8 streams;
++	u8 shift;
++	u16 duration[MCS_GROUP_RATES];
+ };
+ 
+ extern const struct mcs_group minstrel_mcs_groups[];
+--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
+@@ -58,6 +58,7 @@ minstrel_ht_stats_dump(struct minstrel_h
+ 		static const int bitrates[4] = { 10, 20, 55, 110 };
+ 		int idx = i * MCS_GROUP_RATES + j;
+ 		unsigned int prob_ewmsd;
++		unsigned int duration;
+ 
+ 		if (!(mi->supported[i] & BIT(j)))
+ 			continue;
+@@ -95,7 +96,9 @@ minstrel_ht_stats_dump(struct minstrel_h
+ 		p += sprintf(p, "  %3u  ", idx);
+ 
+ 		/* tx_time[rate(i)] in usec */
+-		tx_time = DIV_ROUND_CLOSEST(mg->duration[j], 1000);
++		duration = mg->duration[j];
++		duration <<= mg->shift;
++		tx_time = DIV_ROUND_CLOSEST(duration, 1000);
+ 		p += sprintf(p, "%6u  ", tx_time);
+ 
+ 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
+@@ -204,6 +207,7 @@ minstrel_ht_stats_csv_dump(struct minstr
+ 		static const int bitrates[4] = { 10, 20, 55, 110 };
+ 		int idx = i * MCS_GROUP_RATES + j;
+ 		unsigned int prob_ewmsd;
++		unsigned int duration;
+ 
+ 		if (!(mi->supported[i] & BIT(j)))
+ 			continue;
+@@ -238,7 +242,10 @@ minstrel_ht_stats_csv_dump(struct minstr
+ 		}
+ 
+ 		p += sprintf(p, "%u,", idx);
+-		tx_time = DIV_ROUND_CLOSEST(mg->duration[j], 1000);
++
++		duration = mg->duration[j];
++		duration <<= mg->shift;
++		tx_time = DIV_ROUND_CLOSEST(duration, 1000);
+ 		p += sprintf(p, "%u,", tx_time);
+ 
+ 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
diff -uprN a/package/kernel/mac80211/patches/subsys/306-mac80211-move-store-skb-ack-code-to-its-own-function.patch b/package/kernel/mac80211/patches/subsys/306-mac80211-move-store-skb-ack-code-to-its-own-function.patch
--- a/package/kernel/mac80211/patches/subsys/306-mac80211-move-store-skb-ack-code-to-its-own-function.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/306-mac80211-move-store-skb-ack-code-to-its-own-function.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,78 +0,0 @@
-From: John Crispin <john@phrozen.org>
-Date: Tue, 29 Oct 2019 10:13:02 +0100
-Subject: [PATCH] mac80211: move store skb ack code to its own function
-
-This patch moves the code handling SKBTX_WIFI_STATUS inside the TX path
-into an extra function. This allows us to reuse it inside the 802.11 encap
-offloading datapath.
-
-Signed-off-by: John Crispin <john@phrozen.org>
-Link: https://lore.kernel.org/r/20191029091304.7330-2-john@phrozen.org
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -2439,6 +2439,33 @@ static int ieee80211_lookup_ra_sta(struc
- 	return 0;
- }
- 
-+static int ieee80211_store_ack_skb(struct ieee80211_local *local,
-+				   struct sk_buff *skb,
-+				   u32 *info_flags)
-+{
-+	struct sk_buff *ack_skb = skb_clone_sk(skb);
-+	u16 info_id = 0;
-+
-+	if (ack_skb) {
-+		unsigned long flags;
-+		int id;
-+
-+		spin_lock_irqsave(&local->ack_status_lock, flags);
-+		id = idr_alloc(&local->ack_status_frames, ack_skb,
-+			       1, 0x10000, GFP_ATOMIC);
-+		spin_unlock_irqrestore(&local->ack_status_lock, flags);
-+
-+		if (id >= 0) {
-+			info_id = id;
-+			*info_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
-+		} else {
-+			kfree_skb(ack_skb);
-+		}
-+	}
-+
-+	return info_id;
-+}
-+
- /**
-  * ieee80211_build_hdr - build 802.11 header in the given frame
-  * @sdata: virtual interface to build the header for
-@@ -2732,26 +2759,8 @@ static struct sk_buff *ieee80211_build_h
- 	}
- 
- 	if (unlikely(!multicast && skb->sk &&
--		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS)) {
--		struct sk_buff *ack_skb = skb_clone_sk(skb);
--
--		if (ack_skb) {
--			unsigned long flags;
--			int id;
--
--			spin_lock_irqsave(&local->ack_status_lock, flags);
--			id = idr_alloc(&local->ack_status_frames, ack_skb,
--				       1, 0x10000, GFP_ATOMIC);
--			spin_unlock_irqrestore(&local->ack_status_lock, flags);
--
--			if (id >= 0) {
--				info_id = id;
--				info_flags |= IEEE80211_TX_CTL_REQ_TX_STATUS;
--			} else {
--				kfree_skb(ack_skb);
--			}
--		}
--	}
-+		     skb_shinfo(skb)->tx_flags & SKBTX_WIFI_STATUS))
-+		info_id = ieee80211_store_ack_skb(local, skb, &info_flags);
- 
- 	/*
- 	 * If the skb is shared we need to obtain our own copy.
diff -uprN a/package/kernel/mac80211/patches/subsys/307-mac80211-Shrink-the-size-of-ack_frame_id-to-make-roo.patch b/package/kernel/mac80211/patches/subsys/307-mac80211-Shrink-the-size-of-ack_frame_id-to-make-roo.patch
--- a/package/kernel/mac80211/patches/subsys/307-mac80211-Shrink-the-size-of-ack_frame_id-to-make-roo.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/307-mac80211-Shrink-the-size-of-ack_frame_id-to-make-roo.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,67 +0,0 @@
-From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
-Date: Wed, 23 Oct 2019 11:59:00 +0200
-Subject: [PATCH] mac80211: Shrink the size of ack_frame_id to make room for
- tx_time_est
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-To implement airtime queue limiting, we need to keep a running account of
-the estimated airtime of all skbs queued into the device. Do to this
-correctly, we need to store the airtime estimate into the skb so we can
-decrease the outstanding balance when the skb is freed. This means that the
-time estimate must be stored somewhere that will survive for the lifetime
-of the skb.
-
-To get this, decrease the size of the ack_frame_id field to 6 bits, and
-lower the size of the ID space accordingly. This leaves 10 bits for use for
-tx_time_est, which is enough to store a maximum of 4096 us, if we shift the
-values so they become units of 4us.
-
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/157182474063.150713.16132669599100802716.stgit@toke.dk
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -967,6 +967,7 @@ ieee80211_rate_get_vht_nss(const struct
-  * @band: the band to transmit on (use for checking for races)
-  * @hw_queue: HW queue to put the frame on, skb_get_queue_mapping() gives the AC
-  * @ack_frame_id: internal frame ID for TX status, used internally
-+ * @tx_time_est: TX time estimate in units of 4us, used internally
-  * @control: union part for control data
-  * @control.rates: TX rates array to try
-  * @control.rts_cts_rate_idx: rate for RTS or CTS
-@@ -1007,7 +1008,8 @@ struct ieee80211_tx_info {
- 
- 	u8 hw_queue;
- 
--	u16 ack_frame_id;
-+	u16 ack_frame_id:6;
-+	u16 tx_time_est:10;
- 
- 	union {
- 		struct {
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -3449,7 +3449,7 @@ int ieee80211_attach_ack_skb(struct ieee
- 
- 	spin_lock_irqsave(&local->ack_status_lock, spin_flags);
- 	id = idr_alloc(&local->ack_status_frames, ack_skb,
--		       1, 0x10000, GFP_ATOMIC);
-+		       1, 0x40, GFP_ATOMIC);
- 	spin_unlock_irqrestore(&local->ack_status_lock, spin_flags);
- 
- 	if (id < 0) {
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -2452,7 +2452,7 @@ static int ieee80211_store_ack_skb(struc
- 
- 		spin_lock_irqsave(&local->ack_status_lock, flags);
- 		id = idr_alloc(&local->ack_status_frames, ack_skb,
--			       1, 0x10000, GFP_ATOMIC);
-+			       1, 0x40, GFP_ATOMIC);
- 		spin_unlock_irqrestore(&local->ack_status_lock, flags);
- 
- 		if (id >= 0) {
diff -uprN a/package/kernel/mac80211/patches/subsys/308-mac80211-Add-new-sta_info-getter-by-sta-vif-addrs.patch b/package/kernel/mac80211/patches/subsys/308-mac80211-Add-new-sta_info-getter-by-sta-vif-addrs.patch
--- a/package/kernel/mac80211/patches/subsys/308-mac80211-Add-new-sta_info-getter-by-sta-vif-addrs.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/308-mac80211-Add-new-sta_info-getter-by-sta-vif-addrs.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,78 +0,0 @@
-From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
-Date: Tue, 12 Nov 2019 14:08:35 +0100
-Subject: [PATCH] mac80211: Add new sta_info getter by sta/vif addrs
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In ieee80211_tx_status() we don't have an sdata struct when looking up the
-destination sta. Instead, we just do a lookup by the vif addr that is the
-source of the packet being completed. Factor this out into a new sta_info
-getter helper, since we need to use it for accounting AQL as well.
-
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20191112130835.382062-1-toke@redhat.com
-[remove internal rcu_read_lock(), document instead]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -210,6 +210,20 @@ struct sta_info *sta_info_get_bss(struct
- 	return NULL;
- }
- 
-+struct sta_info *sta_info_get_by_addrs(struct ieee80211_local *local,
-+				       const u8 *sta_addr, const u8 *vif_addr)
-+{
-+	struct rhlist_head *tmp;
-+	struct sta_info *sta;
-+
-+	for_each_sta_info(local, sta_addr, sta, tmp) {
-+		if (ether_addr_equal(vif_addr, sta->sdata->vif.addr))
-+			return sta;
-+	}
-+
-+	return NULL;
-+}
-+
- struct sta_info *sta_info_get_by_idx(struct ieee80211_sub_if_data *sdata,
- 				     int idx)
- {
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -725,6 +725,10 @@ struct sta_info *sta_info_get(struct iee
- struct sta_info *sta_info_get_bss(struct ieee80211_sub_if_data *sdata,
- 				  const u8 *addr);
- 
-+/* user must hold sta_mtx or be in RCU critical section */
-+struct sta_info *sta_info_get_by_addrs(struct ieee80211_local *local,
-+				       const u8 *sta_addr, const u8 *vif_addr);
-+
- #define for_each_sta_info(local, _addr, _sta, _tmp)			\
- 	rhl_for_each_entry_rcu(_sta, _tmp,				\
- 			       sta_info_hash_lookup(local, _addr), hash_node)
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -1086,19 +1086,13 @@ void ieee80211_tx_status(struct ieee8021
- 		.skb = skb,
- 		.info = IEEE80211_SKB_CB(skb),
- 	};
--	struct rhlist_head *tmp;
- 	struct sta_info *sta;
- 
- 	rcu_read_lock();
- 
--	for_each_sta_info(local, hdr->addr1, sta, tmp) {
--		/* skip wrong virtual interface */
--		if (!ether_addr_equal(hdr->addr2, sta->sdata->vif.addr))
--			continue;
--
-+	sta = sta_info_get_by_addrs(local, hdr->addr1, hdr->addr2);
-+	if (sta)
- 		status.sta = &sta->sta;
--		break;
--	}
- 
- 	__ieee80211_tx_status(hw, &status);
- 	rcu_read_unlock();
diff -uprN a/package/kernel/mac80211/patches/subsys/309-mac80211-Import-airtime-calculation-code-from-mt76.patch b/package/kernel/mac80211/patches/subsys/309-mac80211-Import-airtime-calculation-code-from-mt76.patch
--- a/package/kernel/mac80211/patches/subsys/309-mac80211-Import-airtime-calculation-code-from-mt76.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/309-mac80211-Import-airtime-calculation-code-from-mt76.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,690 +0,0 @@
-From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
-Date: Mon, 18 Nov 2019 22:06:08 -0800
-Subject: [PATCH] mac80211: Import airtime calculation code from mt76
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Felix recently added code to calculate airtime of packets to the mt76
-driver. Import this into mac80211 so we can use it for airtime queue limit
-calculations.
-
-The airtime.c file is copied verbatim from the mt76 driver, and adjusted to
-be usable in mac80211. This involves:
-
-- Switching to mac80211 data structures.
-- Adding support for 160 MHz channels and HE mode.
-- Moving the symbol and duration calculations around a bit to avoid
-  rounding with the higher rates and longer symbol times used for HE rates.
-
-The per-rate TX rate calculation is also split out to its own function so
-it can be used directly for the AQL calculations later.
-
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20191119060610.76681-3-kyan@google.com
-[fix HE_GROUP_IDX() to use 3 * bw, since there are 3 _gi values]
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
- create mode 100644 net/mac80211/airtime.c
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -6417,4 +6417,33 @@ void ieee80211_nan_func_match(struct iee
- 			      struct cfg80211_nan_match_params *match,
- 			      gfp_t gfp);
- 
-+/**
-+ * ieee80211_calc_rx_airtime - calculate estimated transmission airtime for RX.
-+ *
-+ * This function calculates the estimated airtime usage of a frame based on the
-+ * rate information in the RX status struct and the frame length.
-+ *
-+ * @hw: pointer as obtained from ieee80211_alloc_hw()
-+ * @status: &struct ieee80211_rx_status containing the transmission rate
-+ *          information.
-+ * @len: frame length in bytes
-+ */
-+u32 ieee80211_calc_rx_airtime(struct ieee80211_hw *hw,
-+			      struct ieee80211_rx_status *status,
-+			      int len);
-+
-+/**
-+ * ieee80211_calc_tx_airtime - calculate estimated transmission airtime for TX.
-+ *
-+ * This function calculates the estimated airtime usage of a frame based on the
-+ * rate information in the TX info struct and the frame length.
-+ *
-+ * @hw: pointer as obtained from ieee80211_alloc_hw()
-+ * @info: &struct ieee80211_tx_info of the frame.
-+ * @len: frame length in bytes
-+ */
-+u32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,
-+			      struct ieee80211_tx_info *info,
-+			      int len);
-+
- #endif /* MAC80211_H */
---- a/net/mac80211/Makefile
-+++ b/net/mac80211/Makefile
-@@ -31,7 +31,8 @@ mac80211-y := \
- 	chan.o \
- 	trace.o mlme.o \
- 	tdls.o \
--	ocb.o
-+	ocb.o \
-+	airtime.o
- 
- mac80211-$(CPTCFG_MAC80211_LEDS) += led.o
- mac80211-$(CPTCFG_MAC80211_DEBUGFS) += \
---- /dev/null
-+++ b/net/mac80211/airtime.c
-@@ -0,0 +1,597 @@
-+// SPDX-License-Identifier: ISC
-+/*
-+ * Copyright (C) 2019 Felix Fietkau <nbd@nbd.name>
-+ */
-+
-+#include <net/mac80211.h>
-+#include "ieee80211_i.h"
-+#include "sta_info.h"
-+
-+#define AVG_PKT_SIZE	1024
-+
-+/* Number of bits for an average sized packet */
-+#define MCS_NBITS (AVG_PKT_SIZE << 3)
-+
-+/* Number of kilo-symbols (symbols * 1024) for a packet with (bps) bits per
-+ * symbol. We use k-symbols to avoid rounding in the _TIME macros below.
-+ */
-+#define MCS_N_KSYMS(bps) DIV_ROUND_UP(MCS_NBITS << 10, (bps))
-+
-+/* Transmission time (in 1024 * usec) for a packet containing (ksyms) * 1024
-+ * symbols.
-+ */
-+#define MCS_SYMBOL_TIME(sgi, ksyms)					\
-+	(sgi ?								\
-+	  ((ksyms) * 4 * 18) / 20 :		/* 3.6 us per sym */	\
-+	  ((ksyms) * 4)			/* 4.0 us per sym */	\
-+	)
-+
-+/* Transmit duration for the raw data part of an average sized packet */
-+#define MCS_DURATION(streams, sgi, bps) \
-+	((u32)MCS_SYMBOL_TIME(sgi, MCS_N_KSYMS((streams) * (bps))))
-+
-+#define MCS_DURATION_S(shift, streams, sgi, bps)		\
-+	((u16)((MCS_DURATION(streams, sgi, bps) >> shift)))
-+
-+/* These should match the values in enum nl80211_he_gi */
-+#define HE_GI_08 0
-+#define HE_GI_16 1
-+#define HE_GI_32 2
-+
-+/* Transmission time (1024 usec) for a packet containing (ksyms) * k-symbols */
-+#define HE_SYMBOL_TIME(gi, ksyms)					\
-+	(gi == HE_GI_08 ?						\
-+	 ((ksyms) * 16 * 17) / 20 :		/* 13.6 us per sym */	\
-+	 (gi == HE_GI_16 ?						\
-+	  ((ksyms) * 16 * 18) / 20 :		/* 14.4 us per sym */	\
-+	  ((ksyms) * 16)			/* 16.0 us per sym */	\
-+	 ))
-+
-+/* Transmit duration for the raw data part of an average sized packet */
-+#define HE_DURATION(streams, gi, bps) \
-+	((u32)HE_SYMBOL_TIME(gi, MCS_N_KSYMS((streams) * (bps))))
-+
-+#define HE_DURATION_S(shift, streams, gi, bps)		\
-+	(HE_DURATION(streams, gi, bps) >> shift)
-+
-+#define BW_20			0
-+#define BW_40			1
-+#define BW_80			2
-+#define BW_160			3
-+
-+/*
-+ * Define group sort order: HT40 -> SGI -> #streams
-+ */
-+#define IEEE80211_MAX_STREAMS		4
-+#define IEEE80211_HT_STREAM_GROUPS	4 /* BW(=2) * SGI(=2) */
-+#define IEEE80211_VHT_STREAM_GROUPS	8 /* BW(=4) * SGI(=2) */
-+
-+#define IEEE80211_HE_MAX_STREAMS	8
-+#define IEEE80211_HE_STREAM_GROUPS	12 /* BW(=4) * GI(=3) */
-+
-+#define IEEE80211_HT_GROUPS_NB	(IEEE80211_MAX_STREAMS *	\
-+				 IEEE80211_HT_STREAM_GROUPS)
-+#define IEEE80211_VHT_GROUPS_NB	(IEEE80211_MAX_STREAMS *	\
-+					 IEEE80211_VHT_STREAM_GROUPS)
-+#define IEEE80211_HE_GROUPS_NB	(IEEE80211_HE_MAX_STREAMS *	\
-+				 IEEE80211_HE_STREAM_GROUPS)
-+#define IEEE80211_GROUPS_NB	(IEEE80211_HT_GROUPS_NB +	\
-+				 IEEE80211_VHT_GROUPS_NB +	\
-+				 IEEE80211_HE_GROUPS_NB)
-+
-+#define IEEE80211_HT_GROUP_0	0
-+#define IEEE80211_VHT_GROUP_0	(IEEE80211_HT_GROUP_0 + IEEE80211_HT_GROUPS_NB)
-+#define IEEE80211_HE_GROUP_0	(IEEE80211_VHT_GROUP_0 + IEEE80211_VHT_GROUPS_NB)
-+
-+#define MCS_GROUP_RATES		12
-+
-+#define HT_GROUP_IDX(_streams, _sgi, _ht40)	\
-+	IEEE80211_HT_GROUP_0 +			\
-+	IEEE80211_MAX_STREAMS * 2 * _ht40 +	\
-+	IEEE80211_MAX_STREAMS * _sgi +		\
-+	_streams - 1
-+
-+#define _MAX(a, b) (((a)>(b))?(a):(b))
-+
-+#define GROUP_SHIFT(duration)						\
-+	_MAX(0, 16 - __builtin_clz(duration))
-+
-+/* MCS rate information for an MCS group */
-+#define __MCS_GROUP(_streams, _sgi, _ht40, _s)				\
-+	[HT_GROUP_IDX(_streams, _sgi, _ht40)] = {			\
-+	.shift = _s,							\
-+	.duration = {							\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 54 : 26),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 108 : 52),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 162 : 78),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 216 : 104),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 324 : 156),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 432 : 208),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 486 : 234),	\
-+		MCS_DURATION_S(_s, _streams, _sgi, _ht40 ? 540 : 260)	\
-+	}								\
-+}
-+
-+#define MCS_GROUP_SHIFT(_streams, _sgi, _ht40)				\
-+	GROUP_SHIFT(MCS_DURATION(_streams, _sgi, _ht40 ? 54 : 26))
-+
-+#define MCS_GROUP(_streams, _sgi, _ht40)				\
-+	__MCS_GROUP(_streams, _sgi, _ht40,				\
-+		    MCS_GROUP_SHIFT(_streams, _sgi, _ht40))
-+
-+#define VHT_GROUP_IDX(_streams, _sgi, _bw)				\
-+	(IEEE80211_VHT_GROUP_0 +					\
-+	 IEEE80211_MAX_STREAMS * 2 * (_bw) +				\
-+	 IEEE80211_MAX_STREAMS * (_sgi) +				\
-+	 (_streams) - 1)
-+
-+#define BW2VBPS(_bw, r4, r3, r2, r1)					\
-+	(_bw == BW_160 ? r4 : _bw == BW_80 ? r3 : _bw == BW_40 ? r2 : r1)
-+
-+#define __VHT_GROUP(_streams, _sgi, _bw, _s)				\
-+	[VHT_GROUP_IDX(_streams, _sgi, _bw)] = {			\
-+	.shift = _s,							\
-+	.duration = {							\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw,  234,  117,  54,  26)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw,  468,  234, 108,  52)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw,  702,  351, 162,  78)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw,  936,  468, 216, 104)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw, 1404,  702, 324, 156)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw, 1872,  936, 432, 208)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw, 2106, 1053, 486, 234)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw, 2340, 1170, 540, 260)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw, 2808, 1404, 648, 312)),	\
-+		MCS_DURATION_S(_s, _streams, _sgi,			\
-+			       BW2VBPS(_bw, 3120, 1560, 720, 346))	\
-+        }								\
-+}
-+
-+#define VHT_GROUP_SHIFT(_streams, _sgi, _bw)				\
-+	GROUP_SHIFT(MCS_DURATION(_streams, _sgi,			\
-+				 BW2VBPS(_bw, 243, 117,  54,  26)))
-+
-+#define VHT_GROUP(_streams, _sgi, _bw)					\
-+	__VHT_GROUP(_streams, _sgi, _bw,				\
-+		    VHT_GROUP_SHIFT(_streams, _sgi, _bw))
-+
-+
-+#define HE_GROUP_IDX(_streams, _gi, _bw)				\
-+	(IEEE80211_HE_GROUP_0 +					\
-+	 IEEE80211_HE_MAX_STREAMS * 3 * (_bw) +			\
-+	 IEEE80211_HE_MAX_STREAMS * (_gi) +				\
-+	 (_streams) - 1)
-+
-+#define __HE_GROUP(_streams, _gi, _bw, _s)				\
-+	[HE_GROUP_IDX(_streams, _gi, _bw)] = {			\
-+	.shift = _s,							\
-+	.duration = {							\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,   979,  489,  230,  115)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  1958,  979,  475,  230)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  2937, 1468,  705,  345)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  3916, 1958,  936,  475)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  5875, 2937, 1411,  705)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  7833, 3916, 1872,  936)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  8827, 4406, 2102, 1051)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw,  9806, 4896, 2347, 1166)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw, 11764, 5875, 2808, 1411)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw, 13060, 6523, 3124, 1555)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw, 14702, 7344, 3513, 1756)),	\
-+		HE_DURATION_S(_s, _streams, _gi,			\
-+			      BW2VBPS(_bw, 16329, 8164, 3902, 1944))	\
-+        }								\
-+}
-+
-+#define HE_GROUP_SHIFT(_streams, _gi, _bw)				\
-+	GROUP_SHIFT(HE_DURATION(_streams, _gi,			\
-+				BW2VBPS(_bw,   979,  489,  230,  115)))
-+
-+#define HE_GROUP(_streams, _gi, _bw)					\
-+	__HE_GROUP(_streams, _gi, _bw,				\
-+		   HE_GROUP_SHIFT(_streams, _gi, _bw))
-+struct mcs_group {
-+	u8 shift;
-+	u16 duration[MCS_GROUP_RATES];
-+};
-+
-+static const struct mcs_group airtime_mcs_groups[] = {
-+	MCS_GROUP(1, 0, BW_20),
-+	MCS_GROUP(2, 0, BW_20),
-+	MCS_GROUP(3, 0, BW_20),
-+	MCS_GROUP(4, 0, BW_20),
-+
-+	MCS_GROUP(1, 1, BW_20),
-+	MCS_GROUP(2, 1, BW_20),
-+	MCS_GROUP(3, 1, BW_20),
-+	MCS_GROUP(4, 1, BW_20),
-+
-+	MCS_GROUP(1, 0, BW_40),
-+	MCS_GROUP(2, 0, BW_40),
-+	MCS_GROUP(3, 0, BW_40),
-+	MCS_GROUP(4, 0, BW_40),
-+
-+	MCS_GROUP(1, 1, BW_40),
-+	MCS_GROUP(2, 1, BW_40),
-+	MCS_GROUP(3, 1, BW_40),
-+	MCS_GROUP(4, 1, BW_40),
-+
-+	VHT_GROUP(1, 0, BW_20),
-+	VHT_GROUP(2, 0, BW_20),
-+	VHT_GROUP(3, 0, BW_20),
-+	VHT_GROUP(4, 0, BW_20),
-+
-+	VHT_GROUP(1, 1, BW_20),
-+	VHT_GROUP(2, 1, BW_20),
-+	VHT_GROUP(3, 1, BW_20),
-+	VHT_GROUP(4, 1, BW_20),
-+
-+	VHT_GROUP(1, 0, BW_40),
-+	VHT_GROUP(2, 0, BW_40),
-+	VHT_GROUP(3, 0, BW_40),
-+	VHT_GROUP(4, 0, BW_40),
-+
-+	VHT_GROUP(1, 1, BW_40),
-+	VHT_GROUP(2, 1, BW_40),
-+	VHT_GROUP(3, 1, BW_40),
-+	VHT_GROUP(4, 1, BW_40),
-+
-+	VHT_GROUP(1, 0, BW_80),
-+	VHT_GROUP(2, 0, BW_80),
-+	VHT_GROUP(3, 0, BW_80),
-+	VHT_GROUP(4, 0, BW_80),
-+
-+	VHT_GROUP(1, 1, BW_80),
-+	VHT_GROUP(2, 1, BW_80),
-+	VHT_GROUP(3, 1, BW_80),
-+	VHT_GROUP(4, 1, BW_80),
-+
-+	VHT_GROUP(1, 0, BW_160),
-+	VHT_GROUP(2, 0, BW_160),
-+	VHT_GROUP(3, 0, BW_160),
-+	VHT_GROUP(4, 0, BW_160),
-+
-+	VHT_GROUP(1, 1, BW_160),
-+	VHT_GROUP(2, 1, BW_160),
-+	VHT_GROUP(3, 1, BW_160),
-+	VHT_GROUP(4, 1, BW_160),
-+
-+	HE_GROUP(1, HE_GI_08, BW_20),
-+	HE_GROUP(2, HE_GI_08, BW_20),
-+	HE_GROUP(3, HE_GI_08, BW_20),
-+	HE_GROUP(4, HE_GI_08, BW_20),
-+	HE_GROUP(5, HE_GI_08, BW_20),
-+	HE_GROUP(6, HE_GI_08, BW_20),
-+	HE_GROUP(7, HE_GI_08, BW_20),
-+	HE_GROUP(8, HE_GI_08, BW_20),
-+
-+	HE_GROUP(1, HE_GI_16, BW_20),
-+	HE_GROUP(2, HE_GI_16, BW_20),
-+	HE_GROUP(3, HE_GI_16, BW_20),
-+	HE_GROUP(4, HE_GI_16, BW_20),
-+	HE_GROUP(5, HE_GI_16, BW_20),
-+	HE_GROUP(6, HE_GI_16, BW_20),
-+	HE_GROUP(7, HE_GI_16, BW_20),
-+	HE_GROUP(8, HE_GI_16, BW_20),
-+
-+	HE_GROUP(1, HE_GI_32, BW_20),
-+	HE_GROUP(2, HE_GI_32, BW_20),
-+	HE_GROUP(3, HE_GI_32, BW_20),
-+	HE_GROUP(4, HE_GI_32, BW_20),
-+	HE_GROUP(5, HE_GI_32, BW_20),
-+	HE_GROUP(6, HE_GI_32, BW_20),
-+	HE_GROUP(7, HE_GI_32, BW_20),
-+	HE_GROUP(8, HE_GI_32, BW_20),
-+
-+	HE_GROUP(1, HE_GI_08, BW_40),
-+	HE_GROUP(2, HE_GI_08, BW_40),
-+	HE_GROUP(3, HE_GI_08, BW_40),
-+	HE_GROUP(4, HE_GI_08, BW_40),
-+	HE_GROUP(5, HE_GI_08, BW_40),
-+	HE_GROUP(6, HE_GI_08, BW_40),
-+	HE_GROUP(7, HE_GI_08, BW_40),
-+	HE_GROUP(8, HE_GI_08, BW_40),
-+
-+	HE_GROUP(1, HE_GI_16, BW_40),
-+	HE_GROUP(2, HE_GI_16, BW_40),
-+	HE_GROUP(3, HE_GI_16, BW_40),
-+	HE_GROUP(4, HE_GI_16, BW_40),
-+	HE_GROUP(5, HE_GI_16, BW_40),
-+	HE_GROUP(6, HE_GI_16, BW_40),
-+	HE_GROUP(7, HE_GI_16, BW_40),
-+	HE_GROUP(8, HE_GI_16, BW_40),
-+
-+	HE_GROUP(1, HE_GI_32, BW_40),
-+	HE_GROUP(2, HE_GI_32, BW_40),
-+	HE_GROUP(3, HE_GI_32, BW_40),
-+	HE_GROUP(4, HE_GI_32, BW_40),
-+	HE_GROUP(5, HE_GI_32, BW_40),
-+	HE_GROUP(6, HE_GI_32, BW_40),
-+	HE_GROUP(7, HE_GI_32, BW_40),
-+	HE_GROUP(8, HE_GI_32, BW_40),
-+
-+	HE_GROUP(1, HE_GI_08, BW_80),
-+	HE_GROUP(2, HE_GI_08, BW_80),
-+	HE_GROUP(3, HE_GI_08, BW_80),
-+	HE_GROUP(4, HE_GI_08, BW_80),
-+	HE_GROUP(5, HE_GI_08, BW_80),
-+	HE_GROUP(6, HE_GI_08, BW_80),
-+	HE_GROUP(7, HE_GI_08, BW_80),
-+	HE_GROUP(8, HE_GI_08, BW_80),
-+
-+	HE_GROUP(1, HE_GI_16, BW_80),
-+	HE_GROUP(2, HE_GI_16, BW_80),
-+	HE_GROUP(3, HE_GI_16, BW_80),
-+	HE_GROUP(4, HE_GI_16, BW_80),
-+	HE_GROUP(5, HE_GI_16, BW_80),
-+	HE_GROUP(6, HE_GI_16, BW_80),
-+	HE_GROUP(7, HE_GI_16, BW_80),
-+	HE_GROUP(8, HE_GI_16, BW_80),
-+
-+	HE_GROUP(1, HE_GI_32, BW_80),
-+	HE_GROUP(2, HE_GI_32, BW_80),
-+	HE_GROUP(3, HE_GI_32, BW_80),
-+	HE_GROUP(4, HE_GI_32, BW_80),
-+	HE_GROUP(5, HE_GI_32, BW_80),
-+	HE_GROUP(6, HE_GI_32, BW_80),
-+	HE_GROUP(7, HE_GI_32, BW_80),
-+	HE_GROUP(8, HE_GI_32, BW_80),
-+
-+	HE_GROUP(1, HE_GI_08, BW_160),
-+	HE_GROUP(2, HE_GI_08, BW_160),
-+	HE_GROUP(3, HE_GI_08, BW_160),
-+	HE_GROUP(4, HE_GI_08, BW_160),
-+	HE_GROUP(5, HE_GI_08, BW_160),
-+	HE_GROUP(6, HE_GI_08, BW_160),
-+	HE_GROUP(7, HE_GI_08, BW_160),
-+	HE_GROUP(8, HE_GI_08, BW_160),
-+
-+	HE_GROUP(1, HE_GI_16, BW_160),
-+	HE_GROUP(2, HE_GI_16, BW_160),
-+	HE_GROUP(3, HE_GI_16, BW_160),
-+	HE_GROUP(4, HE_GI_16, BW_160),
-+	HE_GROUP(5, HE_GI_16, BW_160),
-+	HE_GROUP(6, HE_GI_16, BW_160),
-+	HE_GROUP(7, HE_GI_16, BW_160),
-+	HE_GROUP(8, HE_GI_16, BW_160),
-+
-+	HE_GROUP(1, HE_GI_32, BW_160),
-+	HE_GROUP(2, HE_GI_32, BW_160),
-+	HE_GROUP(3, HE_GI_32, BW_160),
-+	HE_GROUP(4, HE_GI_32, BW_160),
-+	HE_GROUP(5, HE_GI_32, BW_160),
-+	HE_GROUP(6, HE_GI_32, BW_160),
-+	HE_GROUP(7, HE_GI_32, BW_160),
-+	HE_GROUP(8, HE_GI_32, BW_160),
-+};
-+
-+static u32
-+ieee80211_calc_legacy_rate_duration(u16 bitrate, bool short_pre,
-+				    bool cck, int len)
-+{
-+	u32 duration;
-+
-+	if (cck) {
-+		duration = 144 + 48; /* preamble + PLCP */
-+		if (short_pre)
-+			duration >>= 1;
-+
-+		duration += 10; /* SIFS */
-+	} else {
-+		duration = 20 + 16; /* premable + SIFS */
-+	}
-+
-+	len <<= 3;
-+	duration += (len * 10) / bitrate;
-+
-+	return duration;
-+}
-+
-+u32 ieee80211_calc_rx_airtime(struct ieee80211_hw *hw,
-+			      struct ieee80211_rx_status *status,
-+			      int len)
-+{
-+	struct ieee80211_supported_band *sband;
-+	const struct ieee80211_rate *rate;
-+	bool sgi = status->enc_flags & RX_ENC_FLAG_SHORT_GI;
-+	bool sp = status->enc_flags & RX_ENC_FLAG_SHORTPRE;
-+	int bw, streams;
-+	int group, idx;
-+	u32 duration;
-+	bool cck;
-+
-+	switch (status->bw) {
-+	case RATE_INFO_BW_20:
-+		bw = BW_20;
-+		break;
-+	case RATE_INFO_BW_40:
-+		bw = BW_40;
-+		break;
-+	case RATE_INFO_BW_80:
-+		bw = BW_80;
-+		break;
-+	case RATE_INFO_BW_160:
-+		bw = BW_160;
-+		break;
-+	default:
-+		WARN_ON_ONCE(1);
-+		return 0;
-+	}
-+
-+	switch (status->encoding) {
-+	case RX_ENC_LEGACY:
-+		if (WARN_ON_ONCE(status->band > NL80211_BAND_5GHZ))
-+			return 0;
-+
-+		sband = hw->wiphy->bands[status->band];
-+		if (!sband || status->rate_idx > sband->n_bitrates)
-+			return 0;
-+
-+		rate = &sband->bitrates[status->rate_idx];
-+		cck = rate->flags & IEEE80211_RATE_MANDATORY_B;
-+
-+		return ieee80211_calc_legacy_rate_duration(rate->bitrate, sp,
-+							   cck, len);
-+
-+	case RX_ENC_VHT:
-+		streams = status->nss;
-+		idx = status->rate_idx;
-+		group = VHT_GROUP_IDX(streams, sgi, bw);
-+		break;
-+	case RX_ENC_HT:
-+		streams = ((status->rate_idx >> 3) & 3) + 1;
-+		idx = status->rate_idx & 7;
-+		group = HT_GROUP_IDX(streams, sgi, bw);
-+		break;
-+	case RX_ENC_HE:
-+		streams = status->nss;
-+		idx = status->rate_idx;
-+		group = HE_GROUP_IDX(streams, status->he_gi, bw);
-+		break;
-+	default:
-+		WARN_ON_ONCE(1);
-+		return 0;
-+	}
-+
-+	if (WARN_ON_ONCE((status->encoding != RX_ENC_HE && streams > 4) ||
-+			 (status->encoding == RX_ENC_HE && streams > 8)))
-+		return 0;
-+
-+	duration = airtime_mcs_groups[group].duration[idx];
-+	duration <<= airtime_mcs_groups[group].shift;
-+	duration *= len;
-+	duration /= AVG_PKT_SIZE;
-+	duration /= 1024;
-+
-+	duration += 36 + (streams << 2);
-+
-+	return duration;
-+}
-+EXPORT_SYMBOL_GPL(ieee80211_calc_rx_airtime);
-+
-+static u32 ieee80211_calc_tx_airtime_rate(struct ieee80211_hw *hw,
-+					  struct ieee80211_tx_rate *rate,
-+					  u8 band, int len)
-+{
-+	struct ieee80211_rx_status stat = {
-+		.band = band,
-+	};
-+
-+	if (rate->idx < 0 || !rate->count)
-+		return 0;
-+
-+	if (rate->flags & IEEE80211_TX_RC_80_MHZ_WIDTH)
-+		stat.bw = RATE_INFO_BW_80;
-+	else if (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
-+		stat.bw = RATE_INFO_BW_40;
-+	else
-+		stat.bw = RATE_INFO_BW_20;
-+
-+	stat.enc_flags = 0;
-+	if (rate->flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)
-+		stat.enc_flags |= RX_ENC_FLAG_SHORTPRE;
-+	if (rate->flags & IEEE80211_TX_RC_SHORT_GI)
-+		stat.enc_flags |= RX_ENC_FLAG_SHORT_GI;
-+
-+	stat.rate_idx = rate->idx;
-+	if (rate->flags & IEEE80211_TX_RC_VHT_MCS) {
-+		stat.encoding = RX_ENC_VHT;
-+		stat.rate_idx = ieee80211_rate_get_vht_mcs(rate);
-+		stat.nss = ieee80211_rate_get_vht_nss(rate);
-+	} else if (rate->flags & IEEE80211_TX_RC_MCS) {
-+		stat.encoding = RX_ENC_HT;
-+	} else {
-+		stat.encoding = RX_ENC_LEGACY;
-+	}
-+
-+	return ieee80211_calc_rx_airtime(hw, &stat, len);
-+}
-+
-+u32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,
-+			      struct ieee80211_tx_info *info,
-+			      int len)
-+{
-+	u32 duration = 0;
-+	int i;
-+
-+	for (i = 0; i < ARRAY_SIZE(info->status.rates); i++) {
-+		struct ieee80211_tx_rate *rate = &info->status.rates[i];
-+		u32 cur_duration;
-+
-+		cur_duration = ieee80211_calc_tx_airtime_rate(hw, rate,
-+							      info->band, len);
-+		if (!cur_duration)
-+			break;
-+
-+		duration += cur_duration * rate->count;
-+	}
-+
-+	return duration;
-+}
-+EXPORT_SYMBOL_GPL(ieee80211_calc_tx_airtime);
-+
-+u32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,
-+				       struct ieee80211_vif *vif,
-+				       struct ieee80211_sta *pubsta,
-+				       int len)
-+{
-+	struct ieee80211_supported_band *sband;
-+	struct ieee80211_chanctx_conf *conf;
-+	int rateidx, shift = 0;
-+	bool cck, short_pream;
-+	u32 basic_rates;
-+	u8 band = 0;
-+	u16 rate;
-+
-+	len += 38; /* Ethernet header length */
-+
-+	conf = rcu_dereference(vif->chanctx_conf);
-+	if (conf) {
-+		band = conf->def.chan->band;
-+		shift = ieee80211_chandef_get_shift(&conf->def);
-+	}
-+
-+	if (pubsta) {
-+		struct sta_info *sta = container_of(pubsta, struct sta_info,
-+						    sta);
-+
-+		return ieee80211_calc_tx_airtime_rate(hw,
-+						      &sta->tx_stats.last_rate,
-+						      band, len);
-+	}
-+
-+	if (!conf)
-+		return 0;
-+
-+	/* No station to get latest rate from, so calculate the worst-case
-+	 * duration using the lowest configured basic rate.
-+	 */
-+	sband = hw->wiphy->bands[band];
-+
-+	basic_rates = vif->bss_conf.basic_rates;
-+	short_pream = vif->bss_conf.use_short_preamble;
-+
-+	rateidx = basic_rates ? ffs(basic_rates) - 1 : 0;
-+	rate = sband->bitrates[rateidx].bitrate << shift;
-+	cck = sband->bitrates[rateidx].flags & IEEE80211_RATE_MANDATORY_B;
-+
-+	return ieee80211_calc_legacy_rate_duration(rate, short_pream, cck, len);
-+}
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -2253,6 +2253,10 @@ const char *ieee80211_get_reason_code_st
- 
- extern const struct ethtool_ops ieee80211_ethtool_ops;
- 
-+u32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,
-+				       struct ieee80211_vif *vif,
-+				       struct ieee80211_sta *pubsta,
-+				       int len);
- #ifdef CPTCFG_MAC80211_NOINLINE
- #define debug_noinline noinline
- #else
diff -uprN a/package/kernel/mac80211/patches/subsys/310-mac80211-Implement-Airtime-based-Queue-Limit-AQL.patch b/package/kernel/mac80211/patches/subsys/310-mac80211-Implement-Airtime-based-Queue-Limit-AQL.patch
--- a/package/kernel/mac80211/patches/subsys/310-mac80211-Implement-Airtime-based-Queue-Limit-AQL.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/310-mac80211-Implement-Airtime-based-Queue-Limit-AQL.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,446 +0,0 @@
-From: Kan Yan <kyan@google.com>
-Date: Mon, 18 Nov 2019 22:06:09 -0800
-Subject: [PATCH] mac80211: Implement Airtime-based Queue Limit (AQL)
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-In order for the Fq_CoDel algorithm integrated in mac80211 layer to operate
-effectively to control excessive queueing latency, the CoDel algorithm
-requires an accurate measure of how long packets stays in the queue, AKA
-sojourn time. The sojourn time measured at the mac80211 layer doesn't
-include queueing latency in the lower layer (firmware/hardware) and CoDel
-expects lower layer to have a short queue. However, most 802.11ac chipsets
-offload tasks such TX aggregation to firmware or hardware, thus have a deep
-lower layer queue.
-
-Without a mechanism to control the lower layer queue size, packets only
-stay in mac80211 layer transiently before being sent to firmware queue.
-As a result, the sojourn time measured by CoDel in the mac80211 layer is
-almost always lower than the CoDel latency target, hence CoDel does little
-to control the latency, even when the lower layer queue causes excessive
-latency.
-
-The Byte Queue Limits (BQL) mechanism is commonly used to address the
-similar issue with wired network interface. However, this method cannot be
-applied directly to the wireless network interface. "Bytes" is not a
-suitable measure of queue depth in the wireless network, as the data rate
-can vary dramatically from station to station in the same network, from a
-few Mbps to over Gbps.
-
-This patch implements an Airtime-based Queue Limit (AQL) to make CoDel work
-effectively with wireless drivers that utilized firmware/hardware
-offloading. AQL allows each txq to release just enough packets to the lower
-layer to form 1-2 large aggregations to keep hardware fully utilized and
-retains the rest of the frames in mac80211 layer to be controlled by the
-CoDel algorithm.
-
-Signed-off-by: Kan Yan <kyan@google.com>
-[ Toke: Keep API to set pending airtime internal, fix nits in commit msg ]
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20191119060610.76681-4-kyan@google.com
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -2603,6 +2603,13 @@ enum wiphy_params_flags {
- 
- #define IEEE80211_DEFAULT_AIRTIME_WEIGHT	256
- 
-+/* The per TXQ device queue limit in airtime */
-+#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L	5000
-+#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H	12000
-+
-+/* The per interface airtime threshold to switch to lower queue limit */
-+#define IEEE80211_AQL_THRESHOLD			24000
-+
- /**
-  * struct cfg80211_pmksa - PMK Security Association
-  *
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -5559,6 +5559,18 @@ void ieee80211_sta_register_airtime(stru
- 				    u32 tx_airtime, u32 rx_airtime);
- 
- /**
-+ * ieee80211_txq_airtime_check - check if a txq can send frame to device
-+ *
-+ * @hw: pointer obtained from ieee80211_alloc_hw()
-+ * @txq: pointer obtained from station or virtual interface
-+ *
-+ * Return true if the AQL's airtime limit has not been reached and the txq can
-+ * continue to send more packets to the device. Otherwise return false.
-+ */
-+bool
-+ieee80211_txq_airtime_check(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
-+
-+/**
-  * ieee80211_iter_keys - iterate keys programmed into the device
-  * @hw: pointer obtained from ieee80211_alloc_hw()
-  * @vif: virtual interface to iterate, may be %NULL for all
---- a/net/mac80211/debugfs.c
-+++ b/net/mac80211/debugfs.c
-@@ -148,6 +148,87 @@ static const struct file_operations aqm_
- 	.llseek = default_llseek,
- };
- 
-+static ssize_t aql_txq_limit_read(struct file *file,
-+				  char __user *user_buf,
-+				  size_t count,
-+				  loff_t *ppos)
-+{
-+	struct ieee80211_local *local = file->private_data;
-+	char buf[400];
-+	int len = 0;
-+
-+	len = scnprintf(buf, sizeof(buf),
-+			"AC	AQL limit low	AQL limit high\n"
-+			"VO	%u		%u\n"
-+			"VI	%u		%u\n"
-+			"BE	%u		%u\n"
-+			"BK	%u		%u\n",
-+			local->aql_txq_limit_low[IEEE80211_AC_VO],
-+			local->aql_txq_limit_high[IEEE80211_AC_VO],
-+			local->aql_txq_limit_low[IEEE80211_AC_VI],
-+			local->aql_txq_limit_high[IEEE80211_AC_VI],
-+			local->aql_txq_limit_low[IEEE80211_AC_BE],
-+			local->aql_txq_limit_high[IEEE80211_AC_BE],
-+			local->aql_txq_limit_low[IEEE80211_AC_BK],
-+			local->aql_txq_limit_high[IEEE80211_AC_BK]);
-+	return simple_read_from_buffer(user_buf, count, ppos,
-+				       buf, len);
-+}
-+
-+static ssize_t aql_txq_limit_write(struct file *file,
-+				   const char __user *user_buf,
-+				   size_t count,
-+				   loff_t *ppos)
-+{
-+	struct ieee80211_local *local = file->private_data;
-+	char buf[100];
-+	size_t len;
-+	u32 ac, q_limit_low, q_limit_high, q_limit_low_old, q_limit_high_old;
-+	struct sta_info *sta;
-+
-+	if (count > sizeof(buf))
-+		return -EINVAL;
-+
-+	if (copy_from_user(buf, user_buf, count))
-+		return -EFAULT;
-+
-+	buf[sizeof(buf) - 1] = 0;
-+	len = strlen(buf);
-+	if (len > 0 && buf[len - 1] == '\n')
-+		buf[len - 1] = 0;
-+
-+	if (sscanf(buf, "%u %u %u", &ac, &q_limit_low, &q_limit_high) != 3)
-+		return -EINVAL;
-+
-+	if (ac >= IEEE80211_NUM_ACS)
-+		return -EINVAL;
-+
-+	q_limit_low_old = local->aql_txq_limit_low[ac];
-+	q_limit_high_old = local->aql_txq_limit_high[ac];
-+
-+	local->aql_txq_limit_low[ac] = q_limit_low;
-+	local->aql_txq_limit_high[ac] = q_limit_high;
-+
-+	mutex_lock(&local->sta_mtx);
-+	list_for_each_entry(sta, &local->sta_list, list) {
-+		/* If a sta has customized queue limits, keep it */
-+		if (sta->airtime[ac].aql_limit_low == q_limit_low_old &&
-+		    sta->airtime[ac].aql_limit_high == q_limit_high_old) {
-+			sta->airtime[ac].aql_limit_low = q_limit_low;
-+			sta->airtime[ac].aql_limit_high = q_limit_high;
-+		}
-+	}
-+	mutex_unlock(&local->sta_mtx);
-+	return count;
-+}
-+
-+static const struct file_operations aql_txq_limit_ops = {
-+	.write = aql_txq_limit_write,
-+	.read = aql_txq_limit_read,
-+	.open = simple_open,
-+	.llseek = default_llseek,
-+};
-+
- static ssize_t force_tx_status_read(struct file *file,
- 				    char __user *user_buf,
- 				    size_t count,
-@@ -441,6 +522,10 @@ void debugfs_hw_add(struct ieee80211_loc
- 	debugfs_create_u16("airtime_flags", 0600,
- 			   phyd, &local->airtime_flags);
- 
-+	DEBUGFS_ADD(aql_txq_limit);
-+	debugfs_create_u32("aql_threshold", 0600,
-+			   phyd, &local->aql_threshold);
-+
- 	statsd = debugfs_create_dir("statistics", phyd);
- 
- 	/* if the dir failed, don't put all the other things into the root! */
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -197,10 +197,12 @@ static ssize_t sta_airtime_read(struct f
- {
- 	struct sta_info *sta = file->private_data;
- 	struct ieee80211_local *local = sta->sdata->local;
--	size_t bufsz = 200;
-+	size_t bufsz = 400;
- 	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
- 	u64 rx_airtime = 0, tx_airtime = 0;
- 	s64 deficit[IEEE80211_NUM_ACS];
-+	u32 q_depth[IEEE80211_NUM_ACS];
-+	u32 q_limit_l[IEEE80211_NUM_ACS], q_limit_h[IEEE80211_NUM_ACS];
- 	ssize_t rv;
- 	int ac;
- 
-@@ -212,19 +214,22 @@ static ssize_t sta_airtime_read(struct f
- 		rx_airtime += sta->airtime[ac].rx_airtime;
- 		tx_airtime += sta->airtime[ac].tx_airtime;
- 		deficit[ac] = sta->airtime[ac].deficit;
-+		q_limit_l[ac] = sta->airtime[ac].aql_limit_low;
-+		q_limit_h[ac] = sta->airtime[ac].aql_limit_high;
- 		spin_unlock_bh(&local->active_txq_lock[ac]);
-+		q_depth[ac] = atomic_read(&sta->airtime[ac].aql_tx_pending);
- 	}
- 
- 	p += scnprintf(p, bufsz + buf - p,
- 		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
--		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
--		rx_airtime,
--		tx_airtime,
--		sta->airtime_weight,
--		deficit[0],
--		deficit[1],
--		deficit[2],
--		deficit[3]);
-+		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n"
-+		"Q depth: VO: %u us VI: %u us BE: %u us BK: %u us\n"
-+		"Q limit[low/high]: VO: %u/%u VI: %u/%u BE: %u/%u BK: %u/%u\n",
-+		rx_airtime, tx_airtime, sta->airtime_weight,
-+		deficit[0], deficit[1], deficit[2], deficit[3],
-+		q_depth[0], q_depth[1], q_depth[2], q_depth[3],
-+		q_limit_l[0], q_limit_h[0], q_limit_l[1], q_limit_h[1],
-+		q_limit_l[2], q_limit_h[2], q_limit_l[3], q_limit_h[3]),
- 
- 	rv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
- 	kfree(buf);
-@@ -236,7 +241,25 @@ static ssize_t sta_airtime_write(struct
- {
- 	struct sta_info *sta = file->private_data;
- 	struct ieee80211_local *local = sta->sdata->local;
--	int ac;
-+	u32 ac, q_limit_l, q_limit_h;
-+	char _buf[100] = {}, *buf = _buf;
-+
-+	if (count > sizeof(_buf))
-+		return -EINVAL;
-+
-+	if (copy_from_user(buf, userbuf, count))
-+		return -EFAULT;
-+
-+	buf[sizeof(_buf) - 1] = '\0';
-+	if (sscanf(buf, "queue limit %u %u %u", &ac, &q_limit_l, &q_limit_h)
-+	    != 3)
-+		return -EINVAL;
-+
-+	if (ac >= IEEE80211_NUM_ACS)
-+		return -EINVAL;
-+
-+	sta->airtime[ac].aql_limit_low = q_limit_l;
-+	sta->airtime[ac].aql_limit_high = q_limit_h;
- 
- 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
- 		spin_lock_bh(&local->active_txq_lock[ac]);
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1142,6 +1142,10 @@ struct ieee80211_local {
- 	u16 schedule_round[IEEE80211_NUM_ACS];
- 
- 	u16 airtime_flags;
-+	u32 aql_txq_limit_low[IEEE80211_NUM_ACS];
-+	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
-+	u32 aql_threshold;
-+	atomic_t aql_total_pending_airtime;
- 
- 	const struct ieee80211_ops *ops;
- 
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -669,8 +669,16 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
- 		INIT_LIST_HEAD(&local->active_txqs[i]);
- 		spin_lock_init(&local->active_txq_lock[i]);
-+		local->aql_txq_limit_low[i] = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L;
-+		local->aql_txq_limit_high[i] =
-+			IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;
- 	}
--	local->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;
-+
-+	local->airtime_flags = AIRTIME_USE_TX |
-+			       AIRTIME_USE_RX |
-+			       AIRTIME_USE_AQL;
-+	local->aql_threshold = IEEE80211_AQL_THRESHOLD;
-+	atomic_set(&local->aql_total_pending_airtime, 0);
- 
- 	INIT_LIST_HEAD(&local->chanctx_list);
- 	mutex_init(&local->chanctx_mtx);
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -411,6 +411,9 @@ struct sta_info *sta_info_alloc(struct i
- 		skb_queue_head_init(&sta->ps_tx_buf[i]);
- 		skb_queue_head_init(&sta->tx_filtered[i]);
- 		sta->airtime[i].deficit = sta->airtime_weight;
-+		atomic_set(&sta->airtime[i].aql_tx_pending, 0);
-+		sta->airtime[i].aql_limit_low = local->aql_txq_limit_low[i];
-+		sta->airtime[i].aql_limit_high = local->aql_txq_limit_high[i];
- 	}
- 
- 	for (i = 0; i < IEEE80211_NUM_TIDS; i++)
-@@ -1908,6 +1911,41 @@ void ieee80211_sta_register_airtime(stru
- }
- EXPORT_SYMBOL(ieee80211_sta_register_airtime);
- 
-+void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
-+					  struct sta_info *sta, u8 ac,
-+					  u16 tx_airtime, bool tx_completed)
-+{
-+	int tx_pending;
-+
-+	if (!tx_completed) {
-+		if (sta)
-+			atomic_add(tx_airtime,
-+				   &sta->airtime[ac].aql_tx_pending);
-+
-+		atomic_add(tx_airtime, &local->aql_total_pending_airtime);
-+		return;
-+	}
-+
-+	if (sta) {
-+		tx_pending = atomic_sub_return(tx_airtime,
-+					       &sta->airtime[ac].aql_tx_pending);
-+		if (WARN_ONCE(tx_pending < 0,
-+			      "STA %pM AC %d txq pending airtime underflow: %u, %u",
-+			      sta->addr, ac, tx_pending, tx_airtime))
-+			atomic_cmpxchg(&sta->airtime[ac].aql_tx_pending,
-+				       tx_pending, 0);
-+	}
-+
-+	tx_pending = atomic_sub_return(tx_airtime,
-+				       &local->aql_total_pending_airtime);
-+	if (WARN_ONCE(tx_pending < 0,
-+		      "Device %s AC %d pending airtime underflow: %u, %u",
-+		      wiphy_name(local->hw.wiphy), ac, tx_pending,
-+		      tx_airtime))
-+		atomic_cmpxchg(&local->aql_total_pending_airtime,
-+			       tx_pending, 0);
-+}
-+
- int sta_info_move_state(struct sta_info *sta,
- 			enum ieee80211_sta_state new_state)
- {
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -127,13 +127,21 @@ enum ieee80211_agg_stop_reason {
- /* Debugfs flags to enable/disable use of RX/TX airtime in scheduler */
- #define AIRTIME_USE_TX		BIT(0)
- #define AIRTIME_USE_RX		BIT(1)
-+#define AIRTIME_USE_AQL		BIT(2)
- 
- struct airtime_info {
- 	u64 rx_airtime;
- 	u64 tx_airtime;
- 	s64 deficit;
-+	atomic_t aql_tx_pending; /* Estimated airtime for frames pending */
-+	u32 aql_limit_low;
-+	u32 aql_limit_high;
- };
- 
-+void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
-+					  struct sta_info *sta, u8 ac,
-+					  u16 tx_airtime, bool tx_completed);
-+
- struct sta_info;
- 
- /**
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3676,7 +3676,8 @@ struct ieee80211_txq *ieee80211_next_txq
- {
- 	struct ieee80211_local *local = hw_to_local(hw);
- 	struct ieee80211_txq *ret = NULL;
--	struct txq_info *txqi = NULL;
-+	struct txq_info *txqi = NULL, *head = NULL;
-+	bool found_eligible_txq = false;
- 
- 	spin_lock_bh(&local->active_txq_lock[ac]);
- 
-@@ -3687,13 +3688,30 @@ struct ieee80211_txq *ieee80211_next_txq
- 	if (!txqi)
- 		goto out;
- 
-+	if (txqi == head) {
-+		if (!found_eligible_txq)
-+			goto out;
-+		else
-+			found_eligible_txq = false;
-+	}
-+
-+	if (!head)
-+		head = txqi;
-+
- 	if (txqi->txq.sta) {
- 		struct sta_info *sta = container_of(txqi->txq.sta,
--						struct sta_info, sta);
-+						    struct sta_info, sta);
-+		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
-+		s64 deficit = sta->airtime[txqi->txq.ac].deficit;
- 
--		if (sta->airtime[txqi->txq.ac].deficit < 0) {
-+		if (aql_check)
-+			found_eligible_txq = true;
-+
-+		if (deficit < 0)
- 			sta->airtime[txqi->txq.ac].deficit +=
- 				sta->airtime_weight;
-+
-+		if (deficit < 0 || !aql_check) {
- 			list_move_tail(&txqi->schedule_order,
- 				       &local->active_txqs[txqi->txq.ac]);
- 			goto begin;
-@@ -3747,6 +3765,33 @@ void __ieee80211_schedule_txq(struct iee
- }
- EXPORT_SYMBOL(__ieee80211_schedule_txq);
- 
-+bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
-+				 struct ieee80211_txq *txq)
-+{
-+	struct sta_info *sta;
-+	struct ieee80211_local *local = hw_to_local(hw);
-+
-+	if (!(local->airtime_flags & AIRTIME_USE_AQL))
-+		return true;
-+
-+	if (!txq->sta)
-+		return true;
-+
-+	sta = container_of(txq->sta, struct sta_info, sta);
-+	if (atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
-+	    sta->airtime[txq->ac].aql_limit_low)
-+		return true;
-+
-+	if (atomic_read(&local->aql_total_pending_airtime) <
-+	    local->aql_threshold &&
-+	    atomic_read(&sta->airtime[txq->ac].aql_tx_pending) <
-+	    sta->airtime[txq->ac].aql_limit_high)
-+		return true;
-+
-+	return false;
-+}
-+EXPORT_SYMBOL(ieee80211_txq_airtime_check);
-+
- bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
- 				struct ieee80211_txq *txq)
- {
diff -uprN a/package/kernel/mac80211/patches/subsys/310-mac80211-minstrel-do-not-sample-rates-3-times-slower.patch b/package/kernel/mac80211/patches/subsys/310-mac80211-minstrel-do-not-sample-rates-3-times-slower.patch
--- a/package/kernel/mac80211/patches/subsys/310-mac80211-minstrel-do-not-sample-rates-3-times-slower.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/310-mac80211-minstrel-do-not-sample-rates-3-times-slower.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,40 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 3 Mar 2018 18:48:58 +0100
+Subject: [PATCH] mac80211: minstrel: do not sample rates 3 times slower than
+ max_prob_rate
+
+These rates are highly unlikely to be used quickly, even if the link
+deteriorates rapidly. This improves throughput in cases where CCK rates
+are not reliable enough to be skipped entirely during sampling.
+Sampling these rates regularly can cost a lot of airtime.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -1004,10 +1004,13 @@ minstrel_get_sample_rate(struct minstrel
+ 		return -1;
+ 
+ 	/*
+-	 * Do not sample if the probability is already higher than 95%
+-	 * to avoid wasting airtime.
++	 * Do not sample if the probability is already higher than 95%,
++	 * or if the rate is 3 times slower than the current max probability
++	 * rate, to avoid wasting airtime.
+ 	 */
+-	if (mrs->prob_ewma > MINSTREL_FRAC(95, 100))
++	sample_dur = minstrel_get_duration(sample_idx);
++	if (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||
++	    minstrel_get_duration(mi->max_prob_rate) * 3 < sample_dur)
+ 		return -1;
+ 
+ 	/*
+@@ -1017,7 +1020,6 @@ minstrel_get_sample_rate(struct minstrel
+ 
+ 	cur_max_tp_streams = minstrel_mcs_groups[tp_rate1 /
+ 		MCS_GROUP_RATES].streams;
+-	sample_dur = minstrel_get_duration(sample_idx);
+ 	if (sample_dur >= minstrel_get_duration(tp_rate2) &&
+ 	    (cur_max_tp_streams - 1 <
+ 	     minstrel_mcs_groups[sample_group].streams ||
diff -uprN a/package/kernel/mac80211/patches/subsys/311-mac80211-Use-Airtime-based-Queue-Limits-AQL-on-packe.patch b/package/kernel/mac80211/patches/subsys/311-mac80211-Use-Airtime-based-Queue-Limits-AQL-on-packe.patch
--- a/package/kernel/mac80211/patches/subsys/311-mac80211-Use-Airtime-based-Queue-Limits-AQL-on-packe.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/311-mac80211-Use-Airtime-based-Queue-Limits-AQL-on-packe.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,146 +0,0 @@
-From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
-Date: Mon, 18 Nov 2019 22:06:10 -0800
-Subject: [PATCH] mac80211: Use Airtime-based Queue Limits (AQL) on packet
- dequeue
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-The previous commit added the ability to throttle stations when they queue
-too much airtime in the hardware. This commit enables the functionality by
-calculating the expected airtime usage of each packet that is dequeued from
-the TXQs in mac80211, and accounting that as pending airtime.
-
-The estimated airtime for each skb is stored in the tx_info, so we can
-subtract the same amount from the running total when the skb is freed or
-recycled. The throttling mechanism relies on this accounting to be
-accurate (i.e., that we are not freeing skbs without subtracting any
-airtime they were accounted for), so we put the subtraction into
-ieee80211_report_used_skb(). As an optimisation, we also subtract the
-airtime on regular TX completion, zeroing out the value stored in the
-packet afterwards, to avoid having to do an expensive lookup of the station
-from the packet data on every packet.
-
-This patch does *not* include any mechanism to wake a throttled TXQ again,
-on the assumption that this will happen anyway as a side effect of whatever
-freed the skb (most commonly a TX completion).
-
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20191119060610.76681-5-kyan@google.com
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1060,6 +1060,22 @@ struct ieee80211_tx_info {
- 	};
- };
- 
-+static inline u16
-+ieee80211_info_set_tx_time_est(struct ieee80211_tx_info *info, u16 tx_time_est)
-+{
-+	/* We only have 10 bits in tx_time_est, so store airtime
-+	 * in increments of 4us and clamp the maximum to 2**12-1
-+	 */
-+	info->tx_time_est = min_t(u16, tx_time_est, 4095) >> 2;
-+	return info->tx_time_est << 2;
-+}
-+
-+static inline u16
-+ieee80211_info_get_tx_time_est(struct ieee80211_tx_info *info)
-+{
-+	return info->tx_time_est << 2;
-+}
-+
- /**
-  * struct ieee80211_tx_status - extended tx staus info for rate control
-  *
---- a/net/mac80211/status.c
-+++ b/net/mac80211/status.c
-@@ -670,12 +670,26 @@ static void ieee80211_report_used_skb(st
- 				      struct sk_buff *skb, bool dropped)
- {
- 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-+	u16 tx_time_est = ieee80211_info_get_tx_time_est(info);
- 	struct ieee80211_hdr *hdr = (void *)skb->data;
- 	bool acked = info->flags & IEEE80211_TX_STAT_ACK;
- 
- 	if (dropped)
- 		acked = false;
- 
-+	if (tx_time_est) {
-+		struct sta_info *sta;
-+
-+		rcu_read_lock();
-+
-+		sta = sta_info_get_by_addrs(local, hdr->addr1, hdr->addr2);
-+		ieee80211_sta_update_pending_airtime(local, sta,
-+						     skb_get_queue_mapping(skb),
-+						     tx_time_est,
-+						     true);
-+		rcu_read_unlock();
-+	}
-+
- 	if (info->flags & IEEE80211_TX_INTFL_MLME_CONN_TX) {
- 		struct ieee80211_sub_if_data *sdata;
- 
-@@ -885,6 +899,7 @@ static void __ieee80211_tx_status(struct
- 	struct ieee80211_bar *bar;
- 	int shift = 0;
- 	int tid = IEEE80211_NUM_TIDS;
-+	u16 tx_time_est;
- 
- 	rates_idx = ieee80211_tx_get_rates(hw, info, &retry_count);
- 
-@@ -996,6 +1011,17 @@ static void __ieee80211_tx_status(struct
- 			ieee80211_sta_register_airtime(&sta->sta, tid,
- 						       info->status.tx_time, 0);
- 
-+		if ((tx_time_est = ieee80211_info_get_tx_time_est(info)) > 0) {
-+			/* Do this here to avoid the expensive lookup of the sta
-+			 * in ieee80211_report_used_skb().
-+			 */
-+			ieee80211_sta_update_pending_airtime(local, sta,
-+							     skb_get_queue_mapping(skb),
-+							     tx_time_est,
-+							     true);
-+			ieee80211_info_set_tx_time_est(info, 0);
-+		}
-+
- 		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
- 			if (acked) {
- 				if (sta->status_stats.lost_packets)
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3553,6 +3553,9 @@ struct sk_buff *ieee80211_tx_dequeue(str
- 
- 	WARN_ON_ONCE(softirq_count() == 0);
- 
-+	if (!ieee80211_txq_airtime_check(hw, txq))
-+		return NULL;
-+
- begin:
- 	spin_lock_bh(&fq->lock);
- 
-@@ -3663,6 +3666,21 @@ begin:
- 	}
- 
- 	IEEE80211_SKB_CB(skb)->control.vif = vif;
-+
-+	if (local->airtime_flags & AIRTIME_USE_AQL) {
-+		u32 airtime;
-+
-+		airtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,
-+							     skb->len);
-+		if (airtime) {
-+			airtime = ieee80211_info_set_tx_time_est(info, airtime);
-+			ieee80211_sta_update_pending_airtime(local, tx.sta,
-+							     txq->ac,
-+							     airtime,
-+							     false);
-+		}
-+	}
-+
- 	return skb;
- 
- out:
diff -uprN a/package/kernel/mac80211/patches/subsys/312-mac80211-airtime-Fix-an-off-by-one-in-ieee80211_calc.patch b/package/kernel/mac80211/patches/subsys/312-mac80211-airtime-Fix-an-off-by-one-in-ieee80211_calc.patch
--- a/package/kernel/mac80211/patches/subsys/312-mac80211-airtime-Fix-an-off-by-one-in-ieee80211_calc.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/312-mac80211-airtime-Fix-an-off-by-one-in-ieee80211_calc.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,31 +0,0 @@
-From: Dan Carpenter <dan.carpenter@oracle.com>
-Date: Tue, 26 Nov 2019 15:09:39 +0300
-Subject: [PATCH] mac80211: airtime: Fix an off by one in
- ieee80211_calc_rx_airtime()
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-This code was copied from mt76 and inherited an off by one bug from
-there.  The > should be >= so that we don't read one element beyond
-the end of the array.
-
-Fixes: db3e1c40cf2f ("mac80211: Import airtime calculation code from mt76")
-Reported-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
-Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20191126120910.ftr4t7me3by32aiz@kili.mountain
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/net/mac80211/airtime.c
-+++ b/net/mac80211/airtime.c
-@@ -442,7 +442,7 @@ u32 ieee80211_calc_rx_airtime(struct iee
- 			return 0;
- 
- 		sband = hw->wiphy->bands[status->band];
--		if (!sband || status->rate_idx > sband->n_bitrates)
-+		if (!sband || status->rate_idx >= sband->n_bitrates)
- 			return 0;
- 
- 		rate = &sband->bitrates[status->rate_idx];
diff -uprN a/package/kernel/mac80211/patches/subsys/312-mac80211-minstrel_ht-add-flag-to-indicate-missing-in.patch b/package/kernel/mac80211/patches/subsys/312-mac80211-minstrel_ht-add-flag-to-indicate-missing-in.patch
--- a/package/kernel/mac80211/patches/subsys/312-mac80211-minstrel_ht-add-flag-to-indicate-missing-in.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/312-mac80211-minstrel_ht-add-flag-to-indicate-missing-in.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,122 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 16 Jan 2019 22:32:12 +0100
+Subject: [PATCH] mac80211: minstrel_ht: add flag to indicate
+ missing/inaccurate tx A-MPDU length
+
+Some hardware (e.g. MediaTek MT7603) cannot report A-MPDU length in tx status
+information. Add support for a flag to indicate that, to allow minstrel_ht
+to use a fixed value in its internal calculation (which gives better results
+than just defaulting to 1).
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -2131,6 +2131,9 @@ struct ieee80211_txq {
+  * @IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP: The driver (or firmware) doesn't
+  *	support QoS NDP for AP probing - that's most likely a driver bug.
+  *
++ * @IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN: Driver does not report accurate A-MPDU
++ *	length in tx status information
++ *
+  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
+  */
+ enum ieee80211_hw_flags {
+@@ -2176,6 +2179,7 @@ enum ieee80211_hw_flags {
+ 	IEEE80211_HW_SUPPORTS_TDLS_BUFFER_STA,
+ 	IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,
+ 	IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,
++	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,
+ 
+ 	/* keep last, obviously */
+ 	NUM_IEEE80211_HW_FLAGS
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -214,6 +214,7 @@ static const char *hw_flag_names[] = {
+ 	FLAG(SUPPORTS_TDLS_BUFFER_STA),
+ 	FLAG(DEAUTH_NEED_MGD_TX_PREP),
+ 	FLAG(DOESNT_SUPPORT_QOS_NDP),
++	FLAG(TX_STATUS_NO_AMPDU_LEN),
+ #undef FLAG
+ };
+ 
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -294,6 +294,15 @@ minstrel_get_ratestats(struct minstrel_h
+ 	return &mi->groups[index / MCS_GROUP_RATES].rates[index % MCS_GROUP_RATES];
+ }
+ 
++static unsigned int
++minstrel_ht_avg_ampdu_len(struct minstrel_ht_sta *mi)
++{
++	if (!mi->avg_ampdu_len)
++		return AVG_AMPDU_SIZE;
++
++	return MINSTREL_TRUNC(mi->avg_ampdu_len);
++}
++
+ /*
+  * Return current throughput based on the average A-MPDU length, taking into
+  * account the expected number of retransmissions and their expected length
+@@ -309,7 +318,7 @@ minstrel_ht_get_tp_avg(struct minstrel_h
+ 		return 0;
+ 
+ 	if (group != MINSTREL_CCK_GROUP)
+-		nsecs = 1000 * mi->overhead / MINSTREL_TRUNC(mi->avg_ampdu_len);
++		nsecs = 1000 * mi->overhead / minstrel_ht_avg_ampdu_len(mi);
+ 
+ 	nsecs += minstrel_mcs_groups[group].duration[rate] <<
+ 		 minstrel_mcs_groups[group].shift;
+@@ -503,8 +512,12 @@ minstrel_ht_update_stats(struct minstrel
+ 	u16 tmp_cck_tp_rate[MAX_THR_RATES], index;
+ 
+ 	if (mi->ampdu_packets > 0) {
+-		mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
+-			MINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets), EWMA_LEVEL);
++		if (!ieee80211_hw_check(mp->hw, TX_STATUS_NO_AMPDU_LEN))
++			mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
++				MINSTREL_FRAC(mi->ampdu_len, mi->ampdu_packets),
++					      EWMA_LEVEL);
++		else
++			mi->avg_ampdu_len = 0;
+ 		mi->ampdu_len = 0;
+ 		mi->ampdu_packets = 0;
+ 	}
+@@ -709,7 +722,9 @@ minstrel_ht_tx_status(void *priv, struct
+ 	mi->ampdu_len += info->status.ampdu_len;
+ 
+ 	if (!mi->sample_wait && !mi->sample_tries && mi->sample_count > 0) {
+-		mi->sample_wait = 16 + 2 * MINSTREL_TRUNC(mi->avg_ampdu_len);
++		int avg_ampdu_len = minstrel_ht_avg_ampdu_len(mi);
++
++		mi->sample_wait = 16 + 2 * avg_ampdu_len;
+ 		mi->sample_tries = 1;
+ 		mi->sample_count--;
+ 	}
+@@ -777,7 +792,7 @@ minstrel_calc_retransmit(struct minstrel
+ 	unsigned int cw = mp->cw_min;
+ 	unsigned int ctime = 0;
+ 	unsigned int t_slot = 9; /* FIXME */
+-	unsigned int ampdu_len = MINSTREL_TRUNC(mi->avg_ampdu_len);
++	unsigned int ampdu_len = minstrel_ht_avg_ampdu_len(mi);
+ 	unsigned int overhead = 0, overhead_rtscts = 0;
+ 
+ 	mrs = minstrel_get_ratestats(mi, index);
+--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
+@@ -163,9 +163,10 @@ minstrel_ht_stats_open(struct inode *ino
+ 			"lookaround %d\n",
+ 			max(0, (int) mi->total_packets - (int) mi->sample_packets),
+ 			mi->sample_packets);
+-	p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
+-		MINSTREL_TRUNC(mi->avg_ampdu_len),
+-		MINSTREL_TRUNC(mi->avg_ampdu_len * 10) % 10);
++	if (mi->avg_ampdu_len)
++		p += sprintf(p, "Average # of aggregated frames per A-MPDU: %d.%d\n",
++			MINSTREL_TRUNC(mi->avg_ampdu_len),
++			MINSTREL_TRUNC(mi->avg_ampdu_len * 10) % 10);
+ 	ms->len = p - ms->buf;
+ 	WARN_ON(ms->len + sizeof(*ms) > 32768);
+ 
diff -uprN a/package/kernel/mac80211/patches/subsys/313-mac80211-Turn-AQL-into-an-NL80211_EXT_FEATURE.patch b/package/kernel/mac80211/patches/subsys/313-mac80211-Turn-AQL-into-an-NL80211_EXT_FEATURE.patch
--- a/package/kernel/mac80211/patches/subsys/313-mac80211-Turn-AQL-into-an-NL80211_EXT_FEATURE.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/313-mac80211-Turn-AQL-into-an-NL80211_EXT_FEATURE.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,253 +0,0 @@
-From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
-Date: Thu, 12 Dec 2019 12:14:37 +0100
-Subject: [PATCH] mac80211: Turn AQL into an NL80211_EXT_FEATURE
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-Instead of just having an airtime flag in debugfs, turn AQL into a proper
-NL80211_EXT_FEATURE, so drivers can turn it on when they are ready, and so
-we also expose the presence of the feature to userspace.
-
-This also has the effect of flipping the default, so drivers have to opt in
-to using AQL instead of getting it by default with TXQs. To keep
-functionality the same as pre-patch, we set this feature for ath10k (which
-is where it is needed the most).
-
-While we're at it, split out the debugfs interface so AQL gets its own
-per-station debugfs file instead of using the 'airtime' file.
-
-[Johannes:]
-This effectively disables AQL for iwlwifi, where it fixes a number of
-issues:
- * TSO in iwlwifi is causing underflows and associated warnings in AQL
- * HE (802.11ax) rates aren't reported properly so at HE rates, AQL could
-   never have a valid estimate (it'd use 6 Mbps instead of up to 2400!)
-
-Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
-Link: https://lore.kernel.org/r/20191212111437.224294-1-toke@redhat.com
-Fixes: 3ace10f5b5ad ("mac80211: Implement Airtime-based Queue Limit (AQL)")
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
----
-
---- a/drivers/net/wireless/ath/ath10k/mac.c
-+++ b/drivers/net/wireless/ath/ath10k/mac.c
-@@ -8870,6 +8870,7 @@ int ath10k_mac_register(struct ath10k *a
- 	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);
- 	wiphy_ext_feature_set(ar->hw->wiphy,
- 			      NL80211_EXT_FEATURE_SET_SCAN_DWELL);
-+	wiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_AQL);
- 
- 	if (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map) ||
- 	    test_bit(WMI_SERVICE_HTT_MGMT_TX_COMP_VALID_FLAGS, ar->wmi.svc_map))
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -5484,6 +5484,10 @@ enum nl80211_feature_flags {
-  * @NL80211_EXT_FEATURE_SAE_OFFLOAD: Device wants to do SAE authentication in
-  *	station mode (SAE password is passed as part of the connect command).
-  *
-+ * @NL80211_EXT_FEATURE_AQL: The driver supports the Airtime Queue Limit (AQL)
-+ *	feature, which prevents bufferbloat by using the expected transmission
-+ *	time to limit the amount of data buffered in the hardware.
-+ *
-  * @NUM_NL80211_EXT_FEATURES: number of extended features.
-  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
-  */
-@@ -5529,6 +5533,8 @@ enum nl80211_ext_feature_index {
- 	NL80211_EXT_FEATURE_EXT_KEY_ID,
- 	NL80211_EXT_FEATURE_STA_TX_PWR,
- 	NL80211_EXT_FEATURE_SAE_OFFLOAD,
-+	NL80211_EXT_FEATURE_VLAN_OFFLOAD,
-+	NL80211_EXT_FEATURE_AQL,
- 
- 	/* add new features before the definition below */
- 	NUM_NL80211_EXT_FEATURES,
---- a/net/mac80211/debugfs_sta.c
-+++ b/net/mac80211/debugfs_sta.c
-@@ -201,8 +201,6 @@ static ssize_t sta_airtime_read(struct f
- 	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
- 	u64 rx_airtime = 0, tx_airtime = 0;
- 	s64 deficit[IEEE80211_NUM_ACS];
--	u32 q_depth[IEEE80211_NUM_ACS];
--	u32 q_limit_l[IEEE80211_NUM_ACS], q_limit_h[IEEE80211_NUM_ACS];
- 	ssize_t rv;
- 	int ac;
- 
-@@ -214,6 +212,56 @@ static ssize_t sta_airtime_read(struct f
- 		rx_airtime += sta->airtime[ac].rx_airtime;
- 		tx_airtime += sta->airtime[ac].tx_airtime;
- 		deficit[ac] = sta->airtime[ac].deficit;
-+		spin_unlock_bh(&local->active_txq_lock[ac]);
-+	}
-+
-+	p += scnprintf(p, bufsz + buf - p,
-+		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
-+		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
-+		rx_airtime, tx_airtime, sta->airtime_weight,
-+		deficit[0], deficit[1], deficit[2], deficit[3]);
-+
-+	rv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
-+	kfree(buf);
-+	return rv;
-+}
-+
-+static ssize_t sta_airtime_write(struct file *file, const char __user *userbuf,
-+				 size_t count, loff_t *ppos)
-+{
-+	struct sta_info *sta = file->private_data;
-+	struct ieee80211_local *local = sta->sdata->local;
-+	int ac;
-+
-+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-+		spin_lock_bh(&local->active_txq_lock[ac]);
-+		sta->airtime[ac].rx_airtime = 0;
-+		sta->airtime[ac].tx_airtime = 0;
-+		sta->airtime[ac].deficit = sta->airtime_weight;
-+		spin_unlock_bh(&local->active_txq_lock[ac]);
-+	}
-+
-+	return count;
-+}
-+STA_OPS_RW(airtime);
-+
-+static ssize_t sta_aql_read(struct file *file, char __user *userbuf,
-+				size_t count, loff_t *ppos)
-+{
-+	struct sta_info *sta = file->private_data;
-+	struct ieee80211_local *local = sta->sdata->local;
-+	size_t bufsz = 400;
-+	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
-+	u32 q_depth[IEEE80211_NUM_ACS];
-+	u32 q_limit_l[IEEE80211_NUM_ACS], q_limit_h[IEEE80211_NUM_ACS];
-+	ssize_t rv;
-+	int ac;
-+
-+	if (!buf)
-+		return -ENOMEM;
-+
-+	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
-+		spin_lock_bh(&local->active_txq_lock[ac]);
- 		q_limit_l[ac] = sta->airtime[ac].aql_limit_low;
- 		q_limit_h[ac] = sta->airtime[ac].aql_limit_high;
- 		spin_unlock_bh(&local->active_txq_lock[ac]);
-@@ -221,12 +269,8 @@ static ssize_t sta_airtime_read(struct f
- 	}
- 
- 	p += scnprintf(p, bufsz + buf - p,
--		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
--		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n"
- 		"Q depth: VO: %u us VI: %u us BE: %u us BK: %u us\n"
- 		"Q limit[low/high]: VO: %u/%u VI: %u/%u BE: %u/%u BK: %u/%u\n",
--		rx_airtime, tx_airtime, sta->airtime_weight,
--		deficit[0], deficit[1], deficit[2], deficit[3],
- 		q_depth[0], q_depth[1], q_depth[2], q_depth[3],
- 		q_limit_l[0], q_limit_h[0], q_limit_l[1], q_limit_h[1],
- 		q_limit_l[2], q_limit_h[2], q_limit_l[3], q_limit_h[3]),
-@@ -236,11 +280,10 @@ static ssize_t sta_airtime_read(struct f
- 	return rv;
- }
- 
--static ssize_t sta_airtime_write(struct file *file, const char __user *userbuf,
-+static ssize_t sta_aql_write(struct file *file, const char __user *userbuf,
- 				 size_t count, loff_t *ppos)
- {
- 	struct sta_info *sta = file->private_data;
--	struct ieee80211_local *local = sta->sdata->local;
- 	u32 ac, q_limit_l, q_limit_h;
- 	char _buf[100] = {}, *buf = _buf;
- 
-@@ -251,7 +294,7 @@ static ssize_t sta_airtime_write(struct
- 		return -EFAULT;
- 
- 	buf[sizeof(_buf) - 1] = '\0';
--	if (sscanf(buf, "queue limit %u %u %u", &ac, &q_limit_l, &q_limit_h)
-+	if (sscanf(buf, "limit %u %u %u", &ac, &q_limit_l, &q_limit_h)
- 	    != 3)
- 		return -EINVAL;
- 
-@@ -261,17 +304,10 @@ static ssize_t sta_airtime_write(struct
- 	sta->airtime[ac].aql_limit_low = q_limit_l;
- 	sta->airtime[ac].aql_limit_high = q_limit_h;
- 
--	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
--		spin_lock_bh(&local->active_txq_lock[ac]);
--		sta->airtime[ac].rx_airtime = 0;
--		sta->airtime[ac].tx_airtime = 0;
--		sta->airtime[ac].deficit = sta->airtime_weight;
--		spin_unlock_bh(&local->active_txq_lock[ac]);
--	}
--
- 	return count;
- }
--STA_OPS_RW(airtime);
-+STA_OPS_RW(aql);
-+
- 
- static ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,
- 					size_t count, loff_t *ppos)
-@@ -1001,6 +1037,10 @@ void ieee80211_sta_debugfs_add(struct st
- 				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
- 		DEBUGFS_ADD(airtime);
- 
-+	if (wiphy_ext_feature_isset(local->hw.wiphy,
-+				    NL80211_EXT_FEATURE_AQL))
-+		DEBUGFS_ADD(aql);
-+
- 	if (sizeof(sta->driver_buffered_tids) == sizeof(u32))
- 		debugfs_create_x32("driver_buffered_tids", 0400,
- 				   sta->debugfs_dir,
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -674,9 +674,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 			IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;
- 	}
- 
--	local->airtime_flags = AIRTIME_USE_TX |
--			       AIRTIME_USE_RX |
--			       AIRTIME_USE_AQL;
-+	local->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;
- 	local->aql_threshold = IEEE80211_AQL_THRESHOLD;
- 	atomic_set(&local->aql_total_pending_airtime, 0);
- 
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -1917,6 +1917,9 @@ void ieee80211_sta_update_pending_airtim
- {
- 	int tx_pending;
- 
-+	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
-+		return;
-+
- 	if (!tx_completed) {
- 		if (sta)
- 			atomic_add(tx_airtime,
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -127,7 +127,6 @@ enum ieee80211_agg_stop_reason {
- /* Debugfs flags to enable/disable use of RX/TX airtime in scheduler */
- #define AIRTIME_USE_TX		BIT(0)
- #define AIRTIME_USE_RX		BIT(1)
--#define AIRTIME_USE_AQL		BIT(2)
- 
- struct airtime_info {
- 	u64 rx_airtime;
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -3667,7 +3667,7 @@ begin:
- 
- 	IEEE80211_SKB_CB(skb)->control.vif = vif;
- 
--	if (local->airtime_flags & AIRTIME_USE_AQL) {
-+	if (wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
- 		u32 airtime;
- 
- 		airtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,
-@@ -3789,7 +3789,7 @@ bool ieee80211_txq_airtime_check(struct
- 	struct sta_info *sta;
- 	struct ieee80211_local *local = hw_to_local(hw);
- 
--	if (!(local->airtime_flags & AIRTIME_USE_AQL))
-+	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
- 		return true;
- 
- 	if (!txq->sta)
diff -uprN a/package/kernel/mac80211/patches/subsys/314-mac80211-minstrel_ht-reduce-unnecessary-rate-probing.patch b/package/kernel/mac80211/patches/subsys/314-mac80211-minstrel_ht-reduce-unnecessary-rate-probing.patch
--- a/package/kernel/mac80211/patches/subsys/314-mac80211-minstrel_ht-reduce-unnecessary-rate-probing.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/314-mac80211-minstrel_ht-reduce-unnecessary-rate-probing.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,42 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 5 Jun 2019 20:42:49 +0200
+Subject: [PATCH] mac80211: minstrel_ht: reduce unnecessary rate probing
+ attempts
+
+On hardware with static fallback tables (e.g. mt76x2), rate probing attempts
+can be very expensive.
+On such devices, avoid sampling rates slower than the per-group max throughput
+rate, based on the assumption that the fallback table will take care of probing
+lower rates within that group if the higher rates fail.
+To make this work, this also fixes a wrong initialization in the previously
+unused per-group sorted rate array.
+To further reduce unnecessary probing attempts, skip duplicate attempts on
+rates slower than the max throughput rate.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -1028,6 +1028,21 @@ minstrel_get_sample_rate(struct minstrel
+ 	    minstrel_get_duration(mi->max_prob_rate) * 3 < sample_dur)
+ 		return -1;
+ 
++
++	/*
++	 * For devices with no configurable multi-rate retry, skip sampling
++	 * below the per-group max throughput rate, and only use one sampling
++	 * attempt per rate
++	 */
++	if (mp->hw->max_rates == 1 &&
++	    (minstrel_get_duration(mg->max_group_tp_rate[0]) < sample_dur ||
++	     mrs->attempts))
++		return -1;
++
++	/* Skip already sampled slow rates */
++	if (sample_dur >= minstrel_get_duration(tp_rate1) && mrs->attempts)
++		return -1;
++
+ 	/*
+ 	 * Make sure that lower rates get sampled only occasionally,
+ 	 * if the link is working perfectly.
diff -uprN a/package/kernel/mac80211/patches/subsys/315-mac80211-minstrel_ht-fix-default-max-throughput-rate.patch b/package/kernel/mac80211/patches/subsys/315-mac80211-minstrel_ht-fix-default-max-throughput-rate.patch
--- a/package/kernel/mac80211/patches/subsys/315-mac80211-minstrel_ht-fix-default-max-throughput-rate.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/315-mac80211-minstrel_ht-fix-default-max-throughput-rate.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,46 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 14 Jun 2019 21:14:22 +0200
+Subject: [PATCH] mac80211: minstrel_ht: fix default max throughput rate
+ indexes
+
+Use the first supported rate instead of 0 (which can be invalid)
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -453,7 +453,7 @@ minstrel_ht_assign_best_tp_rates(struct
+ 	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
+ 	tmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
+ 
+-	if (tmp_cck_tp > tmp_mcs_tp) {
++	if (tmp_cck_tp_rate && tmp_cck_tp > tmp_mcs_tp) {
+ 		for(i = 0; i < MAX_THR_RATES; i++) {
+ 			minstrel_ht_sort_best_tp_rates(mi, tmp_cck_tp_rate[i],
+ 						       tmp_mcs_tp_rate);
+@@ -525,11 +525,19 @@ minstrel_ht_update_stats(struct minstrel
+ 	mi->sample_slow = 0;
+ 	mi->sample_count = 0;
+ 
+-	/* Initialize global rate indexes */
+-	for(j = 0; j < MAX_THR_RATES; j++){
+-		tmp_mcs_tp_rate[j] = 0;
+-		tmp_cck_tp_rate[j] = 0;
+-	}
++	memset(tmp_mcs_tp_rate, 0, sizeof(tmp_mcs_tp_rate));
++	memset(tmp_cck_tp_rate, 0, sizeof(tmp_cck_tp_rate));
++	if (mi->supported[MINSTREL_CCK_GROUP])
++		for (j = 0; j < ARRAY_SIZE(tmp_cck_tp_rate); j++)
++			tmp_cck_tp_rate[j] = MINSTREL_CCK_GROUP * MCS_GROUP_RATES;
++
++	if (mi->supported[MINSTREL_VHT_GROUP_0])
++		index = MINSTREL_VHT_GROUP_0 * MCS_GROUP_RATES;
++	else
++		index = MINSTREL_HT_GROUP_0 * MCS_GROUP_RATES;
++
++	for (j = 0; j < ARRAY_SIZE(tmp_mcs_tp_rate); j++)
++		tmp_mcs_tp_rate[j] = index;
+ 
+ 	/* Find best rate sets within all MCS groups*/
+ 	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
diff -uprN a/package/kernel/mac80211/patches/subsys/316-mac80211-minstrel_ht-improve-rate-probing-for-device.patch b/package/kernel/mac80211/patches/subsys/316-mac80211-minstrel_ht-improve-rate-probing-for-device.patch
--- a/package/kernel/mac80211/patches/subsys/316-mac80211-minstrel_ht-improve-rate-probing-for-device.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/316-mac80211-minstrel_ht-improve-rate-probing-for-device.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,481 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 14 Jun 2019 21:15:47 +0200
+Subject: [PATCH] mac80211: minstrel_ht: improve rate probing for devices
+ with static fallback
+
+On some devices that only support static rate fallback tables sending rate
+control probing packets can be really expensive.
+Probing lower rates can already hurt throughput quite a bit. What hurts even
+more is the fact that on mt76x0/mt76x2, single probing packets can only be
+forced by directing packets at a different internal hardware queue, which
+causes some heavy reordering and extra latency.
+The reordering issue is mainly problematic while pushing lots of packets to
+a particular station. If there is little activity, the overhead of probing is
+neglegible.
+
+The static fallback behavior is designed to pretty much only handle rate
+control algorithms that use only a very limited set of rates on which the
+algorithm switches up/down based on packet error rate.
+
+In order to better support that kind of hardware, this patch implements a
+different approach to rate probing where it switches to a slightly higher rate,
+waits for tx status feedback, then updates the stats and switches back to
+the new max throughput rate. This only triggers above a packet rate of 100
+per stats interval (~50ms).
+For that kind of probing, the code has to reduce the set of probing rates
+a lot more compared to single packet probing, so it uses only one packet
+per MCS group which is either slightly faster, or as close as possible to
+the max throughput rate.
+This allows switching between similar rates with different numbers of
+streams. The algorithm assumes that the hardware will work its way lower
+within an MCS group in case of retransmissions, so that lower rates don't
+have to be probed by the high packets per second rate probing code.
+
+To further reduce the search space, it also does not probe rates with lower
+channel bandwidth than the max throughput rate.
+
+At the moment, these changes will only affect mt76x0/mt76x2.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel.h
++++ b/net/mac80211/rc80211_minstrel.h
+@@ -113,6 +113,7 @@ struct minstrel_sta_info {
+ struct minstrel_priv {
+ 	struct ieee80211_hw *hw;
+ 	bool has_mrr;
++	u32 sample_switch;
+ 	unsigned int cw_min;
+ 	unsigned int cw_max;
+ 	unsigned int max_retry;
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -21,6 +21,8 @@
+ #define AVG_AMPDU_SIZE	16
+ #define AVG_PKT_SIZE	1200
+ 
++#define SAMPLE_SWITCH_THR	100
++
+ /* Number of bits for an average sized packet */
+ #define MCS_NBITS ((AVG_PKT_SIZE * AVG_AMPDU_SIZE) << 3)
+ 
+@@ -56,6 +58,7 @@
+ 	[GROUP_IDX(_streams, _sgi, _ht40)] = {				\
+ 	.streams = _streams,						\
+ 	.shift = _s,							\
++	.bw = _ht40,							\
+ 	.flags =							\
+ 		IEEE80211_TX_RC_MCS |					\
+ 		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+@@ -85,6 +88,7 @@
+ 	[VHT_GROUP_IDX(_streams, _sgi, _bw)] = {			\
+ 	.streams = _streams,						\
+ 	.shift = _s,							\
++	.bw = _bw,							\
+ 	.flags =							\
+ 		IEEE80211_TX_RC_VHT_MCS |				\
+ 		(_sgi ? IEEE80211_TX_RC_SHORT_GI : 0) |			\
+@@ -493,6 +497,133 @@ minstrel_ht_prob_rate_reduce_streams(str
+ 	}
+ }
+ 
++static inline int
++minstrel_get_duration(int index)
++{
++	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
++	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
++	return duration << group->shift;
++}
++
++static bool
++minstrel_ht_probe_group(struct minstrel_ht_sta *mi, const struct mcs_group *tp_group,
++						int tp_idx, const struct mcs_group *group)
++{
++	if (group->bw < tp_group->bw)
++		return false;
++
++	if (group->streams == tp_group->streams)
++		return true;
++
++	if (tp_idx < 4 && group->streams == tp_group->streams - 1)
++		return true;
++
++	return group->streams == tp_group->streams + 1;
++}
++
++static void
++minstrel_ht_find_probe_rates(struct minstrel_ht_sta *mi, u16 *rates, int *n_rates,
++			     bool faster_rate)
++{
++	const struct mcs_group *group, *tp_group;
++	int i, g, max_dur;
++	int tp_idx;
++
++	tp_group = &minstrel_mcs_groups[mi->max_tp_rate[0] / MCS_GROUP_RATES];
++	tp_idx = mi->max_tp_rate[0] % MCS_GROUP_RATES;
++
++	max_dur = minstrel_get_duration(mi->max_tp_rate[0]);
++	if (faster_rate)
++		max_dur -= max_dur / 16;
++
++	for (g = 0; g < MINSTREL_GROUPS_NB; g++) {
++		u16 supported = mi->supported[g];
++
++		if (!supported)
++			continue;
++
++		group = &minstrel_mcs_groups[g];
++		if (!minstrel_ht_probe_group(mi, tp_group, tp_idx, group))
++			continue;
++
++		for (i = 0; supported; supported >>= 1, i++) {
++			int idx;
++
++			if (!(supported & 1))
++				continue;
++
++			if ((group->duration[i] << group->shift) > max_dur)
++				continue;
++
++			idx = g * MCS_GROUP_RATES + i;
++			if (idx == mi->max_tp_rate[0])
++				continue;
++
++			rates[(*n_rates)++] = idx;
++			break;
++		}
++	}
++}
++
++static void
++minstrel_ht_rate_sample_switch(struct minstrel_priv *mp,
++			       struct minstrel_ht_sta *mi)
++{
++	struct minstrel_rate_stats *mrs;
++	u16 rates[MINSTREL_GROUPS_NB];
++	int n_rates = 0;
++	int probe_rate = 0;
++	bool faster_rate;
++	int i;
++	u8 random;
++
++	/*
++	 * Use rate switching instead of probing packets for devices with
++	 * little control over retry fallback behavior
++	 */
++	if (mp->hw->max_rates > 1)
++		return;
++
++	/*
++	 * If the current EWMA prob is >75%, look for a rate that's 6.25%
++	 * faster than the max tp rate.
++	 * If that fails, look again for a rate that is at least as fast
++	 */
++	mrs = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
++	faster_rate = mrs->prob_ewma > MINSTREL_FRAC(75, 100);
++	minstrel_ht_find_probe_rates(mi, rates, &n_rates, faster_rate);
++	if (!n_rates && faster_rate)
++		minstrel_ht_find_probe_rates(mi, rates, &n_rates, false);
++
++	/* If no suitable rate was found, try to pick the next one in the group */
++	if (!n_rates) {
++		int g_idx = mi->max_tp_rate[0] / MCS_GROUP_RATES;
++		u16 supported = mi->supported[g_idx];
++
++		supported >>= mi->max_tp_rate[0] % MCS_GROUP_RATES;
++		for (i = 0; supported; i++) {
++			if (!(supported & 1))
++				continue;
++
++			probe_rate = mi->max_tp_rate[0] + i;
++			goto out;
++		}
++
++		return;
++	}
++
++	i = 0;
++	if (n_rates > 1) {
++		random = prandom_u32();
++		i = random % n_rates;
++	}
++	probe_rate = rates[i];
++
++out:
++	mi->sample_rate = probe_rate;
++	mi->sample_mode = MINSTREL_SAMPLE_ACTIVE;
++}
++
+ /*
+  * Update rate statistics and select new primary rates
+  *
+@@ -503,7 +634,8 @@ minstrel_ht_prob_rate_reduce_streams(str
+  *    higher throughput rates, even if the probablity is a bit lower
+  */
+ static void
+-minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
++minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
++			 bool sample)
+ {
+ 	struct minstrel_mcs_group_data *mg;
+ 	struct minstrel_rate_stats *mrs;
+@@ -511,6 +643,18 @@ minstrel_ht_update_stats(struct minstrel
+ 	u16 tmp_mcs_tp_rate[MAX_THR_RATES], tmp_group_tp_rate[MAX_THR_RATES];
+ 	u16 tmp_cck_tp_rate[MAX_THR_RATES], index;
+ 
++	mi->sample_mode = MINSTREL_SAMPLE_IDLE;
++
++	if (sample) {
++		mi->total_packets_cur = mi->total_packets -
++					mi->total_packets_last;
++		mi->total_packets_last = mi->total_packets;
++	}
++	if (!mp->sample_switch)
++		sample = false;
++	if (mi->total_packets_cur < SAMPLE_SWITCH_THR && mp->sample_switch != 1)
++	    sample = false;
++
+ 	if (mi->ampdu_packets > 0) {
+ 		if (!ieee80211_hw_check(mp->hw, TX_STATUS_NO_AMPDU_LEN))
+ 			mi->avg_ampdu_len = minstrel_ewma(mi->avg_ampdu_len,
+@@ -597,12 +741,16 @@ minstrel_ht_update_stats(struct minstrel
+ 	/* try to sample all available rates during each interval */
+ 	mi->sample_count *= 8;
+ 
++	if (sample)
++		minstrel_ht_rate_sample_switch(mp, mi);
++
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+ 	/* use fixed index if set */
+ 	if (mp->fixed_rate_idx != -1) {
+ 		for (i = 0; i < 4; i++)
+ 			mi->max_tp_rate[i] = mp->fixed_rate_idx;
+ 		mi->max_prob_rate = mp->fixed_rate_idx;
++		mi->sample_mode = MINSTREL_SAMPLE_IDLE;
+ 	}
+ #endif
+ 
+@@ -706,15 +854,17 @@ minstrel_ht_tx_status(void *priv, struct
+ 	struct minstrel_ht_sta_priv *msp = priv_sta;
+ 	struct minstrel_ht_sta *mi = &msp->ht;
+ 	struct ieee80211_tx_rate *ar = info->status.rates;
+-	struct minstrel_rate_stats *rate, *rate2;
++	struct minstrel_rate_stats *rate, *rate2, *rate_sample = NULL;
+ 	struct minstrel_priv *mp = priv;
+ 	bool last, update = false;
++	bool sample_status = false;
+ 	int i;
+ 
+ 	if (!msp->is_ht)
+ 		return mac80211_minstrel.tx_status_ext(priv, sband,
+ 						       &msp->legacy, st);
+ 
++
+ 	/* This packet was aggregated but doesn't carry status info */
+ 	if ((info->flags & IEEE80211_TX_CTL_AMPDU) &&
+ 	    !(info->flags & IEEE80211_TX_STAT_AMPDU))
+@@ -740,12 +890,17 @@ minstrel_ht_tx_status(void *priv, struct
+ 	if (info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE)
+ 		mi->sample_packets += info->status.ampdu_len;
+ 
++	if (mi->sample_mode != MINSTREL_SAMPLE_IDLE)
++		rate_sample = minstrel_get_ratestats(mi, mi->sample_rate);
++
+ 	last = !minstrel_ht_txstat_valid(mp, &ar[0]);
+ 	for (i = 0; !last; i++) {
+ 		last = (i == IEEE80211_TX_MAX_RATES - 1) ||
+ 		       !minstrel_ht_txstat_valid(mp, &ar[i + 1]);
+ 
+ 		rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
++		if (rate == rate_sample)
++			sample_status = true;
+ 
+ 		if (last)
+ 			rate->success += info->status.ampdu_ack_len;
+@@ -753,44 +908,60 @@ minstrel_ht_tx_status(void *priv, struct
+ 		rate->attempts += ar[i].count * info->status.ampdu_len;
+ 	}
+ 
+-	/*
+-	 * check for sudden death of spatial multiplexing,
+-	 * downgrade to a lower number of streams if necessary.
+-	 */
+-	rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
+-	if (rate->attempts > 30 &&
+-	    MINSTREL_FRAC(rate->success, rate->attempts) <
+-	    MINSTREL_FRAC(20, 100)) {
+-		minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
++	switch (mi->sample_mode) {
++	case MINSTREL_SAMPLE_IDLE:
++		break;
++
++	case MINSTREL_SAMPLE_ACTIVE:
++		if (!sample_status)
++			break;
++
++		mi->sample_mode = MINSTREL_SAMPLE_PENDING;
+ 		update = true;
+-	}
++		break;
++
++	case MINSTREL_SAMPLE_PENDING:
++		if (sample_status)
++			break;
+ 
+-	rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
+-	if (rate2->attempts > 30 &&
+-	    MINSTREL_FRAC(rate2->success, rate2->attempts) <
+-	    MINSTREL_FRAC(20, 100)) {
+-		minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
+ 		update = true;
++		minstrel_ht_update_stats(mp, mi, false);
++		break;
++	}
++
++
++	if (mp->hw->max_rates > 1) {
++		/*
++		 * check for sudden death of spatial multiplexing,
++		 * downgrade to a lower number of streams if necessary.
++		 */
++		rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
++		if (rate->attempts > 30 &&
++		    MINSTREL_FRAC(rate->success, rate->attempts) <
++		    MINSTREL_FRAC(20, 100)) {
++			minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
++			update = true;
++		}
++
++		rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
++		if (rate2->attempts > 30 &&
++		    MINSTREL_FRAC(rate2->success, rate2->attempts) <
++		    MINSTREL_FRAC(20, 100)) {
++			minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
++			update = true;
++		}
+ 	}
+ 
+ 	if (time_after(jiffies, mi->last_stats_update +
+ 				(mp->update_interval / 2 * HZ) / 1000)) {
+ 		update = true;
+-		minstrel_ht_update_stats(mp, mi);
++		minstrel_ht_update_stats(mp, mi, true);
+ 	}
+ 
+ 	if (update)
+ 		minstrel_ht_update_rates(mp, mi);
+ }
+ 
+-static inline int
+-minstrel_get_duration(int index)
+-{
+-	const struct mcs_group *group = &minstrel_mcs_groups[index / MCS_GROUP_RATES];
+-	unsigned int duration = group->duration[index % MCS_GROUP_RATES];
+-	return duration << group->shift;
+-}
+-
+ static void
+ minstrel_calc_retransmit(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+                          int index)
+@@ -955,14 +1126,18 @@ static void
+ minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+ {
+ 	struct ieee80211_sta_rates *rates;
++	u16 first_rate = mi->max_tp_rate[0];
+ 	int i = 0;
+ 
++	if (mi->sample_mode == MINSTREL_SAMPLE_ACTIVE)
++		first_rate = mi->sample_rate;
++
+ 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
+ 	if (!rates)
+ 		return;
+ 
+ 	/* Start with max_tp_rate[0] */
+-	minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);
++	minstrel_ht_set_rate(mp, mi, rates, i++, first_rate);
+ 
+ 	if (mp->hw->max_rates >= 3) {
+ 		/* At least 3 tx rates supported, use max_tp_rate[1] next */
+@@ -989,6 +1164,11 @@ minstrel_get_sample_rate(struct minstrel
+ 	int tp_rate1, tp_rate2;
+ 	int sample_idx = 0;
+ 
++	if (mp->hw->max_rates == 1 && mp->sample_switch &&
++	    (mi->total_packets_cur >= SAMPLE_SWITCH_THR ||
++	     mp->sample_switch == 1))
++		return -1;
++
+ 	if (mi->sample_wait > 0) {
+ 		mi->sample_wait--;
+ 		return -1;
+@@ -1315,7 +1495,7 @@ minstrel_ht_update_caps(void *priv, stru
+ 	mi->supported[MINSTREL_CCK_GROUP] |= mi->cck_supported_short << 4;
+ 
+ 	/* create an initial rate table with the lowest supported rates */
+-	minstrel_ht_update_stats(mp, mi);
++	minstrel_ht_update_stats(mp, mi, true);
+ 	minstrel_ht_update_rates(mp, mi);
+ 
+ 	return;
+@@ -1433,6 +1613,8 @@ minstrel_ht_alloc(struct ieee80211_hw *h
+ 	if (!mp)
+ 		return NULL;
+ 
++	mp->sample_switch = -1;
++
+ 	/* contention window settings
+ 	 * Just an approximation. Using the per-queue values would complicate
+ 	 * the calculations and is probably unnecessary */
+@@ -1464,6 +1646,8 @@ minstrel_ht_alloc(struct ieee80211_hw *h
+ 	mp->fixed_rate_idx = (u32) -1;
+ 	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
+ 			   &mp->fixed_rate_idx);
++	debugfs_create_u32("sample_switch", S_IRUGO | S_IWUSR, debugfsdir,
++			   &mp->sample_switch);
+ #endif
+ 
+ 	minstrel_ht_init_cck_rates(mp);
+--- a/net/mac80211/rc80211_minstrel_ht.h
++++ b/net/mac80211/rc80211_minstrel_ht.h
+@@ -36,6 +36,7 @@ struct mcs_group {
+ 	u16 flags;
+ 	u8 streams;
+ 	u8 shift;
++	u8 bw;
+ 	u16 duration[MCS_GROUP_RATES];
+ };
+ 
+@@ -53,6 +54,12 @@ struct minstrel_mcs_group_data {
+ 	struct minstrel_rate_stats rates[MCS_GROUP_RATES];
+ };
+ 
++enum minstrel_sample_mode {
++	MINSTREL_SAMPLE_IDLE,
++	MINSTREL_SAMPLE_ACTIVE,
++	MINSTREL_SAMPLE_PENDING,
++};
++
+ struct minstrel_ht_sta {
+ 	struct ieee80211_sta *sta;
+ 
+@@ -74,6 +81,8 @@ struct minstrel_ht_sta {
+ 	unsigned int overhead;
+ 	unsigned int overhead_rtscts;
+ 
++	unsigned int total_packets_last;
++	unsigned int total_packets_cur;
+ 	unsigned int total_packets;
+ 	unsigned int sample_packets;
+ 
+@@ -85,6 +94,9 @@ struct minstrel_ht_sta {
+ 	u8 sample_count;
+ 	u8 sample_slow;
+ 
++	enum minstrel_sample_mode sample_mode;
++	u16 sample_rate;
++
+ 	/* current MCS group to be sampled */
+ 	u8 sample_group;
+ 
diff -uprN a/package/kernel/mac80211/patches/subsys/317-mac80211-minstrel_ht-fix-infinite-loop-because-suppo.patch b/package/kernel/mac80211/patches/subsys/317-mac80211-minstrel_ht-fix-infinite-loop-because-suppo.patch
--- a/package/kernel/mac80211/patches/subsys/317-mac80211-minstrel_ht-fix-infinite-loop-because-suppo.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/317-mac80211-minstrel_ht-fix-infinite-loop-because-suppo.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,25 @@
+From: Colin Ian King <colin.king@canonical.com>
+Date: Thu, 22 Aug 2019 13:20:34 +0100
+Subject: [PATCH] mac80211: minstrel_ht: fix infinite loop because supported is
+ not being shifted
+
+Currently the for-loop will spin forever if variable supported is
+non-zero because supported is never changed.  Fix this by adding in
+the missing right shift of supported.
+
+Addresses-Coverity: ("Infinite loop")
+Fixes: 48cb39522a9d ("mac80211: minstrel_ht: improve rate probing for devices with static fallback")
+Signed-off-by: Colin Ian King <colin.king@canonical.com>
+---
+
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -601,7 +601,7 @@ minstrel_ht_rate_sample_switch(struct mi
+ 		u16 supported = mi->supported[g_idx];
+ 
+ 		supported >>= mi->max_tp_rate[0] % MCS_GROUP_RATES;
+-		for (i = 0; supported; i++) {
++		for (i = 0; supported; supported >>= 1, i++) {
+ 			if (!(supported & 1))
+ 				continue;
+ 
diff -uprN a/package/kernel/mac80211/patches/subsys/320-mac80211-Add-TXQ-scheduling-API.patch b/package/kernel/mac80211/patches/subsys/320-mac80211-Add-TXQ-scheduling-API.patch
--- a/package/kernel/mac80211/patches/subsys/320-mac80211-Add-TXQ-scheduling-API.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/320-mac80211-Add-TXQ-scheduling-API.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,292 @@
+From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@toke.dk>
+Date: Tue, 18 Dec 2018 17:02:06 -0800
+Subject: [PATCH] mac80211: Add TXQ scheduling API
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds an API to mac80211 to handle scheduling of TXQs. The interface
+between driver and mac80211 for TXQ handling is changed by adding two new
+functions: ieee80211_next_txq(), which will return the next TXQ to schedule
+in the current round-robin rotation, and ieee80211_return_txq(), which the
+driver uses to indicate that it has finished scheduling a TXQ (which will
+then be put back in the scheduling rotation if it isn't empty).
+
+The driver must call ieee80211_txq_schedule_start() at the start of each
+scheduling session, and ieee80211_txq_schedule_end() at the end. The API
+then guarantees that the same TXQ is not returned twice in the same
+session (so a driver can loop on ieee80211_next_txq() without worrying
+about breaking the loop.
+
+Usage of the new API is optional, so drivers can be ported one at a time.
+In this patch, the actual scheduling performed by mac80211 is simple
+round-robin, but a subsequent commit adds airtime fairness awareness to the
+scheduler.
+
+Signed-off-by: Toke Høiland-Jørgensen <toke@toke.dk>
+[minor kernel-doc fix, propagate sparse locking checks out]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -107,9 +107,15 @@
+  * The driver is expected to initialize its private per-queue data for stations
+  * and interfaces in the .add_interface and .sta_add ops.
+  *
+- * The driver can't access the queue directly. To dequeue a frame, it calls
+- * ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a queue, it
+- * calls the .wake_tx_queue driver op.
++ * The driver can't access the queue directly. To dequeue a frame from a
++ * txq, it calls ieee80211_tx_dequeue(). Whenever mac80211 adds a new frame to a
++ * queue, it calls the .wake_tx_queue driver op.
++ *
++ * Drivers can optionally delegate responsibility for scheduling queues to
++ * mac80211, to take advantage of airtime fairness accounting. In this case, to
++ * obtain the next queue to pull frames from, the driver calls
++ * ieee80211_next_txq(). The driver is then expected to return the txq using
++ * ieee80211_return_txq().
+  *
+  * For AP powersave TIM handling, the driver only needs to indicate if it has
+  * buffered packets in the driver specific data structures by calling
+@@ -5979,7 +5985,8 @@ void ieee80211_unreserve_tid(struct ieee
+  * ieee80211_tx_dequeue - dequeue a packet from a software tx queue
+  *
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+- * @txq: pointer obtained from station or virtual interface
++ * @txq: pointer obtained from station or virtual interface, or from
++ *	ieee80211_next_txq()
+  *
+  * Returns the skb if successful, %NULL if no frame was available.
+  */
+@@ -5987,6 +5994,54 @@ struct sk_buff *ieee80211_tx_dequeue(str
+ 				     struct ieee80211_txq *txq);
+ 
+ /**
++ * ieee80211_next_txq - get next tx queue to pull packets from
++ *
++ * @hw: pointer as obtained from ieee80211_alloc_hw()
++ * @ac: AC number to return packets from.
++ *
++ * Should only be called between calls to ieee80211_txq_schedule_start()
++ * and ieee80211_txq_schedule_end().
++ * Returns the next txq if successful, %NULL if no queue is eligible. If a txq
++ * is returned, it should be returned with ieee80211_return_txq() after the
++ * driver has finished scheduling it.
++ */
++struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);
++
++/**
++ * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
++ *
++ * @hw: pointer as obtained from ieee80211_alloc_hw()
++ * @txq: pointer obtained from station or virtual interface
++ *
++ * Should only be called between calls to ieee80211_txq_schedule_start()
++ * and ieee80211_txq_schedule_end().
++ */
++void ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
++
++/**
++ * ieee80211_txq_schedule_start - acquire locks for safe scheduling of an AC
++ *
++ * @hw: pointer as obtained from ieee80211_alloc_hw()
++ * @ac: AC number to acquire locks for
++ *
++ * Acquire locks needed to schedule TXQs from the given AC. Should be called
++ * before ieee80211_next_txq() or ieee80211_return_txq().
++ */
++void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
++	__acquires(txq_lock);
++
++/**
++ * ieee80211_txq_schedule_end - release locks for safe scheduling of an AC
++ *
++ * @hw: pointer as obtained from ieee80211_alloc_hw()
++ * @ac: AC number to acquire locks for
++ *
++ * Release locks previously acquired by ieee80211_txq_schedule_end().
++ */
++void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)
++	__releases(txq_lock);
++
++/**
+  * ieee80211_txq_get_depth - get pending frame/byte count of given txq
+  *
+  * The values are not guaranteed to be coherent with regard to each other, i.e.
+--- a/net/mac80211/agg-tx.c
++++ b/net/mac80211/agg-tx.c
+@@ -229,7 +229,7 @@ ieee80211_agg_start_txq(struct sta_info
+ 	clear_bit(IEEE80211_TXQ_STOP, &txqi->flags);
+ 	local_bh_disable();
+ 	rcu_read_lock();
+-	drv_wake_tx_queue(sta->sdata->local, txqi);
++	schedule_and_wake_txq(sta->sdata->local, txqi);
+ 	rcu_read_unlock();
+ 	local_bh_enable();
+ }
+--- a/net/mac80211/driver-ops.h
++++ b/net/mac80211/driver-ops.h
+@@ -1176,6 +1176,15 @@ static inline void drv_wake_tx_queue(str
+ 	local->ops->wake_tx_queue(&local->hw, &txq->txq);
+ }
+ 
++static inline void schedule_and_wake_txq(struct ieee80211_local *local,
++					 struct txq_info *txqi)
++{
++	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
++	ieee80211_return_txq(&local->hw, &txqi->txq);
++	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
++	drv_wake_tx_queue(local, txqi);
++}
++
+ static inline int drv_start_nan(struct ieee80211_local *local,
+ 				struct ieee80211_sub_if_data *sdata,
+ 				struct cfg80211_nan_conf *conf)
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -818,6 +818,8 @@ enum txq_info_flags {
+  *	a fq_flow which is already owned by a different tin
+  * @def_cvars: codel vars for @def_flow
+  * @frags: used to keep fragments created after dequeue
++ * @schedule_order: used with ieee80211_local->active_txqs
++ * @schedule_round: counter to prevent infinite loops on TXQ scheduling
+  */
+ struct txq_info {
+ 	struct fq_tin tin;
+@@ -825,6 +827,8 @@ struct txq_info {
+ 	struct codel_vars def_cvars;
+ 	struct codel_stats cstats;
+ 	struct sk_buff_head frags;
++	struct list_head schedule_order;
++	u16 schedule_round;
+ 	unsigned long flags;
+ 
+ 	/* keep last! */
+@@ -1115,6 +1119,11 @@ struct ieee80211_local {
+ 	struct codel_vars *cvars;
+ 	struct codel_params cparams;
+ 
++	/* protects active_txqs and txqi->schedule_order */
++	spinlock_t active_txq_lock[IEEE80211_NUM_ACS];
++	struct list_head active_txqs[IEEE80211_NUM_ACS];
++	u16 schedule_round[IEEE80211_NUM_ACS];
++
+ 	const struct ieee80211_ops *ops;
+ 
+ 	/*
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -652,6 +652,11 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 	spin_lock_init(&local->rx_path_lock);
+ 	spin_lock_init(&local->queue_stop_reason_lock);
+ 
++	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
++		INIT_LIST_HEAD(&local->active_txqs[i]);
++		spin_lock_init(&local->active_txq_lock[i]);
++	}
++
+ 	INIT_LIST_HEAD(&local->chanctx_list);
+ 	mutex_init(&local->chanctx_mtx);
+ 
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -1265,7 +1265,7 @@ void ieee80211_sta_ps_deliver_wakeup(str
+ 			if (!txq_has_queue(sta->sta.txq[i]))
+ 				continue;
+ 
+-			drv_wake_tx_queue(local, to_txq_info(sta->sta.txq[i]));
++			schedule_and_wake_txq(local, to_txq_info(sta->sta.txq[i]));
+ 		}
+ 	}
+ 
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -1441,6 +1441,7 @@ void ieee80211_txq_init(struct ieee80211
+ 	codel_vars_init(&txqi->def_cvars);
+ 	codel_stats_init(&txqi->cstats);
+ 	__skb_queue_head_init(&txqi->frags);
++	INIT_LIST_HEAD(&txqi->schedule_order);
+ 
+ 	txqi->txq.vif = &sdata->vif;
+ 
+@@ -1464,6 +1465,9 @@ void ieee80211_txq_purge(struct ieee8021
+ 
+ 	fq_tin_reset(fq, tin, fq_skb_free_func);
+ 	ieee80211_purge_tx_queue(&local->hw, &txqi->frags);
++	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
++	list_del_init(&txqi->schedule_order);
++	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
+ }
+ 
+ void ieee80211_txq_set_params(struct ieee80211_local *local)
+@@ -1580,7 +1584,7 @@ static bool ieee80211_queue_skb(struct i
+ 	ieee80211_txq_enqueue(local, txqi, skb);
+ 	spin_unlock_bh(&fq->lock);
+ 
+-	drv_wake_tx_queue(local, txqi);
++	schedule_and_wake_txq(local, txqi);
+ 
+ 	return true;
+ }
+@@ -3631,6 +3635,60 @@ out:
+ }
+ EXPORT_SYMBOL(ieee80211_tx_dequeue);
+ 
++struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++	struct txq_info *txqi = NULL;
++
++	lockdep_assert_held(&local->active_txq_lock[ac]);
++
++	txqi = list_first_entry_or_null(&local->active_txqs[ac],
++					struct txq_info,
++					schedule_order);
++
++	if (!txqi || txqi->schedule_round == local->schedule_round[ac])
++		return NULL;
++
++	list_del_init(&txqi->schedule_order);
++	txqi->schedule_round = local->schedule_round[ac];
++	return &txqi->txq;
++}
++EXPORT_SYMBOL(ieee80211_next_txq);
++
++void ieee80211_return_txq(struct ieee80211_hw *hw,
++			  struct ieee80211_txq *txq)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++	struct txq_info *txqi = to_txq_info(txq);
++
++	lockdep_assert_held(&local->active_txq_lock[txq->ac]);
++
++	if (list_empty(&txqi->schedule_order) &&
++	    (!skb_queue_empty(&txqi->frags) || txqi->tin.backlog_packets))
++		list_add_tail(&txqi->schedule_order,
++			      &local->active_txqs[txq->ac]);
++}
++EXPORT_SYMBOL(ieee80211_return_txq);
++
++void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
++	__acquires(txq_lock)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++
++	spin_lock_bh(&local->active_txq_lock[ac]);
++	local->schedule_round[ac]++;
++}
++EXPORT_SYMBOL(ieee80211_txq_schedule_start);
++
++void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)
++	__releases(txq_lock)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++
++	spin_unlock_bh(&local->active_txq_lock[ac]);
++}
++EXPORT_SYMBOL(ieee80211_txq_schedule_end);
++
+ void __ieee80211_subif_start_xmit(struct sk_buff *skb,
+ 				  struct net_device *dev,
+ 				  u32 info_flags,
diff -uprN a/package/kernel/mac80211/patches/subsys/321-cfg80211-Add-airtime-statistics-and-settings.patch b/package/kernel/mac80211/patches/subsys/321-cfg80211-Add-airtime-statistics-and-settings.patch
--- a/package/kernel/mac80211/patches/subsys/321-cfg80211-Add-airtime-statistics-and-settings.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/321-cfg80211-Add-airtime-statistics-and-settings.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,202 @@
+From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@toke.dk>
+Date: Tue, 18 Dec 2018 17:02:07 -0800
+Subject: [PATCH] cfg80211: Add airtime statistics and settings
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds TX airtime statistics to the cfg80211 station dump (to go along
+with the RX info already present), and adds a new parameter to set the
+airtime weight of each station. The latter allows userspace to implement
+policies for different stations by varying their weights.
+
+Signed-off-by: Toke Høiland-Jørgensen <toke@toke.dk>
+[rmanohar@codeaurora.org: fixed checkpatch warnings]
+Signed-off-by: Rajkumar Manoharan <rmanohar@codeaurora.org>
+[move airtime weight != 0 check into policy]
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -988,6 +988,7 @@ enum station_parameters_apply_mask {
+  * @support_p2p_ps: information if station supports P2P PS mechanism
+  * @he_capa: HE capabilities of station
+  * @he_capa_len: the length of the HE capabilities
++ * @airtime_weight: airtime scheduler weight for this station
+  */
+ struct station_parameters {
+ 	const u8 *supported_rates;
+@@ -1017,6 +1018,7 @@ struct station_parameters {
+ 	int support_p2p_ps;
+ 	const struct ieee80211_he_cap_elem *he_capa;
+ 	u8 he_capa_len;
++	u16 airtime_weight;
+ };
+ 
+ /**
+@@ -1284,6 +1286,8 @@ struct cfg80211_tid_stats {
+  * @rx_beacon_signal_avg: signal strength average (in dBm) for beacons received
+  *	from this peer
+  * @rx_duration: aggregate PPDU duration(usecs) for all the frames from a peer
++ * @tx_duration: aggregate PPDU duration(usecs) for all the frames to a peer
++ * @airtime_weight: current airtime scheduling weight
+  * @pertid: per-TID statistics, see &struct cfg80211_tid_stats, using the last
+  *	(IEEE80211_NUM_TIDS) index for MSDUs not encapsulated in QoS-MPDUs.
+  *	Note that this doesn't use the @filled bit, but is used if non-NULL.
+@@ -1330,12 +1334,15 @@ struct station_info {
+ 
+ 	u32 expected_throughput;
+ 
+-	u64 rx_beacon;
++	u64 tx_duration;
+ 	u64 rx_duration;
++	u64 rx_beacon;
+ 	u8 rx_beacon_signal_avg;
+ 	struct cfg80211_tid_stats *pertid;
+ 	s8 ack_signal;
+ 	s8 avg_ack_signal;
++
++	u16 airtime_weight;
+ };
+ 
+ #if IS_ENABLED(CPTCFG_CFG80211)
+@@ -2361,6 +2368,8 @@ enum wiphy_params_flags {
+ 	WIPHY_PARAM_TXQ_QUANTUM		= 1 << 8,
+ };
+ 
++#define IEEE80211_DEFAULT_AIRTIME_WEIGHT	256
++
+ /**
+  * struct cfg80211_pmksa - PMK Security Association
+  *
+--- a/include/uapi/linux/nl80211.h
++++ b/include/uapi/linux/nl80211.h
+@@ -2241,6 +2241,9 @@ enum nl80211_commands {
+  *	association request when used with NL80211_CMD_NEW_STATION). Can be set
+  *	only if %NL80211_STA_FLAG_WME is set.
+  *
++ * @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime
++ *	scheduler.
++ *
+  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
+  * @NL80211_ATTR_MAX: highest attribute number currently defined
+  * @__NL80211_ATTR_AFTER_LAST: internal use
+@@ -2682,6 +2685,14 @@ enum nl80211_attrs {
+ 
+ 	NL80211_ATTR_HE_CAPABILITY,
+ 
++	/* not backported yet */
++	NL80211_ATTR_FTM_RESPONDER,
++	NL80211_ATTR_FTM_RESPONDER_STATS,
++	NL80211_ATTR_TIMEOUT,
++	NL80211_ATTR_PEER_MEASUREMENTS,
++
++	NL80211_ATTR_AIRTIME_WEIGHT,
++
+ 	/* add attributes here, update the policy in nl80211.c */
+ 
+ 	__NL80211_ATTR_AFTER_LAST,
+@@ -3052,6 +3063,9 @@ enum nl80211_sta_bss_param {
+  * @NL80211_STA_INFO_ACK_SIGNAL: signal strength of the last ACK frame(u8, dBm)
+  * @NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG: avg signal strength of (data)
+  *	ACK frame (s8, dBm)
++ * @NL80211_STA_INFO_TX_DURATION: aggregate PPDU duration for all frames
++ *	sent to the station (u64, usec)
++ * @NL80211_STA_INFO_AIRTIME_WEIGHT: current airtime weight for station (u16)
+  * @__NL80211_STA_INFO_AFTER_LAST: internal
+  * @NL80211_STA_INFO_MAX: highest possible station info attribute
+  */
+@@ -3093,6 +3107,14 @@ enum nl80211_sta_info {
+ 	NL80211_STA_INFO_ACK_SIGNAL,
+ 	NL80211_STA_INFO_DATA_ACK_SIGNAL_AVG,
+ 
++	/* not backported yet */
++	NL80211_STA_INFO_RX_MPDUS,
++	NL80211_STA_INFO_FCS_ERROR_COUNT,
++	NL80211_STA_INFO_CONNECTED_TO_GATE,
++
++	NL80211_STA_INFO_TX_DURATION,
++	NL80211_STA_INFO_AIRTIME_WEIGHT,
++
+ 	/* keep last */
+ 	__NL80211_STA_INFO_AFTER_LAST,
+ 	NL80211_STA_INFO_MAX = __NL80211_STA_INFO_AFTER_LAST - 1
+@@ -5224,6 +5246,10 @@ enum nl80211_feature_flags {
+  *	except for supported rates from the probe request content if requested
+  *	by the %NL80211_SCAN_FLAG_MIN_PREQ_CONTENT flag.
+  *
++ * @NL80211_EXT_FEATURE_AIRTIME_FAIRNESS: Driver supports getting airtime
++ *	fairness for transmitted packets and has enabled airtime fairness
++ *	scheduling.
++ *
+  * @NUM_NL80211_EXT_FEATURES: number of extended features.
+  * @MAX_NL80211_EXT_FEATURES: highest extended feature index.
+  */
+@@ -5260,6 +5286,12 @@ enum nl80211_ext_feature_index {
+ 	NL80211_EXT_FEATURE_SCAN_RANDOM_SN,
+ 	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT,
+ 
++	/* --- not backported yet --- */
++	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0,
++	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER,
++
++	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS,
++
+ 	/* add new features before the definition below */
+ 	NUM_NL80211_EXT_FEATURES,
+ 	MAX_NL80211_EXT_FEATURES = NUM_NL80211_EXT_FEATURES - 1
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -469,6 +469,7 @@ static const struct nla_policy nl80211_p
+ 	[NL80211_ATTR_TXQ_QUANTUM] = { .type = NLA_U32 },
+ 	[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,
+ 					 .len = NL80211_HE_MAX_CAPABILITY_LEN },
++	[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),
+ };
+ 
+ /* policy for the key attributes */
+@@ -4715,6 +4716,11 @@ static int nl80211_send_station(struct s
+ 	PUT_SINFO(PLID, plid, u16);
+ 	PUT_SINFO(PLINK_STATE, plink_state, u8);
+ 	PUT_SINFO_U64(RX_DURATION, rx_duration);
++	PUT_SINFO_U64(TX_DURATION, tx_duration);
++
++	if (wiphy_ext_feature_isset(&rdev->wiphy,
++				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++		PUT_SINFO(AIRTIME_WEIGHT, airtime_weight, u16);
+ 
+ 	switch (rdev->wiphy.signal_type) {
+ 	case CFG80211_SIGNAL_TYPE_MBM:
+@@ -5351,6 +5357,15 @@ static int nl80211_set_station(struct sk
+ 			nla_get_u8(info->attrs[NL80211_ATTR_OPMODE_NOTIF]);
+ 	}
+ 
++	if (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])
++		params.airtime_weight =
++			nla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);
++
++	if (params.airtime_weight &&
++	    !wiphy_ext_feature_isset(&rdev->wiphy,
++				     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++		return -EOPNOTSUPP;
++
+ 	/* Include parameters for TDLS peer (will check later) */
+ 	err = nl80211_set_station_tdls(info, &params);
+ 	if (err)
+@@ -5489,6 +5504,15 @@ static int nl80211_new_station(struct sk
+ 			return -EINVAL;
+ 	}
+ 
++	if (info->attrs[NL80211_ATTR_AIRTIME_WEIGHT])
++		params.airtime_weight =
++			nla_get_u16(info->attrs[NL80211_ATTR_AIRTIME_WEIGHT]);
++
++	if (params.airtime_weight &&
++	    !wiphy_ext_feature_isset(&rdev->wiphy,
++				     NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++		return -EOPNOTSUPP;
++
+ 	err = nl80211_parse_sta_channel_info(info, &params);
+ 	if (err)
+ 		return err;
diff -uprN a/package/kernel/mac80211/patches/subsys/322-mac80211-Add-airtime-accounting-and-scheduling-to-TX.patch b/package/kernel/mac80211/patches/subsys/322-mac80211-Add-airtime-accounting-and-scheduling-to-TX.patch
--- a/package/kernel/mac80211/patches/subsys/322-mac80211-Add-airtime-accounting-and-scheduling-to-TX.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/322-mac80211-Add-airtime-accounting-and-scheduling-to-TX.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,522 @@
+From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@toke.dk>
+Date: Tue, 18 Dec 2018 17:02:08 -0800
+Subject: [PATCH] mac80211: Add airtime accounting and scheduling to TXQs
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+This adds airtime accounting and scheduling to the mac80211 TXQ
+scheduler. A new callback, ieee80211_sta_register_airtime(), is added
+that drivers can call to report airtime usage for stations.
+
+When airtime information is present, mac80211 will schedule TXQs
+(through ieee80211_next_txq()) in a way that enforces airtime fairness
+between active stations. This scheduling works the same way as the ath9k
+in-driver airtime fairness scheduling. If no airtime usage is reported
+by the driver, the scheduler will default to round-robin scheduling.
+
+For drivers that don't control TXQ scheduling in software, a new API
+function, ieee80211_txq_may_transmit(), is added which the driver can use
+to check if the TXQ is eligible for transmission, or should be throttled to
+enforce fairness. Calls to this function must also be enclosed in
+ieee80211_txq_schedule_{start,end}() calls to ensure proper locking.
+
+The API ieee80211_txq_may_transmit() also ensures that TXQ list will be
+aligned aginst driver's own round-robin scheduler list. i.e it rotates
+the TXQ list till it makes the requested node becomes the first entry
+in TXQ list. Thus both the TXQ list and driver's list are in sync.
+
+Co-developed-by: Rajkumar Manoharan <rmanohar@codeaurora.org>
+Signed-off-by: Louie Lu <git@louie.lu>
+[added debugfs write op to reset airtime counter]
+Signed-off-by: Toke Høiland-Jørgensen <toke@toke.dk>
+Signed-off-by: Rajkumar Manoharan <rmanohar@codeaurora.org>
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -2304,6 +2304,9 @@ enum ieee80211_hw_flags {
+  *	supported by HW.
+  * @max_nan_de_entries: maximum number of NAN DE functions supported by the
+  *	device.
++ *
++ * @weight_multipler: Driver specific airtime weight multiplier used while
++ *	refilling deficit of each TXQ.
+  */
+ struct ieee80211_hw {
+ 	struct ieee80211_conf conf;
+@@ -2339,6 +2342,7 @@ struct ieee80211_hw {
+ 	u8 n_cipher_schemes;
+ 	const struct ieee80211_cipher_scheme *cipher_schemes;
+ 	u8 max_nan_de_entries;
++	u8 weight_multiplier;
+ };
+ 
+ static inline bool _ieee80211_hw_check(struct ieee80211_hw *hw,
+@@ -5299,6 +5303,34 @@ void ieee80211_sta_eosp(struct ieee80211
+ void ieee80211_send_eosp_nullfunc(struct ieee80211_sta *pubsta, int tid);
+ 
+ /**
++ * ieee80211_sta_register_airtime - register airtime usage for a sta/tid
++ *
++ * Register airtime usage for a given sta on a given tid. The driver can call
++ * this function to notify mac80211 that a station used a certain amount of
++ * airtime. This information will be used by the TXQ scheduler to schedule
++ * stations in a way that ensures airtime fairness.
++ *
++ * The reported airtime should as a minimum include all time that is spent
++ * transmitting to the remote station, including overhead and padding, but not
++ * including time spent waiting for a TXOP. If the time is not reported by the
++ * hardware it can in some cases be calculated from the rate and known frame
++ * composition. When possible, the time should include any failed transmission
++ * attempts.
++ *
++ * The driver can either call this function synchronously for every packet or
++ * aggregate, or asynchronously as airtime usage information becomes available.
++ * TX and RX airtime can be reported together, or separately by setting one of
++ * them to 0.
++ *
++ * @pubsta: the station
++ * @tid: the TID to register airtime for
++ * @tx_airtime: airtime used during TX (in usec)
++ * @rx_airtime: airtime used during RX (in usec)
++ */
++void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
++				    u32 tx_airtime, u32 rx_airtime);
++
++/**
+  * ieee80211_iter_keys - iterate keys programmed into the device
+  * @hw: pointer obtained from ieee80211_alloc_hw()
+  * @vif: virtual interface to iterate, may be %NULL for all
+@@ -6042,6 +6074,33 @@ void ieee80211_txq_schedule_end(struct i
+ 	__releases(txq_lock);
+ 
+ /**
++ * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit
++ *
++ * This function is used to check whether given txq is allowed to transmit by
++ * the airtime scheduler, and can be used by drivers to access the airtime
++ * fairness accounting without going using the scheduling order enfored by
++ * next_txq().
++ *
++ * Returns %true if the airtime scheduler thinks the TXQ should be allowed to
++ * transmit, and %false if it should be throttled. This function can also have
++ * the side effect of rotating the TXQ in the scheduler rotation, which will
++ * eventually bring the deficit to positive and allow the station to transmit
++ * again.
++ *
++ * The API ieee80211_txq_may_transmit() also ensures that TXQ list will be
++ * aligned aginst driver's own round-robin scheduler list. i.e it rotates
++ * the TXQ list till it makes the requested node becomes the first entry
++ * in TXQ list. Thus both the TXQ list and driver's list are in sync. If this
++ * function returns %true, the driver is expected to schedule packets
++ * for transmission, and then return the TXQ through ieee80211_return_txq().
++ *
++ * @hw: pointer as obtained from ieee80211_alloc_hw()
++ * @txq: pointer obtained from station or virtual interface
++ */
++bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
++				struct ieee80211_txq *txq);
++
++/**
+  * ieee80211_txq_get_depth - get pending frame/byte count of given txq
+  *
+  * The values are not guaranteed to be coherent with regard to each other, i.e.
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -1391,6 +1391,9 @@ static int sta_apply_parameters(struct i
+ 	if (ieee80211_vif_is_mesh(&sdata->vif))
+ 		sta_apply_mesh_params(local, sta, params);
+ 
++	if (params->airtime_weight)
++		sta->airtime_weight = params->airtime_weight;
++
+ 	/* set the STA state after all sta info from usermode has been set */
+ 	if (test_sta_flag(sta, WLAN_STA_TDLS_PEER) ||
+ 	    set & BIT(NL80211_STA_FLAG_ASSOCIATED)) {
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -380,6 +380,9 @@ void debugfs_hw_add(struct ieee80211_loc
+ 	if (local->ops->wake_tx_queue)
+ 		DEBUGFS_ADD_MODE(aqm, 0600);
+ 
++	debugfs_create_u16("airtime_flags", 0600,
++			   phyd, &local->airtime_flags);
++
+ 	statsd = debugfs_create_dir("statistics", phyd);
+ 
+ 	/* if the dir failed, don't put all the other things into the root! */
+--- a/net/mac80211/debugfs_sta.c
++++ b/net/mac80211/debugfs_sta.c
+@@ -178,9 +178,9 @@ static ssize_t sta_aqm_read(struct file
+ 			       txqi->tin.tx_bytes,
+ 			       txqi->tin.tx_packets,
+ 			       txqi->flags,
+-			       txqi->flags & (1<<IEEE80211_TXQ_STOP) ? "STOP" : "RUN",
+-			       txqi->flags & (1<<IEEE80211_TXQ_AMPDU) ? " AMPDU" : "",
+-			       txqi->flags & (1<<IEEE80211_TXQ_NO_AMSDU) ? " NO-AMSDU" : "");
++			       test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ? "STOP" : "RUN",
++			       test_bit(IEEE80211_TXQ_AMPDU, &txqi->flags) ? " AMPDU" : "",
++			       test_bit(IEEE80211_TXQ_NO_AMSDU, &txqi->flags) ? " NO-AMSDU" : "");
+ 	}
+ 
+ 	rcu_read_unlock();
+@@ -192,6 +192,64 @@ static ssize_t sta_aqm_read(struct file
+ }
+ STA_OPS(aqm);
+ 
++static ssize_t sta_airtime_read(struct file *file, char __user *userbuf,
++				size_t count, loff_t *ppos)
++{
++	struct sta_info *sta = file->private_data;
++	struct ieee80211_local *local = sta->sdata->local;
++	size_t bufsz = 200;
++	char *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;
++	u64 rx_airtime = 0, tx_airtime = 0;
++	s64 deficit[IEEE80211_NUM_ACS];
++	ssize_t rv;
++	int ac;
++
++	if (!buf)
++		return -ENOMEM;
++
++	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
++		spin_lock_bh(&local->active_txq_lock[ac]);
++		rx_airtime += sta->airtime[ac].rx_airtime;
++		tx_airtime += sta->airtime[ac].tx_airtime;
++		deficit[ac] = sta->airtime[ac].deficit;
++		spin_unlock_bh(&local->active_txq_lock[ac]);
++	}
++
++	p += scnprintf(p, bufsz + buf - p,
++		"RX: %llu us\nTX: %llu us\nWeight: %u\n"
++		"Deficit: VO: %lld us VI: %lld us BE: %lld us BK: %lld us\n",
++		rx_airtime,
++		tx_airtime,
++		sta->airtime_weight,
++		deficit[0],
++		deficit[1],
++		deficit[2],
++		deficit[3]);
++
++	rv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);
++	kfree(buf);
++	return rv;
++}
++
++static ssize_t sta_airtime_write(struct file *file, const char __user *userbuf,
++				 size_t count, loff_t *ppos)
++{
++	struct sta_info *sta = file->private_data;
++	struct ieee80211_local *local = sta->sdata->local;
++	int ac;
++
++	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
++		spin_lock_bh(&local->active_txq_lock[ac]);
++		sta->airtime[ac].rx_airtime = 0;
++		sta->airtime[ac].tx_airtime = 0;
++		sta->airtime[ac].deficit = sta->airtime_weight;
++		spin_unlock_bh(&local->active_txq_lock[ac]);
++	}
++
++	return count;
++}
++STA_OPS_RW(airtime);
++
+ static ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,
+ 					size_t count, loff_t *ppos)
+ {
+@@ -546,6 +604,10 @@ void ieee80211_sta_debugfs_add(struct st
+ 	if (local->ops->wake_tx_queue)
+ 		DEBUGFS_ADD(aqm);
+ 
++	if (wiphy_ext_feature_isset(local->hw.wiphy,
++				    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++		DEBUGFS_ADD(airtime);
++
+ 	if (sizeof(sta->driver_buffered_tids) == sizeof(u32))
+ 		debugfs_create_x32("driver_buffered_tids", 0400,
+ 				   sta->debugfs_dir,
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -1124,6 +1124,8 @@ struct ieee80211_local {
+ 	struct list_head active_txqs[IEEE80211_NUM_ACS];
+ 	u16 schedule_round[IEEE80211_NUM_ACS];
+ 
++	u16 airtime_flags;
++
+ 	const struct ieee80211_ops *ops;
+ 
+ 	/*
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -656,6 +656,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 		INIT_LIST_HEAD(&local->active_txqs[i]);
+ 		spin_lock_init(&local->active_txq_lock[i]);
+ 	}
++	local->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;
+ 
+ 	INIT_LIST_HEAD(&local->chanctx_list);
+ 	mutex_init(&local->chanctx_mtx);
+@@ -1156,6 +1157,9 @@ int ieee80211_register_hw(struct ieee802
+ 	if (!local->hw.max_nan_de_entries)
+ 		local->hw.max_nan_de_entries = IEEE80211_MAX_NAN_INSTANCE_ID;
+ 
++	if (!local->hw.weight_multiplier)
++		local->hw.weight_multiplier = 1;
++
+ 	result = ieee80211_wep_init(local);
+ 	if (result < 0)
+ 		wiphy_debug(local->hw.wiphy, "Failed to initialize wep: %d\n",
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -90,7 +90,6 @@ static void __cleanup_single_sta(struct
+ 	struct tid_ampdu_tx *tid_tx;
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+-	struct fq *fq = &local->fq;
+ 	struct ps_data *ps;
+ 
+ 	if (test_sta_flag(sta, WLAN_STA_PS_STA) ||
+@@ -115,9 +114,7 @@ static void __cleanup_single_sta(struct
+ 		for (i = 0; i < ARRAY_SIZE(sta->sta.txq); i++) {
+ 			struct txq_info *txqi = to_txq_info(sta->sta.txq[i]);
+ 
+-			spin_lock_bh(&fq->lock);
+ 			ieee80211_txq_purge(local, txqi);
+-			spin_unlock_bh(&fq->lock);
+ 		}
+ 	}
+ 
+@@ -401,9 +398,12 @@ struct sta_info *sta_info_alloc(struct i
+ 	if (sta_prepare_rate_control(local, sta, gfp))
+ 		goto free_txq;
+ 
++	sta->airtime_weight = IEEE80211_DEFAULT_AIRTIME_WEIGHT;
++
+ 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
+ 		skb_queue_head_init(&sta->ps_tx_buf[i]);
+ 		skb_queue_head_init(&sta->tx_filtered[i]);
++		sta->airtime[i].deficit = sta->airtime_weight;
+ 	}
+ 
+ 	for (i = 0; i < IEEE80211_NUM_TIDS; i++)
+@@ -1842,6 +1842,27 @@ void ieee80211_sta_set_buffered(struct i
+ }
+ EXPORT_SYMBOL(ieee80211_sta_set_buffered);
+ 
++void ieee80211_sta_register_airtime(struct ieee80211_sta *pubsta, u8 tid,
++				    u32 tx_airtime, u32 rx_airtime)
++{
++	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
++	struct ieee80211_local *local = sta->sdata->local;
++	u8 ac = ieee80211_ac_from_tid(tid);
++	u32 airtime = 0;
++
++	if (sta->local->airtime_flags & AIRTIME_USE_TX)
++		airtime += tx_airtime;
++	if (sta->local->airtime_flags & AIRTIME_USE_RX)
++		airtime += rx_airtime;
++
++	spin_lock_bh(&local->active_txq_lock[ac]);
++	sta->airtime[ac].tx_airtime += tx_airtime;
++	sta->airtime[ac].rx_airtime += rx_airtime;
++	sta->airtime[ac].deficit -= airtime;
++	spin_unlock_bh(&local->active_txq_lock[ac]);
++}
++EXPORT_SYMBOL(ieee80211_sta_register_airtime);
++
+ int sta_info_move_state(struct sta_info *sta,
+ 			enum ieee80211_sta_state new_state)
+ {
+@@ -2212,6 +2233,23 @@ void sta_set_sinfo(struct sta_info *sta,
+ 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);
+ 	}
+ 
++	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_RX_DURATION))) {
++		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
++			sinfo->rx_duration += sta->airtime[ac].rx_airtime;
++		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);
++	}
++
++	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_DURATION))) {
++		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
++			sinfo->tx_duration += sta->airtime[ac].tx_airtime;
++		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);
++	}
++
++	if (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT))) {
++		sinfo->airtime_weight = sta->airtime_weight;
++		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_AIRTIME_WEIGHT);
++	}
++
+ 	sinfo->rx_dropped_misc = sta->rx_stats.dropped;
+ 	if (sta->pcpu_rx_stats) {
+ 		for_each_possible_cpu(cpu) {
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -128,6 +128,16 @@ enum ieee80211_agg_stop_reason {
+ 	AGG_STOP_DESTROY_STA,
+ };
+ 
++/* Debugfs flags to enable/disable use of RX/TX airtime in scheduler */
++#define AIRTIME_USE_TX		BIT(0)
++#define AIRTIME_USE_RX		BIT(1)
++
++struct airtime_info {
++	u64 rx_airtime;
++	u64 tx_airtime;
++	s64 deficit;
++};
++
+ struct sta_info;
+ 
+ /**
+@@ -593,6 +603,9 @@ struct sta_info {
+ 	} tx_stats;
+ 	u16 tid_seq[IEEE80211_QOS_CTL_TID_MASK + 1];
+ 
++	struct airtime_info airtime[IEEE80211_NUM_ACS];
++	u16 airtime_weight;
++
+ 	/*
+ 	 * Aggregation information, locked with lock.
+ 	 */
+--- a/net/mac80211/status.c
++++ b/net/mac80211/status.c
+@@ -827,6 +827,12 @@ static void __ieee80211_tx_status(struct
+ 			ieee80211_sta_tx_notify(sta->sdata, (void *) skb->data,
+ 						acked, info->status.tx_time);
+ 
++		if (info->status.tx_time &&
++		    wiphy_ext_feature_isset(local->hw.wiphy,
++					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++			ieee80211_sta_register_airtime(&sta->sta, tid,
++						       info->status.tx_time, 0);
++
+ 		if (ieee80211_hw_check(&local->hw, REPORTS_TX_ACK_STATUS)) {
+ 			if (acked) {
+ 				if (sta->status_stats.lost_packets)
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -1463,8 +1463,11 @@ void ieee80211_txq_purge(struct ieee8021
+ 	struct fq *fq = &local->fq;
+ 	struct fq_tin *tin = &txqi->tin;
+ 
++	spin_lock_bh(&fq->lock);
+ 	fq_tin_reset(fq, tin, fq_skb_free_func);
+ 	ieee80211_purge_tx_queue(&local->hw, &txqi->frags);
++	spin_unlock_bh(&fq->lock);
++
+ 	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
+ 	list_del_init(&txqi->schedule_order);
+ 	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
+@@ -3642,11 +3645,28 @@ struct ieee80211_txq *ieee80211_next_txq
+ 
+ 	lockdep_assert_held(&local->active_txq_lock[ac]);
+ 
++ begin:
+ 	txqi = list_first_entry_or_null(&local->active_txqs[ac],
+ 					struct txq_info,
+ 					schedule_order);
++	if (!txqi)
++		return NULL;
++
++	if (txqi->txq.sta) {
++		struct sta_info *sta = container_of(txqi->txq.sta,
++						struct sta_info, sta);
++
++		if (sta->airtime[txqi->txq.ac].deficit < 0) {
++			sta->airtime[txqi->txq.ac].deficit +=
++				sta->airtime_weight;
++			list_move_tail(&txqi->schedule_order,
++				       &local->active_txqs[txqi->txq.ac]);
++			goto begin;
++		}
++	}
++
+ 
+-	if (!txqi || txqi->schedule_round == local->schedule_round[ac])
++	if (txqi->schedule_round == local->schedule_round[ac])
+ 		return NULL;
+ 
+ 	list_del_init(&txqi->schedule_order);
+@@ -3664,12 +3684,74 @@ void ieee80211_return_txq(struct ieee802
+ 	lockdep_assert_held(&local->active_txq_lock[txq->ac]);
+ 
+ 	if (list_empty(&txqi->schedule_order) &&
+-	    (!skb_queue_empty(&txqi->frags) || txqi->tin.backlog_packets))
+-		list_add_tail(&txqi->schedule_order,
+-			      &local->active_txqs[txq->ac]);
++	    (!skb_queue_empty(&txqi->frags) || txqi->tin.backlog_packets)) {
++		/* If airtime accounting is active, always enqueue STAs at the
++		 * head of the list to ensure that they only get moved to the
++		 * back by the airtime DRR scheduler once they have a negative
++		 * deficit. A station that already has a negative deficit will
++		 * get immediately moved to the back of the list on the next
++		 * call to ieee80211_next_txq().
++		 */
++		if (txqi->txq.sta &&
++		    wiphy_ext_feature_isset(local->hw.wiphy,
++					    NL80211_EXT_FEATURE_AIRTIME_FAIRNESS))
++			list_add(&txqi->schedule_order,
++				 &local->active_txqs[txq->ac]);
++		else
++			list_add_tail(&txqi->schedule_order,
++				      &local->active_txqs[txq->ac]);
++	}
+ }
+ EXPORT_SYMBOL(ieee80211_return_txq);
+ 
++bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
++				struct ieee80211_txq *txq)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++	struct txq_info *iter, *tmp, *txqi = to_txq_info(txq);
++	struct sta_info *sta;
++	u8 ac = txq->ac;
++
++	lockdep_assert_held(&local->active_txq_lock[ac]);
++
++	if (!txqi->txq.sta)
++		goto out;
++
++	if (list_empty(&txqi->schedule_order))
++		goto out;
++
++	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
++				 schedule_order) {
++		if (iter == txqi)
++			break;
++
++		if (!iter->txq.sta) {
++			list_move_tail(&iter->schedule_order,
++				       &local->active_txqs[ac]);
++			continue;
++		}
++		sta = container_of(iter->txq.sta, struct sta_info, sta);
++		if (sta->airtime[ac].deficit < 0)
++			sta->airtime[ac].deficit += sta->airtime_weight;
++		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
++	}
++
++	sta = container_of(txqi->txq.sta, struct sta_info, sta);
++	if (sta->airtime[ac].deficit >= 0)
++		goto out;
++
++	sta->airtime[ac].deficit += sta->airtime_weight;
++	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
++
++	return false;
++out:
++	if (!list_empty(&txqi->schedule_order))
++		list_del_init(&txqi->schedule_order);
++
++	return true;
++}
++EXPORT_SYMBOL(ieee80211_txq_may_transmit);
++
+ void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
+ 	__acquires(txq_lock)
+ {
diff -uprN a/package/kernel/mac80211/patches/subsys/323-mac80211-Expose-ieee80211_schedule_txq-function.patch b/package/kernel/mac80211/patches/subsys/323-mac80211-Expose-ieee80211_schedule_txq-function.patch
--- a/package/kernel/mac80211/patches/subsys/323-mac80211-Expose-ieee80211_schedule_txq-function.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/323-mac80211-Expose-ieee80211_schedule_txq-function.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,73 @@
+From: =?UTF-8?q?Toke=20H=C3=B8iland-J=C3=B8rgensen?= <toke@redhat.com>
+Date: Tue, 22 Jan 2019 15:20:16 +0100
+Subject: [PATCH] mac80211: Expose ieee80211_schedule_txq() function
+MIME-Version: 1.0
+Content-Type: text/plain; charset=UTF-8
+Content-Transfer-Encoding: 8bit
+
+Since we reworked ieee80211_return_txq() so it assumes that the caller
+takes care of logging, we need another function that can be called without
+holding any locks. Introduce ieee80211_schedule_txq() which serves this
+purpose.
+
+Signed-off-by: Toke Høiland-Jørgensen <toke@redhat.com>
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -6074,6 +6074,19 @@ void ieee80211_txq_schedule_end(struct i
+ 	__releases(txq_lock);
+ 
+ /**
++ * ieee80211_schedule_txq - schedule a TXQ for transmission
++ *
++ * @hw: pointer as obtained from ieee80211_alloc_hw()
++ * @txq: pointer obtained from station or virtual interface
++ *
++ * Schedules a TXQ for transmission if it is not already scheduled. Takes a
++ * lock, which means it must *not* be called between
++ * ieee80211_txq_schedule_start() and ieee80211_txq_schedule_end()
++ */
++void ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
++	__acquires(txq_lock) __releases(txq_lock);
++
++/**
+  * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit
+  *
+  * This function is used to check whether given txq is allowed to transmit by
+--- a/net/mac80211/driver-ops.h
++++ b/net/mac80211/driver-ops.h
+@@ -1179,9 +1179,7 @@ static inline void drv_wake_tx_queue(str
+ static inline void schedule_and_wake_txq(struct ieee80211_local *local,
+ 					 struct txq_info *txqi)
+ {
+-	spin_lock_bh(&local->active_txq_lock[txqi->txq.ac]);
+-	ieee80211_return_txq(&local->hw, &txqi->txq);
+-	spin_unlock_bh(&local->active_txq_lock[txqi->txq.ac]);
++	ieee80211_schedule_txq(&local->hw, &txqi->txq);
+ 	drv_wake_tx_queue(local, txqi);
+ }
+ 
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3704,6 +3704,19 @@ void ieee80211_return_txq(struct ieee802
+ }
+ EXPORT_SYMBOL(ieee80211_return_txq);
+ 
++void ieee80211_schedule_txq(struct ieee80211_hw *hw,
++			    struct ieee80211_txq *txq)
++	__acquires(txq_lock) __releases(txq_lock)
++{
++	struct ieee80211_local *local = hw_to_local(hw);
++	struct txq_info *txqi = to_txq_info(txq);
++
++	spin_lock_bh(&local->active_txq_lock[txq->ac]);
++	ieee80211_return_txq(hw, txq);
++	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
++}
++EXPORT_SYMBOL(ieee80211_schedule_txq);
++
+ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
+ 				struct ieee80211_txq *txq)
+ {
diff -uprN a/package/kernel/mac80211/patches/subsys/350-mac80211-add-hdrlen-to-ieee80211_tx_data.patch b/package/kernel/mac80211/patches/subsys/350-mac80211-add-hdrlen-to-ieee80211_tx_data.patch
--- a/package/kernel/mac80211/patches/subsys/350-mac80211-add-hdrlen-to-ieee80211_tx_data.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/350-mac80211-add-hdrlen-to-ieee80211_tx_data.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,228 @@
+From: Janusz Dziedzic <janusz.dziedzic@tieto.com>
+Date: Fri, 19 Feb 2016 11:01:49 +0100
+Subject: [PATCH] mac80211: add hdrlen to ieee80211_tx_data
+
+This is preparation for adding support for inserting padding between the
+802.11 header and LLC data
+
+Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -161,6 +161,7 @@ struct ieee80211_tx_data {
+ 	struct ieee80211_tx_rate rate;
+ 
+ 	unsigned int flags;
++	unsigned int hdrlen;
+ };
+ 
+ 
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -925,7 +925,7 @@ ieee80211_tx_h_fragment(struct ieee80211
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 	struct ieee80211_hdr *hdr = (void *)skb->data;
+ 	int frag_threshold = tx->local->hw.wiphy->frag_threshold;
+-	int hdrlen;
++	int hdrlen = tx->hdrlen;
+ 	int fragnum;
+ 
+ 	/* no matter what happens, tx->skb moves to tx->skbs */
+@@ -946,8 +946,6 @@ ieee80211_tx_h_fragment(struct ieee80211
+ 	if (WARN_ON(info->flags & IEEE80211_TX_CTL_AMPDU))
+ 		return TX_DROP;
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+-
+ 	/* internal error, why isn't DONTFRAG set? */
+ 	if (WARN_ON(skb->len + FCS_LEN <= frag_threshold))
+ 		return TX_DROP;
+@@ -1178,6 +1176,8 @@ ieee80211_tx_prepare(struct ieee80211_su
+ 
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+ 
++	tx->hdrlen = ieee80211_hdrlen(hdr->frame_control);
++
+ 	if (likely(sta)) {
+ 		if (!IS_ERR(sta))
+ 			tx->sta = sta;
+@@ -3536,6 +3536,7 @@ begin:
+ 	tx.local = local;
+ 	tx.skb = skb;
+ 	tx.sdata = vif_to_sdata(info->control.vif);
++	tx.hdrlen = ieee80211_hdrlen(hdr->frame_control);
+ 
+ 	if (txq->sta) {
+ 		tx.sta = container_of(txq->sta, struct sta_info, sta);
+@@ -3580,7 +3581,7 @@ begin:
+ 
+ 		if (tx.key &&
+ 		    (tx.key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_IV))
+-			pn_offs = ieee80211_hdrlen(hdr->frame_control);
++			pn_offs = tx.hdrlen;
+ 
+ 		ieee80211_xmit_fast_finish(sta->sdata, sta, pn_offs,
+ 					   tx.key, skb);
+@@ -4039,6 +4040,7 @@ ieee80211_build_data_template(struct iee
+ 	hdr = (void *)skb->data;
+ 	tx.sta = sta_info_get(sdata, hdr->addr1);
+ 	tx.skb = skb;
++	tx.hdrlen = ieee80211_hdrlen(hdr->frame_control);
+ 
+ 	if (ieee80211_tx_h_select_key(&tx) != TX_CONTINUE) {
+ 		rcu_read_unlock();
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -1396,6 +1396,7 @@ void ieee80211_send_auth(struct ieee8021
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct sk_buff *skb;
+ 	struct ieee80211_mgmt *mgmt;
++	unsigned int hdrlen;
+ 	int err;
+ 
+ 	/* 24 + 6 = header + auth_algo + auth_transaction + status_code */
+@@ -1419,8 +1420,10 @@ void ieee80211_send_auth(struct ieee8021
+ 		skb_put_data(skb, extra, extra_len);
+ 
+ 	if (auth_alg == WLAN_AUTH_SHARED_KEY && transaction == 3) {
++		hdrlen = ieee80211_hdrlen(mgmt->frame_control);
+ 		mgmt->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+-		err = ieee80211_wep_encrypt(local, skb, key, key_len, key_idx);
++		err = ieee80211_wep_encrypt(local, skb, hdrlen, key,
++					    key_len, key_idx);
+ 		WARN_ON(err);
+ 	}
+ 
+--- a/net/mac80211/wep.c
++++ b/net/mac80211/wep.c
+@@ -89,11 +89,11 @@ static void ieee80211_wep_get_iv(struct
+ 
+ static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,
+ 				struct sk_buff *skb,
++				unsigned int hdrlen,
+ 				int keylen, int keyidx)
+ {
+ 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+-	unsigned int hdrlen;
+ 	u8 *newhdr;
+ 
+ 	hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+@@ -101,7 +101,6 @@ static u8 *ieee80211_wep_add_iv(struct i
+ 	if (WARN_ON(skb_headroom(skb) < IEEE80211_WEP_IV_LEN))
+ 		return NULL;
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+ 	newhdr = skb_push(skb, IEEE80211_WEP_IV_LEN);
+ 	memmove(newhdr, newhdr + IEEE80211_WEP_IV_LEN, hdrlen);
+ 
+@@ -160,6 +159,7 @@ int ieee80211_wep_encrypt_data(struct cr
+  */
+ int ieee80211_wep_encrypt(struct ieee80211_local *local,
+ 			  struct sk_buff *skb,
++			  unsigned int hdrlen,
+ 			  const u8 *key, int keylen, int keyidx)
+ {
+ 	u8 *iv;
+@@ -169,7 +169,7 @@ int ieee80211_wep_encrypt(struct ieee802
+ 	if (WARN_ON(skb_tailroom(skb) < IEEE80211_WEP_ICV_LEN))
+ 		return -1;
+ 
+-	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
++	iv = ieee80211_wep_add_iv(local, skb, hdrlen, keylen, keyidx);
+ 	if (!iv)
+ 		return -1;
+ 
+@@ -307,13 +307,14 @@ static int wep_encrypt_skb(struct ieee80
+ 	struct ieee80211_key_conf *hw_key = info->control.hw_key;
+ 
+ 	if (!hw_key) {
+-		if (ieee80211_wep_encrypt(tx->local, skb, tx->key->conf.key,
++		if (ieee80211_wep_encrypt(tx->local, skb, tx->hdrlen,
++					  tx->key->conf.key,
+ 					  tx->key->conf.keylen,
+ 					  tx->key->conf.keyidx))
+ 			return -1;
+ 	} else if ((hw_key->flags & IEEE80211_KEY_FLAG_GENERATE_IV) ||
+ 		   (hw_key->flags & IEEE80211_KEY_FLAG_PUT_IV_SPACE)) {
+-		if (!ieee80211_wep_add_iv(tx->local, skb,
++		if (!ieee80211_wep_add_iv(tx->local, skb, tx->hdrlen,
+ 					  tx->key->conf.keylen,
+ 					  tx->key->conf.keyidx))
+ 			return -1;
+--- a/net/mac80211/wep.h
++++ b/net/mac80211/wep.h
+@@ -22,6 +22,7 @@ int ieee80211_wep_encrypt_data(struct cr
+ 				size_t klen, u8 *data, size_t data_len);
+ int ieee80211_wep_encrypt(struct ieee80211_local *local,
+ 			  struct sk_buff *skb,
++			  unsigned int hdrlen,
+ 			  const u8 *key, int keylen, int keyidx);
+ int ieee80211_wep_decrypt_data(struct crypto_cipher *tfm, u8 *rc4key,
+ 			       size_t klen, u8 *data, size_t data_len);
+--- a/net/mac80211/wpa.c
++++ b/net/mac80211/wpa.c
+@@ -45,7 +45,7 @@ ieee80211_tx_h_michael_mic_add(struct ie
+ 	    skb->len < 24 || !ieee80211_is_data_present(hdr->frame_control))
+ 		return TX_CONTINUE;
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	hdrlen = tx->hdrlen;
+ 	if (skb->len < hdrlen)
+ 		return TX_DROP;
+ 
+@@ -196,7 +196,6 @@ mic_fail_no_key:
+ 
+ static int tkip_encrypt_skb(struct ieee80211_tx_data *tx, struct sk_buff *skb)
+ {
+-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+ 	struct ieee80211_key *key = tx->key;
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 	unsigned int hdrlen;
+@@ -211,7 +210,7 @@ static int tkip_encrypt_skb(struct ieee8
+ 		return 0;
+ 	}
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	hdrlen = tx->hdrlen;
+ 	len = skb->len - hdrlen;
+ 
+ 	if (info->control.hw_key)
+@@ -429,7 +428,7 @@ static int ccmp_encrypt_skb(struct ieee8
+ 		return 0;
+ 	}
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	hdrlen = tx->hdrlen;
+ 	len = skb->len - hdrlen;
+ 
+ 	if (info->control.hw_key)
+@@ -663,7 +662,7 @@ static int gcmp_encrypt_skb(struct ieee8
+ 		return 0;
+ 	}
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	hdrlen = tx->hdrlen;
+ 	len = skb->len - hdrlen;
+ 
+ 	if (info->control.hw_key)
+@@ -805,7 +804,6 @@ static ieee80211_tx_result
+ ieee80211_crypto_cs_encrypt(struct ieee80211_tx_data *tx,
+ 			    struct sk_buff *skb)
+ {
+-	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+ 	struct ieee80211_key *key = tx->key;
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 	int hdrlen;
+@@ -821,8 +819,7 @@ ieee80211_crypto_cs_encrypt(struct ieee8
+ 		     pskb_expand_head(skb, iv_len, 0, GFP_ATOMIC)))
+ 		return TX_DROP;
+ 
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
+-
++	hdrlen = tx->hdrlen;
+ 	pos = skb_push(skb, iv_len);
+ 	memmove(pos, pos + iv_len, hdrlen);
+ 
diff -uprN a/package/kernel/mac80211/patches/subsys/351-mac80211-add-TX_NEEDS_ALIGNED4_SKBS-hw-flag.patch b/package/kernel/mac80211/patches/subsys/351-mac80211-add-TX_NEEDS_ALIGNED4_SKBS-hw-flag.patch
--- a/package/kernel/mac80211/patches/subsys/351-mac80211-add-TX_NEEDS_ALIGNED4_SKBS-hw-flag.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/351-mac80211-add-TX_NEEDS_ALIGNED4_SKBS-hw-flag.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,304 @@
+From: Janusz Dziedzic <janusz.dziedzic@tieto.com>
+Date: Sun, 10 Mar 2019 17:22:08 +0100
+Subject: [PATCH] mac80211: add TX_NEEDS_ALIGNED4_SKBS hw flag
+
+The driver should set this flag if the hardware requires tx skb data
+(starting with the LLC header) to be aligned to 4 bytes.
+
+Padding is added after ieee80211_hdr, before IV/LLC.
+
+Before this patch, we have to do memmove(hdrlen) twice in the driver:
+Once before we pass this to HW and once again in tx completion
+(to fix up the skb for monitor mode).
+
+With this patch we can skip this memmove() and thus reduce CPU cycles in
+the data path.
+
+Signed-off-by: Janusz Dziedzic <janusz.dziedzic@tieto.com>
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -2140,6 +2140,9 @@ struct ieee80211_txq {
+  * @IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN: Driver does not report accurate A-MPDU
+  *	length in tx status information
+  *
++ * @IEEE80211_HW_TX_NEEDS_ALIGNED4_SKBS: Driver need aligned skbs to four-byte.
++ *	Padding will be added after ieee80211_hdr, before IV/LLC.
++ *
+  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
+  */
+ enum ieee80211_hw_flags {
+@@ -2186,6 +2189,7 @@ enum ieee80211_hw_flags {
+ 	IEEE80211_HW_DEAUTH_NEED_MGD_TX_PREP,
+ 	IEEE80211_HW_DOESNT_SUPPORT_QOS_NDP,
+ 	IEEE80211_HW_TX_STATUS_NO_AMPDU_LEN,
++	IEEE80211_HW_TX_NEEDS_ALIGNED4_SKBS,
+ 
+ 	/* keep last, obviously */
+ 	NUM_IEEE80211_HW_FLAGS
+@@ -2472,6 +2476,40 @@ ieee80211_get_alt_retry_rate(const struc
+ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb);
+ 
+ /**
++ * ieee80211_hdr_padsize - get size of padding between 802.11 header and LLC
++ * @hw: the hardware
++ * @hdrlen: 802.11 header length
++ */
++static inline unsigned int
++ieee80211_hdr_padsize(struct ieee80211_hw *hw, unsigned int hdrlen)
++{
++	/*
++	 * While hdrlen is already aligned to two-byte boundaries,
++	 * simple check with & 2 will return correct padsize.
++	 */
++	if (ieee80211_hw_check(hw, TX_NEEDS_ALIGNED4_SKBS))
++		return hdrlen & 2;
++	return 0;
++}
++
++/**
++ * ieee80211_padded_hdrlen - get padded 802.11 header size
++ * @hw: the hardware
++ * @fc: frame control field in little-endian format
++ */
++static inline unsigned int
++ieee80211_padded_hdrlen(struct ieee80211_hw *hw, __le16 fc)
++{
++	unsigned int hdrlen;
++
++	hdrlen = ieee80211_hdrlen(fc);
++	hdrlen += ieee80211_hdr_padsize(hw, hdrlen);
++
++	return hdrlen;
++}
++
++
++/**
+  * DOC: Hardware crypto acceleration
+  *
+  * mac80211 is capable of taking advantage of many hardware
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -1873,6 +1873,10 @@ int ieee80211_if_add(struct ieee80211_lo
+ 					+ 8 /* rfc1042/bridge tunnel */
+ 					- ETH_HLEN /* ethernet hard_header_len */
+ 					+ IEEE80211_ENCRYPT_HEADROOM;
++
++		if (ieee80211_hw_check(&local->hw, TX_NEEDS_ALIGNED4_SKBS))
++			ndev->needed_headroom += 2; /* padding */
++
+ 		ndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;
+ 
+ 		ret = dev_alloc_name(ndev, ndev->name);
+--- a/net/mac80211/mesh_pathtbl.c
++++ b/net/mac80211/mesh_pathtbl.c
+@@ -106,13 +106,15 @@ void mesh_path_assign_nexthop(struct mes
+ static void prepare_for_gate(struct sk_buff *skb, char *dst_addr,
+ 			     struct mesh_path *gate_mpath)
+ {
++	struct ieee80211_sub_if_data *sdata = gate_mpath->sdata;
++	struct ieee80211_hw *hw = &sdata->local->hw;
+ 	struct ieee80211_hdr *hdr;
+ 	struct ieee80211s_hdr *mshdr;
+ 	int mesh_hdrlen, hdrlen;
+ 	char *next_hop;
+ 
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	hdrlen = ieee80211_padded_hdrlen(hw, hdr->frame_control);
+ 	mshdr = (struct ieee80211s_hdr *) (skb->data + hdrlen);
+ 
+ 	if (!(mshdr->flags & MESH_FLAGS_AE)) {
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -2705,7 +2705,7 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
+ 	struct ieee80211_local *local = rx->local;
+ 	struct ieee80211_sub_if_data *sdata = rx->sdata;
+ 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+-	u16 ac, q, hdrlen;
++	u16 ac, q, hdrlen, padsize;
+ 	int tailroom = 0;
+ 
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+@@ -2798,7 +2798,9 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
+ 	if (sdata->crypto_tx_tailroom_needed_cnt)
+ 		tailroom = IEEE80211_ENCRYPT_TAILROOM;
+ 
+-	fwd_skb = skb_copy_expand(skb, local->tx_headroom +
++	padsize = ieee80211_hdr_padsize(&local->hw, hdrlen);
++
++	fwd_skb = skb_copy_expand(skb, local->tx_headroom + padsize +
+ 				       sdata->encrypt_headroom,
+ 				  tailroom, GFP_ATOMIC);
+ 	if (!fwd_skb)
+@@ -2830,6 +2832,12 @@ ieee80211_rx_h_mesh_fwding(struct ieee80
+ 		return RX_DROP_MONITOR;
+ 	}
+ 
++	if (padsize) {
++		skb_push(fwd_skb, padsize);
++		memmove(fwd_skb->data, skb->data + padsize, hdrlen);
++		memset(fwd_skb->data + hdrlen, 0, padsize);
++	}
++
+ 	IEEE80211_IFSTA_MESH_CTR_INC(ifmsh, fwded_frames);
+ 	ieee80211_add_pending_skb(local, fwd_skb);
+  out:
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -312,7 +312,7 @@ struct ieee80211_fast_tx {
+ 	u8 hdr_len;
+ 	u8 sa_offs, da_offs, pn_offs;
+ 	u8 band;
+-	u8 hdr[30 + 2 + IEEE80211_FAST_XMIT_MAX_IV +
++	u8 hdr[30 + 2 + 2 + IEEE80211_FAST_XMIT_MAX_IV +
+ 	       sizeof(rfc1042_header)] __aligned(2);
+ 
+ 	struct rcu_head rcu_head;
+--- a/net/mac80211/status.c
++++ b/net/mac80211/status.c
+@@ -514,6 +514,7 @@ static void ieee80211_report_used_skb(st
+ {
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 	struct ieee80211_hdr *hdr = (void *)skb->data;
++	struct ieee80211_hw *hw = &local->hw;
+ 	bool acked = info->flags & IEEE80211_TX_STAT_ACK;
+ 
+ 	if (dropped)
+@@ -530,7 +531,7 @@ static void ieee80211_report_used_skb(st
+ 			skb->dev = NULL;
+ 		} else {
+ 			unsigned int hdr_size =
+-				ieee80211_hdrlen(hdr->frame_control);
++				ieee80211_padded_hdrlen(hw, hdr->frame_control);
+ 
+ 			/* Check to see if packet is a TDLS teardown packet */
+ 			if (ieee80211_is_data(hdr->frame_control) &&
+@@ -654,9 +655,22 @@ void ieee80211_tx_monitor(struct ieee802
+ 	struct sk_buff *skb2;
+ 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 	struct ieee80211_sub_if_data *sdata;
++	struct ieee80211_hdr *hdr = (void *)skb->data;
+ 	struct net_device *prev_dev = NULL;
++	unsigned int hdrlen, padsize;
+ 	int rtap_len;
+ 
++	/* Remove padding if was added */
++	if (ieee80211_hw_check(&local->hw, TX_NEEDS_ALIGNED4_SKBS)) {
++		hdrlen = ieee80211_hdrlen(hdr->frame_control);
++		padsize = ieee80211_hdr_padsize(&local->hw, hdrlen);
++
++		if (padsize && skb->len > hdrlen + padsize) {
++			memmove(skb->data + padsize, skb->data, hdrlen);
++			skb_pull(skb, padsize);
++		}
++	}
++
+ 	/* send frame to monitor interfaces now */
+ 	rtap_len = ieee80211_tx_radiotap_len(info);
+ 	if (WARN_ON_ONCE(skb_headroom(skb) < rtap_len)) {
+--- a/net/mac80211/tkip.c
++++ b/net/mac80211/tkip.c
+@@ -201,10 +201,12 @@ void ieee80211_get_tkip_p2k(struct ieee8
+ {
+ 	struct ieee80211_key *key = (struct ieee80211_key *)
+ 			container_of(keyconf, struct ieee80211_key, conf);
++	struct ieee80211_hw *hw = &key->local->hw;
+ 	const u8 *tk = &key->conf.key[NL80211_TKIP_DATA_OFFSET_ENCR_KEY];
+ 	struct tkip_ctx *ctx = &key->u.tkip.tx;
+ 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
+-	const u8 *data = (u8 *)hdr + ieee80211_hdrlen(hdr->frame_control);
++	const u8 *data = (u8 *)hdr + ieee80211_padded_hdrlen(hw,
++							hdr->frame_control);
+ 	u32 iv32 = get_unaligned_le32(&data[4]);
+ 	u16 iv16 = data[2] | (data[0] << 8);
+ 
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -1175,8 +1175,7 @@ ieee80211_tx_prepare(struct ieee80211_su
+ 	info->flags &= ~IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+ 
+ 	hdr = (struct ieee80211_hdr *) skb->data;
+-
+-	tx->hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	tx->hdrlen = ieee80211_padded_hdrlen(&local->hw, hdr->frame_control);
+ 
+ 	if (likely(sta)) {
+ 		if (!IS_ERR(sta))
+@@ -2233,7 +2232,7 @@ netdev_tx_t ieee80211_monitor_start_xmit
+ 		goto fail;
+ 
+ 	hdr = (struct ieee80211_hdr *)(skb->data + len_rthdr);
+-	hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	hdrlen = ieee80211_padded_hdrlen(&local->hw, hdr->frame_control);
+ 
+ 	if (skb->len < len_rthdr + hdrlen)
+ 		goto fail;
+@@ -2452,7 +2451,7 @@ static struct sk_buff *ieee80211_build_h
+ 	struct ieee80211_chanctx_conf *chanctx_conf;
+ 	struct ieee80211_sub_if_data *ap_sdata;
+ 	enum nl80211_band band;
+-	int ret;
++	int padsize, ret;
+ 
+ 	if (IS_ERR(sta))
+ 		sta = NULL;
+@@ -2751,7 +2750,9 @@ static struct sk_buff *ieee80211_build_h
+ 	}
+ 
+ 	skb_pull(skb, skip_header_bytes);
++	padsize = ieee80211_hdr_padsize(&local->hw, hdrlen);
+ 	head_need = hdrlen + encaps_len + meshhdrlen - skb_headroom(skb);
++	head_need += padsize;
+ 
+ 	/*
+ 	 * So we need to modify the skb header and hence need a copy of
+@@ -2784,6 +2785,9 @@ static struct sk_buff *ieee80211_build_h
+ 		memcpy(skb_push(skb, meshhdrlen), &mesh_hdr, meshhdrlen);
+ #endif
+ 
++	if (padsize)
++		memset(skb_push(skb, padsize), 0, padsize);
++
+ 	if (ieee80211_is_data_qos(fc)) {
+ 		__le16 *qos_control;
+ 
+@@ -2960,6 +2964,8 @@ void ieee80211_check_fast_xmit(struct st
+ 		fc |= cpu_to_le16(IEEE80211_STYPE_QOS_DATA);
+ 	}
+ 
++	build.hdr_len += ieee80211_hdr_padsize(&local->hw, build.hdr_len);
++
+ 	/* We store the key here so there's no point in using rcu_dereference()
+ 	 * but that's fine because the code that changes the pointers will call
+ 	 * this function after doing so. For a single CPU that would be enough,
+@@ -3536,7 +3542,7 @@ begin:
+ 	tx.local = local;
+ 	tx.skb = skb;
+ 	tx.sdata = vif_to_sdata(info->control.vif);
+-	tx.hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	tx.hdrlen = ieee80211_padded_hdrlen(hw, hdr->frame_control);
+ 
+ 	if (txq->sta) {
+ 		tx.sta = container_of(txq->sta, struct sta_info, sta);
+@@ -4040,7 +4046,7 @@ ieee80211_build_data_template(struct iee
+ 	hdr = (void *)skb->data;
+ 	tx.sta = sta_info_get(sdata, hdr->addr1);
+ 	tx.skb = skb;
+-	tx.hdrlen = ieee80211_hdrlen(hdr->frame_control);
++	tx.hdrlen = ieee80211_padded_hdrlen(&tx.local->hw, hdr->frame_control);
+ 
+ 	if (ieee80211_tx_h_select_key(&tx) != TX_CONTINUE) {
+ 		rcu_read_unlock();
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -215,6 +215,7 @@ static const char *hw_flag_names[] = {
+ 	FLAG(DEAUTH_NEED_MGD_TX_PREP),
+ 	FLAG(DOESNT_SUPPORT_QOS_NDP),
+ 	FLAG(TX_STATUS_NO_AMPDU_LEN),
++	FLAG(TX_NEEDS_ALIGNED4_SKBS),
+ #undef FLAG
+ };
+ 
diff -uprN a/package/kernel/mac80211/patches/subsys/352-mac80211-rework-locking-for-txq-scheduling-airtime-f.patch b/package/kernel/mac80211/patches/subsys/352-mac80211-rework-locking-for-txq-scheduling-airtime-f.patch
--- a/package/kernel/mac80211/patches/subsys/352-mac80211-rework-locking-for-txq-scheduling-airtime-f.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/352-mac80211-rework-locking-for-txq-scheduling-airtime-f.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,214 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 13 Mar 2019 19:09:22 +0100
+Subject: [PATCH] mac80211: rework locking for txq scheduling / airtime
+ fairness
+
+Holding the lock around the entire duration of tx scheduling can create
+some nasty lock contention, especially when processing airtime information
+from the tx status or the rx path.
+Improve locking by only holding the active_txq_lock for lookups / scheduling
+list modifications.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -6069,8 +6069,6 @@ struct sk_buff *ieee80211_tx_dequeue(str
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+  * @ac: AC number to return packets from.
+  *
+- * Should only be called between calls to ieee80211_txq_schedule_start()
+- * and ieee80211_txq_schedule_end().
+  * Returns the next txq if successful, %NULL if no queue is eligible. If a txq
+  * is returned, it should be returned with ieee80211_return_txq() after the
+  * driver has finished scheduling it.
+@@ -6078,51 +6076,41 @@ struct sk_buff *ieee80211_tx_dequeue(str
+ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac);
+ 
+ /**
+- * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
+- *
+- * @hw: pointer as obtained from ieee80211_alloc_hw()
+- * @txq: pointer obtained from station or virtual interface
+- *
+- * Should only be called between calls to ieee80211_txq_schedule_start()
+- * and ieee80211_txq_schedule_end().
+- */
+-void ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
+-
+-/**
+- * ieee80211_txq_schedule_start - acquire locks for safe scheduling of an AC
++ * ieee80211_txq_schedule_start - start new scheduling round for TXQs
+  *
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+  * @ac: AC number to acquire locks for
+  *
+- * Acquire locks needed to schedule TXQs from the given AC. Should be called
+- * before ieee80211_next_txq() or ieee80211_return_txq().
++ * Should be called before ieee80211_next_txq() or ieee80211_return_txq().
+  */
+-void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
+-	__acquires(txq_lock);
++void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac);
++
++/* (deprecated) */
++static inline void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)
++{
++}
+ 
+ /**
+- * ieee80211_txq_schedule_end - release locks for safe scheduling of an AC
++ * ieee80211_schedule_txq - schedule a TXQ for transmission
+  *
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+- * @ac: AC number to acquire locks for
++ * @txq: pointer obtained from station or virtual interface
+  *
+- * Release locks previously acquired by ieee80211_txq_schedule_end().
++ * Schedules a TXQ for transmission if it is not already scheduled.
+  */
+-void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)
+-	__releases(txq_lock);
++void ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
+ 
+ /**
+- * ieee80211_schedule_txq - schedule a TXQ for transmission
++ * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
+  *
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+  * @txq: pointer obtained from station or virtual interface
+- *
+- * Schedules a TXQ for transmission if it is not already scheduled. Takes a
+- * lock, which means it must *not* be called between
+- * ieee80211_txq_schedule_start() and ieee80211_txq_schedule_end()
+  */
+-void ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
+-	__acquires(txq_lock) __releases(txq_lock);
++static inline void
++ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
++{
++	ieee80211_schedule_txq(hw, txq);
++}
+ 
+ /**
+  * ieee80211_txq_may_transmit - check whether TXQ is allowed to transmit
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3648,16 +3648,17 @@ EXPORT_SYMBOL(ieee80211_tx_dequeue);
+ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
++	struct ieee80211_txq *ret = NULL;
+ 	struct txq_info *txqi = NULL;
+ 
+-	lockdep_assert_held(&local->active_txq_lock[ac]);
++	spin_lock_bh(&local->active_txq_lock[ac]);
+ 
+  begin:
+ 	txqi = list_first_entry_or_null(&local->active_txqs[ac],
+ 					struct txq_info,
+ 					schedule_order);
+ 	if (!txqi)
+-		return NULL;
++		goto out;
+ 
+ 	if (txqi->txq.sta) {
+ 		struct sta_info *sta = container_of(txqi->txq.sta,
+@@ -3674,21 +3675,25 @@ struct ieee80211_txq *ieee80211_next_txq
+ 
+ 
+ 	if (txqi->schedule_round == local->schedule_round[ac])
+-		return NULL;
++		goto out;
+ 
+ 	list_del_init(&txqi->schedule_order);
+ 	txqi->schedule_round = local->schedule_round[ac];
+-	return &txqi->txq;
++	ret = &txqi->txq;
++
++out:
++	spin_unlock_bh(&local->active_txq_lock[ac]);
++	return ret;
+ }
+ EXPORT_SYMBOL(ieee80211_next_txq);
+ 
+-void ieee80211_return_txq(struct ieee80211_hw *hw,
+-			  struct ieee80211_txq *txq)
++void ieee80211_schedule_txq(struct ieee80211_hw *hw,
++			    struct ieee80211_txq *txq)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 	struct txq_info *txqi = to_txq_info(txq);
+ 
+-	lockdep_assert_held(&local->active_txq_lock[txq->ac]);
++	spin_lock_bh(&local->active_txq_lock[txq->ac]);
+ 
+ 	if (list_empty(&txqi->schedule_order) &&
+ 	    (!skb_queue_empty(&txqi->frags) || txqi->tin.backlog_packets)) {
+@@ -3708,18 +3713,7 @@ void ieee80211_return_txq(struct ieee802
+ 			list_add_tail(&txqi->schedule_order,
+ 				      &local->active_txqs[txq->ac]);
+ 	}
+-}
+-EXPORT_SYMBOL(ieee80211_return_txq);
+ 
+-void ieee80211_schedule_txq(struct ieee80211_hw *hw,
+-			    struct ieee80211_txq *txq)
+-	__acquires(txq_lock) __releases(txq_lock)
+-{
+-	struct ieee80211_local *local = hw_to_local(hw);
+-	struct txq_info *txqi = to_txq_info(txq);
+-
+-	spin_lock_bh(&local->active_txq_lock[txq->ac]);
+-	ieee80211_return_txq(hw, txq);
+ 	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
+ }
+ EXPORT_SYMBOL(ieee80211_schedule_txq);
+@@ -3732,7 +3726,7 @@ bool ieee80211_txq_may_transmit(struct i
+ 	struct sta_info *sta;
+ 	u8 ac = txq->ac;
+ 
+-	lockdep_assert_held(&local->active_txq_lock[ac]);
++	spin_lock_bh(&local->active_txq_lock[ac]);
+ 
+ 	if (!txqi->txq.sta)
+ 		goto out;
+@@ -3762,34 +3756,27 @@ bool ieee80211_txq_may_transmit(struct i
+ 
+ 	sta->airtime[ac].deficit += sta->airtime_weight;
+ 	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
++	spin_unlock_bh(&local->active_txq_lock[ac]);
+ 
+ 	return false;
+ out:
+ 	if (!list_empty(&txqi->schedule_order))
+ 		list_del_init(&txqi->schedule_order);
++	spin_unlock_bh(&local->active_txq_lock[ac]);
+ 
+ 	return true;
+ }
+ EXPORT_SYMBOL(ieee80211_txq_may_transmit);
+ 
+ void ieee80211_txq_schedule_start(struct ieee80211_hw *hw, u8 ac)
+-	__acquires(txq_lock)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 
+ 	spin_lock_bh(&local->active_txq_lock[ac]);
+ 	local->schedule_round[ac]++;
+-}
+-EXPORT_SYMBOL(ieee80211_txq_schedule_start);
+-
+-void ieee80211_txq_schedule_end(struct ieee80211_hw *hw, u8 ac)
+-	__releases(txq_lock)
+-{
+-	struct ieee80211_local *local = hw_to_local(hw);
+-
+ 	spin_unlock_bh(&local->active_txq_lock[ac]);
+ }
+-EXPORT_SYMBOL(ieee80211_txq_schedule_end);
++EXPORT_SYMBOL(ieee80211_txq_schedule_start);
+ 
+ void __ieee80211_subif_start_xmit(struct sk_buff *skb,
+ 				  struct net_device *dev,
diff -uprN a/package/kernel/mac80211/patches/subsys/353-mac80211-mesh-drop-redundant-rcu_read_lock-unlock-ca.patch b/package/kernel/mac80211/patches/subsys/353-mac80211-mesh-drop-redundant-rcu_read_lock-unlock-ca.patch
--- a/package/kernel/mac80211/patches/subsys/353-mac80211-mesh-drop-redundant-rcu_read_lock-unlock-ca.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/353-mac80211-mesh-drop-redundant-rcu_read_lock-unlock-ca.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,96 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 16 Mar 2019 17:43:58 +0100
+Subject: [PATCH] mac80211: mesh: drop redundant rcu_read_lock/unlock calls
+
+The callers of these functions are all within RCU locked sections
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/mesh_hwmp.c
++++ b/net/mac80211/mesh_hwmp.c
+@@ -1122,16 +1122,13 @@ int mesh_nexthop_resolve(struct ieee8021
+ 	struct mesh_path *mpath;
+ 	struct sk_buff *skb_to_free = NULL;
+ 	u8 *target_addr = hdr->addr3;
+-	int err = 0;
+ 
+ 	/* Nulls are only sent to peers for PS and should be pre-addressed */
+ 	if (ieee80211_is_qos_nullfunc(hdr->frame_control))
+ 		return 0;
+ 
+-	rcu_read_lock();
+-	err = mesh_nexthop_lookup(sdata, skb);
+-	if (!err)
+-		goto endlookup;
++	if (!mesh_nexthop_lookup(sdata, skb))
++		return 0;
+ 
+ 	/* no nexthop found, start resolving */
+ 	mpath = mesh_path_lookup(sdata, target_addr);
+@@ -1139,8 +1136,7 @@ int mesh_nexthop_resolve(struct ieee8021
+ 		mpath = mesh_path_add(sdata, target_addr);
+ 		if (IS_ERR(mpath)) {
+ 			mesh_path_discard_frame(sdata, skb);
+-			err = PTR_ERR(mpath);
+-			goto endlookup;
++			return PTR_ERR(mpath);
+ 		}
+ 	}
+ 
+@@ -1154,13 +1150,10 @@ int mesh_nexthop_resolve(struct ieee8021
+ 	info->flags |= IEEE80211_TX_INTFL_NEED_TXPROCESSING;
+ 	ieee80211_set_qos_hdr(sdata, skb);
+ 	skb_queue_tail(&mpath->frame_queue, skb);
+-	err = -ENOENT;
+ 	if (skb_to_free)
+ 		mesh_path_discard_frame(sdata, skb_to_free);
+ 
+-endlookup:
+-	rcu_read_unlock();
+-	return err;
++	return -ENOENT;
+ }
+ 
+ /**
+@@ -1180,13 +1173,10 @@ int mesh_nexthop_lookup(struct ieee80211
+ 	struct sta_info *next_hop;
+ 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+ 	u8 *target_addr = hdr->addr3;
+-	int err = -ENOENT;
+ 
+-	rcu_read_lock();
+ 	mpath = mesh_path_lookup(sdata, target_addr);
+-
+ 	if (!mpath || !(mpath->flags & MESH_PATH_ACTIVE))
+-		goto endlookup;
++		return -ENOENT;
+ 
+ 	if (time_after(jiffies,
+ 		       mpath->exp_time -
+@@ -1201,12 +1191,10 @@ int mesh_nexthop_lookup(struct ieee80211
+ 		memcpy(hdr->addr1, next_hop->sta.addr, ETH_ALEN);
+ 		memcpy(hdr->addr2, sdata->vif.addr, ETH_ALEN);
+ 		ieee80211_mps_set_frame_flags(sdata, next_hop, hdr);
+-		err = 0;
++		return 0;
+ 	}
+ 
+-endlookup:
+-	rcu_read_unlock();
+-	return err;
++	return -ENOENT;
+ }
+ 
+ void mesh_path_timer(struct timer_list *t)
+--- a/net/mac80211/mesh_pathtbl.c
++++ b/net/mac80211/mesh_pathtbl.c
+@@ -220,7 +220,7 @@ static struct mesh_path *mpath_lookup(st
+ {
+ 	struct mesh_path *mpath;
+ 
+-	mpath = rhashtable_lookup_fast(&tbl->rhead, dst, mesh_rht_params);
++	mpath = rhashtable_lookup(&tbl->rhead, dst, mesh_rht_params);
+ 
+ 	if (mpath && mpath_expired(mpath)) {
+ 		spin_lock_bh(&mpath->state_lock);
diff -uprN a/package/kernel/mac80211/patches/subsys/353-mac80211-use-more-bits-for-ack_frame_id.patch b/package/kernel/mac80211/patches/subsys/353-mac80211-use-more-bits-for-ack_frame_id.patch
--- a/package/kernel/mac80211/patches/subsys/353-mac80211-use-more-bits-for-ack_frame_id.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/353-mac80211-use-more-bits-for-ack_frame_id.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,70 +0,0 @@
-From: Johannes Berg <johannes.berg@intel.com>
-Date: Wed, 15 Jan 2020 12:25:50 +0100
-Subject: [PATCH] mac80211: use more bits for ack_frame_id
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-It turns out that this wasn't a good idea, I hit a test failure in
-hwsim due to this. That particular failure was easily worked around,
-but it raised questions: if an AP needs to, for example, send action
-frames to each connected station, the current limit is nowhere near
-enough (especially if those stations are sleeping and the frames are
-queued for a while.)
-
-Shuffle around some bits to make more room for ack_frame_id to allow
-up to 8192 queued up frames, that's enough for queueing 4 frames to
-each connected station, even at the maximum of 2007 stations on a
-single AP.
-
-We take the bits from band (which currently only 2 but I leave 3 in
-case we add another band) and from the hw_queue, which can only need
-4 since it has a limit of 16 queues.
-
-Fixes: 6912daed05e1 ("mac80211: Shrink the size of ack_frame_id to make room for tx_time_est")
-Signed-off-by: Johannes Berg <johannes.berg@intel.com>
-Acked-by: Toke Høiland-Jørgensen <toke@redhat.com>
----
-
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1004,12 +1004,11 @@ ieee80211_rate_get_vht_nss(const struct
- struct ieee80211_tx_info {
- 	/* common information */
- 	u32 flags;
--	u8 band;
--
--	u8 hw_queue;
--
--	u16 ack_frame_id:6;
--	u16 tx_time_est:10;
-+	u32 band:3,
-+	    ack_frame_id:13,
-+	    hw_queue:4,
-+	    tx_time_est:10;
-+	/* 2 free bits */
- 
- 	union {
- 		struct {
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -3449,7 +3449,7 @@ int ieee80211_attach_ack_skb(struct ieee
- 
- 	spin_lock_irqsave(&local->ack_status_lock, spin_flags);
- 	id = idr_alloc(&local->ack_status_frames, ack_skb,
--		       1, 0x40, GFP_ATOMIC);
-+		       1, 0x2000, GFP_ATOMIC);
- 	spin_unlock_irqrestore(&local->ack_status_lock, spin_flags);
- 
- 	if (id < 0) {
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -2452,7 +2452,7 @@ static int ieee80211_store_ack_skb(struc
- 
- 		spin_lock_irqsave(&local->ack_status_lock, flags);
- 		id = idr_alloc(&local->ack_status_frames, ack_skb,
--			       1, 0x40, GFP_ATOMIC);
-+			       1, 0x2000, GFP_ATOMIC);
- 		spin_unlock_irqrestore(&local->ack_status_lock, flags);
- 
- 		if (id >= 0) {
diff -uprN a/package/kernel/mac80211/patches/subsys/354-mac80211-calculate-hash-for-fq-without-holding-fq-lo.patch b/package/kernel/mac80211/patches/subsys/354-mac80211-calculate-hash-for-fq-without-holding-fq-lo.patch
--- a/package/kernel/mac80211/patches/subsys/354-mac80211-calculate-hash-for-fq-without-holding-fq-lo.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/354-mac80211-calculate-hash-for-fq-without-holding-fq-lo.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,140 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 16 Mar 2019 17:57:38 +0100
+Subject: [PATCH] mac80211: calculate hash for fq without holding fq->lock
+ in itxq enqueue
+
+Reduces lock contention on enqueue/dequeue of iTXQ packets
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/net/fq_impl.h
++++ b/include/net/fq_impl.h
+@@ -107,29 +107,31 @@ begin:
+ 	return skb;
+ }
+ 
+-static struct fq_flow *fq_flow_classify(struct fq *fq,
+-					struct fq_tin *tin,
+-					struct sk_buff *skb,
+-					fq_flow_get_default_t get_default_func)
++static u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)
+ {
+-	struct fq_flow *flow;
+-	u32 hash;
+-	u32 idx;
+-
+-	lockdep_assert_held(&fq->lock);
+-
+ #if LINUX_VERSION_IS_GEQ(5,3,10) || \
+     LINUX_VERSION_IN_RANGE(4,19,83, 4,20,0) || \
+     LINUX_VERSION_IN_RANGE(4,14,153, 4,15,0) || \
+     LINUX_VERSION_IN_RANGE(4,9,200, 4,10,0) || \
+     LINUX_VERSION_IN_RANGE(4,4,200, 4,5,0)
+-	hash = skb_get_hash_perturb(skb, &fq->perturbation);
++	u32 hash = skb_get_hash_perturb(skb, &fq->perturbation);
+ #else
+-	hash = skb_get_hash_perturb(skb, fq->perturbation);
++	u32 hash = skb_get_hash_perturb(skb, fq->perturbation);
+ #endif
+-	idx = reciprocal_scale(hash, fq->flows_cnt);
+-	flow = &fq->flows[idx];
+ 
++	return reciprocal_scale(hash, fq->flows_cnt);
++}
++
++static struct fq_flow *fq_flow_classify(struct fq *fq,
++					struct fq_tin *tin, u32 idx,
++					struct sk_buff *skb,
++					fq_flow_get_default_t get_default_func)
++{
++	struct fq_flow *flow;
++
++	lockdep_assert_held(&fq->lock);
++
++	flow = &fq->flows[idx];
+ 	if (flow->tin && flow->tin != tin) {
+ 		flow = get_default_func(fq, tin, idx, skb);
+ 		tin->collisions++;
+@@ -161,7 +163,7 @@ static void fq_recalc_backlog(struct fq
+ }
+ 
+ static void fq_tin_enqueue(struct fq *fq,
+-			   struct fq_tin *tin,
++			   struct fq_tin *tin, u32 idx,
+ 			   struct sk_buff *skb,
+ 			   fq_skb_free_t free_func,
+ 			   fq_flow_get_default_t get_default_func)
+@@ -171,7 +173,7 @@ static void fq_tin_enqueue(struct fq *fq
+ 
+ 	lockdep_assert_held(&fq->lock);
+ 
+-	flow = fq_flow_classify(fq, tin, skb, get_default_func);
++	flow = fq_flow_classify(fq, tin, idx, skb, get_default_func);
+ 
+ 	flow->tin = tin;
+ 	flow->backlog += skb->len;
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -1390,11 +1390,15 @@ static void ieee80211_txq_enqueue(struct
+ {
+ 	struct fq *fq = &local->fq;
+ 	struct fq_tin *tin = &txqi->tin;
++	u32 flow_idx = fq_flow_idx(fq, skb);
+ 
+ 	ieee80211_set_skb_enqueue_time(skb);
+-	fq_tin_enqueue(fq, tin, skb,
++
++	spin_lock_bh(&fq->lock);
++	fq_tin_enqueue(fq, tin, flow_idx, skb,
+ 		       fq_skb_free_func,
+ 		       fq_flow_get_default_func);
++	spin_unlock_bh(&fq->lock);
+ }
+ 
+ static bool fq_vlan_filter_func(struct fq *fq, struct fq_tin *tin,
+@@ -1564,7 +1568,6 @@ static bool ieee80211_queue_skb(struct i
+ 				struct sta_info *sta,
+ 				struct sk_buff *skb)
+ {
+-	struct fq *fq = &local->fq;
+ 	struct ieee80211_vif *vif;
+ 	struct txq_info *txqi;
+ 
+@@ -1582,9 +1585,7 @@ static bool ieee80211_queue_skb(struct i
+ 	if (!txqi)
+ 		return false;
+ 
+-	spin_lock_bh(&fq->lock);
+ 	ieee80211_txq_enqueue(local, txqi, skb);
+-	spin_unlock_bh(&fq->lock);
+ 
+ 	schedule_and_wake_txq(local, txqi);
+ 
+@@ -3211,6 +3212,7 @@ static bool ieee80211_amsdu_aggregate(st
+ 	u8 max_subframes = sta->sta.max_amsdu_subframes;
+ 	int max_frags = local->hw.max_tx_fragments;
+ 	int max_amsdu_len = sta->sta.max_amsdu_len;
++	u32 flow_idx;
+ 	int orig_truesize;
+ 	__be16 len;
+ 	void *data;
+@@ -3233,6 +3235,8 @@ static bool ieee80211_amsdu_aggregate(st
+ 		max_amsdu_len = min_t(int, max_amsdu_len,
+ 				      sta->sta.max_rc_amsdu_len);
+ 
++	flow_idx = fq_flow_idx(fq, skb);
++
+ 	spin_lock_bh(&fq->lock);
+ 
+ 	/* TODO: Ideally aggregation should be done on dequeue to remain
+@@ -3240,7 +3244,8 @@ static bool ieee80211_amsdu_aggregate(st
+ 	 */
+ 
+ 	tin = &txqi->tin;
+-	flow = fq_flow_classify(fq, tin, skb, fq_flow_get_default_func);
++	flow = fq_flow_classify(fq, tin, flow_idx, skb,
++				fq_flow_get_default_func);
+ 	head = skb_peek_tail(&flow->queue);
+ 	if (!head)
+ 		goto out;
diff -uprN a/package/kernel/mac80211/patches/subsys/355-mac80211-run-late-dequeue-late-tx-handlers-without-h.patch b/package/kernel/mac80211/patches/subsys/355-mac80211-run-late-dequeue-late-tx-handlers-without-h.patch
--- a/package/kernel/mac80211/patches/subsys/355-mac80211-run-late-dequeue-late-tx-handlers-without-h.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/355-mac80211-run-late-dequeue-late-tx-handlers-without-h.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,55 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 16 Mar 2019 18:00:12 +0100
+Subject: [PATCH] mac80211: run late dequeue late tx handlers without
+ holding fq->lock
+
+Reduces lock contention on enqueue/dequeue of iTXQ packets
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3518,6 +3518,7 @@ struct sk_buff *ieee80211_tx_dequeue(str
+ 	ieee80211_tx_result r;
+ 	struct ieee80211_vif *vif = txq->vif;
+ 
++begin:
+ 	spin_lock_bh(&fq->lock);
+ 
+ 	if (test_bit(IEEE80211_TXQ_STOP, &txqi->flags) ||
+@@ -3534,11 +3535,12 @@ struct sk_buff *ieee80211_tx_dequeue(str
+ 	if (skb)
+ 		goto out;
+ 
+-begin:
+ 	skb = fq_tin_dequeue(fq, tin, fq_tin_dequeue_func);
+ 	if (!skb)
+ 		goto out;
+ 
++	spin_unlock_bh(&fq->lock);
++
+ 	hdr = (struct ieee80211_hdr *)skb->data;
+ 	info = IEEE80211_SKB_CB(skb);
+ 
+@@ -3602,8 +3604,11 @@ begin:
+ 
+ 		skb = __skb_dequeue(&tx.skbs);
+ 
+-		if (!skb_queue_empty(&tx.skbs))
++		if (!skb_queue_empty(&tx.skbs)) {
++			spin_lock_bh(&fq->lock);
+ 			skb_queue_splice_tail(&tx.skbs, &txqi->frags);
++			spin_unlock_bh(&fq->lock);
++		}
+ 	}
+ 
+ 	if (skb && skb_has_frag_list(skb) &&
+@@ -3642,6 +3647,7 @@ begin:
+ 	}
+ 
+ 	IEEE80211_SKB_CB(skb)->control.vif = vif;
++	return skb;
+ 
+ out:
+ 	spin_unlock_bh(&fq->lock);
diff -uprN a/package/kernel/mac80211/patches/subsys/356-mac80211-set-NETIF_F_LLTX-when-using-intermediate-tx.patch b/package/kernel/mac80211/patches/subsys/356-mac80211-set-NETIF_F_LLTX-when-using-intermediate-tx.patch
--- a/package/kernel/mac80211/patches/subsys/356-mac80211-set-NETIF_F_LLTX-when-using-intermediate-tx.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/356-mac80211-set-NETIF_F_LLTX-when-using-intermediate-tx.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,22 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 16 Mar 2019 18:01:53 +0100
+Subject: [PATCH] mac80211: set NETIF_F_LLTX when using intermediate tx
+ queues
+
+When using iTXQ, tx sequence number allocation and statistics are run at
+dequeue time. Because of that, it is safe to enable NETIF_F_LLTX, which
+allows tx handlers to run on multiple CPUs in parallel.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -1297,6 +1297,7 @@ static void ieee80211_if_setup(struct ne
+ static void ieee80211_if_setup_no_queue(struct net_device *dev)
+ {
+ 	ieee80211_if_setup(dev);
++	dev->features |= NETIF_F_LLTX;
+ #if LINUX_VERSION_IS_GEQ(4,3,0)
+ 	dev->priv_flags |= IFF_NO_QUEUE;
+ #else
diff -uprN a/package/kernel/mac80211/patches/subsys/358-mac80211-make-ieee80211_schedule_txq-schedule-empty-.patch b/package/kernel/mac80211/patches/subsys/358-mac80211-make-ieee80211_schedule_txq-schedule-empty-.patch
--- a/package/kernel/mac80211/patches/subsys/358-mac80211-make-ieee80211_schedule_txq-schedule-empty-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/358-mac80211-make-ieee80211_schedule_txq-schedule-empty-.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,105 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sun, 17 Mar 2019 14:26:59 +0100
+Subject: [PATCH] mac80211: make ieee80211_schedule_txq schedule empty TXQs
+
+Currently there is no way for the driver to signal to mac80211 that it should
+schedule a TXQ even if there are no packets on the mac80211 part of that queue.
+This is problematic if the driver has an internal retry queue to deal with
+software A-MPDU retry.
+
+This patch changes the behavior of ieee80211_schedule_txq to always schedule
+the queue, as its only user (ath9k) seems to expect such behavior already:
+it calls this function on tx status and on powersave wakeup whenever its
+internal retry queue is not empty.
+
+Also add an extra argument to ieee80211_return_txq to get the same behavior.
+
+This fixes an issue on ath9k where tx queues with packets to retry (and no
+new packets in mac80211) would not get serviced.
+
+Fixes: 89cea7493a346 ("ath9k: Switch to mac80211 TXQ scheduling and airtime APIs")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -6090,26 +6090,42 @@ static inline void ieee80211_txq_schedul
+ {
+ }
+ 
++void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
++			      struct ieee80211_txq *txq, bool force);
++
+ /**
+  * ieee80211_schedule_txq - schedule a TXQ for transmission
+  *
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+  * @txq: pointer obtained from station or virtual interface
+  *
+- * Schedules a TXQ for transmission if it is not already scheduled.
++ * Schedules a TXQ for transmission if it is not already scheduled,
++ * even if mac80211 does not have any packets buffered.
++ *
++ * The driver may call this function if it has buffered packets for
++ * this TXQ internally.
+  */
+-void ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq);
++static inline void
++ieee80211_schedule_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
++{
++	__ieee80211_schedule_txq(hw, txq, true);
++}
+ 
+ /**
+  * ieee80211_return_txq - return a TXQ previously acquired by ieee80211_next_txq()
+  *
+  * @hw: pointer as obtained from ieee80211_alloc_hw()
+  * @txq: pointer obtained from station or virtual interface
++ * @force: schedule txq even if mac80211 does not have any buffered packets.
++ *
++ * The driver may set force=true if it has buffered packets for this TXQ
++ * internally.
+  */
+ static inline void
+-ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq)
++ieee80211_return_txq(struct ieee80211_hw *hw, struct ieee80211_txq *txq,
++		     bool force)
+ {
+-	ieee80211_schedule_txq(hw, txq);
++	__ieee80211_schedule_txq(hw, txq, force);
+ }
+ 
+ /**
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3698,8 +3698,9 @@ out:
+ }
+ EXPORT_SYMBOL(ieee80211_next_txq);
+ 
+-void ieee80211_schedule_txq(struct ieee80211_hw *hw,
+-			    struct ieee80211_txq *txq)
++void __ieee80211_schedule_txq(struct ieee80211_hw *hw,
++			      struct ieee80211_txq *txq,
++			      bool force)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+ 	struct txq_info *txqi = to_txq_info(txq);
+@@ -3707,7 +3708,8 @@ void ieee80211_schedule_txq(struct ieee8
+ 	spin_lock_bh(&local->active_txq_lock[txq->ac]);
+ 
+ 	if (list_empty(&txqi->schedule_order) &&
+-	    (!skb_queue_empty(&txqi->frags) || txqi->tin.backlog_packets)) {
++	    (force || !skb_queue_empty(&txqi->frags) ||
++	     txqi->tin.backlog_packets)) {
+ 		/* If airtime accounting is active, always enqueue STAs at the
+ 		 * head of the list to ensure that they only get moved to the
+ 		 * back by the airtime DRR scheduler once they have a negative
+@@ -3727,7 +3729,7 @@ void ieee80211_schedule_txq(struct ieee8
+ 
+ 	spin_unlock_bh(&local->active_txq_lock[txq->ac]);
+ }
+-EXPORT_SYMBOL(ieee80211_schedule_txq);
++EXPORT_SYMBOL(__ieee80211_schedule_txq);
+ 
+ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
+ 				struct ieee80211_txq *txq)
diff -uprN a/package/kernel/mac80211/patches/subsys/359-mac80211-un-schedule-TXQs-on-powersave-start.patch b/package/kernel/mac80211/patches/subsys/359-mac80211-un-schedule-TXQs-on-powersave-start.patch
--- a/package/kernel/mac80211/patches/subsys/359-mac80211-un-schedule-TXQs-on-powersave-start.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/359-mac80211-un-schedule-TXQs-on-powersave-start.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,31 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 19 Mar 2019 11:36:12 +0100
+Subject: [PATCH] mac80211: un-schedule TXQs on powersave start
+
+Once a station enters powersave, its queues should not be returned by
+ieee80211_next_txq() anymore. They will be re-scheduled again after the
+station has woken up again
+
+Fixes: 1866760096bf4 ("mac80211: Add TXQ scheduling API")
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -1507,7 +1507,15 @@ static void sta_ps_start(struct sta_info
+ 		return;
+ 
+ 	for (tid = 0; tid < ARRAY_SIZE(sta->sta.txq); tid++) {
+-		if (txq_has_queue(sta->sta.txq[tid]))
++		struct ieee80211_txq *txq = sta->sta.txq[tid];
++		struct txq_info *txqi = to_txq_info(txq);
++
++		spin_lock(&local->active_txq_lock[txq->ac]);
++		if (!list_empty(&txqi->schedule_order))
++			list_del_init(&txqi->schedule_order);
++		spin_unlock(&local->active_txq_lock[txq->ac]);
++
++		if (txq_has_queue(txq))
+ 			set_bit(tid, &sta->txq_buffered_tids);
+ 		else
+ 			clear_bit(tid, &sta->txq_buffered_tids);
diff -uprN a/package/kernel/mac80211/patches/subsys/360-mac80211-when-using-iTXQ-select-the-queue-in-ieee802.patch b/package/kernel/mac80211/patches/subsys/360-mac80211-when-using-iTXQ-select-the-queue-in-ieee802.patch
--- a/package/kernel/mac80211/patches/subsys/360-mac80211-when-using-iTXQ-select-the-queue-in-ieee802.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/360-mac80211-when-using-iTXQ-select-the-queue-in-ieee802.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,183 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Fri, 22 Mar 2019 18:06:03 +0100
+Subject: [PATCH] mac80211: when using iTXQ, select the queue in
+ ieee80211_subif_start_xmit
+
+When using iTXQ, the network stack does not need the real queue number, since
+mac80211 is using its internal queues anyway. In that case we can defer
+selecting the queue and remove a redundant station lookup in the tx path to save
+some CPU cycles.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -3797,6 +3797,7 @@ void __ieee80211_subif_start_xmit(struct
+ 				  u32 ctrl_flags)
+ {
+ 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
++	struct ieee80211_local *local = sdata->local;
+ 	struct sta_info *sta;
+ 	struct sk_buff *next;
+ 
+@@ -3810,7 +3811,15 @@ void __ieee80211_subif_start_xmit(struct
+ 	if (ieee80211_lookup_ra_sta(sdata, skb, &sta))
+ 		goto out_free;
+ 
+-	if (!IS_ERR_OR_NULL(sta)) {
++	if (IS_ERR(sta))
++		sta = NULL;
++
++	if (local->ops->wake_tx_queue) {
++		u16 queue = __ieee80211_select_queue(sdata, sta, skb);
++		skb_set_queue_mapping(skb, queue);
++	}
++
++	if (sta) {
+ 		struct ieee80211_fast_tx *fast_tx;
+ 
+ 		/* We need a bit of data queued to build aggregates properly, so
+--- a/net/mac80211/wme.c
++++ b/net/mac80211/wme.c
+@@ -141,6 +141,42 @@ u16 ieee80211_select_queue_80211(struct
+ 	return ieee80211_downgrade_queue(sdata, NULL, skb);
+ }
+ 
++u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
++			     struct sta_info *sta, struct sk_buff *skb)
++{
++	struct mac80211_qos_map *qos_map;
++	bool qos;
++
++	/* all mesh/ocb stations are required to support WME */
++	if (sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||
++	    sdata->vif.type == NL80211_IFTYPE_OCB)
++		qos = true;
++	else if (sta)
++		qos = sta->sta.wme;
++	else
++		qos = false;
++
++	if (!qos) {
++		skb->priority = 0; /* required for correct WPA/11i MIC */
++		return IEEE80211_AC_BE;
++	}
++
++	if (skb->protocol == sdata->control_port_protocol) {
++		skb->priority = 7;
++		goto downgrade;
++	}
++
++	/* use the data classifier to determine what 802.1d tag the
++	 * data frame has */
++	qos_map = rcu_dereference(sdata->qos_map);
++	skb->priority = cfg80211_classify8021d(skb, qos_map ?
++					       &qos_map->qos_map : NULL);
++
++ downgrade:
++	return ieee80211_downgrade_queue(sdata, sta, skb);
++}
++
++
+ /* Indicate which queue to use. */
+ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+ 			   struct sk_buff *skb)
+@@ -148,10 +184,12 @@ u16 ieee80211_select_queue(struct ieee80
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct sta_info *sta = NULL;
+ 	const u8 *ra = NULL;
+-	bool qos = false;
+-	struct mac80211_qos_map *qos_map;
+ 	u16 ret;
+ 
++	/* when using iTXQ, we can do this later */
++	if (local->ops->wake_tx_queue)
++		return 0;
++
+ 	if (local->hw.queues < IEEE80211_NUM_ACS || skb->len < 6) {
+ 		skb->priority = 0; /* required for correct WPA/11i MIC */
+ 		return 0;
+@@ -161,10 +199,8 @@ u16 ieee80211_select_queue(struct ieee80
+ 	switch (sdata->vif.type) {
+ 	case NL80211_IFTYPE_AP_VLAN:
+ 		sta = rcu_dereference(sdata->u.vlan.sta);
+-		if (sta) {
+-			qos = sta->sta.wme;
++		if (sta)
+ 			break;
+-		}
+ 		/* fall through */
+ 	case NL80211_IFTYPE_AP:
+ 		ra = skb->data;
+@@ -172,56 +208,26 @@ u16 ieee80211_select_queue(struct ieee80
+ 	case NL80211_IFTYPE_WDS:
+ 		ra = sdata->u.wds.remote_addr;
+ 		break;
+-#ifdef CPTCFG_MAC80211_MESH
+-	case NL80211_IFTYPE_MESH_POINT:
+-		qos = true;
+-		break;
+-#endif
+ 	case NL80211_IFTYPE_STATION:
+ 		/* might be a TDLS station */
+ 		sta = sta_info_get(sdata, skb->data);
+ 		if (sta)
+-			qos = sta->sta.wme;
++			break;
+ 
+ 		ra = sdata->u.mgd.bssid;
+ 		break;
+ 	case NL80211_IFTYPE_ADHOC:
+ 		ra = skb->data;
+ 		break;
+-	case NL80211_IFTYPE_OCB:
+-		/* all stations are required to support WME */
+-		qos = true;
+-		break;
+ 	default:
+ 		break;
+ 	}
+ 
+-	if (!sta && ra && !is_multicast_ether_addr(ra)) {
++	if (!sta && ra && !is_multicast_ether_addr(ra))
+ 		sta = sta_info_get(sdata, ra);
+-		if (sta)
+-			qos = sta->sta.wme;
+-	}
+ 
+-	if (!qos) {
+-		skb->priority = 0; /* required for correct WPA/11i MIC */
+-		ret = IEEE80211_AC_BE;
+-		goto out;
+-	}
++	ret = __ieee80211_select_queue(sdata, sta, skb);
+ 
+-	if (skb->protocol == sdata->control_port_protocol) {
+-		skb->priority = 7;
+-		goto downgrade;
+-	}
+-
+-	/* use the data classifier to determine what 802.1d tag the
+-	 * data frame has */
+-	qos_map = rcu_dereference(sdata->qos_map);
+-	skb->priority = cfg80211_classify8021d(skb, qos_map ?
+-					       &qos_map->qos_map : NULL);
+-
+- downgrade:
+-	ret = ieee80211_downgrade_queue(sdata, sta, skb);
+- out:
+ 	rcu_read_unlock();
+ 	return ret;
+ }
+--- a/net/mac80211/wme.h
++++ b/net/mac80211/wme.h
+@@ -16,6 +16,8 @@
+ u16 ieee80211_select_queue_80211(struct ieee80211_sub_if_data *sdata,
+ 				 struct sk_buff *skb,
+ 				 struct ieee80211_hdr *hdr);
++u16 __ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
++			     struct sta_info *sta, struct sk_buff *skb);
+ u16 ieee80211_select_queue(struct ieee80211_sub_if_data *sdata,
+ 			   struct sk_buff *skb);
+ void ieee80211_set_qos_hdr(struct ieee80211_sub_if_data *sdata,
diff -uprN a/package/kernel/mac80211/patches/subsys/361-mac80211-add-IEEE80211_KEY_FLAG_GENERATE_MMIE-to-iee.patch b/package/kernel/mac80211/patches/subsys/361-mac80211-add-IEEE80211_KEY_FLAG_GENERATE_MMIE-to-iee.patch
--- a/package/kernel/mac80211/patches/subsys/361-mac80211-add-IEEE80211_KEY_FLAG_GENERATE_MMIE-to-iee.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/361-mac80211-add-IEEE80211_KEY_FLAG_GENERATE_MMIE-to-iee.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,58 @@
+From: Lorenzo Bianconi <lorenzo@kernel.org>
+Date: Tue, 16 Jul 2019 00:09:19 +0200
+Subject: [PATCH] mac80211: add IEEE80211_KEY_FLAG_GENERATE_MMIE to
+ ieee80211_key_flags
+
+Add IEEE80211_KEY_FLAG_GENERATE_MMIE flag to ieee80211_key_flags in order
+to allow the driver to notify mac80211 to generate MMIE and that it
+requires sequence number generation only.
+This is a preliminary patch to add BIP_CMAC_128 hw support to mt7615
+driver
+
+Signed-off-by: Lorenzo Bianconi <lorenzo@kernel.org>
+Link: https://lore.kernel.org/r/dfe275f9aa0f1cc6b33085f9efd5d8447f68ad13.1563228405.git.lorenzo@kernel.org
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -1616,6 +1616,9 @@ struct wireless_dev *ieee80211_vif_to_wd
+  * @IEEE80211_KEY_FLAG_PUT_MIC_SPACE: This flag should be set by the driver for
+  *	a TKIP key if it only requires MIC space. Do not set together with
+  *	@IEEE80211_KEY_FLAG_GENERATE_MMIC on the same key.
++ * @IEEE80211_KEY_FLAG_GENERATE_MMIE: This flag should be set by the driver
++ *	for a AES_CMAC key to indicate that it requires sequence number
++ *	generation only
+  */
+ enum ieee80211_key_flags {
+ 	IEEE80211_KEY_FLAG_GENERATE_IV_MGMT	= BIT(0),
+@@ -1627,6 +1630,7 @@ enum ieee80211_key_flags {
+ 	IEEE80211_KEY_FLAG_RX_MGMT		= BIT(6),
+ 	IEEE80211_KEY_FLAG_RESERVE_TAILROOM	= BIT(7),
+ 	IEEE80211_KEY_FLAG_PUT_MIC_SPACE	= BIT(8),
++	IEEE80211_KEY_FLAG_GENERATE_MMIE	= BIT(10),
+ };
+ 
+ /**
+--- a/net/mac80211/wpa.c
++++ b/net/mac80211/wpa.c
+@@ -952,7 +952,8 @@ ieee80211_crypto_aes_cmac_encrypt(struct
+ 
+ 	info = IEEE80211_SKB_CB(skb);
+ 
+-	if (info->control.hw_key)
++	if (info->control.hw_key &&
++	    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIE))
+ 		return TX_CONTINUE;
+ 
+ 	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
+@@ -968,6 +969,9 @@ ieee80211_crypto_aes_cmac_encrypt(struct
+ 
+ 	bip_ipn_set64(mmie->sequence_number, pn64);
+ 
++	if (info->control.hw_key)
++		return TX_CONTINUE;
++
+ 	bip_aad(skb, aad);
+ 
+ 	/*
diff -uprN a/package/kernel/mac80211/patches/subsys/362-mac80211-minstrel-remove-divisions-in-tx-status-path.patch b/package/kernel/mac80211/patches/subsys/362-mac80211-minstrel-remove-divisions-in-tx-status-path.patch
--- a/package/kernel/mac80211/patches/subsys/362-mac80211-minstrel-remove-divisions-in-tx-status-path.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/362-mac80211-minstrel-remove-divisions-in-tx-status-path.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,61 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 28 Sep 2019 15:44:06 +0200
+Subject: [PATCH] mac80211: minstrel: remove divisions in tx status path
+
+Use a slightly different threshold for downgrading spatial streams to
+make it easier to calculate without divisions.
+Slightly reduces CPU overhead.
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel.c
++++ b/net/mac80211/rc80211_minstrel.c
+@@ -289,8 +289,7 @@ minstrel_tx_status(void *priv, struct ie
+ 			mi->r[ndx].stats.success += success;
+ 	}
+ 
+-	if (time_after(jiffies, mi->last_stats_update +
+-				(mp->update_interval * HZ) / 1000))
++	if (time_after(jiffies, mi->last_stats_update + mp->update_interval))
+ 		minstrel_update_stats(mp, mi);
+ }
+ 
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -937,23 +937,21 @@ minstrel_ht_tx_status(void *priv, struct
+ 		 */
+ 		rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
+ 		if (rate->attempts > 30 &&
+-		    MINSTREL_FRAC(rate->success, rate->attempts) <
+-		    MINSTREL_FRAC(20, 100)) {
++		    rate->success < rate->attempts / 4) {
+ 			minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
+ 			update = true;
+ 		}
+ 
+ 		rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
+ 		if (rate2->attempts > 30 &&
+-		    MINSTREL_FRAC(rate2->success, rate2->attempts) <
+-		    MINSTREL_FRAC(20, 100)) {
++		    rate2->success < rate2->attempts / 4) {
+ 			minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
+ 			update = true;
+ 		}
+ 	}
+ 
+ 	if (time_after(jiffies, mi->last_stats_update +
+-				(mp->update_interval / 2 * HZ) / 1000)) {
++				mp->update_interval / 2)) {
+ 		update = true;
+ 		minstrel_ht_update_stats(mp, mi, true);
+ 	}
+@@ -1640,7 +1638,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
+ 		mp->has_mrr = true;
+ 
+ 	mp->hw = hw;
+-	mp->update_interval = 100;
++	mp->update_interval = HZ / 10;
+ 
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+ 	mp->fixed_rate_idx = (u32) -1;
diff -uprN a/package/kernel/mac80211/patches/subsys/363-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch b/package/kernel/mac80211/patches/subsys/363-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch
--- a/package/kernel/mac80211/patches/subsys/363-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/363-mac80211-minstrel_ht-replace-rate-stats-ewma-with-a-.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,235 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Sat, 28 Sep 2019 15:46:06 +0200
+Subject: [PATCH] mac80211: minstrel_ht: replace rate stats ewma with a
+ better moving average
+
+Rate success probability usually fluctuates a lot under normal conditions.
+With a simple EWMA, noise and fluctuation can be reduced by increasing the
+window length, but that comes at the cost of introducing lag on sudden
+changes.
+
+This change replaces the EWMA implementation with a moving average that's
+designed to significantly reduce lag while keeping a bigger window size
+by being better at filtering out noise.
+
+It is only slightly more expensive than the simple EWMA and still avoids
+divisions in its calculation.
+
+The algorithm is adapted from an implementation intended for a completely
+different field (stock market trading), where the tradeoff of lag vs
+noise filtering is equally important.
+
+The algorithm works in the same way as the "smoothing filter" from
+http://www.stockspotter.com/files/PredictiveIndicators.pdf adapted for
+fixed-point math with some constants, using only addition, bit shifts
+and multiplication
+
+To better make use of the filtering and bigger window size, the update
+interval is cut in half.
+
+For testing, the algorithm can be reverted to the older one via debugfs
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel.c
++++ b/net/mac80211/rc80211_minstrel.c
+@@ -157,14 +157,18 @@ minstrel_update_rates(struct minstrel_pr
+ * Recalculate statistics and counters of a given rate
+ */
+ void
+-minstrel_calc_rate_stats(struct minstrel_rate_stats *mrs)
++minstrel_calc_rate_stats(struct minstrel_priv *mp,
++			 struct minstrel_rate_stats *mrs)
+ {
+ 	unsigned int cur_prob;
+ 
+ 	if (unlikely(mrs->attempts > 0)) {
+ 		mrs->sample_skipped = 0;
+ 		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
+-		if (unlikely(!mrs->att_hist)) {
++		if (mp->new_avg) {
++			mrs->prob_ewma = minstrel_filter_avg_add(&mrs->avg,
++								 cur_prob);
++		} else if (unlikely(!mrs->att_hist)) {
+ 			mrs->prob_ewma = cur_prob;
+ 		} else {
+ 			/* update exponential weighted moving variance */
+@@ -206,7 +210,7 @@ minstrel_update_stats(struct minstrel_pr
+ 		struct minstrel_rate_stats *tmp_mrs = &mi->r[tmp_prob_rate].stats;
+ 
+ 		/* Update statistics of success probability per rate */
+-		minstrel_calc_rate_stats(mrs);
++		minstrel_calc_rate_stats(mp, mrs);
+ 
+ 		/* Sample less often below the 10% chance of success.
+ 		 * Sample less often above the 95% chance of success. */
+@@ -289,7 +293,8 @@ minstrel_tx_status(void *priv, struct ie
+ 			mi->r[ndx].stats.success += success;
+ 	}
+ 
+-	if (time_after(jiffies, mi->last_stats_update + mp->update_interval))
++	if (time_after(jiffies, mi->last_stats_update +
++				mp->update_interval / (mp->new_avg ? 2 : 1)))
+ 		minstrel_update_stats(mp, mi);
+ }
+ 
+--- a/net/mac80211/rc80211_minstrel.h
++++ b/net/mac80211/rc80211_minstrel.h
+@@ -22,6 +22,21 @@
+ #define MAX_THR_RATES 4
+ 
+ /*
++ * Coefficients for moving average with noise filter (period=16),
++ * scaled by 10 bits
++ *
++ * a1 = exp(-pi * sqrt(2) / period)
++ * coeff2 = 2 * a1 * cos(sqrt(2) * 2 * pi / period)
++ * coeff3 = -sqr(a1)
++ * coeff1 = 1 - coeff2 - coeff3
++ */
++#define MINSTREL_AVG_COEFF1		(MINSTREL_FRAC(1, 1) - \
++					 MINSTREL_AVG_COEFF2 - \
++					 MINSTREL_AVG_COEFF3)
++#define MINSTREL_AVG_COEFF2		0x00001499
++#define MINSTREL_AVG_COEFF3		-0x0000092e
++
++/*
+  * Perform EWMA (Exponentially Weighted Moving Average) calculation
+  */
+ static inline int
+@@ -48,6 +63,41 @@ minstrel_ewmv(int old_ewmv, int cur_prob
+ 	return weight * (old_ewmv + MINSTREL_TRUNC(diff * incr)) / EWMA_DIV;
+ }
+ 
++struct minstrel_avg_ctx {
++	s32 prev[2];
++};
++
++static inline int minstrel_filter_avg_add(struct minstrel_avg_ctx *ctx, s32 in)
++{
++	s32 out_1 = ctx->prev[0];
++	s32 out_2 = ctx->prev[1];
++	s32 val;
++
++	if (!in)
++		in += 1;
++
++	if (!out_1) {
++		val = out_1 = in;
++		goto out;
++	}
++
++	val = MINSTREL_AVG_COEFF1 * in;
++	val += MINSTREL_AVG_COEFF2 * out_1;
++	val += MINSTREL_AVG_COEFF3 * out_2;
++	val >>= MINSTREL_SCALE;
++
++	if (val > 1 << MINSTREL_SCALE)
++		val = 1 << MINSTREL_SCALE;
++	if (val < 0)
++		val = 1;
++
++out:
++	ctx->prev[1] = out_1;
++	ctx->prev[0] = val;
++
++	return val;
++}
++
+ struct minstrel_rate_stats {
+ 	/* current / last sampling period attempts/success counters */
+ 	u16 attempts, last_attempts;
+@@ -56,6 +106,8 @@ struct minstrel_rate_stats {
+ 	/* total attempts/success counters */
+ 	u32 att_hist, succ_hist;
+ 
++	struct minstrel_avg_ctx avg;
++
+ 	/* statistis of packet delivery probability
+ 	 *  prob_ewma - exponential weighted moving average of prob
+ 	 *  prob_ewmsd - exp. weighted moving standard deviation of prob */
+@@ -113,6 +165,7 @@ struct minstrel_sta_info {
+ struct minstrel_priv {
+ 	struct ieee80211_hw *hw;
+ 	bool has_mrr;
++	bool new_avg;
+ 	u32 sample_switch;
+ 	unsigned int cw_min;
+ 	unsigned int cw_max;
+@@ -152,7 +205,8 @@ extern const struct rate_control_ops mac
+ void minstrel_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+ 
+ /* Recalculate success probabilities and counters for a given rate using EWMA */
+-void minstrel_calc_rate_stats(struct minstrel_rate_stats *mrs);
++void minstrel_calc_rate_stats(struct minstrel_priv *mp,
++			      struct minstrel_rate_stats *mrs);
+ int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma);
+ 
+ /* debugfs */
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -704,7 +704,7 @@ minstrel_ht_update_stats(struct minstrel
+ 
+ 			mrs = &mg->rates[i];
+ 			mrs->retry_updated = false;
+-			minstrel_calc_rate_stats(mrs);
++			minstrel_calc_rate_stats(mp, mrs);
+ 			cur_prob = mrs->prob_ewma;
+ 
+ 			if (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)
+@@ -740,6 +740,8 @@ minstrel_ht_update_stats(struct minstrel
+ 
+ 	/* try to sample all available rates during each interval */
+ 	mi->sample_count *= 8;
++	if (mp->new_avg)
++		mi->sample_count /= 2;
+ 
+ 	if (sample)
+ 		minstrel_ht_rate_sample_switch(mp, mi);
+@@ -856,6 +858,7 @@ minstrel_ht_tx_status(void *priv, struct
+ 	struct ieee80211_tx_rate *ar = info->status.rates;
+ 	struct minstrel_rate_stats *rate, *rate2, *rate_sample = NULL;
+ 	struct minstrel_priv *mp = priv;
++	u32 update_interval = mp->update_interval / 2;
+ 	bool last, update = false;
+ 	bool sample_status = false;
+ 	int i;
+@@ -910,6 +913,10 @@ minstrel_ht_tx_status(void *priv, struct
+ 
+ 	switch (mi->sample_mode) {
+ 	case MINSTREL_SAMPLE_IDLE:
++		if (mp->new_avg &&
++		    (mp->hw->max_rates > 1 ||
++		     mi->total_packets_cur < SAMPLE_SWITCH_THR))
++			update_interval /= 2;
+ 		break;
+ 
+ 	case MINSTREL_SAMPLE_ACTIVE:
+@@ -950,8 +957,7 @@ minstrel_ht_tx_status(void *priv, struct
+ 		}
+ 	}
+ 
+-	if (time_after(jiffies, mi->last_stats_update +
+-				mp->update_interval / 2)) {
++	if (time_after(jiffies, mi->last_stats_update + update_interval)) {
+ 		update = true;
+ 		minstrel_ht_update_stats(mp, mi, true);
+ 	}
+@@ -1639,6 +1645,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
+ 
+ 	mp->hw = hw;
+ 	mp->update_interval = HZ / 10;
++	mp->new_avg = true;
+ 
+ #ifdef CPTCFG_MAC80211_DEBUGFS
+ 	mp->fixed_rate_idx = (u32) -1;
+@@ -1646,6 +1653,8 @@ minstrel_ht_alloc(struct ieee80211_hw *h
+ 			   &mp->fixed_rate_idx);
+ 	debugfs_create_u32("sample_switch", S_IRUGO | S_IWUSR, debugfsdir,
+ 			   &mp->sample_switch);
++	debugfs_create_bool("new_avg", S_IRUGO | S_IWUSR, debugfsdir,
++			   &mp->new_avg);
+ #endif
+ 
+ 	minstrel_ht_init_cck_rates(mp);
diff -uprN a/package/kernel/mac80211/patches/subsys/364-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch b/package/kernel/mac80211/patches/subsys/364-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch
--- a/package/kernel/mac80211/patches/subsys/364-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/364-mac80211-minstrel_ht-rename-prob_ewma-to-prob_avg-us.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,437 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Tue, 8 Oct 2019 18:54:46 +0200
+Subject: [PATCH] mac80211: minstrel_ht: rename prob_ewma to prob_avg, use it
+ for the new average
+
+Reduces per-rate data structure size
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/net/mac80211/rc80211_minstrel.c
++++ b/net/mac80211/rc80211_minstrel.c
+@@ -70,7 +70,7 @@ rix_to_ndx(struct minstrel_sta_info *mi,
+ }
+ 
+ /* return current EMWA throughput */
+-int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma)
++int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_avg)
+ {
+ 	int usecs;
+ 
+@@ -79,13 +79,13 @@ int minstrel_get_tp_avg(struct minstrel_
+ 		usecs = 1000000;
+ 
+ 	/* reset thr. below 10% success */
+-	if (mr->stats.prob_ewma < MINSTREL_FRAC(10, 100))
++	if (mr->stats.prob_avg < MINSTREL_FRAC(10, 100))
+ 		return 0;
+ 
+-	if (prob_ewma > MINSTREL_FRAC(90, 100))
++	if (prob_avg > MINSTREL_FRAC(90, 100))
+ 		return MINSTREL_TRUNC(100000 * (MINSTREL_FRAC(90, 100) / usecs));
+ 	else
+-		return MINSTREL_TRUNC(100000 * (prob_ewma / usecs));
++		return MINSTREL_TRUNC(100000 * (prob_avg / usecs));
+ }
+ 
+ /* find & sort topmost throughput rates */
+@@ -98,8 +98,8 @@ minstrel_sort_best_tp_rates(struct minst
+ 
+ 	for (j = MAX_THR_RATES; j > 0; --j) {
+ 		tmp_mrs = &mi->r[tp_list[j - 1]].stats;
+-		if (minstrel_get_tp_avg(&mi->r[i], cur_mrs->prob_ewma) <=
+-		    minstrel_get_tp_avg(&mi->r[tp_list[j - 1]], tmp_mrs->prob_ewma))
++		if (minstrel_get_tp_avg(&mi->r[i], cur_mrs->prob_avg) <=
++		    minstrel_get_tp_avg(&mi->r[tp_list[j - 1]], tmp_mrs->prob_avg))
+ 			break;
+ 	}
+ 
+@@ -166,21 +166,21 @@ minstrel_calc_rate_stats(struct minstrel
+ 		mrs->sample_skipped = 0;
+ 		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
+ 		if (mp->new_avg) {
+-			mrs->prob_ewma = minstrel_filter_avg_add(&mrs->avg,
+-								 cur_prob);
++			minstrel_filter_avg_add(&mrs->prob_avg,
++						&mrs->prob_avg_1, cur_prob);
+ 		} else if (unlikely(!mrs->att_hist)) {
+-			mrs->prob_ewma = cur_prob;
++			mrs->prob_avg = cur_prob;
+ 		} else {
+ 			/* update exponential weighted moving variance */
+ 			mrs->prob_ewmv = minstrel_ewmv(mrs->prob_ewmv,
+ 							cur_prob,
+-							mrs->prob_ewma,
++							mrs->prob_avg,
+ 							EWMA_LEVEL);
+ 
+ 			/*update exponential weighted moving avarage */
+-			mrs->prob_ewma = minstrel_ewma(mrs->prob_ewma,
+-						       cur_prob,
+-						       EWMA_LEVEL);
++			mrs->prob_avg = minstrel_ewma(mrs->prob_avg,
++							cur_prob,
++							EWMA_LEVEL);
+ 		}
+ 		mrs->att_hist += mrs->attempts;
+ 		mrs->succ_hist += mrs->success;
+@@ -214,8 +214,8 @@ minstrel_update_stats(struct minstrel_pr
+ 
+ 		/* Sample less often below the 10% chance of success.
+ 		 * Sample less often above the 95% chance of success. */
+-		if (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||
+-		    mrs->prob_ewma < MINSTREL_FRAC(10, 100)) {
++		if (mrs->prob_avg > MINSTREL_FRAC(95, 100) ||
++		    mrs->prob_avg < MINSTREL_FRAC(10, 100)) {
+ 			mr->adjusted_retry_count = mrs->retry_count >> 1;
+ 			if (mr->adjusted_retry_count > 2)
+ 				mr->adjusted_retry_count = 2;
+@@ -235,14 +235,14 @@ minstrel_update_stats(struct minstrel_pr
+ 		 * choose the maximum throughput rate as max_prob_rate
+ 		 * (2) if all success probabilities < 95%, the rate with
+ 		 * highest success probability is chosen as max_prob_rate */
+-		if (mrs->prob_ewma >= MINSTREL_FRAC(95, 100)) {
+-			tmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_ewma);
++		if (mrs->prob_avg >= MINSTREL_FRAC(95, 100)) {
++			tmp_cur_tp = minstrel_get_tp_avg(mr, mrs->prob_avg);
+ 			tmp_prob_tp = minstrel_get_tp_avg(&mi->r[tmp_prob_rate],
+-							  tmp_mrs->prob_ewma);
++							  tmp_mrs->prob_avg);
+ 			if (tmp_cur_tp >= tmp_prob_tp)
+ 				tmp_prob_rate = i;
+ 		} else {
+-			if (mrs->prob_ewma >= tmp_mrs->prob_ewma)
++			if (mrs->prob_avg >= tmp_mrs->prob_avg)
+ 				tmp_prob_rate = i;
+ 		}
+ 	}
+@@ -418,7 +418,7 @@ minstrel_get_rate(void *priv, struct iee
+ 	 * has a probability of >95%, we shouldn't be attempting
+ 	 * to use it, as this only wastes precious airtime */
+ 	if (!mrr_capable &&
+-	   (mi->r[ndx].stats.prob_ewma > MINSTREL_FRAC(95, 100)))
++	   (mi->r[ndx].stats.prob_avg > MINSTREL_FRAC(95, 100)))
+ 		return;
+ 
+ 	mi->prev_sample = true;
+@@ -570,7 +570,7 @@ static u32 minstrel_get_expected_through
+ 	 * computing cur_tp
+ 	 */
+ 	tmp_mrs = &mi->r[idx].stats;
+-	tmp_cur_tp = minstrel_get_tp_avg(&mi->r[idx], tmp_mrs->prob_ewma) * 10;
++	tmp_cur_tp = minstrel_get_tp_avg(&mi->r[idx], tmp_mrs->prob_avg) * 10;
+ 	tmp_cur_tp = tmp_cur_tp * 1200 * 8 / 1024;
+ 
+ 	return tmp_cur_tp;
+--- a/net/mac80211/rc80211_minstrel.h
++++ b/net/mac80211/rc80211_minstrel.h
+@@ -63,14 +63,10 @@ minstrel_ewmv(int old_ewmv, int cur_prob
+ 	return weight * (old_ewmv + MINSTREL_TRUNC(diff * incr)) / EWMA_DIV;
+ }
+ 
+-struct minstrel_avg_ctx {
+-	s32 prev[2];
+-};
+-
+-static inline int minstrel_filter_avg_add(struct minstrel_avg_ctx *ctx, s32 in)
++static inline int minstrel_filter_avg_add(u16 *prev_1, u16 *prev_2, s32 in)
+ {
+-	s32 out_1 = ctx->prev[0];
+-	s32 out_2 = ctx->prev[1];
++	s32 out_1 = *prev_1;
++	s32 out_2 = *prev_2;
+ 	s32 val;
+ 
+ 	if (!in)
+@@ -92,8 +88,8 @@ static inline int minstrel_filter_avg_ad
+ 		val = 1;
+ 
+ out:
+-	ctx->prev[1] = out_1;
+-	ctx->prev[0] = val;
++	*prev_2 = out_1;
++	*prev_1 = val;
+ 
+ 	return val;
+ }
+@@ -106,14 +102,15 @@ struct minstrel_rate_stats {
+ 	/* total attempts/success counters */
+ 	u32 att_hist, succ_hist;
+ 
+-	struct minstrel_avg_ctx avg;
+-
+ 	/* statistis of packet delivery probability
+ 	 *  prob_ewma - exponential weighted moving average of prob
+ 	 *  prob_ewmsd - exp. weighted moving standard deviation of prob */
+-	u16 prob_ewma;
+ 	u16 prob_ewmv;
+ 
++	/* prob_avg - moving average of prob */
++	u16 prob_avg;
++	u16 prob_avg_1;
++
+ 	/* maximum retry counts */
+ 	u8 retry_count;
+ 	u8 retry_count_rtscts;
+@@ -207,7 +204,7 @@ void minstrel_add_sta_debugfs(void *priv
+ /* Recalculate success probabilities and counters for a given rate using EWMA */
+ void minstrel_calc_rate_stats(struct minstrel_priv *mp,
+ 			      struct minstrel_rate_stats *mrs);
+-int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_ewma);
++int minstrel_get_tp_avg(struct minstrel_rate *mr, int prob_avg);
+ 
+ /* debugfs */
+ int minstrel_stats_open(struct inode *inode, struct file *file);
+--- a/net/mac80211/rc80211_minstrel_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_debugfs.c
+@@ -91,8 +91,9 @@ minstrel_stats_open(struct inode *inode,
+ 		p += sprintf(p, "%6u ", mr->perfect_tx_time);
+ 
+ 		tp_max = minstrel_get_tp_avg(mr, MINSTREL_FRAC(100,100));
+-		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_ewma);
+-		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
++		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_avg);
++		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
++
+ 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+ 
+ 		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u    %3u.%1u"
+@@ -151,8 +152,8 @@ minstrel_stats_csv_open(struct inode *in
+ 		p += sprintf(p, "%u,",mr->perfect_tx_time);
+ 
+ 		tp_max = minstrel_get_tp_avg(mr, MINSTREL_FRAC(100,100));
+-		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_ewma);
+-		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
++		tp_avg = minstrel_get_tp_avg(mr, mrs->prob_avg);
++		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
+ 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+ 
+ 		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,%u,"
+--- a/net/mac80211/rc80211_minstrel_ht.c
++++ b/net/mac80211/rc80211_minstrel_ht.c
+@@ -313,12 +313,12 @@ minstrel_ht_avg_ampdu_len(struct minstre
+  */
+ int
+ minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
+-		       int prob_ewma)
++		       int prob_avg)
+ {
+ 	unsigned int nsecs = 0;
+ 
+ 	/* do not account throughput if sucess prob is below 10% */
+-	if (prob_ewma < MINSTREL_FRAC(10, 100))
++	if (prob_avg < MINSTREL_FRAC(10, 100))
+ 		return 0;
+ 
+ 	if (group != MINSTREL_CCK_GROUP)
+@@ -332,11 +332,11 @@ minstrel_ht_get_tp_avg(struct minstrel_h
+ 	 * account for collision related packet error rate fluctuation
+ 	 * (prob is scaled - see MINSTREL_FRAC above)
+ 	 */
+-	if (prob_ewma > MINSTREL_FRAC(90, 100))
++	if (prob_avg > MINSTREL_FRAC(90, 100))
+ 		return MINSTREL_TRUNC(100000 * ((MINSTREL_FRAC(90, 100) * 1000)
+ 								      / nsecs));
+ 	else
+-		return MINSTREL_TRUNC(100000 * ((prob_ewma * 1000) / nsecs));
++		return MINSTREL_TRUNC(100000 * ((prob_avg * 1000) / nsecs));
+ }
+ 
+ /*
+@@ -356,13 +356,13 @@ minstrel_ht_sort_best_tp_rates(struct mi
+ 
+ 	cur_group = index / MCS_GROUP_RATES;
+ 	cur_idx = index  % MCS_GROUP_RATES;
+-	cur_prob = mi->groups[cur_group].rates[cur_idx].prob_ewma;
++	cur_prob = mi->groups[cur_group].rates[cur_idx].prob_avg;
+ 	cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx, cur_prob);
+ 
+ 	do {
+ 		tmp_group = tp_list[j - 1] / MCS_GROUP_RATES;
+ 		tmp_idx = tp_list[j - 1] % MCS_GROUP_RATES;
+-		tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
++		tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
+ 		tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx,
+ 						    tmp_prob);
+ 		if (cur_tp_avg < tmp_tp_avg ||
+@@ -399,7 +399,7 @@ minstrel_ht_set_best_prob_rate(struct mi
+ 
+ 	tmp_group = mi->max_prob_rate / MCS_GROUP_RATES;
+ 	tmp_idx = mi->max_prob_rate % MCS_GROUP_RATES;
+-	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
++	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
+ 	tmp_tp_avg = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
+ 
+ 	/* if max_tp_rate[0] is from MCS_GROUP max_prob_rate get selected from
+@@ -411,11 +411,11 @@ minstrel_ht_set_best_prob_rate(struct mi
+ 
+ 	max_gpr_group = mg->max_group_prob_rate / MCS_GROUP_RATES;
+ 	max_gpr_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
+-	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_ewma;
++	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
+ 
+-	if (mrs->prob_ewma > MINSTREL_FRAC(75, 100)) {
++	if (mrs->prob_avg > MINSTREL_FRAC(75, 100)) {
+ 		cur_tp_avg = minstrel_ht_get_tp_avg(mi, cur_group, cur_idx,
+-						    mrs->prob_ewma);
++						    mrs->prob_avg);
+ 		if (cur_tp_avg > tmp_tp_avg)
+ 			mi->max_prob_rate = index;
+ 
+@@ -425,9 +425,9 @@ minstrel_ht_set_best_prob_rate(struct mi
+ 		if (cur_tp_avg > max_gpr_tp_avg)
+ 			mg->max_group_prob_rate = index;
+ 	} else {
+-		if (mrs->prob_ewma > tmp_prob)
++		if (mrs->prob_avg > tmp_prob)
+ 			mi->max_prob_rate = index;
+-		if (mrs->prob_ewma > max_gpr_prob)
++		if (mrs->prob_avg > max_gpr_prob)
+ 			mg->max_group_prob_rate = index;
+ 	}
+ }
+@@ -449,12 +449,12 @@ minstrel_ht_assign_best_tp_rates(struct
+ 
+ 	tmp_group = tmp_cck_tp_rate[0] / MCS_GROUP_RATES;
+ 	tmp_idx = tmp_cck_tp_rate[0] % MCS_GROUP_RATES;
+-	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
++	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
+ 	tmp_cck_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
+ 
+ 	tmp_group = tmp_mcs_tp_rate[0] / MCS_GROUP_RATES;
+ 	tmp_idx = tmp_mcs_tp_rate[0] % MCS_GROUP_RATES;
+-	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_ewma;
++	tmp_prob = mi->groups[tmp_group].rates[tmp_idx].prob_avg;
+ 	tmp_mcs_tp = minstrel_ht_get_tp_avg(mi, tmp_group, tmp_idx, tmp_prob);
+ 
+ 	if (tmp_cck_tp_rate && tmp_cck_tp > tmp_mcs_tp) {
+@@ -485,7 +485,7 @@ minstrel_ht_prob_rate_reduce_streams(str
+ 			continue;
+ 
+ 		tmp_idx = mg->max_group_prob_rate % MCS_GROUP_RATES;
+-		tmp_prob = mi->groups[group].rates[tmp_idx].prob_ewma;
++		tmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;
+ 
+ 		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&
+ 		   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {
+@@ -590,7 +590,7 @@ minstrel_ht_rate_sample_switch(struct mi
+ 	 * If that fails, look again for a rate that is at least as fast
+ 	 */
+ 	mrs = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
+-	faster_rate = mrs->prob_ewma > MINSTREL_FRAC(75, 100);
++	faster_rate = mrs->prob_avg > MINSTREL_FRAC(75, 100);
+ 	minstrel_ht_find_probe_rates(mi, rates, &n_rates, faster_rate);
+ 	if (!n_rates && faster_rate)
+ 		minstrel_ht_find_probe_rates(mi, rates, &n_rates, false);
+@@ -705,7 +705,7 @@ minstrel_ht_update_stats(struct minstrel
+ 			mrs = &mg->rates[i];
+ 			mrs->retry_updated = false;
+ 			minstrel_calc_rate_stats(mp, mrs);
+-			cur_prob = mrs->prob_ewma;
++			cur_prob = mrs->prob_avg;
+ 
+ 			if (minstrel_ht_get_tp_avg(mi, group, i, cur_prob) == 0)
+ 				continue;
+@@ -979,7 +979,7 @@ minstrel_calc_retransmit(struct minstrel
+ 	unsigned int overhead = 0, overhead_rtscts = 0;
+ 
+ 	mrs = minstrel_get_ratestats(mi, index);
+-	if (mrs->prob_ewma < MINSTREL_FRAC(1, 10)) {
++	if (mrs->prob_avg < MINSTREL_FRAC(1, 10)) {
+ 		mrs->retry_count = 1;
+ 		mrs->retry_count_rtscts = 1;
+ 		return;
+@@ -1036,7 +1036,7 @@ minstrel_ht_set_rate(struct minstrel_pri
+ 	if (!mrs->retry_updated)
+ 		minstrel_calc_retransmit(mp, mi, index);
+ 
+-	if (mrs->prob_ewma < MINSTREL_FRAC(20, 100) || !mrs->retry_count) {
++	if (mrs->prob_avg < MINSTREL_FRAC(20, 100) || !mrs->retry_count) {
+ 		ratetbl->rate[offset].count = 2;
+ 		ratetbl->rate[offset].count_rts = 2;
+ 		ratetbl->rate[offset].count_cts = 2;
+@@ -1070,11 +1070,11 @@ minstrel_ht_set_rate(struct minstrel_pri
+ }
+ 
+ static inline int
+-minstrel_ht_get_prob_ewma(struct minstrel_ht_sta *mi, int rate)
++minstrel_ht_get_prob_avg(struct minstrel_ht_sta *mi, int rate)
+ {
+ 	int group = rate / MCS_GROUP_RATES;
+ 	rate %= MCS_GROUP_RATES;
+-	return mi->groups[group].rates[rate].prob_ewma;
++	return mi->groups[group].rates[rate].prob_avg;
+ }
+ 
+ static int
+@@ -1086,7 +1086,7 @@ minstrel_ht_get_max_amsdu_len(struct min
+ 	unsigned int duration;
+ 
+ 	/* Disable A-MSDU if max_prob_rate is bad */
+-	if (mi->groups[group].rates[rate].prob_ewma < MINSTREL_FRAC(50, 100))
++	if (mi->groups[group].rates[rate].prob_avg < MINSTREL_FRAC(50, 100))
+ 		return 1;
+ 
+ 	duration = g->duration[rate];
+@@ -1109,7 +1109,7 @@ minstrel_ht_get_max_amsdu_len(struct min
+ 	 * data packet size
+ 	 */
+ 	if (duration > MCS_DURATION(1, 0, 260) ||
+-	    (minstrel_ht_get_prob_ewma(mi, mi->max_tp_rate[0]) <
++	    (minstrel_ht_get_prob_avg(mi, mi->max_tp_rate[0]) <
+ 	     MINSTREL_FRAC(75, 100)))
+ 		return 3200;
+ 
+@@ -1216,7 +1216,7 @@ minstrel_get_sample_rate(struct minstrel
+ 	 * rate, to avoid wasting airtime.
+ 	 */
+ 	sample_dur = minstrel_get_duration(sample_idx);
+-	if (mrs->prob_ewma > MINSTREL_FRAC(95, 100) ||
++	if (mrs->prob_avg > MINSTREL_FRAC(95, 100) ||
+ 	    minstrel_get_duration(mi->max_prob_rate) * 3 < sample_dur)
+ 		return -1;
+ 
+@@ -1679,7 +1679,7 @@ static u32 minstrel_ht_get_expected_thro
+ 
+ 	i = mi->max_tp_rate[0] / MCS_GROUP_RATES;
+ 	j = mi->max_tp_rate[0] % MCS_GROUP_RATES;
+-	prob = mi->groups[i].rates[j].prob_ewma;
++	prob = mi->groups[i].rates[j].prob_avg;
+ 
+ 	/* convert tp_avg from pkt per second in kbps */
+ 	tp_avg = minstrel_ht_get_tp_avg(mi, i, j, prob) * 10;
+--- a/net/mac80211/rc80211_minstrel_ht.h
++++ b/net/mac80211/rc80211_minstrel_ht.h
+@@ -122,6 +122,6 @@ struct minstrel_ht_sta_priv {
+ 
+ void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+ int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
+-			   int prob_ewma);
++			   int prob_avg);
+ 
+ #endif
+--- a/net/mac80211/rc80211_minstrel_ht_debugfs.c
++++ b/net/mac80211/rc80211_minstrel_ht_debugfs.c
+@@ -102,8 +102,8 @@ minstrel_ht_stats_dump(struct minstrel_h
+ 		p += sprintf(p, "%6u  ", tx_time);
+ 
+ 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
+-		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_ewma);
+-		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
++		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_avg);
++		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
+ 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+ 
+ 		p += sprintf(p, "%4u.%1u    %4u.%1u     %3u.%1u    %3u.%1u"
+@@ -250,8 +250,8 @@ minstrel_ht_stats_csv_dump(struct minstr
+ 		p += sprintf(p, "%u,", tx_time);
+ 
+ 		tp_max = minstrel_ht_get_tp_avg(mi, i, j, MINSTREL_FRAC(100, 100));
+-		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_ewma);
+-		eprob = MINSTREL_TRUNC(mrs->prob_ewma * 1000);
++		tp_avg = minstrel_ht_get_tp_avg(mi, i, j, mrs->prob_avg);
++		eprob = MINSTREL_TRUNC(mrs->prob_avg * 1000);
+ 		prob_ewmsd = minstrel_get_ewmsd10(mrs);
+ 
+ 		p += sprintf(p, "%u.%u,%u.%u,%u.%u,%u.%u,%u,%u,"
diff -uprN a/package/kernel/mac80211/patches/subsys/365-mac80211-IBSS-send-deauth-when-expiring-inactive-STA.patch b/package/kernel/mac80211/patches/subsys/365-mac80211-IBSS-send-deauth-when-expiring-inactive-STA.patch
--- a/package/kernel/mac80211/patches/subsys/365-mac80211-IBSS-send-deauth-when-expiring-inactive-STA.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/365-mac80211-IBSS-send-deauth-when-expiring-inactive-STA.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,128 @@
+From 4b08d1b6a994dbb593557bd2095ba4f0c3c47819 Mon Sep 17 00:00:00 2001
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Fri, 30 Aug 2019 14:24:51 +0300
+Subject: [PATCH] mac80211: IBSS: send deauth when expiring inactive STAs
+
+When we expire an inactive station, try to send it a deauth. This
+helps if it's actually still around, and just has issues with
+beacon distribution (or we do), and it will not also remove us.
+Then, if we have shared state, this may not be reset properly,
+causing problems; for example, we saw a case where aggregation
+sessions weren't removed properly (due to the TX start being
+offloaded to firmware and it relying on deauth for stop), causing
+a lot of traffic to get lost due to the SN reset after remove/add
+of the peer.
+
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
+Link: https://lore.kernel.org/r/20190830112451.21655-9-luca@coelho.fi
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+ net/mac80211/ibss.c        |  8 ++++++++
+ net/mac80211/ieee80211_i.h |  3 ++-
+ net/mac80211/mlme.c        | 11 ++++++-----
+ net/mac80211/util.c        |  5 +++--
+ 4 files changed, 19 insertions(+), 8 deletions(-)
+
+--- a/net/mac80211/ibss.c
++++ b/net/mac80211/ibss.c
+@@ -1253,6 +1253,7 @@ void ieee80211_ibss_rx_no_sta(struct iee
+ 
+ static void ieee80211_ibss_sta_expire(struct ieee80211_sub_if_data *sdata)
+ {
++	struct ieee80211_if_ibss *ifibss = &sdata->u.ibss;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct sta_info *sta, *tmp;
+ 	unsigned long exp_time = IEEE80211_IBSS_INACTIVITY_LIMIT;
+@@ -1269,10 +1270,17 @@ static void ieee80211_ibss_sta_expire(st
+ 		if (time_is_before_jiffies(last_active + exp_time) ||
+ 		    (time_is_before_jiffies(last_active + exp_rsn) &&
+ 		     sta->sta_state != IEEE80211_STA_AUTHORIZED)) {
++			u8 frame_buf[IEEE80211_DEAUTH_FRAME_LEN];
++
+ 			sta_dbg(sta->sdata, "expiring inactive %sSTA %pM\n",
+ 				sta->sta_state != IEEE80211_STA_AUTHORIZED ?
+ 				"not authorized " : "", sta->sta.addr);
+ 
++			ieee80211_send_deauth_disassoc(sdata, sta->sta.addr,
++						       ifibss->bssid,
++						       IEEE80211_STYPE_DEAUTH,
++						       WLAN_REASON_DEAUTH_LEAVING,
++						       true, frame_buf);
+ 			WARN_ON(__sta_info_destroy(sta));
+ 		}
+ 	}
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -2056,7 +2056,8 @@ void ieee80211_send_auth(struct ieee8021
+ 			 const u8 *da, const u8 *key, u8 key_len, u8 key_idx,
+ 			 u32 tx_flags);
+ void ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,
+-				    const u8 *bssid, u16 stype, u16 reason,
++				    const u8 *da, const u8 *bssid,
++				    u16 stype, u16 reason,
+ 				    bool send_frame, u8 *frame_buf);
+ 
+ enum {
+--- a/net/mac80211/mlme.c
++++ b/net/mac80211/mlme.c
+@@ -2208,8 +2208,9 @@ static void ieee80211_set_disassoc(struc
+ 		    !ifmgd->have_beacon)
+ 			drv_mgd_prepare_tx(sdata->local, sdata, 0);
+ 
+-		ieee80211_send_deauth_disassoc(sdata, ifmgd->bssid, stype,
+-					       reason, tx, frame_buf);
++		ieee80211_send_deauth_disassoc(sdata, ifmgd->bssid,
++					       ifmgd->bssid, stype, reason,
++					       tx, frame_buf);
+ 	}
+ 
+ 	/* flush out frame - make sure the deauth was actually sent */
+@@ -4374,7 +4375,7 @@ void ieee80211_mgd_quiesce(struct ieee80
+ 		 * cfg80211 won't know and won't actually abort those attempts,
+ 		 * thus we need to do that ourselves.
+ 		 */
+-		ieee80211_send_deauth_disassoc(sdata, bssid,
++		ieee80211_send_deauth_disassoc(sdata, bssid, bssid,
+ 					       IEEE80211_STYPE_DEAUTH,
+ 					       WLAN_REASON_DEAUTH_LEAVING,
+ 					       false, frame_buf);
+@@ -5354,7 +5355,7 @@ int ieee80211_mgd_deauth(struct ieee8021
+ 			   ieee80211_get_reason_code_string(req->reason_code));
+ 
+ 		drv_mgd_prepare_tx(sdata->local, sdata, 0);
+-		ieee80211_send_deauth_disassoc(sdata, req->bssid,
++		ieee80211_send_deauth_disassoc(sdata, req->bssid, req->bssid,
+ 					       IEEE80211_STYPE_DEAUTH,
+ 					       req->reason_code, tx,
+ 					       frame_buf);
+@@ -5374,7 +5375,7 @@ int ieee80211_mgd_deauth(struct ieee8021
+ 			   ieee80211_get_reason_code_string(req->reason_code));
+ 
+ 		drv_mgd_prepare_tx(sdata->local, sdata, 0);
+-		ieee80211_send_deauth_disassoc(sdata, req->bssid,
++		ieee80211_send_deauth_disassoc(sdata, req->bssid, req->bssid,
+ 					       IEEE80211_STYPE_DEAUTH,
+ 					       req->reason_code, tx,
+ 					       frame_buf);
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -1433,7 +1433,8 @@ void ieee80211_send_auth(struct ieee8021
+ }
+ 
+ void ieee80211_send_deauth_disassoc(struct ieee80211_sub_if_data *sdata,
+-				    const u8 *bssid, u16 stype, u16 reason,
++				    const u8 *da, const u8 *bssid,
++				    u16 stype, u16 reason,
+ 				    bool send_frame, u8 *frame_buf)
+ {
+ 	struct ieee80211_local *local = sdata->local;
+@@ -1444,7 +1445,7 @@ void ieee80211_send_deauth_disassoc(stru
+ 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);
+ 	mgmt->duration = 0; /* initialize only */
+ 	mgmt->seq_ctrl = 0; /* initialize only */
+-	memcpy(mgmt->da, bssid, ETH_ALEN);
++	memcpy(mgmt->da, da, ETH_ALEN);
+ 	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
+ 	memcpy(mgmt->bssid, bssid, ETH_ALEN);
+ 	/* u.deauth.reason_code == u.disassoc.reason_code */
diff -uprN a/package/kernel/mac80211/patches/subsys/367-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch b/package/kernel/mac80211/patches/subsys/367-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch
--- a/package/kernel/mac80211/patches/subsys/367-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/367-mac80211-sta-randomize-BA-session-dialog-token-alloc.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,38 @@
+From b478e06a16a8baa00c5ecc87c1d636981f2206d5 Mon Sep 17 00:00:00 2001
+From: Johannes Berg <johannes.berg@intel.com>
+Date: Tue, 29 Oct 2019 10:25:25 +0100
+Subject: [PATCH] mac80211: sta: randomize BA session dialog token allocator
+
+We currently always start the dialog token generator at zero,
+so the first dialog token we use is always 1. This would be
+OK if we had a perfect guarantee that we always do a proper
+deauth/re-auth handshake, but in IBSS mode this doesn't always
+happen properly.
+
+To make problems with block ack (aggregation) sessions getting
+stuck less likely, randomize the dialog token so if we start a
+new session but the peer still has old state for us, it can
+better detect this.
+
+This is really just a workaround to make things a bit more
+robust than they are now - a better fix would be to do a full
+authentication handshake in IBSS mode upon having discovered a
+new station, and on the receiver resetting the state (removing
+and re-adding the station) on receiving the authentication
+packet.
+
+Signed-off-by: Johannes Berg <johannes.berg@intel.com>
+---
+ net/mac80211/sta_info.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -340,6 +340,7 @@ struct sta_info *sta_info_alloc(struct i
+ 	INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);
+ 	INIT_WORK(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
+ 	mutex_init(&sta->ampdu_mlme.mtx);
++	sta->ampdu_mlme.dialog_token_allocator = prandom_u32_max(U8_MAX);
+ #ifdef CPTCFG_MAC80211_MESH
+ 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
+ 		sta->mesh = kzalloc(sizeof(*sta->mesh), gfp);
diff -uprN a/package/kernel/mac80211/patches/subsys/368-cfg80211-add-local-BSS-receive-time-to-survey-inform.patch b/package/kernel/mac80211/patches/subsys/368-cfg80211-add-local-BSS-receive-time-to-survey-inform.patch
--- a/package/kernel/mac80211/patches/subsys/368-cfg80211-add-local-BSS-receive-time-to-survey-inform.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/368-cfg80211-add-local-BSS-receive-time-to-survey-inform.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,77 @@
+From: Felix Fietkau <nbd@nbd.name>
+Date: Wed, 28 Aug 2019 12:13:55 +0200
+Subject: [PATCH] cfg80211: add local BSS receive time to survey information
+
+This is useful for checking how much airtime is being used up by other
+transmissions on the channel, e.g. by calculating (time_rx - time_bss_rx)
+or (time_busy - time_bss_rx - time_tx)
+
+Signed-off-by: Felix Fietkau <nbd@nbd.name>
+---
+
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -668,6 +668,7 @@ ieee80211_chandef_max_power(struct cfg80
+  * @SURVEY_INFO_TIME_RX: receive time was filled in
+  * @SURVEY_INFO_TIME_TX: transmit time was filled in
+  * @SURVEY_INFO_TIME_SCAN: scan time was filled in
++ * @SURVEY_INFO_TIME_BSS_RX: local BSS receive time was filled in
+  *
+  * Used by the driver to indicate which info in &struct survey_info
+  * it has filled in during the get_survey().
+@@ -681,6 +682,7 @@ enum survey_info_flags {
+ 	SURVEY_INFO_TIME_RX		= BIT(5),
+ 	SURVEY_INFO_TIME_TX		= BIT(6),
+ 	SURVEY_INFO_TIME_SCAN		= BIT(7),
++	SURVEY_INFO_TIME_BSS_RX		= BIT(8),
+ };
+ 
+ /**
+@@ -697,6 +699,7 @@ enum survey_info_flags {
+  * @time_rx: amount of time the radio spent receiving data
+  * @time_tx: amount of time the radio spent transmitting data
+  * @time_scan: amount of time the radio spent for scanning
++ * @time_bss_rx: amount of time the radio spent receiving data on a local BSS
+  *
+  * Used by dump_survey() to report back per-channel survey information.
+  *
+@@ -711,6 +714,7 @@ struct survey_info {
+ 	u64 time_rx;
+ 	u64 time_tx;
+ 	u64 time_scan;
++	u64 time_bss_rx;
+ 	u32 filled;
+ 	s8 noise;
+ };
+--- a/include/uapi/linux/nl80211.h
++++ b/include/uapi/linux/nl80211.h
+@@ -3693,6 +3693,8 @@ enum nl80211_user_reg_hint_type {
+  * @NL80211_SURVEY_INFO_TIME_SCAN: time the radio spent for scan
+  *	(on this channel or globally)
+  * @NL80211_SURVEY_INFO_PAD: attribute used for padding for 64-bit alignment
++ * @NL80211_SURVEY_INFO_TIME_BSS_RX: amount of time the radio spent
++ *	receiving local BSS data
+  * @NL80211_SURVEY_INFO_MAX: highest survey info attribute number
+  *	currently defined
+  * @__NL80211_SURVEY_INFO_AFTER_LAST: internal use
+@@ -3709,6 +3711,7 @@ enum nl80211_survey_info {
+ 	NL80211_SURVEY_INFO_TIME_TX,
+ 	NL80211_SURVEY_INFO_TIME_SCAN,
+ 	NL80211_SURVEY_INFO_PAD,
++	NL80211_SURVEY_INFO_TIME_BSS_RX,
+ 
+ 	/* keep last */
+ 	__NL80211_SURVEY_INFO_AFTER_LAST,
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -8379,6 +8379,10 @@ static int nl80211_send_survey(struct sk
+ 	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_SCAN,
+ 			      survey->time_scan, NL80211_SURVEY_INFO_PAD))
+ 		goto nla_put_failure;
++	if ((survey->filled & SURVEY_INFO_TIME_BSS_RX) &&
++	    nla_put_u64_64bit(msg, NL80211_SURVEY_INFO_TIME_BSS_RX,
++			      survey->time_bss_rx, NL80211_SURVEY_INFO_PAD))
++		goto nla_put_failure;
+ 
+ 	nla_nest_end(msg, infoattr);
+ 
diff -uprN a/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch b/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch
--- a/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/400-allow-ibss-mixed.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,29 +0,0 @@
-ath10k-ct starting with version 5.2 allows the combination of 
-NL80211_IFTYPE_ADHOC and beacon_int_min_gcd in ath10k_10x_ct_if_comb 
-which triggers this warning. Ben told me that this is not a big problem 
-and we should ignore this.
-
---- a/net/wireless/core.c
-+++ b/net/wireless/core.c
-@@ -613,21 +613,6 @@ static int wiphy_verify_combinations(str
- 				    c->limits[j].max > 1))
- 				return -EINVAL;
- 
--			/*
--			 * This isn't well-defined right now. If you have an
--			 * IBSS interface, then its beacon interval may change
--			 * by joining other networks, and nothing prevents it
--			 * from doing that.
--			 * So technically we probably shouldn't even allow AP
--			 * and IBSS in the same interface, but it seems that
--			 * some drivers support that, possibly only with fixed
--			 * beacon intervals for IBSS.
--			 */
--			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
--				    c->beacon_int_min_gcd)) {
--				return -EINVAL;
--			}
--
- 			cnt += c->limits[j].max;
- 			/*
- 			 * Don't advertise an unsupported type
diff -uprN a/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch b/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch
--- a/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/500-mac80211_configure_antenna_gain.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,160 +0,0 @@
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -3454,6 +3454,7 @@ struct cfg80211_update_owe_info {
-  *	(as advertised by the nl80211 feature flag.)
-  * @get_tx_power: store the current TX power into the dbm variable;
-  *	return 0 if successful
-+ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
-  *
-  * @set_wds_peer: set the WDS peer for a WDS interface
-  *
-@@ -3769,6 +3770,7 @@ struct cfg80211_ops {
- 				enum nl80211_tx_power_setting type, int mbm);
- 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
- 				int *dbm);
-+	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
- 
- 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
- 				const u8 *addr);
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -1501,6 +1501,7 @@ enum ieee80211_smps_mode {
-  *
-  * @power_level: requested transmit power (in dBm), backward compatibility
-  *	value only that is set to the minimum of all interfaces
-+ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
-  *
-  * @chandef: the channel definition to tune to
-  * @radar_enabled: whether radar detection is enabled
-@@ -1521,6 +1522,7 @@ enum ieee80211_smps_mode {
- struct ieee80211_conf {
- 	u32 flags;
- 	int power_level, dynamic_ps_timeout;
-+	int max_antenna_gain;
- 
- 	u16 listen_interval;
- 	u8 ps_dtim_period;
---- a/include/uapi/linux/nl80211.h
-+++ b/include/uapi/linux/nl80211.h
-@@ -2373,6 +2373,9 @@ enum nl80211_commands {
-  *	the allowed channel bandwidth configurations. (u8 attribute)
-  *	Defined by IEEE P802.11ay/D4.0 section 9.4.2.251, Table 13.
-  *
-+ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
-+ *	transmit power to stay within regulatory limits. u32, dBi.
-+ *
-  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
-  * @NL80211_ATTR_MAX: highest attribute number currently defined
-  * @__NL80211_ATTR_AFTER_LAST: internal use
-@@ -2835,6 +2838,8 @@ enum nl80211_attrs {
- 	NL80211_ATTR_WIPHY_EDMG_CHANNELS,
- 	NL80211_ATTR_WIPHY_EDMG_BW_CONFIG,
- 
-+	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
-+
- 	/* add attributes here, update the policy in nl80211.c */
- 
- 	__NL80211_ATTR_AFTER_LAST,
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -2582,6 +2582,19 @@ static int ieee80211_get_tx_power(struct
- 	return 0;
- }
- 
-+static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
-+{
-+	struct ieee80211_local *local = wiphy_priv(wiphy);
-+
-+	if (dbi < 0)
-+		return -EINVAL;
-+
-+	local->user_antenna_gain = dbi;
-+	ieee80211_hw_config(local, 0);
-+
-+	return 0;
-+}
-+
- static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
- 				  const u8 *addr)
- {
-@@ -4017,6 +4030,7 @@ const struct cfg80211_ops mac80211_confi
- 	.set_wiphy_params = ieee80211_set_wiphy_params,
- 	.set_tx_power = ieee80211_set_tx_power,
- 	.get_tx_power = ieee80211_get_tx_power,
-+	.set_antenna_gain = ieee80211_set_antenna_gain,
- 	.set_wds_peer = ieee80211_set_wds_peer,
- 	.rfkill_poll = ieee80211_rfkill_poll,
- 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
---- a/net/mac80211/ieee80211_i.h
-+++ b/net/mac80211/ieee80211_i.h
-@@ -1376,6 +1376,7 @@ struct ieee80211_local {
- 	int dynamic_ps_forced_timeout;
- 
- 	int user_power_level; /* in dBm, for all interfaces */
-+	int user_antenna_gain; /* in dBi */
- 
- 	enum ieee80211_smps_mode smps_mode;
- 
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -93,7 +93,7 @@ static u32 ieee80211_hw_conf_chan(struct
- 	struct ieee80211_sub_if_data *sdata;
- 	struct cfg80211_chan_def chandef = {};
- 	u32 changed = 0;
--	int power;
-+	int power, max_power;
- 	u32 offchannel_flag;
- 
- 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
-@@ -150,6 +150,12 @@ static u32 ieee80211_hw_conf_chan(struct
- 	}
- 	rcu_read_unlock();
- 
-+	max_power = chandef.chan->max_reg_power;
-+	if (local->user_antenna_gain > 0) {
-+		max_power -= local->user_antenna_gain;
-+		power = min(power, max_power);
-+	}
-+
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
- 		local->hw.conf.power_level = power;
-@@ -639,6 +645,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
- 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
- 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
- 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
-+	local->user_antenna_gain = 0;
- 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
- 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
- 	local->hw.max_mtu = IEEE80211_MAX_DATA_LEN;
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -630,6 +630,7 @@ const struct nla_policy nl80211_policy[N
- 					.len = SAE_PASSWORD_MAX_LEN },
- 	[NL80211_ATTR_TWT_RESPONDER] = { .type = NLA_FLAG },
- 	[NL80211_ATTR_HE_OBSS_PD] = NLA_POLICY_NESTED(he_obss_pd_policy),
-+	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
- };
- 
- /* policy for the key attributes */
-@@ -2994,6 +2995,20 @@ static int nl80211_set_wiphy(struct sk_b
- 		if (result)
- 			return result;
- 	}
-+
-+	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
-+		int idx, dbi = 0;
-+
-+		if (!rdev->ops->set_antenna_gain)
-+			return -EOPNOTSUPP;
-+
-+		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
-+		dbi = nla_get_u32(info->attrs[idx]);
-+
-+		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
-+		if (result)
-+			return result;
-+	}
- 
- 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
- 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
diff -uprN a/package/kernel/mac80211/patches/subsys/522-mac80211_configure_antenna_gain.patch b/package/kernel/mac80211/patches/subsys/522-mac80211_configure_antenna_gain.patch
--- a/package/kernel/mac80211/patches/subsys/522-mac80211_configure_antenna_gain.patch	1970-01-01 08:00:00.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/522-mac80211_configure_antenna_gain.patch	2022-04-04 20:20:32.959828000 +0800
@@ -0,0 +1,160 @@
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -2972,6 +2972,7 @@ struct cfg80211_external_auth_params {
+  *	(as advertised by the nl80211 feature flag.)
+  * @get_tx_power: store the current TX power into the dbm variable;
+  *	return 0 if successful
++ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
+  *
+  * @set_wds_peer: set the WDS peer for a WDS interface
+  *
+@@ -3275,6 +3276,7 @@ struct cfg80211_ops {
+ 				enum nl80211_tx_power_setting type, int mbm);
+ 	int	(*get_tx_power)(struct wiphy *wiphy, struct wireless_dev *wdev,
+ 				int *dbm);
++	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
+ 
+ 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
+ 				const u8 *addr);
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -1395,6 +1395,7 @@ enum ieee80211_smps_mode {
+  *
+  * @power_level: requested transmit power (in dBm), backward compatibility
+  *	value only that is set to the minimum of all interfaces
++ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
+  *
+  * @chandef: the channel definition to tune to
+  * @radar_enabled: whether radar detection is enabled
+@@ -1415,6 +1416,7 @@ enum ieee80211_smps_mode {
+ struct ieee80211_conf {
+ 	u32 flags;
+ 	int power_level, dynamic_ps_timeout;
++	int max_antenna_gain;
+ 
+ 	u16 listen_interval;
+ 	u8 ps_dtim_period;
+--- a/include/uapi/linux/nl80211.h
++++ b/include/uapi/linux/nl80211.h
+@@ -2244,6 +2244,9 @@ enum nl80211_commands {
+  * @NL80211_ATTR_AIRTIME_WEIGHT: Station's weight when scheduled by the airtime
+  *	scheduler.
+  *
++ * @NL80211_ATTR_WIPHY_ANTENNA_GAIN: Configured antenna gain. Used to reduce
++ *	transmit power to stay within regulatory limits. u32, dBi.
++ *
+  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
+  * @NL80211_ATTR_MAX: highest attribute number currently defined
+  * @__NL80211_ATTR_AFTER_LAST: internal use
+@@ -2693,6 +2696,8 @@ enum nl80211_attrs {
+ 
+ 	NL80211_ATTR_AIRTIME_WEIGHT,
+ 
++	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
++
+ 	/* add attributes here, update the policy in nl80211.c */
+ 
+ 	__NL80211_ATTR_AFTER_LAST,
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -2460,6 +2460,19 @@ static int ieee80211_get_tx_power(struct
+ 	return 0;
+ }
+ 
++static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
++{
++	struct ieee80211_local *local = wiphy_priv(wiphy);
++
++	if (dbi < 0)
++		return -EINVAL;
++
++	local->user_antenna_gain = dbi;
++	ieee80211_hw_config(local, 0);
++
++	return 0;
++}
++
+ static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
+ 				  const u8 *addr)
+ {
+@@ -3849,6 +3862,7 @@ const struct cfg80211_ops mac80211_confi
+ 	.set_wiphy_params = ieee80211_set_wiphy_params,
+ 	.set_tx_power = ieee80211_set_tx_power,
+ 	.get_tx_power = ieee80211_get_tx_power,
++	.set_antenna_gain = ieee80211_set_antenna_gain,
+ 	.set_wds_peer = ieee80211_set_wds_peer,
+ 	.rfkill_poll = ieee80211_rfkill_poll,
+ 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -1353,6 +1353,7 @@ struct ieee80211_local {
+ 	int dynamic_ps_forced_timeout;
+ 
+ 	int user_power_level; /* in dBm, for all interfaces */
++	int user_antenna_gain; /* in dBi */
+ 
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -94,7 +94,7 @@ static u32 ieee80211_hw_conf_chan(struct
+ 	struct ieee80211_sub_if_data *sdata;
+ 	struct cfg80211_chan_def chandef = {};
+ 	u32 changed = 0;
+-	int power;
++	int power, max_power;
+ 	u32 offchannel_flag;
+ 
+ 	offchannel_flag = local->hw.conf.flags & IEEE80211_CONF_OFFCHANNEL;
+@@ -151,6 +151,12 @@ static u32 ieee80211_hw_conf_chan(struct
+ 	}
+ 	rcu_read_unlock();
+ 
++	max_power = chandef.chan->max_reg_power;
++	if (local->user_antenna_gain > 0) {
++		max_power -= local->user_antenna_gain;
++		power = min(power, max_power);
++	}
++
+ 	if (local->hw.conf.power_level != power) {
+ 		changed |= IEEE80211_CONF_CHANGE_POWER;
+ 		local->hw.conf.power_level = power;
+@@ -626,6 +632,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
+ 	local->hw.radiotap_vht_details = IEEE80211_RADIOTAP_VHT_KNOWN_GI |
+ 					 IEEE80211_RADIOTAP_VHT_KNOWN_BANDWIDTH;
++	local->user_antenna_gain = 0;
+ 	local->hw.uapsd_queues = IEEE80211_DEFAULT_UAPSD_QUEUES;
+ 	local->hw.uapsd_max_sp_len = IEEE80211_DEFAULT_MAX_SP_LEN;
+ 	local->user_power_level = IEEE80211_UNSET_POWER_LEVEL;
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -470,6 +470,7 @@ static const struct nla_policy nl80211_p
+ 	[NL80211_ATTR_HE_CAPABILITY] = { .type = NLA_BINARY,
+ 					 .len = NL80211_HE_MAX_CAPABILITY_LEN },
+ 	[NL80211_ATTR_AIRTIME_WEIGHT] = NLA_POLICY_MIN(NLA_U16, 1),
++	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
+ };
+ 
+ /* policy for the key attributes */
+@@ -2632,6 +2633,20 @@ static int nl80211_set_wiphy(struct sk_b
+ 		if (result)
+ 			return result;
+ 	}
++
++	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
++		int idx, dbi = 0;
++
++		if (!rdev->ops->set_antenna_gain)
++			return -EOPNOTSUPP;
++
++		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
++		dbi = nla_get_u32(info->attrs[idx]);
++
++		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
++		if (result)
++			return result;
++	}
+ 
+ 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
+ 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
diff -uprN a/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch b/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch
--- a/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/patches/subsys/600-mac80211-allow-vht-on-2g.patch	1970-01-01 08:00:00.000000000 +0800
@@ -1,36 +0,0 @@
---- a/net/mac80211/vht.c
-+++ b/net/mac80211/vht.c
-@@ -135,7 +135,8 @@ ieee80211_vht_cap_ie_to_sta_vht_cap(stru
- 	have_80mhz = false;
- 	for (i = 0; i < sband->n_channels; i++) {
- 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
--						IEEE80211_CHAN_NO_80MHZ))
-+						IEEE80211_CHAN_NO_80MHZ) &&
-+						(sband->band != NL80211_BAND_2GHZ))
- 			continue;
- 
- 		have_80mhz = true;
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -1769,7 +1769,8 @@ static int ieee80211_build_preq_ies_band
- 	/* Check if any channel in this sband supports at least 80 MHz */
- 	for (i = 0; i < sband->n_channels; i++) {
- 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
--						IEEE80211_CHAN_NO_80MHZ))
-+						IEEE80211_CHAN_NO_80MHZ) &&
-+						(sband->band != NL80211_BAND_2GHZ))
- 			continue;
- 
- 		have_80mhz = true;
---- a/net/mac80211/mlme.c
-+++ b/net/mac80211/mlme.c
-@@ -4824,7 +4824,8 @@ static int ieee80211_prep_channel(struct
- 	have_80mhz = false;
- 	for (i = 0; i < sband->n_channels; i++) {
- 		if (sband->channels[i].flags & (IEEE80211_CHAN_DISABLED |
--						IEEE80211_CHAN_NO_80MHZ))
-+						IEEE80211_CHAN_NO_80MHZ) &&
-+						(sband->band != NL80211_BAND_2GHZ))
- 			continue;
- 
- 		have_80mhz = true;
diff -uprN a/package/kernel/mac80211/realtek.mk b/package/kernel/mac80211/realtek.mk
--- a/package/kernel/mac80211/realtek.mk	2020-04-15 20:42:34.000000000 +0800
+++ b/package/kernel/mac80211/realtek.mk	2022-04-04 20:20:32.963828000 +0800
@@ -1,8 +1,8 @@
 PKG_DRIVERS += \
 	rtl8180 rtl8187 \
 	rtlwifi rtlwifi-pci rtlwifi-btcoexist rtlwifi-usb rtl8192c-common \
-	rtl8192ce rtl8192se rtl8192de rtl8192cu rtl8723bs rtl8821ae \
-	rtl8xxxu rtw88
+	rtl8192ce rtl8192se rtl8192de rtl8192cu rtl8821ae \
+	rtl8xxxu
 
 config-$(call config_package,rtl8180) += RTL8180
 config-$(call config_package,rtl8187) += RTL8187
@@ -22,12 +22,6 @@ config-$(CONFIG_PACKAGE_RTLWIFI_DEBUG) +
 config-$(call config_package,rtl8xxxu) += RTL8XXXU
 config-y += RTL8XXXU_UNTESTED
 
-config-$(call config_package,rtl8723bs) += RTL8723BS
-config-y += STAGING
-
-config-$(call config_package,rtw88) += RTW88 RTW88_CORE RTW88_PCI
-config-y += RTW88_8822BE RTW88_8822CE
-
 define KernelPackage/rtl818x/Default
   $(call KernelPackage/mac80211/Default)
   TITLE:=Realtek Drivers for RTL818x devices
@@ -174,26 +168,3 @@ define KernelPackage/rtl8xxxu/descriptio
 
   Please report your results!
 endef
-
-define KernelPackage/rtw88
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8822BE/RTL8822CE
-  DEPENDS+= @(PCI_SUPPORT) +kmod-mac80211 +@DRIVER_11AC_SUPPORT +@DRIVER_11N_SUPPORT +@DRIVER_11W_SUPPORT
-  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtw88.ko	\
-	$(PKG_BUILD_DIR)/drivers/net/wireless/realtek/rtw88/rtwpci.ko
-  AUTOLOAD:=$(call AutoProbe,rtwpci)
-endef
-
-define KernelPackage/rtl8723bs
-  $(call KernelPackage/mac80211/Default)
-  TITLE:=Realtek RTL8723BS SDIO Wireless LAN NIC driver (staging)
-  DEPENDS+=+kmod-mmc +kmod-mac80211
-  FILES:=$(PKG_BUILD_DIR)/drivers/staging/rtl8723bs/r8723bs.ko
-  AUTOLOAD:=$(call AutoProbe,r8723bs)
-endef
-
-define KernelPackage/rtl8723bs/description
- This option enables support for RTL8723BS SDIO drivers, such as the wifi found
- on the 1st gen Intel Compute Stick, the CHIP and many other Intel Atom and ARM
- based devices.
-endef

